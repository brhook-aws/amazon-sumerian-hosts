/*! For license information please see host.core.js.LICENSE.txt */
!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("HOST_CORE",[],t):"object"==typeof exports?exports.HOST_CORE=t():e.HOST_CORE=t()}("undefined"!=typeof self?self:"undefined"!=typeof global?global:this,(function(){return(()=>{"use strict";var __webpack_modules__={506:()=>{eval('\n// UNUSED EXPORTS: AnimationFeature, AnimationLayer, AnimationTypes, AnimationUtils, AxisMap, Blend1dState, Blend2dState, DefaultGestureWords, DefaultLayerBlendMode, DefaultVisemeMap, Deferred, Easing, FreeBlendState, GestureFeature, HostObject, LayerBlendModes, LipsyncFeature, MathUtils, Messenger, PointOfInterestFeature, QueueState, RandomAnimationState, SingleState, Speech, TextToSpeechFeature, TextToSpeechUtils, TransitionState, Utils, env\n\n;// CONCATENATED MODULE: ./src/core/Deferred.js\nfunction _typeof(obj) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, _typeof(obj); }\n\nfunction _toConsumableArray(arr) { return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread(); }\n\nfunction _nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction _unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return _arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen); }\n\nfunction _iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction _arrayWithoutHoles(arr) { if (Array.isArray(arr)) return _arrayLikeToArray(arr); }\n\nfunction _arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _createSuper(Derived) { var hasNativeReflectConstruct = _isNativeReflectConstruct(); return function _createSuperInternal() { var Super = _getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = _getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return _possibleConstructorReturn(this, result); }; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return _assertThisInitialized(self); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction _wrapNativeSuper(Class) { var _cache = typeof Map === "function" ? new Map() : undefined; _wrapNativeSuper = function _wrapNativeSuper(Class) { if (Class === null || !_isNativeFunction(Class)) return Class; if (typeof Class !== "function") { throw new TypeError("Super expression must either be null or a function"); } if (typeof _cache !== "undefined") { if (_cache.has(Class)) return _cache.get(Class); _cache.set(Class, Wrapper); } function Wrapper() { return _construct(Class, arguments, _getPrototypeOf(this).constructor); } Wrapper.prototype = Object.create(Class.prototype, { constructor: { value: Wrapper, enumerable: false, writable: true, configurable: true } }); return _setPrototypeOf(Wrapper, Class); }; return _wrapNativeSuper(Class); }\n\nfunction _construct(Parent, args, Class) { if (_isNativeReflectConstruct()) { _construct = Reflect.construct; } else { _construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) _setPrototypeOf(instance, Class.prototype); return instance; }; } return _construct.apply(null, arguments); }\n\nfunction _isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction _isNativeFunction(fn) { return Function.toString.call(fn).indexOf("[native code]") !== -1; }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/**\r\n * The built-in class for asynchronous Promises.\r\n * @external Promise\r\n * @see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise\r\n */\n\n/**\r\n * A Promise object that can be resolved, rejected or canceled at any time by the\r\n * user.\r\n *\r\n * @extends external:Promise\r\n */\nvar Deferred = /*#__PURE__*/function (_Promise) {\n  _inherits(Deferred, _Promise);\n\n  var _super = _createSuper(Deferred);\n\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {Function} [executable=() => {}] - The function to be executed by the\r\n   * constructor, during the process of constructing the promise. The signature\r\n   * of this is expected to be: executable(  resolutionFunc, rejectionFunc, cancellationFunc ).\r\n   * @param {Function=} onResolve - Optional function to execute once the promise\r\n   * is resolved.\r\n   * @param {Function=} onReject - Optional function to execute once the promise\r\n   * is rejected.\r\n   * @param {Function=} onCancel - Optional function to execute if the user cancels\r\n   * the promise. Canceling results in the promise having a status of \'resolved\'.\r\n   */\n  function Deferred() {\n    var _this;\n\n    var executable = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {};\n    var onResolve = arguments.length > 1 ? arguments[1] : undefined;\n    var onReject = arguments.length > 2 ? arguments[2] : undefined;\n    var onCancel = arguments.length > 3 ? arguments[3] : undefined;\n\n    _classCallCheck(this, Deferred);\n\n    if (typeof executable !== \'function\') {\n      throw new Error("Cannot create new Deferred. Executable must be a function.");\n    }\n\n    if (typeof onResolve !== \'undefined\' && typeof onResolve !== \'function\') {\n      throw new Error("Cannot create new Deferred. OnResolve must be a function.");\n    }\n\n    if (typeof onReject !== \'undefined\' && typeof onReject !== \'function\') {\n      throw new Error("Cannot create new Deferred. OnReject must be a function.");\n    }\n\n    if (typeof onCancel !== \'undefined\' && typeof onCancel !== \'function\') {\n      throw new Error("Cannot create new Deferred. OnCancel must be a function.");\n    }\n\n    var res;\n    var rej;\n    var cancel;\n    var status = {\n      resolved: false,\n      rejected: false,\n      canceled: false,\n      pending: true\n    };\n    _this = _super.call(this, function (resolve, reject) {\n      // Store the resolver\n      res = function res(value) {\n        if (status.pending) {\n          status.resolved = true;\n          status.pending = false;\n\n          if (typeof onResolve === \'function\') {\n            value = onResolve(value);\n          }\n\n          return resolve(value);\n        }\n      }; // Store the rejecter\n\n\n      rej = function rej(value) {\n        if (status.pending) {\n          status.rejected = true;\n          status.pending = false;\n\n          if (typeof onReject === \'function\') {\n            value = onReject(value);\n          }\n\n          return reject(value);\n        }\n      }; // Store the canceler\n\n\n      cancel = function cancel(value) {\n        if (status.pending) {\n          status.canceled = true;\n          status.pending = false;\n\n          if (typeof onCancel === \'function\') {\n            value = onCancel(value);\n          }\n\n          return resolve(value);\n        }\n      }; // Run the executable with custom resolver and rejecter\n\n\n      executable(res, rej, cancel);\n    });\n    _this._status = status;\n    _this._resolve = res;\n    _this._reject = rej;\n    _this._cancel = cancel;\n    _this._executable = executable;\n    return _this;\n  }\n  /**\r\n   * Gets the resolved state of the promise.\r\n   *\r\n   * @readonly\r\n   */\n\n\n  _createClass(Deferred, [{\n    key: "resolved",\n    get: function get() {\n      return this._status.resolved;\n    }\n    /**\r\n     * Gets the rejected state of the promise.\r\n     *\r\n     * @readonly\r\n     */\n\n  }, {\n    key: "rejected",\n    get: function get() {\n      return this._status.rejected;\n    }\n    /**\r\n     * Gets the canceled state of the promise.\r\n     *\r\n     * @readonly\r\n     */\n\n  }, {\n    key: "canceled",\n    get: function get() {\n      return this._status.canceled;\n    }\n    /**\r\n     * Gets the pending state of the promise.\r\n     *\r\n     * @readonly\r\n     */\n\n  }, {\n    key: "pending",\n    get: function get() {\n      return this._status.pending;\n    }\n    /**\r\n     * Force the promise to resolve.\r\n     *\r\n     * @param {any=} value - Value to pass to the resolver.\r\n     *\r\n     * @returns {any} - The return value of the resolver function.\r\n     */\n\n  }, {\n    key: "resolve",\n    value: function resolve(value) {\n      return this._resolve(value);\n    }\n    /**\r\n     * Force the promise to reject.\r\n     *\r\n     * @param {any=} value - Value to pass to the rejecter.\r\n     *\r\n     * @returns {any} - The return value of the rejecter function.\r\n     */\n\n  }, {\n    key: "reject",\n    value: function reject(value) {\n      return this._reject(value);\n    }\n    /**\r\n     * Force the promise to resolve and set the canceled state to true.\r\n     *\r\n     * @param {any=} value - Value to pass to the canceller.\r\n     *\r\n     * @returns {any} - The return value of the canceller function.\r\n     */\n\n  }, {\n    key: "cancel",\n    value: function cancel(value) {\n      return this._cancel(value);\n    }\n    /**\r\n     * Run the promise function to try to resolve the promise. Promise must be\r\n     * pending.\r\n     *\r\n     * @param {...any} args - Optional arguments to pass after resolve and reject.\r\n     */\n\n  }, {\n    key: "execute",\n    value: function execute() {\n      if (this.pending) {\n        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n          args[_key] = arguments[_key];\n        }\n\n        this._executable.apply(this, [this._resolve, this._reject, this._cancel].concat(args));\n      }\n    }\n    /**\r\n     * Return a canceled deferred promise.\r\n     *\r\n     * @param {any=} value - Value to cancel the promise with.\r\n     *\r\n     * @returns {Deferred}\r\n     */\n\n  }], [{\n    key: "cancel",\n    value: function cancel(value) {\n      return new Deferred(function (_resolve, _reject, cancel) {\n        cancel(value);\n      });\n    }\n    /**\r\n     * Return a new Deferred promise that will resolve or reject once all promises\r\n     * in the input array have been resolved or one promise is canceled or rejected.\r\n     * Promises in the array that are Deferred promises will be manually resolved,\r\n     * rejected or canceled when calling resolve, reject or cancel on the return promise.\r\n     *\r\n     * @param {Array.<any>} iterable - An iterable such as an array.\r\n     * @param {Function=} onResolve - Optional function to execute once the promise\r\n     * is resolved.\r\n     * @param {Function=} onReject - Optional function to execute once the promise\r\n     * is rejected.\r\n     * @param {Function=} onCancel - Optional function to execute if the user cancels\r\n     * the promise. Canceling results in the promise having a status of \'canceled\'.\r\n     *\r\n     * @returns Deferred\r\n     */\n\n  }, {\n    key: "all",\n    value: function all(iterable, onResolve, onReject, onCancel) {\n      if (iterable == null || typeof iterable[Symbol.iterator] !== \'function\') {\n        var e = "Cannot execute Deferred.all. First argument must be iterable.";\n\n        if (typeof onReject === \'function\') {\n          e = onReject(e);\n        }\n\n        return Deferred.reject(e);\n      }\n\n      var array = _toConsumableArray(iterable);\n\n      var deferred = array.filter(function (item) {\n        return item instanceof Deferred;\n      });\n      var result = new Deferred(undefined, function (resolveValue) {\n        deferred.forEach(function (item) {\n          item.resolve(resolveValue);\n        });\n        deferred.length = 0;\n\n        if (typeof onResolve === \'function\') {\n          return onResolve(resolveValue);\n        } else {\n          return resolveValue;\n        }\n      }, function (error) {\n        deferred.forEach(function (item) {\n          item.reject(error);\n        });\n        deferred.length = 0;\n\n        if (typeof onReject === \'function\') {\n          return onReject(error);\n        } else {\n          return error;\n        }\n      }, function (cancelValue) {\n        deferred.forEach(function (item) {\n          item.cancel(cancelValue);\n        });\n        deferred.length = 0;\n\n        if (typeof onCancel === \'function\') {\n          return onCancel(cancelValue);\n        } else {\n          return cancelValue;\n        }\n      });\n      var numItems = array.length;\n      var itemTracker = {\n        failed: false,\n        numResolved: 0,\n        resolutions: []\n      };\n      array.forEach(function (item, index) {\n        if (itemTracker.failed) {\n          return;\n        } else if (!(item instanceof Promise)) {\n          itemTracker.resolutions[index] = item;\n          itemTracker.numResolved += 1;\n\n          if (itemTracker.numResolved === numItems) {\n            result.resolve(itemTracker.resolutions);\n          }\n\n          return;\n        }\n\n        item.then(function (value) {\n          if (!itemTracker.failed && !item.canceled) {\n            itemTracker.resolutions[index] = value;\n            itemTracker.numResolved += 1;\n\n            if (itemTracker.numResolved === numItems) {\n              result.resolve(itemTracker.resolutions);\n            }\n          } else if (!itemTracker.failed) {\n            itemTracker.failed = true;\n            result.cancel(value);\n          }\n        }, function (error) {\n          if (!itemTracker.failed) {\n            itemTracker.failed = true;\n            result.reject(error);\n          }\n        });\n      });\n      return result;\n    }\n  }]);\n\n  return Deferred;\n}( /*#__PURE__*/_wrapNativeSuper(Promise));\n\n/* harmony default export */ const core_Deferred = (Deferred);\n;// CONCATENATED MODULE: ./src/core/Utils.js\nfunction Utils_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Utils_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Utils_createClass(Constructor, protoProps, staticProps) { if (protoProps) Utils_defineProperties(Constructor.prototype, protoProps); if (staticProps) Utils_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/**\r\n * A collection of useful generic functions.\r\n *\r\n * @hideconstructor\r\n */\n\nvar Utils = /*#__PURE__*/function () {\n  function Utils() {\n    Utils_classCallCheck(this, Utils);\n  }\n\n  Utils_createClass(Utils, null, [{\n    key: "createId",\n    value:\n    /**\r\n     * @static\r\n     *\r\n     * Generate a unique id\r\n     *\r\n     * @returns {String}\r\n     */\n    function createId() {\n      return \'xxxxxxxxxxxx4xxxyxxxxxxxxxxxxxxx\'.replace(/[xy]/g, function (c) {\n        var randomNumber = Math.floor((Date.now() + Math.random() * 16) % 16);\n\n        if (c === \'x\') {\n          return randomNumber.toString(16);\n        } // Set bit 6 and 7 to 0 and 1\n\n\n        return (randomNumber & 0x3 | 0x8).toString(16);\n      });\n    }\n    /**\r\n     * @static\r\n     *\r\n     * Check a name string against an array of strings to determine if it is unique.\r\n     * If it isn\'t, append incremented trailing integers to the end of the name\r\n     * until it is unique.\r\n     *\r\n     * @param {string} name - String name to make unique.\r\n     * @param {Array.<string>=} nameArray - Array of string names to check agains.\r\n     *\r\n     * @returns {string}\r\n     */\n\n  }, {\n    key: "getUniqueName",\n    value: function getUniqueName(name) {\n      var nameArray = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n      // If the name isn\'t in the array return it right away\n      if (!nameArray.includes(name)) {\n        return name;\n      }\n\n      var nameSet = new Set(nameArray); // Separate the name into string and trailing numbers\n\n      var matchGroup = name.match(/\\d*$/);\n      var index = matchGroup.index;\n      var baseName = name.slice(0, index);\n      var increment = Number(matchGroup[0]); // Find the highest trailing number value for the base of the name\n\n      nameSet.forEach(function (setName) {\n        var setMatchGroup = setName.match(/\\d*$/);\n\n        if (setName.slice(0, setMatchGroup.index) === baseName) {\n          var setIncrement = Number(setMatchGroup[0]);\n\n          if (setIncrement > increment) {\n            increment = setIncrement;\n          }\n        }\n      }); // Increment the highest trailing number and append to the name\n\n      return "".concat(baseName).concat(increment + 1);\n    }\n    /**\r\n     * Return a deferred promise that will wait a given number of seconds before\r\n     * resolving. Pass delta time in milliseconds to the deferred promise\'s execute\r\n     * method in an update loop to progress time.\r\n     *\r\n     * @param {number} [seconds=0] - Number of seconds to wait before resolving.\r\n     * @param {Object=} options - Optional options object\r\n     * @param {Function} [options.onFinish] - Callback to execute once the wait time\r\n     * is met.\r\n     * @param {Function=} options.onProgress - Callback to execute each time the wait\r\n     * time progresses towards the target number of seconds. The amount of progress\r\n     * as a 0-1 percentage is passed as an argument.\r\n     * @param {Function=} options.onCancel - Callback to execute if the user cancels\r\n     * the wait before completion.\r\n     * @param {Function=} options.onError - Callback to execute if the wait stops\r\n     * because an error is encountered. The error message is passed as a parameter.\r\n     *\r\n     * @returns {Deferred}\r\n     */\n\n  }, {\n    key: "wait",\n    value: function wait() {\n      var seconds = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n\n      var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          onFinish = _ref.onFinish,\n          onProgress = _ref.onProgress,\n          onCancel = _ref.onCancel,\n          onError = _ref.onError;\n\n      // Make sure seconds is numeric\n      if (typeof seconds !== \'number\') {\n        console.warn("Invalid seconds value ".concat(seconds, " for wait. Defaulting to 0."));\n        seconds = 0;\n      } // Resolve immediately if the wait time is not greater than 0\n\n\n      if (seconds <= 0) {\n        if (typeof onFinish === \'function\') {\n          onFinish();\n        }\n\n        return core_Deferred.resolve();\n      }\n\n      var currentTime = 0;\n      var totalTime = seconds * 1000; // convert to milliseconds\n      // Executable to pass to Deferred, meant to be run in an update loop\n\n      var onUpdate = function onUpdate(resolve, reject, _cancel) {\n        var deltaTime = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n\n        if (typeof deltaTime !== \'number\') {\n          var e = new Error("Invalid property wait deltaTime. DeltaTime must be a number.");\n          reject(e);\n          return;\n        } // Make sure time has passed\n\n\n        if (deltaTime === 0) {\n          return;\n        } // Signal progress\n\n\n        currentTime += deltaTime;\n\n        if (currentTime < 0) {\n          currentTime = 0;\n        }\n\n        if (typeof onProgress === \'function\') {\n          onProgress(Math.min(currentTime / totalTime, 1));\n        } // Signal completion once time is up\n\n\n        if (currentTime >= totalTime) {\n          resolve();\n        }\n      };\n\n      return new core_Deferred(onUpdate, onFinish, onError, onCancel);\n    }\n    /**\r\n      * Get a random float number between a min (inclusive) and max (exclusive) value\r\n      * @param {number} min minimum value\r\n      * @param {number} max maximum value\r\n      * @returns {float}\r\n      */\n\n  }, {\n    key: "getRandomFloat",\n    value: function getRandomFloat(min, max) {\n      return Math.random() * (max - min) + min;\n    }\n    /**\r\n      * Get a random integer number between a min (inclusive) and max (exclusive) value\r\n      * @param {number} min minimum value\r\n      * @param {number} max maximum value\r\n      * @returns {integer}\r\n      */\n\n  }, {\n    key: "getRandomInt",\n    value: function getRandomInt(min, max) {\n      min = Math.ceil(min);\n      max = Math.floor(max);\n      return Math.floor(Math.random() * (max - min)) + min;\n    }\n  }]);\n\n  return Utils;\n}();\n\n/* harmony default export */ const core_Utils = (Utils);\n;// CONCATENATED MODULE: ./src/core/MathUtils.js\nfunction MathUtils_toConsumableArray(arr) { return MathUtils_arrayWithoutHoles(arr) || MathUtils_iterableToArray(arr) || MathUtils_unsupportedIterableToArray(arr) || MathUtils_nonIterableSpread(); }\n\nfunction MathUtils_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction MathUtils_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return MathUtils_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return MathUtils_arrayLikeToArray(o, minLen); }\n\nfunction MathUtils_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction MathUtils_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return MathUtils_arrayLikeToArray(arr); }\n\nfunction MathUtils_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction MathUtils_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction MathUtils_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction MathUtils_createClass(Constructor, protoProps, staticProps) { if (protoProps) MathUtils_defineProperties(Constructor.prototype, protoProps); if (staticProps) MathUtils_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\nvar RadianToDegree = 180 / Math.PI;\nvar DegreeToRadian = Math.PI / 180;\n/**\r\n * A collection of useful math functions.\r\n *\r\n * @hideconstructor\r\n */\n\nvar MathUtils = /*#__PURE__*/function () {\n  function MathUtils() {\n    MathUtils_classCallCheck(this, MathUtils);\n  }\n\n  MathUtils_createClass(MathUtils, null, [{\n    key: "toDegrees",\n    value:\n    /**\r\n     * Convert the given angle from radians to degrees.\r\n     *\r\n     * @param {number} radians - Angle in radians.\r\n     *\r\n     * @returns {number} - Angle in degrees.\r\n     */\n    function toDegrees(radians) {\n      return radians * RadianToDegree;\n    }\n    /**\r\n     * Convert the given angle from degrees to radians.\r\n     *\r\n     * @param {number} degrees - Angle in degrees.\r\n     *\r\n     * @returns {number} - Angle in radians.\r\n     */\n\n  }, {\n    key: "toRadians",\n    value: function toRadians(degrees) {\n      return degrees * DegreeToRadian;\n    }\n    /**\r\n     * Linearly interpolate between two values.\r\n     *\r\n     * @param {number} from - Start value.\r\n     * @param {number} to - Target value.\r\n     * @param {number} factor - 0-1 amount to interpolate between from and to.\r\n     *\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: "lerp",\n    value: function lerp(from, to, factor) {\n      return from + (to - from) * factor;\n    }\n    /**\r\n     * Clamp a number between 2 values.\r\n     *\r\n     * @param {number} value - Value to clamp.\r\n     * @param {number} [min=0] - Minumum value.\r\n     * @param {number} [max=1] - Maximum value.\r\n     *\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: "clamp",\n    value: function clamp(value) {\n      var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      return Math.max(min, Math.min(value, max));\n    }\n    /**\r\n     * Calculates the closest point on a given 2D line segement\r\n     * from a given 2D point.\r\n     *\r\n     * @param {Array.<number>} a - First point on line segment.\r\n     * @param {Array.<number>} b - Second point on line segment.\r\n     * @param {Array.<number>} p - 2D point.\r\n     *\r\n     * @returns {Array.<number>}\r\n     */\n\n  }, {\n    key: "closestPointOnLine",\n    value: function closestPointOnLine(a, b, p) {\n      var distSqr = MathUtils.distanceSquared(a, b); // Line segment is a single point\n\n      if (distSqr === 0) {\n        return a;\n      }\n\n      var t = ((p[0] - a[0]) * (b[0] - a[0]) + (p[1] - a[1]) * (b[1] - a[1])) / distSqr;\n\n      var point = MathUtils_toConsumableArray(a);\n\n      if (t > 1) {\n        point = MathUtils_toConsumableArray(b);\n      } else if (t > 0) {\n        point = [a[0] + t * (b[0] - a[0]), a[1] + t * (b[1] - a[1])];\n      }\n\n      return point;\n    }\n    /**\r\n     * Gets the distance squared for two 2D points.\r\n     * @param {Array.<number>} a - 2D point.\r\n     * @param {Array.<number>} b - 2D point.\r\n     *\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: "distanceSquared",\n    value: function distanceSquared(a, b) {\n      return (a[0] - b[0]) * (a[0] - b[0]) + (a[1] - b[1]) * (a[1] - b[1]);\n    }\n    /**\r\n     * Triangulates a set of 2D points using an implementation\r\n     * of the Bowyer-Watson incremental Delaunay triangulation.\r\n     *\r\n     * @param {Array.<Array.<number>>} vertices - Array of 2D points.\r\n     *\r\n     * @returns {Array.<Array<number>>} - Array of triangle indices.\r\n     */\n\n  }, {\n    key: "getDelaunayTriangulation",\n    value: function getDelaunayTriangulation(vertices) {\n      if (!vertices || vertices.length < 3) {\n        throw new Error("Cannot get delaunay triangulation for points ".concat(vertices, ". Input must contain at least three points."));\n      }\n\n      var minX = Number.POSITIVE_INFINITY;\n      var minY = Number.POSITIVE_INFINITY;\n      var maxX = Number.NEGATIVE_INFINITY;\n      var maxY = Number.NEGATIVE_INFINITY;\n      vertices.forEach(function (v) {\n        minX = v[0] < minX ? v[0] : minX;\n        minY = v[1] < minY ? v[1] : minY;\n        maxX = v[0] > maxX ? v[0] : maxX;\n        maxY = v[1] > maxY ? v[1] : maxY;\n      });\n      var dX = maxX - minX;\n      var dY = maxY - minY;\n      var midX = (minX + maxX) / 2;\n      var midY = (minY + maxY) / 2;\n      var dMax = dX > dY ? dX : dY;\n      var superIndices = [vertices.length, vertices.length + 1, vertices.length + 2];\n      var vertsWithSuper = [].concat(MathUtils_toConsumableArray(vertices), [[midX - 20 * dMax, midY - dMax], [midX, midY + 20 * dMax], [midX + 20 * dMax, midY - dMax]]);\n      var superSortedIndices = MathUtils.sortPointsCCW(superIndices, vertsWithSuper);\n      var superTriangle = {\n        indices: superSortedIndices,\n        edges: [[superSortedIndices[0], superSortedIndices[1]], [superSortedIndices[1], superSortedIndices[2]], [superSortedIndices[2], superSortedIndices[0]]]\n      };\n      var triangles = [superTriangle];\n      vertsWithSuper.forEach(function (newVert, newIndex) {\n        var invalidTriangles = [];\n        triangles.forEach(function (triangle) {\n          if (MathUtils.isPointInCircumCircle(vertsWithSuper[triangle.indices[0]], vertsWithSuper[triangle.indices[1]], vertsWithSuper[triangle.indices[2]], newVert)) {\n            invalidTriangles.push(triangle);\n          }\n        });\n        var boundingPoly = [];\n        invalidTriangles.forEach(function (triangle) {\n          triangle.edges.forEach(function (edge) {\n            var count = 0;\n            invalidTriangles.forEach(function (otherTriangle) {\n              if (triangle !== otherTriangle) {\n                otherTriangle.edges.forEach(function (otherEdge) {\n                  if (edge[0] === otherEdge[0] && edge[1] === otherEdge[1] || edge[1] === otherEdge[0] && edge[0] === otherEdge[1]) {\n                    count += 1;\n                  }\n                });\n              }\n            });\n            if (count === 0) boundingPoly.push(edge);\n          });\n        });\n        invalidTriangles.forEach(function (triangle) {\n          triangles.splice(triangles.indexOf(triangle), 1);\n        });\n        boundingPoly.forEach(function (edge) {\n          var sortedIndices = MathUtils.sortPointsCCW([edge[0], edge[1], newIndex], vertsWithSuper);\n          triangles.push({\n            indices: sortedIndices,\n            edges: [[sortedIndices[0], sortedIndices[1]], [sortedIndices[1], sortedIndices[2]], [sortedIndices[2], sortedIndices[0]]]\n          });\n        });\n      });\n      var trianglesToRemove = [];\n      triangles.forEach(function (triangle) {\n        triangle.indices.forEach(function (index) {\n          if (superIndices.includes(index)) {\n            trianglesToRemove.push(triangle);\n          }\n        });\n      });\n      trianglesToRemove.forEach(function (triangle) {\n        var index = triangles.indexOf(triangle);\n\n        if (index !== -1) {\n          triangles.splice(index, 1);\n        }\n      });\n      return triangles.map(function (triangle) {\n        return triangle.indices;\n      });\n    }\n    /**\r\n     * Determines if a given 2D point is within the cicrumcircle\r\n     * defined by three 2D points. The triangle points must be in\r\n     * counter-clockwise order a -> b -> c.\r\n     *\r\n     * @param {Array.<number>} a - First triangle point.\r\n     * @param {Array.<number>} b - Second triangle point.\r\n     * @param {Array.<number>} c - Third triangle point.\r\n     * @param {Array.<number>} p - 2D point.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "isPointInCircumCircle",\n    value: function isPointInCircumCircle(a, b, c, p) {\n      var ax = a[0] - p[0];\n      var ay = a[1] - p[1];\n      var bx = b[0] - p[0];\n      var by = b[1] - p[1];\n      var cx = c[0] - p[0];\n      var cy = c[1] - p[1];\n      return (ax * ax + ay * ay) * (bx * cy - cx * by) - (bx * bx + by * by) * (ax * cy - cx * ay) + (cx * cx + cy * cy) * (ax * by - bx * ay) > 0;\n    }\n    /**\r\n     * Determines if a given 2D point is within a given triangle.\r\n     *\r\n     * @param {Array.<number>} a - First triangle point.\r\n     * @param {Array.<number>} b - Second triangle point.\r\n     * @param {Array.<number>} c - Third triangle point.\r\n     * @param {Array.<number>} p - 2D point.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "isPointInTriangle",\n    value: function isPointInTriangle(a, b, c, p) {\n      var denom = (b[1] - c[1]) * (a[0] - c[0]) + (c[0] - b[0]) * (a[1] - c[1]);\n      var aVal = ((b[1] - c[1]) * (p[0] - c[0]) + (c[0] - b[0]) * (p[1] - c[1])) / denom;\n      var bVal = ((c[1] - a[1]) * (p[0] - c[0]) + (a[0] - c[0]) * (p[1] - c[1])) / denom;\n      var cVal = 1 - aVal - bVal;\n      return aVal >= 0 && aVal <= 1 && bVal >= 0 && bVal <= 1 && cVal >= 0 && cVal <= 1;\n    }\n    /**\r\n     * Gets the sorted indices of a given set of 2D points in\r\n     * counter-clockwise order.\r\n     *\r\n     * @param {Array.<number>} indices - List of indices.\r\n     * @param {Array.<Array.<number>>} vertices - List of 2D points.\r\n     *\r\n     * @returns {Array.<Array.<number>>} - List of sorted indices.\r\n     */\n\n  }, {\n    key: "sortPointsCCW",\n    value: function sortPointsCCW(indices, vertices) {\n      var centroid = [0, 0];\n      indices.forEach(function (index) {\n        centroid[0] += vertices[index][0];\n        centroid[1] += vertices[index][1];\n      });\n      centroid[0] /= indices.length;\n      centroid[1] /= indices.length;\n      indices.sort(function (a, b) {\n        var bVal = Math.atan2(vertices[b][1] - centroid[1], vertices[b][0] - centroid[0]);\n        var aVal = Math.atan2(vertices[a][1] - centroid[1], vertices[a][0] - centroid[0]);\n        return aVal - bVal;\n      });\n      return indices;\n    }\n    /**\r\n     * Cacluates the area of a triangle\r\n     * @param {Array.<number>} a - First triangle point.\r\n     * @param {Array.<number>} b - Second triangle point.\r\n     * @param {Array.<number>} c - Third triangle point.\r\n     *\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: "triangleArea",\n    value: function triangleArea(a, b, c) {\n      return Math.abs((a[0] * (b[1] - c[1]) + b[0] * (c[1] - a[1]) + c[0] * (a[1] - b[1])) * 0.5);\n    }\n    /**\r\n     * Return the magnitude of a given vector array.\r\n     *\r\n     * @param {Array.<number>} vector - Array consisting of numbers.\r\n     *\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: "getVectorMagnitude",\n    value: function getVectorMagnitude(vector) {\n      if (!(vector instanceof Array)) {\n        throw new Error("Cannot get magnitude for vector ".concat(vector, ". Input must be an Array numbers."));\n      }\n\n      var reducer = function reducer(accumulator, currentValue) {\n        if (typeof currentValue !== \'number\') {\n          throw new Error("Cannot get magnitude for vector ".concat(vector, ". All items in the input Array must be numbers."));\n        }\n\n        return accumulator + Math.pow(currentValue, 2);\n      };\n\n      return Math.sqrt(vector.reduce(reducer, 0));\n    }\n    /**\r\n     * Return the dot product between two vectors.\r\n     *\r\n     * @param {Array.<number>} vectorA - Array consisting of numbers.\r\n     * @param {Array.<number>} vectorB - Array consisting of numbers.\r\n     *\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: "getDotProduct",\n    value: function getDotProduct(vectorA, vectorB) {\n      if (!(vectorA instanceof Array) || !(vectorB instanceof Array) || vectorA.length !== vectorB.length) {\n        throw new Error("Cannot get dot product between ".concat(vectorA, " and ").concat(vectorB, ". Inputs must be vectors of the same length."));\n      }\n\n      var result = 0;\n      vectorA.forEach(function (valueA, index) {\n        var valueB = vectorB[index];\n\n        if (typeof valueA !== \'number\' || typeof valueB !== \'number\') {\n          throw new Error("Cannot get dot product between ".concat(vectorA, " and ").concat(vectorB, ". Vectors must only consist of numeric values."));\n        }\n\n        result += valueA * valueB;\n      });\n      return result;\n    }\n    /**\r\n     * Return the angle in radians between vectorA and vectorB.\r\n     *\r\n     * @param {Array.<number>} vectorA - Array consisting of numbers.\r\n     * @param {Array.<number>} vectorB - Array consisting of numbers.\r\n     *\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: "getAngleBetween",\n    value: function getAngleBetween(vectorA, vectorB) {\n      var normalA = this.normalizeVector(MathUtils_toConsumableArray(vectorA));\n      var normalB = this.normalizeVector(MathUtils_toConsumableArray(vectorB));\n      var dot = this.getDotProduct(normalA, normalB);\n      return Math.acos(this.clamp(dot, -1, 1));\n    }\n    /**\r\n     * Multiply a 3x3 rotation matrix with a vector3.\r\n     *\r\n     * @param {Array.<number>} vector3 - Array consisting of 3 numbers representing\r\n     * a direction vector.\r\n     * @param {Array.<number>} matrix3 - An array of 9 numbers representing a row\r\n     * major rotation matrix.\r\n     *\r\n     * @returns {Array.<number>} - An array of 3 numbers representing the new direction\r\n     * of the vector.\r\n     */\n\n  }, {\n    key: "rotateVector",\n    value: function rotateVector(vector3, matrix3) {\n      if (!(vector3 instanceof Array) || vector3.length !== 3 || !vector3.every(function (v) {\n        return typeof v === \'number\';\n      })) {\n        throw new Error("Cannot rotate vector ".concat(vector3, " by rotation matrix ").concat(matrix3, ". Input vector must be an array of 3 numbers."));\n      }\n\n      if (!(matrix3 instanceof Array) || matrix3.length !== 9 || !matrix3.every(function (v) {\n        return typeof v === \'number\';\n      })) {\n        throw new Error("Cannot rotate vector ".concat(vector3, " by rotation matrix ").concat(matrix3, ". Input matrix3 must be an array of 9 numbers."));\n      }\n\n      var x = matrix3[0] * vector3[0] + matrix3[3] * vector3[1] + matrix3[6] * vector3[2];\n      var y = matrix3[1] * vector3[0] + matrix3[4] * vector3[1] + matrix3[7] * vector3[2];\n      var z = matrix3[2] * vector3[0] + matrix3[5] * vector3[1] + matrix3[8] * vector3[2];\n      return [x, y, z];\n    }\n    /**\r\n     * Normalize a given vector array.\r\n     *\r\n     * @param {Array.<number>} vector - Array consisting of numbers.\r\n     *\r\n     * @returns {Array.<number>} The original vector with normalized values, for chaining.\r\n     */\n\n  }, {\n    key: "normalizeVector",\n    value: function normalizeVector(vector) {\n      var magnitude = this.getVectorMagnitude(vector);\n\n      if (magnitude === 0) {\n        vector.fill(0);\n      } else {\n        vector.forEach(function (value, index) {\n          vector[index] = value / magnitude;\n        });\n      }\n\n      return vector;\n    }\n    /**\r\n     * Extract the 3x3 rotation matrix from a given 4x4 transformation matrix.\r\n     *\r\n     * @param {Array.<number>} matrix4 - An array of 16 numbers representing a row\r\n     * major transformation matrix.\r\n     *\r\n     * @returns {Array.<number>} - An array of 9 numbers representing a row major\r\n     * rotation matrix.\r\n     */\n\n  }, {\n    key: "getRotationMatrix",\n    value: function getRotationMatrix(matrix4) {\n      if (!(matrix4 instanceof Array) || matrix4.length !== 16 || !matrix4.every(function (v) {\n        return typeof v === \'number\';\n      })) {\n        throw new Error("Cannot convert matrix ".concat(matrix4, " to a rotation matrix. Input matrix must be an array of 16 numbers."));\n      } // Extract scale\n\n\n      var scaleX = 1 / (this.getVectorMagnitude(matrix4.slice(0, 4)) || 1);\n      var scaleY = 1 / (this.getVectorMagnitude(matrix4.slice(4, 8)) || 1);\n      var scaleZ = 1 / (this.getVectorMagnitude(matrix4.slice(8, 12)) || 1);\n      return [matrix4[0] * scaleX, matrix4[1] * scaleX, matrix4[2] * scaleX, matrix4[4] * scaleY, matrix4[5] * scaleY, matrix4[6] * scaleY, matrix4[8] * scaleZ, matrix4[9] * scaleZ, matrix4[10] * scaleZ];\n    }\n    /**\r\n     * Return an array containing the spherical coordinates of the given cartesian\r\n     * xyz coordinates.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {number} x - Position along the x axis.\r\n     * @param {number} y - Position along the y axis.\r\n     * @param {number} z - Position along the z axis.\r\n     *\r\n     * @returns {Array.<number>} - An array consisting of three numberes where index\r\n     * 0 represents the radius, index 1 represents the vertical/polar angle in radians\r\n     * and index 2 represents the horizontal/azimuthal angle in radians.\r\n     */\n\n  }, {\n    key: "cartesianToSpherical",\n    value: function cartesianToSpherical(x, y, z) {\n      var r = this.getVectorMagnitude([x, y, z]); // Return identity if the vector has no length\n\n      if (r === 0) {\n        return [0, 0, 0];\n      }\n\n      return [r, Math.acos(this.clamp(y / r, -1, 1)), Math.atan2(x, z)];\n    }\n    /**\r\n     * Gradually change a value of a numeric property towards a goal over time using\r\n     * a critically damped spring function.\r\n     *\r\n     * @param {number} currentValue - The starting value.\r\n     * @param {number} targetValue- The goal value.\r\n     * @param {Array.<number>} [valueStore = [0, 0]] - An Array consisting of two\r\n     * numbers where the first number holds the result value and the second holds\r\n     * the velocity that resulted in that value. The same array should be provided\r\n     * with each call to this function.\r\n     * @param {number} [deltaTime = 1e-7] - The time since the last call to this function\r\n     * in seconds.\r\n     * @param {number} [smoothTime = 0.3] - The approximate amount of time in seconds\r\n     * it should take to reach the target value.\r\n     * @param {number} [maxSpeed = 1e7] - A clamping value for the maximum speed the\r\n     * value can change.\r\n     *\r\n     * @returns {Array.<number>} - The valueStore array.\r\n     */\n\n  }, {\n    key: "dampValue",\n    value: function dampValue(currentValue, targetValue) {\n      var valueStore = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [0, 0];\n      var deltaTime = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1e-7;\n      var smoothTime = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 0.3;\n      var maxSpeed = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 1e7;\n      smoothTime = Math.max(0.0001, smoothTime);\n      deltaTime = Math.max(1e-7, deltaTime); // Find the delta between values and use it to estimate the previous value\n\n      var clampTime = maxSpeed * smoothTime;\n      var deltaValue = currentValue - targetValue;\n      var clampDeltaValue = this.clamp(deltaValue, -clampTime, clampTime);\n      var lastValue = currentValue - clampDeltaValue; // Calculate damping factors\n\n      var d1 = 2 / smoothTime;\n      var d2 = d1 * deltaTime;\n      var d3 = 1 / (1 + d2 + 0.5 * Math.pow(d2, 2) + 0.25 * Math.pow(d2, 3));\n      var d4 = (valueStore[1] + d1 * clampDeltaValue) * deltaTime; // Damp the target value and update the velocity\n\n      valueStore[0] = lastValue + (clampDeltaValue + d4) * d3;\n      valueStore[1] = (valueStore[1] - d1 * d4) * d3; // Prevent overshooting\n\n      if (targetValue - currentValue > 0 === valueStore[0] > targetValue) {\n        valueStore[0] = targetValue;\n        valueStore[1] = (valueStore[0] - targetValue) / deltaTime;\n      }\n\n      return valueStore;\n    }\n  }]);\n\n  return MathUtils;\n}();\n\n/* harmony default export */ const core_MathUtils = (MathUtils);\n;// CONCATENATED MODULE: ./src/core/Messenger.js\nfunction Messenger_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Messenger_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Messenger_createClass(Constructor, protoProps, staticProps) { if (protoProps) Messenger_defineProperties(Constructor.prototype, protoProps); if (staticProps) Messenger_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/* eslint-disable no-underscore-dangle */\n\n/**\r\n * Class that can execute functions when local messages are received. Local messages\r\n * are prefixed with the instance\'s id.\r\n *\r\n * @alias core/Messenger\r\n *\r\n * @property {core/Messenger} GlobalMessenger - A messenger that can be used for\r\n * global messaging. When using static listen and emit methods they are executed\r\n * on this messenger.\r\n * @property {Object} EVENTS - Built-in events that the Messenger emits.\r\n */\n\nvar Messenger = /*#__PURE__*/function () {\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {any=} id - Id for the object. If none is provided a new id will\r\n   * be created. Id should be able to be represented as a string.\r\n   */\n  function Messenger(id) {\n    Messenger_classCallCheck(this, Messenger);\n\n    this._id = id !== undefined ? id : core_Utils.createId();\n    this._dispatcher = window;\n    this._callbacks = {};\n    this._eventListeners = {};\n  }\n  /**\r\n   * Gets the string id of the object.\r\n   *\r\n   * @readonly\r\n   * @type {string}\r\n   */\n\n\n  Messenger_createClass(Messenger, [{\n    key: "id",\n    get: function get() {\n      return this._id;\n    }\n    /**\r\n     * Prefix a message with the instance id.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} message\r\n     *\r\n     * @returns {string}\r\n     */\n\n  }, {\n    key: "_createLocalMessage",\n    value: function _createLocalMessage(message) {\n      return "".concat(this.id, ".").concat(message);\n    }\n    /**\r\n     * Return a function that will call a callback function and supply the event\'s\r\n     * detail property as an argument.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {Function} callback\r\n     *\r\n     * @returns {Function}\r\n     */\n\n  }, {\n    key: "_createListener",\n    value: function _createListener(callback) {\n      return function (e) {\n        var value;\n\n        if (e.detail !== null) {\n          value = e.detail;\n        }\n\n        callback(value);\n      };\n    }\n    /**\r\n     * Create an event object and send it to listeners.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} message - Event type name.\r\n     * @param {any=} value - Value to send to listeners.\r\n     *\r\n     * @returns {CustomEvent}\r\n     */\n\n  }, {\n    key: "_createEvent",\n    value: function _createEvent(message, value) {\n      return new CustomEvent(message, {\n        detail: value\n      });\n    }\n    /**\r\n     * Register an event.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} message - Event type name.\r\n     * @param {Function} listener - A listener function generated using _createListener.\r\n     */\n\n  }, {\n    key: "_addListener",\n    value: function _addListener(message, listener) {\n      this._dispatcher.addEventListener(this._createLocalMessage(message), listener);\n    }\n    /**\r\n     * Unregister an event.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} message - Event type name.\r\n     * @param {Function} listener - A listener function generated using _createListener.\r\n     */\n\n  }, {\n    key: "_removeListener",\n    value: function _removeListener(message, listener) {\n      this._dispatcher.removeEventListener(this._createLocalMessage(message), listener);\n    }\n    /**\r\n     * Execute a function when a message is received for this object.\r\n     *\r\n     * @param {string} message - The message to listen for.\r\n     * @param {Function} callback - Function to execute once the message is received.\r\n     */\n\n  }, {\n    key: "listenTo",\n    value: function listenTo(message, callback) {\n      if (typeof callback !== \'function\') {\n        throw new Error("Cannot add listener for ".concat(message, " on ").concat(this.id, ". Callback must be a function."));\n      }\n\n      if (this._callbacks[message] === undefined) {\n        this._callbacks[message] = [];\n        this._eventListeners[message] = [];\n      }\n\n      var listener = this._createListener(callback);\n\n      this._callbacks[message].push(callback);\n\n      this._eventListeners[message].push(listener);\n\n      this._addListener(message, listener);\n    }\n    /**\r\n     * Prevent a function from being executed when a message is received for this\r\n     * object.\r\n     *\r\n     * @param {string} message - The message to stop listening for.\r\n     * @param {Function=} callback - Optional callback to remove. If none is defined,\r\n     * remove all callbacks for the message.\r\n     */\n\n  }, {\n    key: "stopListening",\n    value: function stopListening(message, callback) {\n      if (this._callbacks[message] === undefined) {\n        return;\n      } else if (callback === undefined) {\n        // If no callback was defined, call stopListening on all callbacks for the message\n        for (var i = this._callbacks[message].length - 1; i > -1; i--) {\n          this.stopListening(message, this._callbacks[message][i]);\n        }\n\n        return;\n      } // If a callback was defined, make sure it\'s a listener\n\n\n      var index = this._callbacks[message].indexOf(callback);\n\n      if (index === -1) {\n        return;\n      }\n\n      var listener = this._eventListeners[message][index];\n\n      this._removeListener(message, listener);\n\n      this._callbacks[message].splice(index, 1);\n\n      this._eventListeners[message].splice(index, 1);\n\n      if (this._callbacks[message].length === 0) {\n        delete this._callbacks[message];\n        delete this._eventListeners[message];\n      }\n    }\n    /**\r\n     * De-register callback(s) from being executed when messages matching the given\r\n     * regular expression are received.\r\n     *\r\n     * @param {Regexp} regexp - regexp - The regular expression to filter messages with.\r\n     * @param {Function=} callback - Optional callback to remove. If none is defined,\r\n     * remove all callbacks for messages matching the regular expression.\r\n     */\n\n  }, {\n    key: "stopListeningByRegexp",\n    value: function stopListeningByRegexp(regexp, callback) {\n      var _this = this;\n\n      var messages = Object.keys(this._callbacks).filter(function (message) {\n        return regexp.test(message);\n      });\n      messages.forEach(function (message) {\n        _this.stopListening(message, callback);\n      });\n    }\n    /**\r\n     * Prevent any functions from being executed when any message is received for\r\n     * this object.\r\n     */\n\n  }, {\n    key: "stopListeningToAll",\n    value: function stopListeningToAll() {\n      var messages = Object.keys(this._callbacks);\n\n      for (var i = messages.length - 1; i > -1; i--) {\n        this.stopListening(messages[i]);\n      }\n    }\n    /**\r\n     * Send a message, causing listener functions for the message on this object\r\n     * to be executed.\r\n     *\r\n     * @param {string} message - The message to emit.\r\n     * @param {any=} value - Optional argument to pass to listener callbacks.\r\n     */\n\n  }, {\n    key: "emit",\n    value: function emit(message, value) {\n      if (this._callbacks[message] === undefined) {\n        return;\n      }\n\n      message = this._createLocalMessage(message);\n\n      var event = this._createEvent(message, value);\n\n      this._dispatcher.dispatchEvent(event);\n    }\n    /**\r\n     * Execute a function when a message is received for the global Messenger instance.\r\n     *\r\n     * @static\r\n     *\r\n     * @param {string} message - The message to listen for.\r\n     * @param {Function} callback - Function to execute once the message is received.\r\n     */\n\n  }], [{\n    key: "listenTo",\n    value: function listenTo(message, callback, messenger) {\n      this.GlobalMessenger.listenTo(message, callback, messenger);\n    }\n    /**\r\n     * Prevent a function from being executed when a message is received for the\r\n     * global Messenger instance.\r\n     *\r\n     * @static\r\n     *\r\n     * @param {string} message - The message to stop listening for.\r\n     * @param {Function=} callback - Optional callback to remove. If none is defined,\r\n     * remove all callbacks for the message.\r\n     */\n\n  }, {\n    key: "stopListening",\n    value: function stopListening(message, callback) {\n      this.GlobalMessenger.stopListening(message, callback);\n    }\n    /**\r\n     * De-register callback(s) from being executed on the global messengerr instance\r\n     * when messages matching the given regular expression are received.\r\n     *\r\n     * @param {Regexp} regexp - regexp - The regular expression to filter messages with.\r\n     * @param {Function=} callback - Optional callback to remove. If none is defined,\r\n     * remove all callbacks for messages matching the regular expression.\r\n     */\n\n  }, {\n    key: "stopListeningByRegexp",\n    value: function stopListeningByRegexp(regexp, callback) {\n      var _this2 = this;\n\n      var messages = Object.keys(this.GlobalMessenger._callbacks).filter(function (message) {\n        return regexp.test(message);\n      });\n      messages.forEach(function (message) {\n        _this2.stopListening(message, callback);\n      });\n    }\n    /**\r\n     * Prevent any functions from being executed when any message is received for\r\n     * the global Messenger instance.\r\n     *\r\n     * @static\r\n     */\n\n  }, {\n    key: "stopListeningToAll",\n    value: function stopListeningToAll() {\n      this.GlobalMessenger.stopListeningToAll();\n    }\n    /**\r\n     * Send a message, causing listener functions for the message on the global Messenger\r\n     * instance to be executed.\r\n     *\r\n     * @static\r\n     *\r\n     * @param {string} message - The message to emit.\r\n     * @param {any=} value - Optional argument to pass to listener callbacks.\r\n     */\n\n  }, {\n    key: "emit",\n    value: function emit(message, value) {\n      this.GlobalMessenger.emit(message, value);\n    }\n  }]);\n\n  return Messenger;\n}();\n\nObject.defineProperties(Messenger, {\n  GlobalMessenger: {\n    value: new Messenger(),\n    writable: false\n  },\n  EVENTS: {\n    value: {},\n    writable: false\n  }\n});\n/* harmony default export */ const core_Messenger = (Messenger);\n;// CONCATENATED MODULE: ./src/core/AbstractHostFeature.js\nfunction _slicedToArray(arr, i) { return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || AbstractHostFeature_unsupportedIterableToArray(arr, i) || _nonIterableRest(); }\n\nfunction _nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction AbstractHostFeature_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return AbstractHostFeature_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return AbstractHostFeature_arrayLikeToArray(o, minLen); }\n\nfunction AbstractHostFeature_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction _iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction _arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction AbstractHostFeature_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction AbstractHostFeature_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction AbstractHostFeature_createClass(Constructor, protoProps, staticProps) { if (protoProps) AbstractHostFeature_defineProperties(Constructor.prototype, protoProps); if (staticProps) AbstractHostFeature_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/**\r\n * Base class for all host features. Keeps a reference to the host object managing\r\n * the feature.\r\n *\r\n * @abstract\r\n *\r\n * @property {Object} EVENTS - Built-in messages that the feature emits. When the\r\n * feature is added to a {@link core/HostObject}, event names will be prefixed by the\r\n * name of the feature class + \'.\'.\r\n * @property {string} [EVENTS.update=onUpdate] - Message that is emitted after\r\n * each call to [update]{@link AbstractHostFeature#update}.\r\n * @property {Object} SERVICES - Any AWS services that are necessary for the\r\n * feature to function.\r\n */\n\nvar AbstractHostFeature = /*#__PURE__*/function () {\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {core/HostObject} host - The HostObject managing the feature.\r\n   */\n  function AbstractHostFeature(host) {\n    AbstractHostFeature_classCallCheck(this, AbstractHostFeature);\n\n    this._host = host;\n  }\n  /**\r\n   * Adds a namespace to the host with the name of the feature to contain properties\r\n   * and methods from the feature that users of the host need access to.\r\n   */\n\n\n  AbstractHostFeature_createClass(AbstractHostFeature, [{\n    key: "installApi",\n    value: function installApi() {\n      var _this = this;\n\n      var events = {};\n      var api = {\n        EVENTS: events\n      }; // Add the class name to event names\n\n      Object.entries(this.constructor.EVENTS).forEach(function (_ref) {\n        var _ref2 = _slicedToArray(_ref, 2),\n            name = _ref2[0],\n            value = _ref2[1];\n\n        events[name] = "".concat(_this.constructor.name, ".").concat(value);\n      });\n      this._host[this.constructor.name] = api;\n      return api;\n    }\n    /**\r\n     * Gets the host that manages the feature.\r\n     *\r\n     * @readonly\r\n     */\n\n  }, {\n    key: "host",\n    get: function get() {\n      return this._host;\n    }\n    /**\r\n     * Gets the engine owner object of the host.\r\n     *\r\n     * @readonly\r\n     */\n\n  }, {\n    key: "owner",\n    get: function get() {\n      return this._host.owner;\n    }\n    /**\r\n     * Listen to a feature message from the host object.\r\n     *\r\n     * @param {string} message - Message to listen for.\r\n     * @param {Function} callback - The callback to execute when the message is received.\r\n     */\n\n  }, {\n    key: "listenTo",\n    value: function listenTo(message, callback) {\n      this._host.listenTo(message, callback);\n    }\n    /**\r\n     * Listen to a feature message from the global messenger. Feature messages will\r\n     * be prefixed with the class name of the feature.\r\n     *\r\n     * @param {string} message - Message to listen for.\r\n     * @param {Function} callback - The callback to execute when the message is received.\r\n     */\n\n  }, {\n    key: "stopListening",\n    value:\n    /**\r\n     * Stop listening to a message from the host object.\r\n     *\r\n     * @param {string} message - Message to stop listening for.\r\n     * @param {Function=} callback - Optional callback to remove. If none is defined,\r\n     * remove all callbacks for the message.\r\n     */\n    function stopListening(message, callback) {\n      this._host.stopListening(message, callback);\n    }\n    /**\r\n     * Stop listening to a message from the global messenger.\r\n     *\r\n     * @param {string} message - Message to stop listening for.\r\n     * @param {Function=} callback - Optional callback to remove. If none is defined,\r\n     * remove all callbacks for the message.\r\n     */\n\n  }, {\n    key: "stopListeningByRegexp",\n    value:\n    /**\r\n     * Stop listening to a message matching the given regular expression from the\r\n     * host object.\r\n     *\r\n     * @param {Regexp} regexp - The regular expression to stop listening for.\r\n     * @param {Function=} callback - Optional callback to remove. If none is defined,\r\n     * remove all callbacks for the message.\r\n     */\n    function stopListeningByRegexp(regexp, callback) {\n      this._host.stopListeningByRegexp(regexp, callback);\n    }\n    /**\r\n     * Stop listening to a message matching the given regular expression from the\r\n     * global messenger.\r\n     *\r\n     * @param {Regexp} regexp - The regular expression to stop listening for.\r\n     * @param {Function=} callback - Optional callback to remove. If none is defined,\r\n     * remove all callbacks for the message.\r\n     */\n\n  }, {\n    key: "stopListeningToAll",\n    value:\n    /**\r\n     * Stop listening to all messages.\r\n     */\n    function stopListeningToAll() {\n      this._host.stopListeningToAll();\n    }\n    /**\r\n     * Stop listening to all feature messages.\r\n     */\n\n  }, {\n    key: "emit",\n    value:\n    /**\r\n     * Emit feature messages from the host. Feature messages will be prefixed with\r\n     * the class name of the feature.\r\n     *\r\n     * @param {string} message - The message to emit.\r\n     * @param {any=} value - Optional parameter to pass to listener callbacks.\r\n     */\n    function emit(message, value) {\n      message = "".concat(this.constructor.name, ".").concat(message);\n\n      this._host.emit(message, value);\n    }\n    /**\r\n     * Emit feature messages from the global messenger. Feature messages will be prefixed\r\n     * with the class name of the feature.\r\n     *\r\n     * @param {string} message - The message to emit.\r\n     * @param {any=} value - Optional parameter to pass to listener callbacks.\r\n     */\n\n  }, {\n    key: "update",\n    value:\n    /**\r\n     * Executes each time the host is updated.\r\n     *\r\n     * @param {number} deltaTime - Amount of time since the last host update was\r\n     * called.\r\n     */\n    function update(deltaTime) {\n      this.emit(this.constructor.EVENTS.update, deltaTime);\n    }\n    /**\r\n     * Clean up once the feature is no longer in use. Remove the feature namespace\r\n     * from the host and remove reference to the host.\r\n     */\n\n  }, {\n    key: "discard",\n    value: function discard() {\n      var _this2 = this;\n\n      Object.keys(this._host[this.constructor.name]).forEach(function (name) {\n        delete _this2._host[_this2.constructor.name][name];\n      });\n      delete this._host[this.constructor.name];\n      delete this._host;\n    }\n    /**\r\n     * Applies a sequence of mixin class factory functions to this class and\r\n     * returns the result. Each function is expected to return a class that\r\n     * extends the class it was given. The functions are applied in the order\r\n     * that parameters are given, meaning that the first factory will\r\n     * extend this base class.\r\n     *\r\n     * @param {...Function} mixinClassFactories Class factory functions that will\r\n     * be applied.\r\n     *\r\n     * @returns {Class} A class that is the result of applying the factory functions.\r\n     * The resulting class will always inherit from AbstractHostFeature.\r\n     */\n\n  }], [{\n    key: "listenTo",\n    value: function listenTo(message, callback) {\n      message = "".concat(this.name, ".").concat(message);\n      core_Messenger.listenTo(message, callback);\n    }\n  }, {\n    key: "stopListening",\n    value: function stopListening(message, callback) {\n      message = "".concat(this.name, ".").concat(message);\n      core_Messenger.stopListening(message, callback);\n    }\n  }, {\n    key: "stopListeningByRegexp",\n    value: function stopListeningByRegexp(regexp, callback) {\n      regexp = new RegExp("^".concat(this.name, ".").concat(regexp.source.replace(/\\^/, \'\')));\n      core_Messenger.stopListeningByRegexp(regexp, callback);\n    }\n  }, {\n    key: "stopListeningToAll",\n    value: function stopListeningToAll() {\n      core_Messenger.stopListeningByRegexp(new RegExp("^".concat(this.name, ".")));\n    }\n  }, {\n    key: "emit",\n    value: function emit(message, value) {\n      message = "".concat(this.name, ".").concat(message);\n      core_Messenger.emit(message, value);\n    }\n  }, {\n    key: "mix",\n    value: function mix() {\n      var ResultClass = this;\n\n      for (var _len = arguments.length, mixinClassFactories = new Array(_len), _key = 0; _key < _len; _key++) {\n        mixinClassFactories[_key] = arguments[_key];\n      }\n\n      mixinClassFactories.forEach(function (mixinClassFactory) {\n        ResultClass = mixinClassFactory(ResultClass);\n      });\n      return ResultClass;\n    }\n  }]);\n\n  return AbstractHostFeature;\n}();\n\nObject.defineProperties(AbstractHostFeature, {\n  EVENTS: {\n    value: {\n      update: \'onUpdate\'\n    },\n    writable: false\n  },\n  SERVICES: {\n    value: {},\n    writable: false\n  }\n});\n/* harmony default export */ const core_AbstractHostFeature = (AbstractHostFeature);\n;// CONCATENATED MODULE: ./src/core/HostObject.js\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction HostObject_construct(Parent, args, Class) { if (HostObject_isNativeReflectConstruct()) { HostObject_construct = Reflect.construct; } else { HostObject_construct = function _construct(Parent, args, Class) { var a = [null]; a.push.apply(a, args); var Constructor = Function.bind.apply(Parent, a); var instance = new Constructor(); if (Class) HostObject_setPrototypeOf(instance, Class.prototype); return instance; }; } return HostObject_construct.apply(null, arguments); }\n\nfunction HostObject_typeof(obj) { "@babel/helpers - typeof"; return HostObject_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, HostObject_typeof(obj); }\n\nfunction HostObject_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction HostObject_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction HostObject_createClass(Constructor, protoProps, staticProps) { if (protoProps) HostObject_defineProperties(Constructor.prototype, protoProps); if (staticProps) HostObject_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction HostObject_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) HostObject_setPrototypeOf(subClass, superClass); }\n\nfunction HostObject_setPrototypeOf(o, p) { HostObject_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return HostObject_setPrototypeOf(o, p); }\n\nfunction HostObject_createSuper(Derived) { var hasNativeReflectConstruct = HostObject_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = HostObject_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = HostObject_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return HostObject_possibleConstructorReturn(this, result); }; }\n\nfunction HostObject_possibleConstructorReturn(self, call) { if (call && (HostObject_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return HostObject_assertThisInitialized(self); }\n\nfunction HostObject_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction HostObject_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction HostObject_getPrototypeOf(o) { HostObject_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return HostObject_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n/**\r\n * Object that manages access to all Host features. Contains a reference to\r\n * engine-specific visuals if applicable.\r\n *\r\n * @extends core/Messenger\r\n * @alias core/HostObject\r\n *\r\n * @property {Object} EVENTS - Built-in messages that the Messenger emits.\r\n * @property {string} [EVENTS.update=\'onUpdate\'] - Message that is emitted after\r\n * each call to [update]{@link core/HostObject#update}.\r\n * @property {string} [EVENTS.addFeature=\'onAddFeature\'] - Message that is emitted\r\n * after each call to [addFeature]{@link core/HostObject#addFeature}.\r\n * @property {string} [EVENTS.removeFeature=\'onRemoveFeature\'] - Message that is emitted\r\n * after each call to [removeFeature]{@link core/HostObject#removeFeature}.\r\n */\n\nvar HostObject = /*#__PURE__*/function (_Messenger) {\n  HostObject_inherits(HostObject, _Messenger);\n\n  var _super = HostObject_createSuper(HostObject);\n\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {Object=} options - Options for the host.\r\n   * @param {Object=} options.owner - Optional engine-specific owner of the host.\r\n   */\n  function HostObject() {\n    var _this;\n\n    var _ref = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {},\n        _ref$owner = _ref.owner,\n        owner = _ref$owner === void 0 ? {} : _ref$owner;\n\n    HostObject_classCallCheck(this, HostObject);\n\n    // If an owner is specified, use its id for messaging\n    _this = _super.call(this, owner.id);\n    _this._owner = owner;\n    _this._features = {};\n    _this._waits = [];\n    _this._lastUpdate = _this.now;\n    return _this;\n  }\n  /**\r\n   * Gets the engine owner object of the host.\r\n   *\r\n   * @readonly\r\n   * @type {Object}\r\n   */\n\n\n  HostObject_createClass(HostObject, [{\n    key: "owner",\n    get: function get() {\n      return this._owner;\n    }\n    /**\r\n     * Gets the current time in milliseconds.\r\n     *\r\n     * @readonly\r\n     * @type {number}\r\n     */\n\n  }, {\n    key: "now",\n    get: function get() {\n      return Date.now();\n    }\n    /**\r\n     * Gets the amount of time in milliseconds since update was last called.\r\n     *\r\n     * @readonly\r\n     * @type {number}\r\n     */\n\n  }, {\n    key: "deltaTime",\n    get: function get() {\n      return this.now - this._lastUpdate;\n    }\n    /**\r\n     * This function should be called in the engine\'s render loop. Executes update\r\n     * loops for all features.\r\n     */\n\n  }, {\n    key: "update",\n    value: function update() {\n      var currentTime = this.now;\n      var dt = this.deltaTime; // Progress stored waits\n\n      this._waits.forEach(function (wait) {\n        wait.execute(dt);\n      }); // Update all features\n\n\n      Object.values(this._features).forEach(function (feature) {\n        feature.update(dt);\n      }); // Notify listeners an update occured\n\n      this.emit(this.constructor.EVENTS.update, dt);\n      this._lastUpdate = currentTime;\n    }\n    /**\r\n     * Return a deferred promise that will wait a given number of seconds before\r\n     * resolving. The host will continuously update the wait promise during the\r\n     * update loop until it resolves.\r\n     *\r\n     * @param {number} [seconds=0] - Number of seconds to wait before resolving.\r\n     * @param {Object=} options - Optional options object\r\n     * @param {Function} [options.onFinish] - Callback to execute once the wait time\r\n     * is met.\r\n     * @param {Function=} options.onProgress - Callback to execute each time the wait\r\n     * time progresses towards the target number of seconds. The amount of progress\r\n     * as a 0-1 percentage is passed as an argument.\r\n     * @param {Function=} options.onCancel - Callback to execute if the user cancels\r\n     * the wait before completion.\r\n     * @param {Function=} options.onError - Callback to execute if the wait stops\r\n     * because an error is encountered. The error message is passed as a parameter.\r\n     *\r\n     * @returns {Deferred}\r\n     */\n\n  }, {\n    key: "wait",\n    value: function wait(seconds) {\n      var _this2 = this;\n\n      var _ref2 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          onFinish = _ref2.onFinish,\n          onProgress = _ref2.onProgress,\n          onCancel = _ref2.onCancel,\n          onError = _ref2.onError;\n\n      var wait = core_Utils.wait(seconds, {\n        onFinish: onFinish,\n        onProgress: onProgress,\n        onCancel: onCancel,\n        onError: onError\n      });\n\n      this._waits.push(wait); // Once the wait promise is no longer pending remove it from the waits array\n\n\n      var onComplete = function onComplete() {\n        _this2._waits.splice(_this2._waits.indexOf(wait), 1);\n      };\n\n      wait.then(onComplete, onComplete);\n      return wait;\n    }\n    /**\r\n     * Instantiate a new Host feature and store it. Features must inherit from\r\n     * AbstractHostFeature.\r\n     *\r\n     * @param {Class} FeatureClass - Class that will instantiate the feature. Must\r\n     * extend {@link AbstractHostFeature}.\r\n     * @param {boolean} [force=false] - Whether or not to overwrite an existing\r\n     * feature if one of this type already exists on the object.\r\n     * @param  {...any} args - Additional arguments to pass to the FeatureClass\r\n     * constructor. The HostObject will always be passed as the first argument.\r\n     *\r\n     * @returns {boolean} - Whether or not a feature was successfully added.\r\n     */\n\n  }, {\n    key: "addFeature",\n    value: function addFeature(FeatureClass) {\n      var force = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      var inputType = HostObject_typeof(FeatureClass); // Make sure the FeatureClass can be executed\n\n\n      if (inputType !== \'function\') {\n        throw new Error("Cannot add feature to host ".concat(this.id, ". FeatureClass must be a class."));\n      } // Make sure the feature is a host feature\n      else if (!(FeatureClass.prototype instanceof core_AbstractHostFeature)) {\n        throw new Error("Cannot add feature ".concat(FeatureClass.name, " to host ").concat(this.id, ". FeatureClass must extend AbstractHostFeature."));\n      } // Check if the FeatureClass already exists on this object\n\n\n      if (this._features[FeatureClass.name] !== undefined) {\n        if (force) {\n          console.warn("Feature ".concat(FeatureClass.name, " already exists on host ").concat(this.id, ". Existing feature will be overwritten."));\n        } else {\n          throw new Error("Feature ".concat(FeatureClass.name, " already exists on host ").concat(this.id, ". Use \'force\' argument to overwrite the feature."));\n        }\n      } // Initialize the feature\n\n\n      for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n        args[_key - 2] = arguments[_key];\n      }\n\n      var feature = HostObject_construct(FeatureClass, [this].concat(args));\n\n      feature.installApi();\n      this._features[FeatureClass.name] = feature;\n      this.emit(this.constructor.EVENTS.addFeature, FeatureClass.name);\n      return true;\n    }\n    /**\r\n     * Remove a feature from the object.\r\n     *\r\n     * @param {string} typeName - Name of the type of feature to remove.\r\n     *\r\n     * @returns {boolean} - Whether or not a feature was successfully removed.\r\n     */\n\n  }, {\n    key: "removeFeature",\n    value: function removeFeature(typeName) {\n      if (this._features[typeName] === undefined) {\n        console.warn("Feature of type ".concat(typeName, " does not exist on host ").concat(this.id, ". No feature will be removed."));\n        return false;\n      } else {\n        // Remove the feature\n        this.emit(this.constructor.EVENTS.removeFeature, typeName);\n\n        this._features[typeName].discard();\n\n        delete this._features[typeName];\n        return true;\n      }\n    }\n    /**\r\n     * Indicate whether a specified feature is installed on the host.\r\n     *\r\n     * @param {string} typeName - Name of the type of feature to look for.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "hasFeature",\n    value: function hasFeature(typeName) {\n      return !!this._features[typeName];\n    }\n    /**\r\n     * List the names of the features installed on the host.\r\n     *\r\n     * @returns {Array.<string>}\r\n     */\n\n  }, {\n    key: "listFeatures",\n    value: function listFeatures() {\n      return Object.keys(this._features);\n    }\n  }]);\n\n  return HostObject;\n}(core_Messenger);\n\nObject.defineProperty(HostObject, \'EVENTS\', {\n  value: _objectSpread(_objectSpread({}, Object.getPrototypeOf(HostObject).EVENTS), {}, {\n    update: \'onUpdate\',\n    addFeature: \'onAddFeature\',\n    removeFeature: \'onRemoveFeature\'\n  }),\n  writable: false\n});\n/* harmony default export */ const core_HostObject = (HostObject);\n;// CONCATENATED MODULE: ./src/core/animpack/Easing.js\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/**\r\n * @typedef {Object} EasingObject Object containing easing functions\r\n * @property {Function} In - Easing \'In\' function. Should use the signature (k:number):number.\r\n * @property {Function} Out - Easing \'Out\' function. Should use the signature (k:number):number.\r\n * @property {Function} InOut - Easing \'InOut\' function. Should use the signature (k:number):number.\r\n */\n\n/**\r\n * Linear Easing\r\n * @type {EasingObject}\r\n */\nvar Linear = {\n  None: function None(k) {\n    return k;\n  },\n  In: function In(k) {\n    return k;\n  },\n  Out: function Out(k) {\n    return k;\n  },\n  InOut: function InOut(k) {\n    return k;\n  }\n};\n/**\r\n * Quadratic Easing\r\n * @type {EasingObject}\r\n */\n\nvar Quadratic = {\n  In: function In(k) {\n    return k * k;\n  },\n  Out: function Out(k) {\n    return k * (2 - k);\n  },\n  InOut: function InOut(k) {\n    k *= 2;\n\n    if (k < 1) {\n      return 0.5 * k * k;\n    }\n\n    return -0.5 * (--k * (k - 2) - 1);\n  }\n};\n/**\r\n * Cubic Easing\r\n * @type {EasingObject}\r\n */\n\nvar Cubic = {\n  In: function In(k) {\n    return k * k * k;\n  },\n  Out: function Out(k) {\n    return --k * k * k + 1;\n  },\n  InOut: function InOut(k) {\n    k *= 2;\n\n    if (k < 1) {\n      return 0.5 * k * k * k;\n    }\n\n    k -= 2;\n    return 0.5 * (k * k * k + 2);\n  }\n};\n/**\r\n * Quartic Easing\r\n * @type {EasingObject}\r\n */\n\nvar Quartic = {\n  In: function In(k) {\n    return k * k * k * k;\n  },\n  Out: function Out(k) {\n    return 1 - --k * k * k * k;\n  },\n  InOut: function InOut(k) {\n    k *= 2;\n\n    if (k < 1) {\n      return 0.5 * k * k * k * k;\n    }\n\n    k -= 2;\n    return -0.5 * (k * k * k * k - 2);\n  }\n};\n/**\r\n * Quintic Easing\r\n * @type {EasingObject}\r\n */\n\nvar Quintic = {\n  In: function In(k) {\n    return k * k * k * k * k;\n  },\n  Out: function Out(k) {\n    return --k * k * k * k * k + 1;\n  },\n  InOut: function InOut(k) {\n    k *= 2;\n\n    if (k < 1) {\n      return 0.5 * k * k * k * k * k;\n    }\n\n    k -= 2;\n    return 0.5 * (k * k * k * k * k + 2);\n  }\n};\n/**\r\n * Sinusoidal Easing\r\n * @type {EasingObject}\r\n */\n\nvar Sinusoidal = {\n  In: function In(k) {\n    return 1 - Math.cos(k * Math.PI / 2);\n  },\n  Out: function Out(k) {\n    return Math.sin(k * Math.PI / 2);\n  },\n  InOut: function InOut(k) {\n    return 0.5 * (1 - Math.cos(Math.PI * k));\n  }\n};\n/**\r\n * Exponential Easing\r\n * @type {EasingObject}\r\n */\n\nvar Exponential = {\n  In: function In(k) {\n    return k === 0 ? 0 : Math.pow(1024, k - 1);\n  },\n  Out: function Out(k) {\n    return k === 1 ? 1 : 1 - Math.pow(2, -10 * k);\n  },\n  InOut: function InOut(k) {\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    k *= 2;\n\n    if (k < 1) {\n      return 0.5 * Math.pow(1024, k - 1);\n    }\n\n    return 0.5 * (-Math.pow(2, -10 * (k - 1)) + 2);\n  }\n};\n/**\r\n * Circular Easing\r\n * @type {EasingObject}\r\n */\n\nvar Circular = {\n  In: function In(k) {\n    return 1 - Math.sqrt(1 - k * k);\n  },\n  Out: function Out(k) {\n    return Math.sqrt(1 - --k * k);\n  },\n  InOut: function InOut(k) {\n    k *= 2;\n\n    if (k < 1) {\n      return -0.5 * (Math.sqrt(1 - k * k) - 1);\n    }\n\n    k -= 2;\n    return 0.5 * (Math.sqrt(1 - k * k) + 1);\n  }\n};\n/**\r\n * Elastic Easing\r\n * @type {EasingObject}\r\n */\n\nvar Elastic = {\n  In: function In(k) {\n    var s;\n    var a = 0.1;\n    var p = 0.4;\n\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if (!a || a < 1) {\n      a = 1;\n      s = p / 4;\n    } else {\n      s = p * Math.asin(1 / a) / (2 * Math.PI);\n    }\n\n    k -= 1;\n    return -(a * Math.pow(2, 10 * k) * Math.sin((k - s) * (2 * Math.PI) / p));\n  },\n  Out: function Out(k) {\n    var s;\n    var a = 0.1;\n    var p = 0.4;\n\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if (!a || a < 1) {\n      a = 1;\n      s = p / 4;\n    } else {\n      s = p * Math.asin(1 / a) / (2 * Math.PI);\n    }\n\n    return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) + 1;\n  },\n  InOut: function InOut(k) {\n    var s;\n    var a = 0.1;\n    var p = 0.4;\n\n    if (k === 0) {\n      return 0;\n    }\n\n    if (k === 1) {\n      return 1;\n    }\n\n    if (!a || a < 1) {\n      a = 1;\n      s = p / 4;\n    } else {\n      s = p * Math.asin(1 / a) / (2 * Math.PI);\n    }\n\n    k *= 2;\n\n    if (k < 1) {\n      k -= 1;\n      return -0.5 * (a * Math.pow(2, 10 * k) * Math.sin((k - s) * (2 * Math.PI) / p));\n    }\n\n    k -= 1;\n    return a * Math.pow(2, -10 * k) * Math.sin((k - s) * (2 * Math.PI) / p) * 0.5 + 1;\n  }\n};\n/**\r\n * Back Easing\r\n * @type {EasingObject}\r\n */\n\nvar Back = {\n  In: function In(k) {\n    var s = 1.70158;\n    return k * k * ((s + 1) * k - s);\n  },\n  Out: function Out(k) {\n    var s = 1.70158;\n    return --k * k * ((s + 1) * k + s) + 1;\n  },\n  InOut: function InOut(k) {\n    var s = 1.70158 * 1.525;\n    k *= 2;\n\n    if (k < 1) {\n      return 0.5 * (k * k * ((s + 1) * k - s));\n    }\n\n    k -= 2;\n    return 0.5 * (k * k * ((s + 1) * k + s) + 2);\n  }\n};\n/**\r\n * Bounce Easing\r\n * @type {EasingObject}\r\n */\n\nvar Bounce = {\n  In: function In(k) {\n    return 1 - Bounce.Out(1 - k);\n  },\n  Out: function Out(k) {\n    if (k < 1 / 2.75) {\n      return 7.5625 * k * k;\n    } else if (k < 2 / 2.75) {\n      k -= 1.5;\n      return 7.5625 * (k / 2.75) * k + 0.75;\n    } else if (k < 2.5 / 2.75) {\n      k -= 2.25;\n      return 7.5625 * (k / 2.75) * k + 0.9375;\n    }\n\n    k -= 2.625;\n    return 7.5625 * (k / 2.75) * k + 0.984375;\n  },\n  InOut: function InOut(k) {\n    if (k < 0.5) {\n      return Bounce.In(k * 2) * 0.5;\n    }\n\n    return Bounce.Out(k * 2 - 1) * 0.5 + 0.5;\n  }\n};\n;// CONCATENATED MODULE: ./src/core/FeatureDependentInterface.js\nfunction FeatureDependentInterface_typeof(obj) { "@babel/helpers - typeof"; return FeatureDependentInterface_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, FeatureDependentInterface_typeof(obj); }\n\nfunction FeatureDependentInterface_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction FeatureDependentInterface_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? FeatureDependentInterface_ownKeys(Object(source), !0).forEach(function (key) { FeatureDependentInterface_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : FeatureDependentInterface_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction FeatureDependentInterface_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction FeatureDependentInterface_slicedToArray(arr, i) { return FeatureDependentInterface_arrayWithHoles(arr) || FeatureDependentInterface_iterableToArrayLimit(arr, i) || FeatureDependentInterface_unsupportedIterableToArray(arr, i) || FeatureDependentInterface_nonIterableRest(); }\n\nfunction FeatureDependentInterface_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction FeatureDependentInterface_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return FeatureDependentInterface_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return FeatureDependentInterface_arrayLikeToArray(o, minLen); }\n\nfunction FeatureDependentInterface_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction FeatureDependentInterface_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction FeatureDependentInterface_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction _get() { if (typeof Reflect !== "undefined" && Reflect.get) { _get = Reflect.get; } else { _get = function _get(target, property, receiver) { var base = _superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return _get.apply(this, arguments); }\n\nfunction _superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = FeatureDependentInterface_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction FeatureDependentInterface_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) FeatureDependentInterface_setPrototypeOf(subClass, superClass); }\n\nfunction FeatureDependentInterface_setPrototypeOf(o, p) { FeatureDependentInterface_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return FeatureDependentInterface_setPrototypeOf(o, p); }\n\nfunction FeatureDependentInterface_createSuper(Derived) { var hasNativeReflectConstruct = FeatureDependentInterface_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = FeatureDependentInterface_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = FeatureDependentInterface_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return FeatureDependentInterface_possibleConstructorReturn(this, result); }; }\n\nfunction FeatureDependentInterface_possibleConstructorReturn(self, call) { if (call && (FeatureDependentInterface_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return FeatureDependentInterface_assertThisInitialized(self); }\n\nfunction FeatureDependentInterface_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction FeatureDependentInterface_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction FeatureDependentInterface_getPrototypeOf(o) { FeatureDependentInterface_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return FeatureDependentInterface_getPrototypeOf(o); }\n\nfunction FeatureDependentInterface_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction FeatureDependentInterface_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction FeatureDependentInterface_createClass(Constructor, protoProps, staticProps) { if (protoProps) FeatureDependentInterface_defineProperties(Constructor.prototype, protoProps); if (staticProps) FeatureDependentInterface_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/* eslint-disable no-unused-vars */\n\n/* eslint-disable max-classes-per-file */\n\n/**\r\n * Class factory interface for features that are dependent on other features being\r\n * present on the host. Event dependencies will be listened for when a feature of\r\n * matching type is added to the host and will stop being listened for when one\r\n * is removed. If the feature is already present when constructed, events will\r\n * be listened for right away.\r\n *\r\n * @interface\r\n *\r\n * @property {Object} EVENT_DEPENDENCIES - Events that the feature should start/stop\r\n * listening for when a feature of type FeatureName is added/removed from the host.\r\n * Event dependencies should follow the signature:\r\n *  { FeatureName: { eventName: callbackName, ... }, ... }\r\n */\n\nvar FeatureDependentInterface = /*#__PURE__*/function () {\n  function FeatureDependentInterface() {\n    FeatureDependentInterface_classCallCheck(this, FeatureDependentInterface);\n  }\n\n  FeatureDependentInterface_createClass(FeatureDependentInterface, [{\n    key: "_onFeatureAdded",\n    value:\n    /**\r\n     * Start listening for event dependencies that match the given feature type.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} typeName - type of feature to listen for.\r\n     */\n    function _onFeatureAdded(typeName) {}\n    /**\r\n     * Stop listening for event dependencies that match the given feature type.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} typeName - type of feature to stop listening for.\r\n     */\n\n  }, {\n    key: "_onFeatureRemoved",\n    value: function _onFeatureRemoved(typeName) {}\n    /**\r\n     * @augments {@link AbstractHostFeature#discard}\r\n     */\n\n  }, {\n    key: "discard",\n    value: function discard() {}\n    /**\r\n     * Creates a class that implements {@link FeatureDependentInterface} and extends\r\n     * a specified base class.\r\n     *\r\n     * @param {Class} BaseClass - The class to extend.\r\n     *\r\n     * @return {Class} A class that extends `BaseClass` and implements {@link FeatureDependentInterface}.\r\n     */\n\n  }], [{\n    key: "Mixin",\n    value: function Mixin(BaseClass) {\n      var FeatureDependentMixin = /*#__PURE__*/function (_BaseClass) {\n        FeatureDependentInterface_inherits(FeatureDependentMixin, _BaseClass);\n\n        var _super = FeatureDependentInterface_createSuper(FeatureDependentMixin);\n\n        function FeatureDependentMixin(host) {\n          var _this;\n\n          FeatureDependentInterface_classCallCheck(this, FeatureDependentMixin);\n\n          _this = _super.call(this, host);\n          _this._host = host; // No need to listen for events if the mixin is in the prototype chain multiple times\n\n          if (!_this._initialized) {\n            _this._initialized = true; // Start listening for feature events\n\n            _this._onFeatureAdded = _this._onFeatureAdded.bind(FeatureDependentInterface_assertThisInitialized(_this));\n            _this._onFeatureRemoved = _this._onFeatureRemoved.bind(FeatureDependentInterface_assertThisInitialized(_this));\n\n            _this._host.listenTo(core_HostObject.EVENTS.addFeature, _this._onFeatureAdded);\n\n            _this._host.listenTo(core_HostObject.EVENTS.removeFeature, _this._onFeatureRemoved); // Register features that already exist\n\n\n            Object.keys(_this.constructor.EVENT_DEPENDENCIES).forEach(function (typeName) {\n              if (_this._host[typeName] !== undefined) {\n                _this._onFeatureAdded(typeName);\n              }\n            });\n          }\n\n          return _this;\n        }\n\n        FeatureDependentInterface_createClass(FeatureDependentMixin, [{\n          key: "_onFeatureAdded",\n          value: function _onFeatureAdded(typeName) {\n            var _this2 = this;\n\n            if (this.constructor.EVENT_DEPENDENCIES[typeName] !== undefined) {\n              var events = this.constructor.EVENT_DEPENDENCIES[typeName];\n              Object.entries(events).forEach(function (_ref) {\n                var _ref2 = FeatureDependentInterface_slicedToArray(_ref, 2),\n                    eventName = _ref2[0],\n                    callback = _ref2[1];\n\n                _this2[callback] = _this2[callback].bind(_this2);\n\n                _this2._host.listenTo(_this2._host[typeName].EVENTS[eventName], _this2[callback]);\n              });\n            }\n          }\n        }, {\n          key: "_onFeatureRemoved",\n          value: function _onFeatureRemoved(typeName) {\n            var _this3 = this;\n\n            if (this.constructor.EVENT_DEPENDENCIES[typeName] !== undefined) {\n              var events = this.constructor.EVENT_DEPENDENCIES[typeName];\n              Object.entries(events).forEach(function (_ref3) {\n                var _ref4 = FeatureDependentInterface_slicedToArray(_ref3, 2),\n                    eventName = _ref4[0],\n                    callback = _ref4[1];\n\n                _this3._host.stopListening(_this3._host[typeName].EVENTS[eventName], _this3[callback]);\n              });\n            }\n          }\n        }, {\n          key: "discard",\n          value: function discard() {\n            var _this4 = this;\n\n            // Stop listening for feature events\n            this._host.stopListening(core_HostObject.EVENTS.addFeature, this._onFeatureAdded);\n\n            this._host.stopListening(core_HostObject.EVENTS.removeFeature, this._onFeatureRemoved); // Stop listening to feature-specific events\n\n\n            Object.keys(this.constructor.EVENT_DEPENDENCIES).forEach(function (typeName) {\n              if (_this4._host[typeName] !== undefined) {\n                _this4._onFeatureRemoved(typeName);\n              }\n            });\n\n            _get(FeatureDependentInterface_getPrototypeOf(FeatureDependentMixin.prototype), "discard", this).call(this);\n          }\n        }]);\n\n        return FeatureDependentMixin;\n      }(BaseClass);\n\n      var EVENT_DEPENDENCIES = BaseClass.EVENT_DEPENDENCIES || {};\n      Object.defineProperties(FeatureDependentMixin, {\n        EVENT_DEPENDENCIES: {\n          value: FeatureDependentInterface_objectSpread({}, EVENT_DEPENDENCIES),\n          writable: false\n        }\n      });\n      return FeatureDependentMixin;\n    }\n  }]);\n\n  return FeatureDependentInterface;\n}();\n/**\r\n * Event dependencies should follow the signature:\r\n * {\r\n *  FeatureName: {\r\n *    // Events that the feature should start/stop listening for when a feature\r\n *    // of type FeatureName is added/removed from the host\r\n *    {\r\n *      eventName: callbackName,\r\n *      ...\r\n *    },\r\n *  }\r\n * }\r\n */\n\n\nObject.defineProperties(FeatureDependentInterface, {\n  EVENT_DEPENDENCIES: {\n    value: {},\n    writable: false\n  }\n});\n/* harmony default export */ const core_FeatureDependentInterface = (FeatureDependentInterface);\n;// CONCATENATED MODULE: ./src/core/animpack/AnimationFeatureDependentInterface.js\nfunction AnimationFeatureDependentInterface_typeof(obj) { "@babel/helpers - typeof"; return AnimationFeatureDependentInterface_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, AnimationFeatureDependentInterface_typeof(obj); }\n\nfunction AnimationFeatureDependentInterface_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction AnimationFeatureDependentInterface_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? AnimationFeatureDependentInterface_ownKeys(Object(source), !0).forEach(function (key) { AnimationFeatureDependentInterface_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : AnimationFeatureDependentInterface_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction AnimationFeatureDependentInterface_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction AnimationFeatureDependentInterface_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction AnimationFeatureDependentInterface_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction AnimationFeatureDependentInterface_createClass(Constructor, protoProps, staticProps) { if (protoProps) AnimationFeatureDependentInterface_defineProperties(Constructor.prototype, protoProps); if (staticProps) AnimationFeatureDependentInterface_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction AnimationFeatureDependentInterface_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) AnimationFeatureDependentInterface_setPrototypeOf(subClass, superClass); }\n\nfunction AnimationFeatureDependentInterface_setPrototypeOf(o, p) { AnimationFeatureDependentInterface_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return AnimationFeatureDependentInterface_setPrototypeOf(o, p); }\n\nfunction AnimationFeatureDependentInterface_createSuper(Derived) { var hasNativeReflectConstruct = AnimationFeatureDependentInterface_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = AnimationFeatureDependentInterface_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = AnimationFeatureDependentInterface_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return AnimationFeatureDependentInterface_possibleConstructorReturn(this, result); }; }\n\nfunction AnimationFeatureDependentInterface_possibleConstructorReturn(self, call) { if (call && (AnimationFeatureDependentInterface_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return AnimationFeatureDependentInterface_assertThisInitialized(self); }\n\nfunction AnimationFeatureDependentInterface_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction AnimationFeatureDependentInterface_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction AnimationFeatureDependentInterface_getPrototypeOf(o) { AnimationFeatureDependentInterface_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return AnimationFeatureDependentInterface_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/* eslint-disable no-unused-vars */\n\n/* eslint-disable max-classes-per-file */\n\n/**\r\n * Class factory interface for features that are dependent on the AnimationFeature\r\n * being present on the host. Layer and animation events will automatically be\r\n * listened for once a AnimationFeature is added to the host and stopped once it\r\n * is removed.\r\n *\r\n * @interface\r\n * @extends FeatureDependentInterface\r\n *\r\n * @property {Object} EVENT_DEPENDENCIES - Events that the feature should start/stop\r\n * listening for when a feature of type FeatureName is added/removed from the host.\r\n * @property {Object} EVENT_DEPENDENCIES.AnimationFeature - Events that are\r\n * specific to the AnimationFeature.\r\n * @property {string} [EVENT_DEPENDENCIES.AnimationFeature.addLayer=\'_onLayerAdded\'] -\r\n * The name of the method that will be executed when AnimationFeature addLayer\r\n * events are emitted.\r\n * @property {string} [EVENT_DEPENDENCIES.AnimationFeature.removeLayer=\'_onLayerRemoved\'] -\r\n * The name of the method that will be executed when AnimationFeature removeLayer\r\n * events are emitted.\r\n * @property {string} [EVENT_DEPENDENCIES.AnimationFeature.renameLayer=\'_onLayerRenamed\'] -\r\n * The name of the method that will be executed when AnimationFeature renameLayer\r\n * events are emitted.\r\n * @property {string} [EVENT_DEPENDENCIES.AnimationFeature.addAnimation=\'_onAnimationAdded\'] -\r\n * The name of the method that will be executed when AnimationFeature addAnimation\r\n * events are emitted.\r\n * @property {string} [EVENT_DEPENDENCIES.AnimationFeature.removeAnimation=\'_onAnimationRemoved\'] -\r\n * The name of the method that will be executed when AnimationFeature removeAnimation\r\n * events are emitted.\r\n * @property {string} [EVENT_DEPENDENCIES.AnimationFeature.renameAnimation=\'_onAnimationRenamed\'] -\r\n * The name of the method that will be executed when AnimationFeature renameAnimation\r\n * events are emitted.\r\n */\n\nvar AnimationFeatureDependentInterface = /*#__PURE__*/function (_FeatureDependentInte) {\n  AnimationFeatureDependentInterface_inherits(AnimationFeatureDependentInterface, _FeatureDependentInte);\n\n  var _super = AnimationFeatureDependentInterface_createSuper(AnimationFeatureDependentInterface);\n\n  function AnimationFeatureDependentInterface() {\n    AnimationFeatureDependentInterface_classCallCheck(this, AnimationFeatureDependentInterface);\n\n    return _super.apply(this, arguments);\n  }\n\n  AnimationFeatureDependentInterface_createClass(AnimationFeatureDependentInterface, [{\n    key: "_onLayerAdded",\n    value:\n    /**\r\n     * Executed when animation layer added events are caught.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} name - Name of the layer that was added.\r\n     */\n    function _onLayerAdded(_ref) {\n      var name = _ref.name;\n    }\n    /**\r\n     * Executed when animation layer removed events are caught.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} name - Name of the layer that was removed.\r\n     */\n\n  }, {\n    key: "_onLayerRemoved",\n    value: function _onLayerRemoved(_ref2) {\n      var name = _ref2.name;\n    }\n    /**\r\n     * Executed when animation layer renamed events are caught.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} oldName - Name of the layer that was renamed.\r\n     * @param {string} newName - New name of the layer.\r\n     */\n\n  }, {\n    key: "_onLayerRenamed",\n    value: function _onLayerRenamed(_ref3) {\n      var oldName = _ref3.oldName,\n          newName = _ref3.newName;\n    }\n    /**\r\n     * Executed when animation added events are caught.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} layerName - Name of the layer that an animation was added to.\r\n     * @param {string} animationName - Name of the animation that was added.\r\n     */\n\n  }, {\n    key: "_onAnimationAdded",\n    value: function _onAnimationAdded(_ref4) {\n      var layerName = _ref4.layerName,\n          animationName = _ref4.animationName;\n    }\n    /**\r\n     * Executed when animation removed events are caught.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} layerName - Name of the layer that an animation was removed from.\r\n     * @param {string} animationName - Name of the animation that was removed.\r\n     */\n\n  }, {\n    key: "_onAnimationRemoved",\n    value: function _onAnimationRemoved(_ref5) {\n      var layerName = _ref5.layerName,\n          animationName = _ref5.animationName;\n    }\n    /**\r\n     * Executed when animation renamed events are caught.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} layerName - Name of the layer that an animation belongs to.\r\n     * @param {string} oldName - Name of the animation that was renamed.\r\n     * @param {string} newName - New name of the animation.\r\n     */\n\n  }, {\n    key: "_onAnimationRenamed",\n    value: function _onAnimationRenamed(_ref6) {\n      var layerName = _ref6.layerName,\n          oldName = _ref6.oldName,\n          newName = _ref6.newName;\n    }\n    /**\r\n     * Creates a class that implements {@link AnimationFeatureDependentInterface}\r\n     * and extends a specified base class.\r\n     *\r\n     * @param {Class} BaseClass - The class to extend.\r\n     *\r\n     * @return {Class} A class that extends `BaseClass` and implements {@link AnimationFeatureDependentInterface}.\r\n     */\n\n  }], [{\n    key: "Mixin",\n    value: function Mixin(BaseClass) {\n      var ParentClass = core_FeatureDependentInterface.Mixin(BaseClass);\n\n      var AnimationFeatureDependentMixin = /*#__PURE__*/function (_ParentClass) {\n        AnimationFeatureDependentInterface_inherits(AnimationFeatureDependentMixin, _ParentClass);\n\n        var _super2 = AnimationFeatureDependentInterface_createSuper(AnimationFeatureDependentMixin);\n\n        function AnimationFeatureDependentMixin() {\n          AnimationFeatureDependentInterface_classCallCheck(this, AnimationFeatureDependentMixin);\n\n          return _super2.apply(this, arguments);\n        }\n\n        AnimationFeatureDependentInterface_createClass(AnimationFeatureDependentMixin, [{\n          key: "_onLayerAdded",\n          value: function _onLayerAdded(_ref7) {\n            var name = _ref7.name;\n          }\n        }, {\n          key: "_onLayerRemoved",\n          value: function _onLayerRemoved(_ref8) {\n            var name = _ref8.name;\n          }\n        }, {\n          key: "_onLayerRenamed",\n          value: function _onLayerRenamed(_ref9) {\n            var oldName = _ref9.oldName,\n                newName = _ref9.newName;\n          }\n        }, {\n          key: "_onAnimationAdded",\n          value: function _onAnimationAdded(_ref10) {\n            var layerName = _ref10.layerName,\n                animationName = _ref10.animationName;\n          }\n        }, {\n          key: "_onAnimationRemoved",\n          value: function _onAnimationRemoved(_ref11) {\n            var layerName = _ref11.layerName,\n                animationName = _ref11.animationName;\n          }\n        }, {\n          key: "_onAnimationRenamed",\n          value: function _onAnimationRenamed(_ref12) {\n            var layerName = _ref12.layerName,\n                oldName = _ref12.oldName,\n                newName = _ref12.newName;\n          }\n        }]);\n\n        return AnimationFeatureDependentMixin;\n      }(ParentClass);\n\n      Object.defineProperties(AnimationFeatureDependentMixin, {\n        EVENT_DEPENDENCIES: {\n          value: AnimationFeatureDependentInterface_objectSpread(AnimationFeatureDependentInterface_objectSpread({}, ParentClass.EVENT_DEPENDENCIES), AnimationFeatureDependentInterface.EVENT_DEPENDENCIES),\n          writable: false\n        }\n      });\n      return AnimationFeatureDependentMixin;\n    }\n  }]);\n\n  return AnimationFeatureDependentInterface;\n}(core_FeatureDependentInterface);\n\nObject.defineProperties(AnimationFeatureDependentInterface, {\n  EVENT_DEPENDENCIES: {\n    value: {\n      AnimationFeature: {\n        addLayer: \'_onLayerAdded\',\n        removeLayer: \'_onLayerRemoved\',\n        renameLayer: \'_onLayerRenamed\',\n        addAnimation: \'_onAnimationAdded\',\n        removeAnimation: \'_onAnimationRemoved\',\n        renameAnimation: \'_onAnimationRenamed\'\n      }\n    },\n    writable: false\n  }\n});\n/* harmony default export */ const animpack_AnimationFeatureDependentInterface = (AnimationFeatureDependentInterface);\n;// CONCATENATED MODULE: ./src/core/animpack/ManagedAnimationLayerInterface.js\nfunction ManagedAnimationLayerInterface_typeof(obj) { "@babel/helpers - typeof"; return ManagedAnimationLayerInterface_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, ManagedAnimationLayerInterface_typeof(obj); }\n\nfunction ManagedAnimationLayerInterface_slicedToArray(arr, i) { return ManagedAnimationLayerInterface_arrayWithHoles(arr) || ManagedAnimationLayerInterface_iterableToArrayLimit(arr, i) || ManagedAnimationLayerInterface_unsupportedIterableToArray(arr, i) || ManagedAnimationLayerInterface_nonIterableRest(); }\n\nfunction ManagedAnimationLayerInterface_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction ManagedAnimationLayerInterface_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return ManagedAnimationLayerInterface_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return ManagedAnimationLayerInterface_arrayLikeToArray(o, minLen); }\n\nfunction ManagedAnimationLayerInterface_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction ManagedAnimationLayerInterface_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction ManagedAnimationLayerInterface_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction ManagedAnimationLayerInterface_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction ManagedAnimationLayerInterface_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ManagedAnimationLayerInterface_ownKeys(Object(source), !0).forEach(function (key) { ManagedAnimationLayerInterface_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ManagedAnimationLayerInterface_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction ManagedAnimationLayerInterface_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction ManagedAnimationLayerInterface_get() { if (typeof Reflect !== "undefined" && Reflect.get) { ManagedAnimationLayerInterface_get = Reflect.get; } else { ManagedAnimationLayerInterface_get = function _get(target, property, receiver) { var base = ManagedAnimationLayerInterface_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return ManagedAnimationLayerInterface_get.apply(this, arguments); }\n\nfunction ManagedAnimationLayerInterface_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = ManagedAnimationLayerInterface_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction ManagedAnimationLayerInterface_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction ManagedAnimationLayerInterface_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction ManagedAnimationLayerInterface_createClass(Constructor, protoProps, staticProps) { if (protoProps) ManagedAnimationLayerInterface_defineProperties(Constructor.prototype, protoProps); if (staticProps) ManagedAnimationLayerInterface_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction ManagedAnimationLayerInterface_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) ManagedAnimationLayerInterface_setPrototypeOf(subClass, superClass); }\n\nfunction ManagedAnimationLayerInterface_setPrototypeOf(o, p) { ManagedAnimationLayerInterface_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return ManagedAnimationLayerInterface_setPrototypeOf(o, p); }\n\nfunction ManagedAnimationLayerInterface_createSuper(Derived) { var hasNativeReflectConstruct = ManagedAnimationLayerInterface_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = ManagedAnimationLayerInterface_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = ManagedAnimationLayerInterface_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return ManagedAnimationLayerInterface_possibleConstructorReturn(this, result); }; }\n\nfunction ManagedAnimationLayerInterface_possibleConstructorReturn(self, call) { if (call && (ManagedAnimationLayerInterface_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return ManagedAnimationLayerInterface_assertThisInitialized(self); }\n\nfunction ManagedAnimationLayerInterface_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction ManagedAnimationLayerInterface_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction ManagedAnimationLayerInterface_getPrototypeOf(o) { ManagedAnimationLayerInterface_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return ManagedAnimationLayerInterface_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/* eslint-disable no-unused-vars */\n\n/* eslint-disable max-classes-per-file */\n\n/**\r\n * Class factory interface for that keeps track of layers and animations on a host.\r\n * Tracked assets are marked as inactive until layers and animations with matching\r\n * names are detected as present on the host.\r\n *\r\n * @interface\r\n * @extends AnimationFeatureDependentInterface\r\n *\r\n * @property {Object} DEFAULT_LAYER_OPTIONS - Default options to use when executing\r\n * {@link AnimationLayer} methods.\r\n * @property {number} [DEFAULT_LAYER_OPTIONS.blendTime=0.5] - Default time in seconds\r\n * to use when executing {@link AnimationLayer.setBlendWeight}.\r\n * @property {Object} [DEFAULT_LAYER_OPTIONS.animations={}] - Maps animation names\r\n * to default options objects to use for managed animations.\r\n */\n\nvar ManagedAnimationLayerInterface = /*#__PURE__*/function (_AnimationFeatureDepe) {\n  ManagedAnimationLayerInterface_inherits(ManagedAnimationLayerInterface, _AnimationFeatureDepe);\n\n  var _super = ManagedAnimationLayerInterface_createSuper(ManagedAnimationLayerInterface);\n\n  function ManagedAnimationLayerInterface() {\n    ManagedAnimationLayerInterface_classCallCheck(this, ManagedAnimationLayerInterface);\n\n    return _super.apply(this, arguments);\n  }\n\n  ManagedAnimationLayerInterface_createClass(ManagedAnimationLayerInterface, [{\n    key: "registerLayer",\n    value:\n    /**\r\n     * Start tracking keeping track of whether a layer with the given name is present\r\n     * on the host.\r\n     *\r\n     * @param {string} name - Name of the layer to keep track of.\r\n     * @param {Object=} options - Options for the layer.\r\n     * @param {number=} options.blendTime - Default amount of time to use when\r\n     * manipulating layer weights on this layer.\r\n     * @param {Function=} options.easingFn - Default easing function to use when\r\n     * manipulating layer weights on this layer.\r\n     * @param {Object=} options.animations - Animations to keep track of on the layer.\r\n     * Animations are represented as key/value pairs of animation names and their\r\n     * options.\r\n     */\n    function registerLayer(name) {\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n    }\n    /**\r\n     * Start tracking keeping track of whether an animation with the given name is\r\n     * present on the host.\r\n     *\r\n     * @param {string} layerName - Name of the layer that will own the animation.\r\n     * @param {string} animationName - Name of the animation to keep track of.\r\n     * @param {Object=} options - Options for the animation.\r\n     */\n\n  }, {\n    key: "registerAnimation",\n    value: function registerAnimation(layerName, animationName) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    }\n    /**\r\n     * Set layer weights on tracked layers.\r\n     *\r\n     * @param {Function=} nameFilter - Predicate function to test each tracked layer\r\n     * with. By default all layers will pass.\r\n     * @param {number} weight - Weight value to set on layers.\r\n     * @param {number=} seconds - Number of seconds it will take to reach the weight\r\n     * on each layer. If undefined, each layers\' blendTime option is used.\r\n     * @param {Function=} easingFn - Easing function to use when setting weight\r\n     * on each layer. If undefined, each layers\' easingFn option is used.\r\n     */\n\n  }, {\n    key: "setLayerWeights",\n    value: function setLayerWeights() {\n      var nameFilter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {\n        return true;\n      };\n      var weight = arguments.length > 1 ? arguments[1] : undefined;\n      var seconds = arguments.length > 2 ? arguments[2] : undefined;\n      var easingFn = arguments.length > 3 ? arguments[3] : undefined;\n    }\n    /**\r\n     * Set all tracked layers\' weights to 1.\r\n     *\r\n     * @param {number=} seconds - Number of seconds it will take to reach the weight\r\n     * on each layer. If undefined, each layers\' blendTime option is used.\r\n     * @param {Function=} easingFn - Easing function to use when setting weight\r\n     * on each layer. If undefined, each layers\' easingFn option is used.\r\n     */\n\n  }, {\n    key: "enable",\n    value: function enable(seconds, easingFn) {}\n    /**\r\n     * Set all tracked layers\' weights to 0.\r\n     *\r\n     * @param {number=} seconds - Number of seconds it will take to reach the weight\r\n     * on each layer. If undefined, each layers\' blendTime option is used.\r\n     * @param {Function=} easingFn - Easing function to use when setting weight\r\n     * on each layer. If undefined, each layers\' easingFn option is used.\r\n     */\n\n  }, {\n    key: "disable",\n    value: function disable(seconds, easingFn) {}\n    /**\r\n     * Creates a class that implements {@link ManagedAnimationLayerInterface}\r\n     * and extends a specified base class.\r\n     *\r\n     * @param {Class} BaseClass - The class to extend.\r\n     *\r\n     * @return {Class} A class that extends `BaseClass` and implements {@link ManagedAnimationLayerInterface}.\r\n     */\n\n  }], [{\n    key: "Mixin",\n    value: function Mixin(BaseClass) {\n      var ParentClass = animpack_AnimationFeatureDependentInterface.Mixin(BaseClass);\n\n      var ManagedAnimationLayerMixin = /*#__PURE__*/function (_ParentClass) {\n        ManagedAnimationLayerInterface_inherits(ManagedAnimationLayerMixin, _ParentClass);\n\n        var _super2 = ManagedAnimationLayerInterface_createSuper(ManagedAnimationLayerMixin);\n\n        function ManagedAnimationLayerMixin() {\n          var _this;\n\n          ManagedAnimationLayerInterface_classCallCheck(this, ManagedAnimationLayerMixin);\n\n          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n            args[_key] = arguments[_key];\n          }\n\n          _this = _super2.call.apply(_super2, [this].concat(args));\n          _this._managedLayers = {};\n          return _this;\n        }\n\n        ManagedAnimationLayerInterface_createClass(ManagedAnimationLayerMixin, [{\n          key: "_onFeatureAdded",\n          value: function _onFeatureAdded(typeName) {\n            var _this2 = this;\n\n            ManagedAnimationLayerInterface_get(ManagedAnimationLayerInterface_getPrototypeOf(ManagedAnimationLayerMixin.prototype), "_onFeatureAdded", this).call(this, typeName);\n\n            if (typeName !== \'AnimationFeature\') {\n              return;\n            }\n\n            this._managedLayers = this._managedLayers || {}; // Detect new layers\n\n            this._host.AnimationFeature.layers.forEach(function (name) {\n              _this2._onLayerAdded({\n                name: name\n              });\n            });\n          }\n        }, {\n          key: "_onFeatureRemoved",\n          value: function _onFeatureRemoved(typeName) {\n            var _this3 = this;\n\n            ManagedAnimationLayerInterface_get(ManagedAnimationLayerInterface_getPrototypeOf(ManagedAnimationLayerMixin.prototype), "_onFeatureRemoved", this).call(this, typeName);\n\n            if (typeName !== \'AnimationFeature\') {\n              return;\n            }\n\n            this._managedLayers = this._managedLayers || {}; // Deactivate the layers\n\n            Object.keys(this._managedLayers).forEach(function (name) {\n              _this3._onLayerRemoved({\n                name: name\n              });\n            });\n          }\n        }, {\n          key: "_onLayerAdded",\n          value: function _onLayerAdded(_ref) {\n            var _this4 = this;\n\n            var name = _ref.name;\n\n            // Mark the layer as active if it is managed\n            if (this._managedLayers[name] !== undefined) {\n              this._managedLayers[name].isActive = true; // Detect new animations\n\n              this._host.AnimationFeature.getAnimations(name).forEach(function (animName) {\n                _this4._onAnimationAdded({\n                  layerName: name,\n                  animationName: animName\n                });\n              });\n            }\n          }\n        }, {\n          key: "_onLayerRemoved",\n          value: function _onLayerRemoved(_ref2) {\n            var _this5 = this;\n\n            var name = _ref2.name;\n\n            // Deactivate the layer if it is managed\n            if (this._managedLayers[name] !== undefined) {\n              this._managedLayers[name].isActive = false; // Deactivate the animations\n\n              Object.keys(this._managedLayers[name].animations).forEach(function (animName) {\n                _this5._onAnimationRemoved({\n                  layerName: name,\n                  animationName: animName\n                });\n              });\n            }\n          }\n        }, {\n          key: "_onLayerRenamed",\n          value: function _onLayerRenamed(_ref3) {\n            var oldName = _ref3.oldName,\n                newName = _ref3.newName;\n            var layerOptions = this._managedLayers[oldName]; // Replace the layer key with the new name\n\n            if (layerOptions !== undefined) {\n              delete this._managedLayers[oldName];\n              this._managedLayers[newName] = layerOptions;\n            }\n          }\n        }, {\n          key: "_onAnimationAdded",\n          value: function _onAnimationAdded(_ref4) {\n            var layerName = _ref4.layerName,\n                animationName = _ref4.animationName;\n\n            // Mark the animation as active if it is managed\n            if (this._managedLayers[layerName] !== undefined && this._managedLayers[layerName].animations[animationName] !== undefined) {\n              this._managedLayers[layerName].animations[animationName].isActive = true;\n            }\n          }\n        }, {\n          key: "_onAnimationRemoved",\n          value: function _onAnimationRemoved(_ref5) {\n            var layerName = _ref5.layerName,\n                animationName = _ref5.animationName;\n\n            // Deactivate the animation if it is managed\n            if (this._managedLayers[layerName] !== undefined && this._managedLayers[layerName].animations[animationName] !== undefined) {\n              this._managedLayers[layerName].animations[animationName].isActive = false;\n            }\n          }\n        }, {\n          key: "_onAnimationRenamed",\n          value: function _onAnimationRenamed(_ref6) {\n            var layerName = _ref6.layerName,\n                oldName = _ref6.oldName,\n                newName = _ref6.newName;\n\n            if (this._managedLayers[layerName] !== undefined && this._managedLayers[layerName].animations[oldName] !== undefined) {\n              // Replace the animation key with the new name\n              var animOptions = this._managedLayers[layerName].animations[oldName];\n              delete this._managedLayers[layerName].animations[oldName];\n              this._managedLayers[layerName].animations[newName] = animOptions;\n            }\n          }\n        }, {\n          key: "registerLayer",\n          value: function registerLayer(name) {\n            var _this6 = this;\n\n            var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n            // Start with default options for each new layer\n            if (this._managedLayers[name] === undefined) {\n              this._managedLayers[name] = ManagedAnimationLayerInterface_objectSpread(ManagedAnimationLayerInterface_objectSpread({}, this.constructor.DEFAULT_LAYER_OPTIONS), {}, {\n                animations: {}\n              });\n            } // Update all options except animations\n\n\n            var layerOptions = this._managedLayers[name];\n            options = ManagedAnimationLayerInterface_objectSpread({}, options);\n            var animationOptions = options.animations || {};\n            delete options.animations;\n            Object.assign(layerOptions, options); // Check whether the layer can be manipulated now\n\n            layerOptions.isActive = this._host.AnimationFeature !== undefined && this._host.AnimationFeature.layers.includes(name); // Register the animations\n\n            Object.entries(animationOptions).forEach(function (_ref7) {\n              var _ref8 = ManagedAnimationLayerInterface_slicedToArray(_ref7, 2),\n                  animName = _ref8[0],\n                  animOptions = _ref8[1];\n\n              _this6.registerAnimation(name, animName, animOptions);\n            });\n          }\n        }, {\n          key: "registerAnimation",\n          value: function registerAnimation(layerName, animationName) {\n            var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n            // Register the layer if it hasn\'t been registered yet\n            if (this._managedLayers[layerName] === undefined) {\n              this.registerLayer(layerName);\n            } // Update animation options\n\n\n            var animOptions = this._managedLayers[layerName].animations[animationName] || {};\n            Object.assign(animOptions, options);\n            this._managedLayers[layerName].animations[animationName] = animOptions; // Check whether the animation can be manipulated now\n\n            this._managedLayers[layerName].animations[animationName].isActive = this._managedLayers[layerName].isActive && this._host.AnimationFeature.getAnimations(layerName).includes(animationName);\n          }\n        }, {\n          key: "setLayerWeights",\n          value: function setLayerWeights() {\n            var _this7 = this;\n\n            var nameFilter = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : function () {\n              return true;\n            };\n            var weight = arguments.length > 1 ? arguments[1] : undefined;\n            var seconds = arguments.length > 2 ? arguments[2] : undefined;\n            var easingFn = arguments.length > 3 ? arguments[3] : undefined;\n            var layerNames = Object.keys(this._managedLayers).filter(nameFilter);\n            layerNames.forEach(function (name) {\n              var layerOptions = _this7._managedLayers[name];\n\n              if (layerOptions.isActive) {\n                _this7._host.AnimationFeature.setLayerWeight(name, weight, seconds !== undefined ? seconds : layerOptions.blendTime, easingFn || layerOptions.easingFn);\n              }\n            });\n          }\n        }, {\n          key: "enable",\n          value: function enable(seconds, easingFn) {\n            this.setLayerWeights(undefined, 1, seconds, easingFn);\n          }\n        }, {\n          key: "disable",\n          value: function disable(seconds, easingFn) {\n            this.setLayerWeights(undefined, 0, seconds, easingFn);\n          }\n        }, {\n          key: "installApi",\n          value: function installApi() {\n            var api = ManagedAnimationLayerInterface_get(ManagedAnimationLayerInterface_getPrototypeOf(ManagedAnimationLayerMixin.prototype), "installApi", this).call(this);\n\n            Object.assign(api, {\n              registerLayer: this.registerLayer.bind(this),\n              registerAnimation: this.registerAnimation.bind(this),\n              setLayerWeights: this.setLayerWeights.bind(this),\n              enable: this.enable.bind(this),\n              disable: this.disable.bind(this)\n            });\n            return api;\n          }\n        }]);\n\n        return ManagedAnimationLayerMixin;\n      }(ParentClass);\n\n      Object.defineProperties(ManagedAnimationLayerMixin, {\n        DEFAULT_LAYER_OPTIONS: {\n          value: ManagedAnimationLayerInterface.DEFAULT_LAYER_OPTIONS,\n          writable: false\n        }\n      });\n      return ManagedAnimationLayerMixin;\n    }\n  }]);\n\n  return ManagedAnimationLayerInterface;\n}(animpack_AnimationFeatureDependentInterface);\n\nObject.defineProperties(ManagedAnimationLayerInterface, {\n  DEFAULT_LAYER_OPTIONS: {\n    value: {\n      blendTime: 0.5,\n      animations: {}\n    },\n    writable: false\n  }\n});\n/* harmony default export */ const animpack_ManagedAnimationLayerInterface = (ManagedAnimationLayerInterface);\n;// CONCATENATED MODULE: ./src/core/awspack/TextToSpeechFeatureDependentInterface.js\nfunction TextToSpeechFeatureDependentInterface_typeof(obj) { "@babel/helpers - typeof"; return TextToSpeechFeatureDependentInterface_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, TextToSpeechFeatureDependentInterface_typeof(obj); }\n\nfunction TextToSpeechFeatureDependentInterface_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction TextToSpeechFeatureDependentInterface_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? TextToSpeechFeatureDependentInterface_ownKeys(Object(source), !0).forEach(function (key) { TextToSpeechFeatureDependentInterface_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : TextToSpeechFeatureDependentInterface_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction TextToSpeechFeatureDependentInterface_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction TextToSpeechFeatureDependentInterface_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction TextToSpeechFeatureDependentInterface_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction TextToSpeechFeatureDependentInterface_createClass(Constructor, protoProps, staticProps) { if (protoProps) TextToSpeechFeatureDependentInterface_defineProperties(Constructor.prototype, protoProps); if (staticProps) TextToSpeechFeatureDependentInterface_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction TextToSpeechFeatureDependentInterface_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) TextToSpeechFeatureDependentInterface_setPrototypeOf(subClass, superClass); }\n\nfunction TextToSpeechFeatureDependentInterface_setPrototypeOf(o, p) { TextToSpeechFeatureDependentInterface_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return TextToSpeechFeatureDependentInterface_setPrototypeOf(o, p); }\n\nfunction TextToSpeechFeatureDependentInterface_createSuper(Derived) { var hasNativeReflectConstruct = TextToSpeechFeatureDependentInterface_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = TextToSpeechFeatureDependentInterface_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = TextToSpeechFeatureDependentInterface_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return TextToSpeechFeatureDependentInterface_possibleConstructorReturn(this, result); }; }\n\nfunction TextToSpeechFeatureDependentInterface_possibleConstructorReturn(self, call) { if (call && (TextToSpeechFeatureDependentInterface_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return TextToSpeechFeatureDependentInterface_assertThisInitialized(self); }\n\nfunction TextToSpeechFeatureDependentInterface_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction TextToSpeechFeatureDependentInterface_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction TextToSpeechFeatureDependentInterface_getPrototypeOf(o) { TextToSpeechFeatureDependentInterface_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return TextToSpeechFeatureDependentInterface_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/* eslint-disable max-classes-per-file */\n\n/**\r\n * Class factory interface for features that are dependent on the TextToSpeechFeature\r\n * being present on the host. Speech events will automatically be listened for once a\r\n * TextToSpeechFeature is added to the host and stopped once it is removed.\r\n *\r\n * @interface\r\n * @extends FeatureDependentInterface\r\n *\r\n * @property {Object} EVENT_DEPENDENCIES - Events that the feature should start/stop\r\n * listening for when a feature of type FeatureName is added/removed from the host.\r\n * @property {Object} EVENT_DEPENDENCIES.TextToSpeechFeature - Events that are\r\n * specific to the TextToSpeechFeature.\r\n * @property {string} [EVENT_DEPENDENCIES.TextToSpeechFeature.play=\'_onPlay\'] -\r\n * The name of the method that will be executed when TextToSpeechFeature play\r\n * events are emitted.\r\n * @property {string} [EVENT_DEPENDENCIES.TextToSpeechFeature.pause=\'_onPause\'] -\r\n * The name of the method that will be executed when TextToSpeechFeature pause\r\n * events are emitted.\r\n * @property {string} [EVENT_DEPENDENCIES.TextToSpeechFeature.resume=\'_onResume\'] -\r\n * The name of the method that will be executed when TextToSpeechFeature resume\r\n * events are emitted.\r\n * @property {string} [EVENT_DEPENDENCIES.TextToSpeechFeature.stop=\'_onStop\'] -\r\n * The name of the method that will be executed when TextToSpeechFeature stop\r\n * events are emitted.\r\n * @property {string} [EVENT_DEPENDENCIES.TextToSpeechFeature.sentence=\'_onSentence\'] -\r\n * The name of the method that will be executed when TextToSpeechFeature sentence\r\n * events are emitted.\r\n * @property {string} [EVENT_DEPENDENCIES.TextToSpeechFeature.word=\'_onWord\'] -\r\n * The name of the method that will be executed when TextToSpeechFeature word\r\n * events are emitted.\r\n * @property {string} [EVENT_DEPENDENCIES.TextToSpeechFeature.viseme=\'_onViseme\'] -\r\n * The name of the method that will be executed when TextToSpeechFeature viseme\r\n * events are emitted.\r\n * @property {string} [EVENT_DEPENDENCIES.TextToSpeechFeature.ssml=\'_onSsml\'] -\r\n * The name of the method that will be executed when TextToSpeechFeature ssml\r\n * events are emitted.\r\n */\n\nvar TextToSpeechFeatureDependentInterface = /*#__PURE__*/function (_FeatureDependentInte) {\n  TextToSpeechFeatureDependentInterface_inherits(TextToSpeechFeatureDependentInterface, _FeatureDependentInte);\n\n  var _super = TextToSpeechFeatureDependentInterface_createSuper(TextToSpeechFeatureDependentInterface);\n\n  function TextToSpeechFeatureDependentInterface() {\n    TextToSpeechFeatureDependentInterface_classCallCheck(this, TextToSpeechFeatureDependentInterface);\n\n    return _super.apply(this, arguments);\n  }\n\n  TextToSpeechFeatureDependentInterface_createClass(TextToSpeechFeatureDependentInterface, [{\n    key: "_onPlay",\n    value:\n    /**\r\n     * Executed when speech play events are caught.\r\n     *\r\n     * @private\r\n     */\n    function _onPlay() {}\n    /**\r\n     * Executed when speech pause events are caught.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_onPause",\n    value: function _onPause() {}\n    /**\r\n     * Executed when speech resume events are caught.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_onResume",\n    value: function _onResume() {}\n    /**\r\n     * Executed when speech stop events are caught.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_onStop",\n    value: function _onStop() {}\n    /**\r\n     * Executed when speech sentence events are caught.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_onSentence",\n    value: function _onSentence() {}\n    /**\r\n     * Executed when speech word events are caught.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_onWord",\n    value: function _onWord() {}\n    /**\r\n     * Executed when speech viseme events are caught.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_onViseme",\n    value: function _onViseme() {}\n    /**\r\n     * Executed when speech ssml events are caught.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_onSsml",\n    value: function _onSsml() {}\n    /**\r\n     * Creates a class that implements {@link TextToSpeechFeatureDependentInterface}\r\n     * and extends a specified base class.\r\n     *\r\n     * @param {Class} BaseClass - The class to extend.\r\n     *\r\n     * @return {Class} A class that extends `BaseClass` and implements {@link TextToSpeechFeatureDependentInterface}.\r\n     */\n\n  }], [{\n    key: "Mixin",\n    value: function Mixin(BaseClass) {\n      var ParentClass = core_FeatureDependentInterface.Mixin(BaseClass);\n\n      var TextToSpeechFeatureDependentMixin = /*#__PURE__*/function (_ParentClass) {\n        TextToSpeechFeatureDependentInterface_inherits(TextToSpeechFeatureDependentMixin, _ParentClass);\n\n        var _super2 = TextToSpeechFeatureDependentInterface_createSuper(TextToSpeechFeatureDependentMixin);\n\n        function TextToSpeechFeatureDependentMixin() {\n          TextToSpeechFeatureDependentInterface_classCallCheck(this, TextToSpeechFeatureDependentMixin);\n\n          return _super2.apply(this, arguments);\n        }\n\n        TextToSpeechFeatureDependentInterface_createClass(TextToSpeechFeatureDependentMixin, [{\n          key: "_onPlay",\n          value: function _onPlay() {}\n        }, {\n          key: "_onPause",\n          value: function _onPause() {}\n        }, {\n          key: "_onResume",\n          value: function _onResume() {}\n        }, {\n          key: "_onStop",\n          value: function _onStop() {}\n        }, {\n          key: "_onSentence",\n          value: function _onSentence() {}\n        }, {\n          key: "_onWord",\n          value: function _onWord() {}\n        }, {\n          key: "_onViseme",\n          value: function _onViseme() {}\n        }, {\n          key: "_onSsml",\n          value: function _onSsml() {}\n        }]);\n\n        return TextToSpeechFeatureDependentMixin;\n      }(ParentClass);\n\n      Object.defineProperties(TextToSpeechFeatureDependentMixin, {\n        EVENT_DEPENDENCIES: {\n          value: TextToSpeechFeatureDependentInterface_objectSpread(TextToSpeechFeatureDependentInterface_objectSpread({}, ParentClass.EVENT_DEPENDENCIES), TextToSpeechFeatureDependentInterface.EVENT_DEPENDENCIES),\n          writable: false\n        }\n      });\n      return TextToSpeechFeatureDependentMixin;\n    }\n  }]);\n\n  return TextToSpeechFeatureDependentInterface;\n}(core_FeatureDependentInterface);\n\nObject.defineProperties(TextToSpeechFeatureDependentInterface, {\n  EVENT_DEPENDENCIES: {\n    value: {\n      TextToSpeechFeature: {\n        play: \'_onPlay\',\n        pause: \'_onPause\',\n        resume: \'_onResume\',\n        stop: \'_onStop\',\n        sentence: \'_onSentence\',\n        word: \'_onWord\',\n        viseme: \'_onViseme\',\n        ssml: \'_onSsml\'\n      }\n    },\n    writable: false\n  }\n});\n/* harmony default export */ const awspack_TextToSpeechFeatureDependentInterface = (TextToSpeechFeatureDependentInterface);\n;// CONCATENATED MODULE: ./src/core/LipsyncFeature.js\nfunction LipsyncFeature_typeof(obj) { "@babel/helpers - typeof"; return LipsyncFeature_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, LipsyncFeature_typeof(obj); }\n\nfunction LipsyncFeature_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction LipsyncFeature_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? LipsyncFeature_ownKeys(Object(source), !0).forEach(function (key) { LipsyncFeature_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : LipsyncFeature_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction LipsyncFeature_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) { try { var info = gen[key](arg); var value = info.value; } catch (error) { reject(error); return; } if (info.done) { resolve(value); } else { Promise.resolve(value).then(_next, _throw); } }\n\nfunction _asyncToGenerator(fn) { return function () { var self = this, args = arguments; return new Promise(function (resolve, reject) { var gen = fn.apply(self, args); function _next(value) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value); } function _throw(err) { asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err); } _next(undefined); }); }; }\n\nfunction LipsyncFeature_slicedToArray(arr, i) { return LipsyncFeature_arrayWithHoles(arr) || LipsyncFeature_iterableToArrayLimit(arr, i) || LipsyncFeature_unsupportedIterableToArray(arr, i) || LipsyncFeature_nonIterableRest(); }\n\nfunction LipsyncFeature_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction LipsyncFeature_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return LipsyncFeature_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return LipsyncFeature_arrayLikeToArray(o, minLen); }\n\nfunction LipsyncFeature_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction LipsyncFeature_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction LipsyncFeature_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction LipsyncFeature_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction LipsyncFeature_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction LipsyncFeature_createClass(Constructor, protoProps, staticProps) { if (protoProps) LipsyncFeature_defineProperties(Constructor.prototype, protoProps); if (staticProps) LipsyncFeature_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction LipsyncFeature_get() { if (typeof Reflect !== "undefined" && Reflect.get) { LipsyncFeature_get = Reflect.get; } else { LipsyncFeature_get = function _get(target, property, receiver) { var base = LipsyncFeature_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return LipsyncFeature_get.apply(this, arguments); }\n\nfunction LipsyncFeature_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = LipsyncFeature_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction LipsyncFeature_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) LipsyncFeature_setPrototypeOf(subClass, superClass); }\n\nfunction LipsyncFeature_setPrototypeOf(o, p) { LipsyncFeature_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return LipsyncFeature_setPrototypeOf(o, p); }\n\nfunction LipsyncFeature_createSuper(Derived) { var hasNativeReflectConstruct = LipsyncFeature_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = LipsyncFeature_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = LipsyncFeature_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return LipsyncFeature_possibleConstructorReturn(this, result); }; }\n\nfunction LipsyncFeature_possibleConstructorReturn(self, call) { if (call && (LipsyncFeature_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return LipsyncFeature_assertThisInitialized(self); }\n\nfunction LipsyncFeature_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction LipsyncFeature_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction LipsyncFeature_getPrototypeOf(o) { LipsyncFeature_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return LipsyncFeature_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n\n\n/**\r\n * Default mapping of Polly viseme names to animation options objects.\r\n *\r\n * @property {Object} [sil={name: \'sil\'}]\r\n * @property {Object} [p={name: \'p\', overrideWeight: 0.9}]\r\n * @property {Object} [t={name: \'t\', blendTime: 0.2}]\r\n * @property {Object} [S={name: \'S\'}]\r\n * @property {Object} [T={name: \'T\'}]\r\n * @property {Object} [f={name: \'f\', overrideWeight: 0.75}]\r\n * @property {Object} [k={name: \'k\'}]\r\n * @property {Object} [i={name: \'i\'}]\r\n * @property {Object} [r={name: \'r\'}]\r\n * @property {Object} [s={name: \'s\', blendTime: 0.25}]\r\n * @property {Object} [u={name: \'u\'}]\r\n * @property {Object} [@={name: \'@\'}]\r\n * @property {Object} [a={name: \'a\'}]\r\n * @property {Object} [e={name: \'e\', blendTime: 0.2}]\r\n * @property {Object} [E={name: \'E\'}]\r\n * @property {Object} [o={name: \'o\'}]\r\n * @property {Object} [O={name: \'O\'}]\r\n */\n\nvar DefaultVisemeMap = {\n  sil: {\n    name: \'sil\'\n  },\n  p: {\n    name: \'p\',\n    overrideWeight: 0.9\n  },\n  t: {\n    name: \'t\',\n    blendTime: 0.2\n  },\n  S: {\n    name: \'S\'\n  },\n  T: {\n    name: \'T\'\n  },\n  f: {\n    name: \'f\',\n    overrideWeight: 0.75\n  },\n  k: {\n    name: \'k\'\n  },\n  i: {\n    name: \'i\'\n  },\n  r: {\n    name: \'r\'\n  },\n  s: {\n    name: \'s\',\n    blendTime: 0.25\n  },\n  u: {\n    name: \'u\'\n  },\n  \'@\': {\n    name: \'@\'\n  },\n  a: {\n    name: \'a\'\n  },\n  e: {\n    name: \'e\',\n    blendTime: 0.2\n  },\n  E: {\n    name: \'E\'\n  },\n  o: {\n    name: \'o\'\n  },\n  O: {\n    name: \'O\'\n  }\n};\n/**\r\n * Lipsync controls two types of movement: idle animation that should play while\r\n * speech is playing and viseme animations corresponding to Polly visemes whose\r\n * weights should be turned on and off as they are encountered in the Polly SSML\r\n * transcript. Layers owned by this feature will be enabled while speech is playing\r\n * and disabled once it stops.\r\n *\r\n * @extends AbstractHostFeature\r\n * @alias core/LipsyncFeature\r\n * @implements TextToSpeechFeatureDependentInterface\r\n * @implements ManagedAnimationLayerInterface\r\n */\n\nvar LipsyncFeature = /*#__PURE__*/function (_AbstractHostFeature$) {\n  LipsyncFeature_inherits(LipsyncFeature, _AbstractHostFeature$);\n\n  var _super = LipsyncFeature_createSuper(LipsyncFeature);\n\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {core/HostObject} host - Host that owns the feature.\r\n   * @param {Object=} visemeOptions - Options for the viseme layers.\r\n   * @param {number} [visemeOptions.blendTime=0.15] - Default amount of time it\r\n   * will take to manipulate each freeBlend weight on the viseme states.\r\n   * @param {Object} [visemeOptions.decayRate={amount: .5, seconds: .5}] - An object\r\n   * describing the 0-1 factor viseme weight will decay if the viseme duration is\r\n   * longer than the blendTime and the number of seconds it would take to decay\r\n   * by that factor.\r\n   * @param {number} [visemeOptions.easingFn=Quadratic.InOut] - Default easing function\r\n   * to use when manipulating viseme freeBlend weights.\r\n   * @param {Array.<Object>} [visemeOptions..layers=[]] - An array of layer options\r\n   * objects to register as viseme layers.\r\n   * @param {Object=} talkingOptions - Options for the talking layers.\r\n   * @param {number} [talkingOptions.blendTime=0.75] - Default amount of time to\r\n   * enable and disable the talking idle layers\r\n   * @param {number} [talkingOptions.easingFn=Quadratic.InOut] - Default easing\r\n   * function to use when manipulating weights on the talking idle layers.\r\n   * @param {Array.<Object>} [talkingOptions.layers=[]] - An array of layer options\r\n   * objects to register as talking layers.\r\n   * @param {number} [visemeLeadTime=.067] - The amount of time to instruct the\r\n   * TextToSpeechFeature to emit speechmarks before each one\'s actual timestamp\r\n   * is reached. This will set the \'speechMarkOffset\' variable on the TextToSpeechFeature.\r\n   */\n  function LipsyncFeature(host) {\n    var _this;\n\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$blendTime = _ref.blendTime,\n        visemeBlendTime = _ref$blendTime === void 0 ? 0.15 : _ref$blendTime,\n        _ref$decayRate = _ref.decayRate;\n\n    _ref$decayRate = _ref$decayRate === void 0 ? {} : _ref$decayRate;\n    var _ref$decayRate$amount = _ref$decayRate.amount,\n        amount = _ref$decayRate$amount === void 0 ? 0.5 : _ref$decayRate$amount,\n        _ref$decayRate$second = _ref$decayRate.seconds,\n        seconds = _ref$decayRate$second === void 0 ? 0.5 : _ref$decayRate$second,\n        _ref$easingFn = _ref.easingFn,\n        visemeEasingFn = _ref$easingFn === void 0 ? Quadratic.InOut : _ref$easingFn,\n        _ref$layers = _ref.layers,\n        visemeLayers = _ref$layers === void 0 ? [] : _ref$layers;\n\n    var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        _ref2$blendTime = _ref2.blendTime,\n        talkingBlendTime = _ref2$blendTime === void 0 ? 0.75 : _ref2$blendTime,\n        _ref2$easingFn = _ref2.easingFn,\n        talkingEasingFn = _ref2$easingFn === void 0 ? Quadratic.InOut : _ref2$easingFn,\n        _ref2$layers = _ref2.layers,\n        talkingLayers = _ref2$layers === void 0 ? [] : _ref2$layers;\n\n    var visemeLeadTime = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0.067;\n\n    LipsyncFeature_classCallCheck(this, LipsyncFeature);\n\n    _this = _super.call(this, host);\n    _this._visemeLayers = {};\n    _this._talkingLayers = {};\n    _this.visemeLeadTime = visemeLeadTime; // Register the viseme layers\n\n    visemeLayers.forEach(function (_ref3) {\n      var name = _ref3.name,\n          animation = _ref3.animation,\n          _ref3$visemeMap = _ref3.visemeMap,\n          visemeMap = _ref3$visemeMap === void 0 ? DefaultVisemeMap : _ref3$visemeMap;\n\n      _this.registerVisemeLayer(name, {\n        animation: animation,\n        visemeMap: visemeMap,\n        decayRate: {\n          amount: amount,\n          seconds: seconds\n        },\n        blendTime: visemeBlendTime,\n        easingFn: visemeEasingFn\n      });\n    }); // Register the talking layers\n\n    talkingLayers.forEach(function (_ref4) {\n      var name = _ref4.name,\n          animation = _ref4.animation;\n\n      _this.registerTalkingLayer(name, {\n        animation: animation,\n        blendTime: talkingBlendTime,\n        easingFn: talkingEasingFn\n      });\n    });\n    return _this;\n  }\n  /**\r\n   * Ensure that registered viseme animations are FreeBlendStates.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {string} layerName - Name of the layer that contains the viseme animation.\r\n   * @param {string} animationName - Name of the animation.\r\n   */\n\n\n  LipsyncFeature_createClass(LipsyncFeature, [{\n    key: "_registerVisemeAnimation",\n    value: function _registerVisemeAnimation(layerName, animationName) {\n      if (this._managedLayers[layerName].animations[animationName].isActive) {\n        if (this._host.AnimationFeature.getAnimationType(layerName, animationName) !== \'freeBlend\') {\n          // Warn and deactivate if the registered state is not freeBlend\n          console.warn("Cannot register Lipsync viseme animation ".concat(animationName, " on layer ").concat(layerName, " for host ").concat(this._host.id, ". Viseme animations must be of type \'freeBlend\'."));\n          this._managedLayers[layerName].animations[animationName].isActive = false;\n        } else {\n          // Check if the blendWeights can be manipulated now\n          var weightNames = this._host.AnimationFeature.getAnimationBlendNames(layerName, animationName);\n\n          var visemeMap = this._managedLayers[layerName].animations[animationName].visemeMap;\n          Object.values(visemeMap).forEach(function (visemeOptions) {\n            visemeOptions.isActive = weightNames.includes(visemeOptions.name);\n          });\n        }\n      }\n    }\n    /**\r\n     * If the added feature is TextToSpeech, update its speechMarkOffset variable.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} typeName - Name of the type of feature that was added.\r\n     */\n\n  }, {\n    key: "_onFeatureAdded",\n    value: function _onFeatureAdded(typeName) {\n      this._visemeLayers = this._visemeLayers || {};\n      this._talkingLayers = this._talkingLayers || {};\n\n      LipsyncFeature_get(LipsyncFeature_getPrototypeOf(LipsyncFeature.prototype), "_onFeatureAdded", this).call(this, typeName);\n\n      if (typeName === \'TextToSpeechFeature\') {\n        this._host.TextToSpeechFeature.speechmarkOffset = -this._visemeLeadTime || 0;\n      }\n    }\n  }, {\n    key: "_onLayerAdded",\n    value: function _onLayerAdded(_ref5) {\n      var name = _ref5.name;\n\n      LipsyncFeature_get(LipsyncFeature_getPrototypeOf(LipsyncFeature.prototype), "_onLayerAdded", this).call(this, {\n        name: name\n      }); // Validate the viseme animation\n\n\n      if (this._visemeLayers[name] !== undefined) {\n        this._registerVisemeAnimation(name, this._visemeLayers[name]);\n      }\n    }\n  }, {\n    key: "_onAnimationAdded",\n    value: function _onAnimationAdded(_ref6) {\n      var layerName = _ref6.layerName,\n          animationName = _ref6.animationName;\n\n      LipsyncFeature_get(LipsyncFeature_getPrototypeOf(LipsyncFeature.prototype), "_onAnimationAdded", this).call(this, {\n        layerName: layerName\n      }); // Validate the viseme animation\n\n\n      if (this._visemeLayers[layerName] === animationName) {\n        this._registerVisemeAnimation(layerName, this._visemeLayers[layerName]);\n      }\n    }\n  }, {\n    key: "_onPlay",\n    value: function _onPlay() {\n      var _this2 = this;\n\n      // Turn on the layer weights\n      this.enable(); // Set the current animations\n\n      [this._visemeLayers, this._talkingLayers].forEach(function (layers) {\n        Object.entries(layers).forEach(function (_ref7) {\n          var _ref8 = LipsyncFeature_slicedToArray(_ref7, 2),\n              layerName = _ref8[0],\n              animationName = _ref8[1];\n\n          if (_this2._managedLayers[layerName].animations[animationName].isActive) {\n            _this2._host.AnimationFeature.resumeAnimation(layerName, animationName);\n          }\n        });\n      });\n    }\n  }, {\n    key: "_onPause",\n    value: function _onPause() {\n      this._onStop();\n    }\n  }, {\n    key: "_onResume",\n    value: function _onResume() {\n      this._onPlay();\n    }\n  }, {\n    key: "_onStop",\n    value: function _onStop() {\n      var _this3 = this;\n\n      // Turn off the layer weights\n      this.disable(); // Pause the current animations\n\n      [this._visemeLayers, this._talkingLayers].forEach(function (layers) {\n        Object.entries(layers).forEach(function (_ref9) {\n          var _ref10 = LipsyncFeature_slicedToArray(_ref9, 2),\n              layerName = _ref10[0],\n              animationName = _ref10[1];\n\n          if (_this3._managedLayers[layerName].animations[animationName].isActive) {\n            _this3._host.AnimationFeature.pauseAnimation(layerName, animationName);\n          }\n        });\n      });\n    }\n    /**\r\n     * When viseme events are caught, turn on weight of the new viseme for the duration\r\n     * of the speech mark, then turn weight back off.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {Object} event - Event data passed from the speech.\r\n     * @param {Object} event.mark - Speechmark object.\r\n     */\n\n  }, {\n    key: "_onViseme",\n    value: function () {\n      var _onViseme2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee(_ref11) {\n        var _this4 = this;\n\n        var mark;\n        return regeneratorRuntime.wrap(function _callee$(_context) {\n          while (1) {\n            switch (_context.prev = _context.next) {\n              case 0:\n                mark = _ref11.mark;\n                Object.entries(this._visemeLayers).forEach(function (_ref12) {\n                  var _ref13 = LipsyncFeature_slicedToArray(_ref12, 2),\n                      layerName = _ref13[0],\n                      animName = _ref13[1];\n\n                  // Make sure the layer can be manipulated\n                  var _this4$_managedLayers = _this4._managedLayers[layerName].animations[animName],\n                      isActive = _this4$_managedLayers.isActive,\n                      visemeMap = _this4$_managedLayers.visemeMap;\n\n                  if (!isActive) {\n                    return;\n                  } // Take variables from the viseme if they exist and default to the layer\n\n\n                  var _this4$_managedLayers2 = LipsyncFeature_objectSpread(LipsyncFeature_objectSpread({}, _this4._managedLayers[layerName]), visemeMap[mark.value]),\n                      viseme = _this4$_managedLayers2.name,\n                      isVisemeActive = _this4$_managedLayers2.isActive,\n                      decayRate = _this4$_managedLayers2.decayRate,\n                      blendTime = _this4$_managedLayers2.blendTime,\n                      easingFn = _this4$_managedLayers2.easingFn,\n                      overrideWeight = _this4$_managedLayers2.overrideWeight;\n\n                  var visemeNames = _this4._host.AnimationFeature.getAnimationBlendNames(layerName, animName); // Make sure the new viseme has an active freeBlend weight\n\n\n                  if (!isVisemeActive || !visemeNames.includes(viseme)) {\n                    return;\n                  } // Find the peak weight for the viseme and the amount of time it should\n                  // take to reach it\n\n\n                  var weight = 1;\n                  var duration = mark.duration / 1000;\n\n                  if (duration < blendTime) {\n                    var lerpFactor = blendTime > 0 ? duration / blendTime : 1;\n                    weight = overrideWeight !== undefined ? overrideWeight : core_MathUtils.lerp(0, 1, lerpFactor);\n                  }\n\n                  var blendInTime = Math.min(duration, blendTime); // Find the amount and time viseme will be held for\n\n                  var holdTime = duration - blendTime;\n\n                  if (holdTime < 0) {\n                    // Perform in -> out animation\n                    _this4._animateSimpleViseme(layerName, animName, viseme, weight, blendInTime, blendTime, easingFn);\n                  } else {\n                    var _lerpFactor = decayRate.seconds > 0 ? holdTime / decayRate.seconds : 1; // Perform in -> hold -> out animation\n\n\n                    var decayWeight = core_MathUtils.lerp(weight, weight * decayRate.amount, Math.min(1, _lerpFactor));\n\n                    _this4._animateHeldViseme(layerName, animName, viseme, weight, decayWeight, blendInTime, holdTime, blendTime, easingFn);\n                  }\n                });\n\n              case 2:\n              case "end":\n                return _context.stop();\n            }\n          }\n        }, _callee, this);\n      }));\n\n      function _onViseme(_x) {\n        return _onViseme2.apply(this, arguments);\n      }\n\n      return _onViseme;\n    }()\n    /**\r\n     * Animate a viseme blend weight towards a value and then back to zero.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} layerName - Name of the layer that contains the viseme.\r\n     * @param {string} animName - Name of the freeblend animation that contains\r\n     * the viseme.\r\n     * @param {string} visemeName - Name of the blend weight to manipulate.\r\n     * @param {number} weight - Peak weight to animate towards.\r\n     * @param {number} blendInTime - Amount of time it should take to reach the\r\n     * peak weight.\r\n     * @param {number} blendOutTime - Amount of time it should take to animate back\r\n     * to zero after reaching the peak weight.\r\n     * @param {Function} easingFn - Easing function to use during animation.\r\n     */\n\n  }, {\n    key: "_animateSimpleViseme",\n    value: function _animateSimpleViseme(layerName, animName, visemeName, peakWeight, blendInTime, blendOutTime, easingFn) {\n      var _this5 = this;\n\n      // Animate towards the peak value\n      var weightPromise = this._host.AnimationFeature.setAnimationBlendWeight(layerName, animName, visemeName, peakWeight, blendInTime, easingFn); // Animate back to zero if there was no weight interruption\n\n\n      weightPromise.then(function () {\n        if (!weightPromise.canceled) {\n          _this5._host.AnimationFeature.setAnimationBlendWeight(layerName, animName, visemeName, 0, blendOutTime, easingFn);\n        }\n      });\n    }\n    /**\r\n     * Animate a viseme blend weight towards a value and then back to zero.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} layerName - Name of the layer that contains the viseme.\r\n     * @param {string} animName - Name of the freeblend animation that contains\r\n     * the viseme.\r\n     * @param {string} visemeName - Name of the blend weight to manipulate.\r\n     * @param {number} peakWeight - Peak weight to animate towards.\r\n     * @param {number} decayWeight - Weight to animate towards after reaching the\r\n     * peak weight.\r\n     * @param {number} blendInTime - Amount of time it should take to reach the\r\n     * peak weight.\r\n     * @param {number} holdTime - Amount of time it should take to reach the decay\r\n     * weight after the peak weight has been reached.\r\n     * @param {number} blendOutTime - Amount of time it should take to animate back\r\n     * to zero after reaching the decay weight.\r\n     * @param {Function} easingFn - Easing function to use during animation.\r\n     */\n\n  }, {\n    key: "_animateHeldViseme",\n    value: function () {\n      var _animateHeldViseme2 = _asyncToGenerator( /*#__PURE__*/regeneratorRuntime.mark(function _callee2(layerName, animName, visemeName, peakWeight, decayWeight, blendInTime, holdTime, blendOutTime, easingFn) {\n        var startPromise, holdPromise;\n        return regeneratorRuntime.wrap(function _callee2$(_context2) {\n          while (1) {\n            switch (_context2.prev = _context2.next) {\n              case 0:\n                // Animate towards the peak value\n                startPromise = this._host.AnimationFeature.setAnimationBlendWeight(layerName, animName, visemeName, peakWeight, blendInTime, easingFn);\n                _context2.next = 3;\n                return startPromise;\n\n              case 3:\n                if (startPromise.canceled) {\n                  _context2.next = 8;\n                  break;\n                }\n\n                // Animate towards the decay value if there was no weight interruption\n                holdPromise = this._host.AnimationFeature.setAnimationBlendWeight(layerName, animName, visemeName, decayWeight, holdTime, easingFn);\n                _context2.next = 7;\n                return holdPromise;\n\n              case 7:\n                if (!holdPromise.canceled) {\n                  // Animate back to zero if there was no weight interruption\n                  this._host.AnimationFeature.setAnimationBlendWeight(layerName, animName, visemeName, 0, blendOutTime, easingFn);\n                }\n\n              case 8:\n              case "end":\n                return _context2.stop();\n            }\n          }\n        }, _callee2, this);\n      }));\n\n      function _animateHeldViseme(_x2, _x3, _x4, _x5, _x6, _x7, _x8, _x9, _x10) {\n        return _animateHeldViseme2.apply(this, arguments);\n      }\n\n      return _animateHeldViseme;\n    }()\n    /**\r\n     * Gets and sets the amount of time in seconds to negatively offset speechmark\r\n     * emission by.\r\n     *\r\n     * @type {number}\r\n     */\n\n  }, {\n    key: "visemeLeadTime",\n    get: function get() {\n      return this._visemeLeadTime;\n    },\n    set: function set(seconds) {\n      this._visemeLeadTime = seconds;\n\n      if (this._host.TextToSpeechFeature) {\n        this._host.TextToSpeechFeature.speechmarkOffset = -seconds;\n      }\n    }\n    /**\r\n     * Start keeping track of an animation layer that owns a freeBlend animation\r\n     * with blendWeights corresponding to visemes.\r\n     *\r\n     * @param {string} layerName - Name of the layer to keep track of.\r\n     * @param {Object=} options - Options for the layer.\r\n     * @param {string} [options.animation=\'visemes\'] - Name of the animation on the\r\n     * layer that will be played during speech. This animation must be of type\r\n     * freeBlend.\r\n     * @param {Object=} decayRate\r\n     * @param {number} [decayRate.amount=0.5] - The percentage to decrease the viseme\'s\r\n     * peak value by over time once the peak value has been reached.\r\n     * @param {number} [decayRate.seconds=0.5] - The amount of time in seconds to\r\n     * decrease the viseme\'s weight once it has reached its peak value.\r\n     * @param {number=} [options.blendTime=[LipsyncFeature.DEFAULT_LAYER_OPTIONS.blendTime]{@link LipsyncFeature#DEFAULT_LAYER_OPTIONS#blendTime}] -\r\n     * Default amount of time to use when manipulating animation blendWeights.\r\n     * @param {Function=} options.easingFn - Default easing function to use when\r\n     * manipulating animation blendWeights.\r\n     * @param {Object} [options.visemeMap=DefaultVisemeMap] - Object containing key/value pairs of\r\n     * Polly viseme names mapped to objects containing the name of the corresponding\r\n     * animation blendWeight and any other animation options to use such as viseme\r\n     * specific blend times and easing functions.\r\n     */\n\n  }, {\n    key: "registerVisemeLayer",\n    value: function registerVisemeLayer(layerName) {\n      var _ref14 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref14$animation = _ref14.animation,\n          animation = _ref14$animation === void 0 ? \'visemes\' : _ref14$animation,\n          _ref14$decayRate = _ref14.decayRate,\n          decayRate = _ref14$decayRate === void 0 ? {\n        amount: 0.5,\n        seconds: 0.5\n      } : _ref14$decayRate,\n          _ref14$blendTime = _ref14.blendTime,\n          blendTime = _ref14$blendTime === void 0 ? LipsyncFeature.DEFAULT_LAYER_OPTIONS.blendTime : _ref14$blendTime,\n          easingFn = _ref14.easingFn,\n          _ref14$visemeMap = _ref14.visemeMap,\n          visemeMap = _ref14$visemeMap === void 0 ? DefaultVisemeMap : _ref14$visemeMap;\n\n      // Register the layer and animation\n      this.registerLayer(layerName, {\n        decayRate: decayRate,\n        blendTime: blendTime,\n        easingFn: easingFn,\n        animations: LipsyncFeature_defineProperty({}, animation, {\n          visemeMap: visemeMap\n        })\n      });\n      this._visemeLayers[layerName] = animation; // Validate the viseme animation\n\n      this._registerVisemeAnimation(layerName, animation);\n    }\n    /**\r\n     * Start keeping track of an animation layer that contains a looping animation\r\n     * to be played during speech.\r\n     *\r\n     * @param {string} layerName - Name of the layer to keep track of.\r\n     * @param {Object=} options - Options for the layer.\r\n     * @param {string} [options.animation=\'stand_talk\'] - Name of the animation on the\r\n     * layer that will be played during speech.\r\n     * @param {number} [options.blendTime=[LipsyncFeature.DEFAULT_LAYER_OPTIONS.blendTime]{@link LipsyncFeature#DEFAULT_LAYER_OPTIONS#blendTime}] -\r\n     * Default amount of time to use when manipulating the layer\'s weights.\r\n     * @param {Function=} options.easingFn - Default easing function to use when\r\n     * manipulating the layer\'s weights.\r\n     */\n\n  }, {\n    key: "registerTalkingLayer",\n    value: function registerTalkingLayer(layerName) {\n      var _ref15 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref15$animation = _ref15.animation,\n          animation = _ref15$animation === void 0 ? \'stand_talk\' : _ref15$animation,\n          _ref15$blendTime = _ref15.blendTime,\n          blendTime = _ref15$blendTime === void 0 ? LipsyncFeature.DEFAULT_LAYER_OPTIONS.blendTime : _ref15$blendTime,\n          easingFn = _ref15.easingFn;\n\n      // Register the layer and animation\n      this.registerLayer(layerName, {\n        blendTime: blendTime,\n        easingFn: easingFn,\n        animations: LipsyncFeature_defineProperty({}, animation, {})\n      });\n      this._talkingLayers[layerName] = animation;\n    }\n    /**\r\n     * Adds a namespace to the host with the name of the feature to contain properties\r\n     * and methods from the feature that users of the host need access to.\r\n     *\r\n     * @see LipsyncFeature\r\n     */\n\n  }, {\n    key: "installApi",\n    value: function installApi() {\n      var _this6 = this;\n\n      /**\r\n       * @inner\r\n       * @namespace LipsyncFeature\r\n       */\n      var api = LipsyncFeature_get(LipsyncFeature_getPrototypeOf(LipsyncFeature.prototype), "installApi", this).call(this);\n      /**\r\n       * @memberof LipsyncFeature\r\n       * @name registerLayer\r\n       * @instance\r\n       * @method\r\n       * @see ManagedAnimationLayerInterface#registerLayer\r\n       */\n\n      /**\r\n       * @memberof LipsyncFeature\r\n       * @name registerAnimation\r\n       * @instance\r\n       * @method\r\n       * @see ManagedAnimationLayerInterface#registerAnimation\r\n       */\n\n      /**\r\n       * @memberof LipsyncFeature\r\n       * @name setLayerWeights\r\n       * @instance\r\n       * @method\r\n       * @see ManagedAnimationLayerInterface#setLayerWeights\r\n       */\n\n      /**\r\n       * @memberof LipsyncFeature\r\n       * @name enable\r\n       * @instance\r\n       * @method\r\n       * @see ManagedAnimationLayerInterface#enable\r\n       */\n\n      /**\r\n       * @memberof LipsyncFeature\r\n       * @name disable\r\n       * @instance\r\n       * @method\r\n       * @see ManagedAnimationLayerInterface#disable\r\n       */\n\n\n      Object.assign(api, {\n        /**\r\n         * @memberof LipsyncFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/LipsyncFeature#registerVisemeLayer\r\n         */\n        registerVisemeLayer: this.registerVisemeLayer.bind(this),\n\n        /**\r\n         * @memberof LipsyncFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/LipsyncFeature#registerTalkingLayer\r\n         */\n        registerTalkingLayer: this.registerTalkingLayer.bind(this)\n      });\n      /**\r\n       * @memberof LipsyncFeature\r\n       * @instance\r\n       * @name visemeLeadTime\r\n       * @see core/LipsyncFeature#visemeLeadTime\r\n       */\n\n      Object.defineProperty(api, \'visemeLeadTime\', {\n        get: function get() {\n          return _this6.visemeLeadTime;\n        },\n        set: function set(seconds) {\n          _this6.visemeLeadTime = seconds;\n        }\n      });\n      return api;\n    }\n  }]);\n\n  return LipsyncFeature;\n}(core_AbstractHostFeature.mix(awspack_TextToSpeechFeatureDependentInterface.Mixin, animpack_ManagedAnimationLayerInterface.Mixin));\n\n/* harmony default export */ const core_LipsyncFeature = ((/* unused pure expression or super */ null && (LipsyncFeature)));\n\n;// CONCATENATED MODULE: ./src/core/awspack/SSMLSpeechmarkInterface.js\nfunction SSMLSpeechmarkInterface_typeof(obj) { "@babel/helpers - typeof"; return SSMLSpeechmarkInterface_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, SSMLSpeechmarkInterface_typeof(obj); }\n\nfunction SSMLSpeechmarkInterface_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction SSMLSpeechmarkInterface_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction SSMLSpeechmarkInterface_createClass(Constructor, protoProps, staticProps) { if (protoProps) SSMLSpeechmarkInterface_defineProperties(Constructor.prototype, protoProps); if (staticProps) SSMLSpeechmarkInterface_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction SSMLSpeechmarkInterface_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) SSMLSpeechmarkInterface_setPrototypeOf(subClass, superClass); }\n\nfunction SSMLSpeechmarkInterface_setPrototypeOf(o, p) { SSMLSpeechmarkInterface_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return SSMLSpeechmarkInterface_setPrototypeOf(o, p); }\n\nfunction SSMLSpeechmarkInterface_createSuper(Derived) { var hasNativeReflectConstruct = SSMLSpeechmarkInterface_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = SSMLSpeechmarkInterface_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = SSMLSpeechmarkInterface_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return SSMLSpeechmarkInterface_possibleConstructorReturn(this, result); }; }\n\nfunction SSMLSpeechmarkInterface_possibleConstructorReturn(self, call) { if (call && (SSMLSpeechmarkInterface_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return SSMLSpeechmarkInterface_assertThisInitialized(self); }\n\nfunction SSMLSpeechmarkInterface_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction SSMLSpeechmarkInterface_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction SSMLSpeechmarkInterface_getPrototypeOf(o) { SSMLSpeechmarkInterface_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return SSMLSpeechmarkInterface_getPrototypeOf(o); }\n\n/* eslint-disable no-unused-vars */\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/* eslint-disable max-classes-per-file */\n\n/* eslint-disable no-empty */\n\n/**\r\n * Class factory interface for that registers callback method when a ssml speechmark event is emitted.\r\n *\r\n * @interface\r\n * @extends TextToSpeechFeatureDependentInterface\r\n */\n\nvar SSMLSpeechmarkInterface = /*#__PURE__*/function (_TextToSpeechFeatureD) {\n  SSMLSpeechmarkInterface_inherits(SSMLSpeechmarkInterface, _TextToSpeechFeatureD);\n\n  var _super = SSMLSpeechmarkInterface_createSuper(SSMLSpeechmarkInterface);\n\n  function SSMLSpeechmarkInterface() {\n    SSMLSpeechmarkInterface_classCallCheck(this, SSMLSpeechmarkInterface);\n\n    return _super.apply(this, arguments);\n  }\n\n  SSMLSpeechmarkInterface_createClass(SSMLSpeechmarkInterface, [{\n    key: "_onSsml",\n    value:\n    /**\r\n     * When ssml events are caught, this will try to parse the speech mark value and execute any function which meets criteria defined in the value.\r\n     * Speech mark value will be treated as stringified json format containing required feature name, function name and argument array to pass in.\r\n     * Example speech mark value might look like: \'{"feature":"GestureFeature", "method":"switchToGesture", "args":["genricA", 0.5]}\'\r\n     *\r\n     * @private\r\n     *\r\n     * @param {Object} event - Event data passed from the speech.\r\n     * @param {Object} event.mark - Speechmark object.\r\n     */\n    function _onSsml(_ref) {\n      var mark = _ref.mark;\n    }\n    /**\r\n     * Creates a class that implements {@link SSMLSpeechmarkInterface}\r\n     * and extends a specified base class.\r\n     *\r\n     * @param {Class} BaseClass - The class to extend.\r\n     *\r\n     * @return {Class} A class that extends `BaseClass` and implements {@link SSMLSpeechmarkInterface}.\r\n     */\n\n  }], [{\n    key: "Mixin",\n    value: function Mixin(BaseClass) {\n      var ParentClass = awspack_TextToSpeechFeatureDependentInterface.Mixin(BaseClass);\n\n      var SSMLSpeechMarkMixin = /*#__PURE__*/function (_ParentClass) {\n        SSMLSpeechmarkInterface_inherits(SSMLSpeechMarkMixin, _ParentClass);\n\n        var _super2 = SSMLSpeechmarkInterface_createSuper(SSMLSpeechMarkMixin);\n\n        function SSMLSpeechMarkMixin() {\n          SSMLSpeechmarkInterface_classCallCheck(this, SSMLSpeechMarkMixin);\n\n          return _super2.apply(this, arguments);\n        }\n\n        SSMLSpeechmarkInterface_createClass(SSMLSpeechMarkMixin, [{\n          key: "_onSsml",\n          value: function _onSsml(_ref2) {\n            var mark = _ref2.mark;\n\n            try {\n              var _JSON$parse = JSON.parse(mark.value),\n                  feature = _JSON$parse.feature,\n                  method = _JSON$parse.method,\n                  args = _JSON$parse.args;\n\n              if (this.constructor.name === feature) {\n                var callback = this[method];\n\n                if (callback && typeof callback === \'function\') {\n                  callback.apply(this, args);\n                } else {\n                  console.warn("Function ".concat(method, " does not exist within feature ").concat(feature));\n                }\n              }\n            } catch (e) {}\n          }\n        }]);\n\n        return SSMLSpeechMarkMixin;\n      }(ParentClass);\n\n      return SSMLSpeechMarkMixin;\n    }\n  }]);\n\n  return SSMLSpeechmarkInterface;\n}(awspack_TextToSpeechFeatureDependentInterface);\n\n/* harmony default export */ const awspack_SSMLSpeechmarkInterface = (SSMLSpeechmarkInterface);\n;// CONCATENATED MODULE: ./src/core/GestureFeature.js\nfunction GestureFeature_typeof(obj) { "@babel/helpers - typeof"; return GestureFeature_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, GestureFeature_typeof(obj); }\n\nfunction GestureFeature_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction GestureFeature_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? GestureFeature_ownKeys(Object(source), !0).forEach(function (key) { GestureFeature_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : GestureFeature_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction GestureFeature_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction GestureFeature_slicedToArray(arr, i) { return GestureFeature_arrayWithHoles(arr) || GestureFeature_iterableToArrayLimit(arr, i) || GestureFeature_unsupportedIterableToArray(arr, i) || GestureFeature_nonIterableRest(); }\n\nfunction GestureFeature_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction GestureFeature_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return GestureFeature_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return GestureFeature_arrayLikeToArray(o, minLen); }\n\nfunction GestureFeature_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction GestureFeature_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction GestureFeature_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction GestureFeature_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction GestureFeature_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction GestureFeature_createClass(Constructor, protoProps, staticProps) { if (protoProps) GestureFeature_defineProperties(Constructor.prototype, protoProps); if (staticProps) GestureFeature_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction GestureFeature_get() { if (typeof Reflect !== "undefined" && Reflect.get) { GestureFeature_get = Reflect.get; } else { GestureFeature_get = function _get(target, property, receiver) { var base = GestureFeature_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return GestureFeature_get.apply(this, arguments); }\n\nfunction GestureFeature_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = GestureFeature_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction GestureFeature_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) GestureFeature_setPrototypeOf(subClass, superClass); }\n\nfunction GestureFeature_setPrototypeOf(o, p) { GestureFeature_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return GestureFeature_setPrototypeOf(o, p); }\n\nfunction GestureFeature_createSuper(Derived) { var hasNativeReflectConstruct = GestureFeature_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = GestureFeature_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = GestureFeature_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return GestureFeature_possibleConstructorReturn(this, result); }; }\n\nfunction GestureFeature_possibleConstructorReturn(self, call) { if (call && (GestureFeature_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return GestureFeature_assertThisInitialized(self); }\n\nfunction GestureFeature_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction GestureFeature_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction GestureFeature_getPrototypeOf(o) { GestureFeature_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return GestureFeature_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n\n\nvar DefaultGestureWords = {\n  big: [\'add\', \'above\', \'authority\', \'big\', \'cover\', \'full\', \'fly\', \'grow\', \'growth\', \'high\', \'huge\', \'increase\', \'major\', \'majority\', \'large\', \'leader\', \'lot\', \'raise\', \'rise\', \'tall\'],\n  heart: [\'accept\', \'admit\', \'believe\', \'care\', \'feeling\', \'feel\', \'friend\', \'grateful\', \'happy\', \'heart\', \'human\', \'pain\', \'save\', \'safe\', \'kind\', \'love\'],\n  "in": [\'include\', \'including\', \'inside\', \'into\', \'now\', \'near\', \'nearest\', \'closest\', \'therein\', \'within\'],\n  many: [\'all\', \'always\', \'any\', \'anyone\', \'among\', \'area\', \'around\', \'beautiful\', \'entire\', \'environment\', \'environments\', \'environmental\', \'everybody\', \'everyone\', \'everything\', \'audience\', \'total\', \'group\', \'groups\', \'million\', \'millions\', \'others\', \'billion\', \'billions\', \'hundred\', \'hundreds\', \'many\', \'thousand\', \'thousands\', \'world\', \'worlds\', \'outside\', \'reveal\'],\n  movement: [\'away\', \'across\', \'ahead\', \'along\', \'far\', \'fast\', \'follow\', \'go\', \'leave\', \'move\', \'movement\', \'through\', \'throughout\', \'toward\', \'travel\', \'turned\', \'passed\'],\n  one: [\'single\', \'one\', \'once\', \'first\', \'firstly\', \'only\', \'solo\', \'warned\', \'truly\', \'up\', \'alone\'],\n  aggressive: [\'power\', \'powers\', \'powerful\', \'assert\', \'assertive\', \'strong\', \'stronger\', \'strongest\', \'strength\', \'flex\', \'dang\', \'damn\', \'damnit\', \'darn\', \'shucks\', \'doh\', \'drat\', \'angry\', \'angrier\', \'angriest\', \'aggressive\', \'annoyed\', \'annoying\', \'attack\', \'attacking\', \'offense\', \'offensive\', \'battle\'],\n  you: [\'you\', \'yall\', "y\'all", \'your\', \'yours\', \'thou\', \'thy\'],\n  defense: [\'defense\', \'fear\', \'repulsed\', \'scared\', \'scary\', \'scarier\', \'scariest\', \'fearful\', \'afraid\', \'cower\', \'cowers\', \'cowering\', \'hideous\', \'doomed\', \'terrified\', \'terrify\', \'terrifying\', \'terrifies\', \'spooky\', \'spookier\', \'spookiest\'],\n  wave: [\'hello\', \'hi\', \'hiya\', \'howdy\', \'welcome\', \'aloha\', \'heya\', \'hey\', \'bye\', \'goodbye\', \'hola\', \'adios\', \'chao\'],\n  self: [\'my\', \'I\', \'myself\', \'self\', "I\'ve", \'Ive\', \'me\', \'mine\', \'own\']\n};\n/**\r\n * Gesture allows you to play animations on demand on one or more layers from script\r\n * or ssml. If gesture is played that is a QueueState, the queue will automatically\r\n * be progressed after a given hold time if a looping queued state is reached. Gesture\r\n * layers can optionally be automatically disabled when no gesture animation is\r\n * in progress.\r\n *\r\n * @extends AbstractHostFeature\r\n * @implements SSMLSpeechmarkInterface\r\n * @implements ManagedAnimationLayerInterface\r\n */\n\nvar GestureFeature = /*#__PURE__*/function (_AbstractHostFeature$) {\n  GestureFeature_inherits(GestureFeature, _AbstractHostFeature$);\n\n  var _super = GestureFeature_createSuper(GestureFeature);\n\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {core/HostObject} host - Host object that owns the feature.\r\n   * @param {Object=} options - Optional options for the feature.\r\n   * @param {number} [options.holdTime = 3] - Amount of time in seconds that must\r\n   * elapse before advancing a gesture that\'s a {@link QueueState} when the current\r\n   * state in the queue is set to loop infinitely.\r\n   * @param {number} [options.minimumInterval = 0.25] - The minimum amount of time\r\n   * in seconds that must elapse before another gesture can be played.\r\n   * @param  {Object} layers - An object that maps layer names to layer options.\r\n   * These are the layers that will be registered as tracked gesture layers. See\r\n   * {@link ManagedAnimationLayerInterface#registerLayer} for more information\r\n   * on expected format for each layer options object.\r\n   */\n  function GestureFeature(host) {\n    var _this;\n\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        _ref$holdTime = _ref.holdTime,\n        holdTime = _ref$holdTime === void 0 ? 3 : _ref$holdTime,\n        _ref$minimumInterval = _ref.minimumInterval,\n        minimumInterval = _ref$minimumInterval === void 0 ? 1 : _ref$minimumInterval,\n        _ref$layers = _ref.layers,\n        layers = _ref$layers === void 0 ? {} : _ref$layers;\n\n    GestureFeature_classCallCheck(this, GestureFeature);\n\n    _this = _super.call(this, host);\n    _this.holdTime = holdTime;\n    _this.minimumInterval = minimumInterval; // Register the gesture layers\n\n    Object.entries(layers).forEach(function (_ref2) {\n      var _ref3 = GestureFeature_slicedToArray(_ref2, 2),\n          name = _ref3[0],\n          _ref3$ = _ref3[1],\n          options = _ref3$ === void 0 ? {} : _ref3$;\n\n      _this.registerLayer(name, options);\n    });\n    return _this;\n  }\n  /**\r\n   * Return a valid hold time value. If hold time isn\'t defined for the animation,\r\n   * try to use the hold time for the layer. If that\'s not defined, fall back to\r\n   * the hold time for the feature.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {Object} layer - Managed layer options object.\r\n   * @param {Object} animation - Managed animation options object.\r\n   *\r\n   * @returns {number}\r\n   */\n\n\n  GestureFeature_createClass(GestureFeature, [{\n    key: "_getHoldTime",\n    value: function _getHoldTime(layer, animation) {\n      var layerHoldTime = layer.holdTime !== undefined ? layer.holdTime : this.holdTime;\n      return animation.holdTime !== undefined ? animation.holdTime : layerHoldTime;\n    }\n    /**\r\n     * Return a valid minimum interval value. If minimum interval isn\'t defined for\r\n     * the animation, try to use the minimum interval for the layer. If that\'s not\r\n     * defined, fall back to the minimum interval for the feature.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {Object} layer - Managed layer options object.\r\n     * @param {Object} animation - Managed animation options object.\r\n     *\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: "_getMinimumInterval",\n    value: function _getMinimumInterval(layer, animation) {\n      var layerMinimumInterval = layer.minimumInterval !== undefined ? layer.minimumInterval : this.minimumInterval;\n      return animation.minimumInterval !== undefined ? animation.minimumInterval : layerMinimumInterval;\n    }\n    /**\r\n     * Callback for {@link core/AnimationFeature#playNextAnimation} event. If the\r\n     * event is emitted for a managed animation and the new queued state cannot\r\n     * advance on its own, start a new timer promise that will advance the queue\r\n     * once it resolves.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {Object} options - Options object passed from playNextAnimation event.\r\n     * @param {string} layerName - Name of the layer that owns the queue state.\r\n     * @param {string} animationName - Name of the queue state animation.\r\n     * @param {boolean} canAdvance - Whether or not the current state in the queue\r\n     * can advance on its own.\r\n     * @param {boolean} isQueueEnd - Whether the current state in the queue is the last\r\n     * state in the queue.\r\n     */\n\n  }, {\n    key: "_onNext",\n    value: function _onNext(_ref4) {\n      var _this2 = this;\n\n      var layerName = _ref4.layerName,\n          animationName = _ref4.animationName,\n          canAdvance = _ref4.canAdvance,\n          isQueueEnd = _ref4.isQueueEnd;\n      // Exit if this isn\'t a managed layer\n      var layer = this._managedLayers[layerName];\n\n      if (layer === undefined) {\n        return;\n      } // Exit if it isn\'t a managed animation\n\n\n      var animation = layer.animations[animationName];\n\n      if (animation === undefined) {\n        return;\n      } // Start a new timer for looping states that aren\'t the end of the queue\n\n\n      if (!canAdvance && !isQueueEnd && layer.currentGesture === animationName) {\n        var holdTime = this._getHoldTime(layer, animation);\n\n        layer.holdTimer.cancel(); // Skip to the next animation right away if hold time is zero\n\n        if (holdTime <= 0) {\n          this._host.AnimationFeature.playNextAnimation(layerName, animationName);\n        } // Wait for the given hold time before progressing\n        else {\n          layer.holdTimer = core_Utils.wait(holdTime, {\n            onFinish: function onFinish() {\n              // Advance the queue to the next state\n              if (layer.currentGesture === animationName) {\n                _this2._host.AnimationFeature.playNextAnimation(layerName, animationName);\n              }\n            }\n          });\n        }\n      }\n    }\n    /**\r\n     * Callback for {@link core/AnimationFeature#stopAnimation} event. If the\r\n     * event is emitted for a managed animation cancel the layer\'s stored timers.\r\n     * If the layer is set to auto-disable set its weight to 0.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {Object} options - Options object passed from playNextAnimation event.\r\n     * @param {string} layerName - Name of the layer that owns the stopped animation.\r\n     * @param {string} animationName - Name of the animation that was stopped.\r\n     */\n\n  }, {\n    key: "_onStop",\n    value: function _onStop(_ref5) {\n      var layerName = _ref5.layerName,\n          animationName = _ref5.animationName;\n      // Make sure the layer is managed\n      var layer = this._managedLayers[layerName];\n\n      if (layer === undefined) {\n        return;\n      } // Make sure the animation is managed\n\n\n      var animation = layer.animations[animationName];\n\n      if (animation !== undefined && animationName === layer.currentGesture) {\n        layer.currentGesture = null;\n        layer.playTimer = null;\n        layer.holdTimer.cancel(); // Turn off layer weight\n\n        if (layer.autoDisable) {\n          this.setLayerWeights(function (name) {\n            return name === layerName;\n          }, 0);\n        }\n      }\n    }\n  }, {\n    key: "_onAnimationAdded",\n    value: function _onAnimationAdded(_ref6) {\n      var layerName = _ref6.layerName,\n          animationName = _ref6.animationName;\n      var layer = this._managedLayers[layerName];\n\n      if (layer !== undefined) {\n        var animation = layer.animations[animationName]; // Register the animation as active if it is unmanaged\n\n        if (animation === undefined) {\n          this.registerAnimation(layerName, animationName);\n        } // Mark the animation as active if it is managed\n        else {\n          animation.isActive = true;\n        }\n      }\n    }\n  }, {\n    key: "registerLayer",\n    value: function registerLayer(name) {\n      var _this3 = this;\n\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n      GestureFeature_get(GestureFeature_getPrototypeOf(GestureFeature.prototype), "registerLayer", this).call(this, name, GestureFeature_objectSpread(GestureFeature_objectSpread({}, options), {}, {\n        holdTimer: core_Deferred.resolve(),\n        playTimer: null,\n        currentGesture: null\n      }));\n\n      if (this._managedLayers[name].isActive) {\n        this._host.AnimationFeature.getAnimations(name).forEach(function (anim) {\n          // Automatically register all animations on the layer\n          if (_this3._managedLayers[name].animations[anim] === undefined) {\n            _this3.registerAnimation(name, anim, _this3._managedLayers[name].animations[anim]);\n          }\n        });\n      }\n    }\n  }, {\n    key: "registerAnimation",\n    value: function registerAnimation(layerName, animationName) {\n      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n\n      // Try to fall back to a default word array\n      if (!(options.words instanceof Array) && !(options.words instanceof Set)) {\n        options.words = DefaultGestureWords[animationName] || [];\n      }\n\n      GestureFeature_get(GestureFeature_getPrototypeOf(GestureFeature.prototype), "registerAnimation", this).call(this, layerName, animationName, options);\n    }\n    /**\r\n     * Create an object that maps ssml mark syntax required to play each gesture to\r\n     * the words array associated with each gesture. Words arrays are defined at when\r\n     * the gesture animation is registered. Gestures without associated words will\r\n     * be excluded from the result. The resulting object can be used as an input\r\n     * for {@link TextToSpeechUtils.autoGenerateSSMLMarks} to update a speech string\r\n     * with the markup required to play gestures timed with their associated words.\r\n     *\r\n     * @returns {Object}\r\n     */\n\n  }, {\n    key: "createGestureMap",\n    value: function createGestureMap() {\n      var _this4 = this;\n\n      var gestureMap = {};\n      Object.entries(this._managedLayers).forEach(function (_ref7) {\n        var _ref8 = GestureFeature_slicedToArray(_ref7, 2),\n            layerName = _ref8[0],\n            animations = _ref8[1].animations;\n\n        Object.entries(animations).forEach(function (_ref9) {\n          var _ref10 = GestureFeature_slicedToArray(_ref9, 2),\n              animationName = _ref10[0],\n              _ref10$ = _ref10[1],\n              holdTime = _ref10$.holdTime,\n              minimumInterval = _ref10$.minimumInterval,\n              words = _ref10$.words,\n              transitionTime = _ref10$.transitionTime;\n\n          // Only store gestures that have any associated words\n          if (words.length) {\n            var options = GestureFeature_objectSpread(GestureFeature_objectSpread(GestureFeature_objectSpread({}, holdTime && {\n              holdTime: holdTime\n            }), minimumInterval && {\n              minimumInterval: minimumInterval\n            }), transitionTime && {\n              transitionTime: transitionTime\n            });\n\n            var key = {\n              feature: _this4.constructor.name,\n              method: \'playGesture\',\n              args: [layerName, animationName, options]\n            };\n            gestureMap[JSON.stringify(key)] = words;\n          }\n        });\n      });\n      return gestureMap;\n    }\n    /**\r\n     * Create an array that contains ssml mark syntax required to play each gesture\r\n     * that does not have any associated words. The resulting array can be used as\r\n     * an input for {@link TextToSpeechUtils.autoGenerateSSMLMarks} or\r\n     * {@link TextToSpeechUtils.addMarksToUnmarkedSentences} to update a speech\r\n     * string with the markup required to play random gestures at each unmarked\r\n     * sentence in the string.\r\n     *\r\n     * @param {Array.<string>=} layers - An array of names of managed layers to generate\r\n     * marks for. If undefined, use all managed layers.\r\n     *\r\n     * @returns {Array.<string>}\r\n     */\n\n  }, {\n    key: "createGenericGestureArray",\n    value: function createGenericGestureArray(layers) {\n      var _this5 = this;\n\n      var genericGestures = [];\n      layers = layers || Object.keys(this._managedLayers);\n      layers.forEach(function (layerName) {\n        var layer = _this5._managedLayers[layerName]; // Make sure the layer is managed\n\n        if (!layer) {\n          return;\n        }\n\n        Object.entries(layer.animations).forEach(function (_ref11) {\n          var _ref12 = GestureFeature_slicedToArray(_ref11, 2),\n              animationName = _ref12[0],\n              _ref12$ = _ref12[1],\n              holdTime = _ref12$.holdTime,\n              minimumInterval = _ref12$.minimumInterval,\n              words = _ref12$.words,\n              transitionTime = _ref12$.transitionTime;\n\n          // Only store gestures that don\'t have any associated words\n          if (!words.length) {\n            var options = GestureFeature_objectSpread(GestureFeature_objectSpread(GestureFeature_objectSpread({}, holdTime && {\n              holdTime: holdTime\n            }), minimumInterval && {\n              minimumInterval: minimumInterval\n            }), transitionTime && {\n              transitionTime: transitionTime\n            });\n\n            var key = JSON.stringify({\n              feature: _this5.constructor.name,\n              method: \'playGesture\',\n              args: [layerName, animationName, options]\n            });\n\n            if (!genericGestures.includes(key)) {\n              genericGestures.push(key);\n            }\n          }\n        });\n      });\n      return genericGestures;\n    }\n    /**\r\n     * Play a managed gesture animation.\r\n     *\r\n     * @param {string} layerName - The name of the layer that contains the gesture\r\n     * animation.\r\n     * @param {string} animationName - The name of the gesture animation.\r\n     * @param {Object=} options - Optional gesture options.\r\n     * @param {number=} options.holdTime - This option only applies to {@link QueueState}\r\n     * gestures. When a QueueState gesture progresses to a looping state, this option\r\n     * defines how many seconds should elapse before moving the queue forward. If\r\n     * undefined, it will fall back first to the holdTime defined in the options when\r\n     * the gesture animation was registered and then to the holdTime defined on the\r\n     * feature.\r\n     * @param {number=} options.minimumInterval - The minimum amount of time that\r\n     * must have elapsed since the last time a gesture was played.\r\n     */\n\n  }, {\n    key: "playGesture",\n    value: function playGesture(layerName, animationName) {\n      var _ref13 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n          holdTime = _ref13.holdTime,\n          minimumInterval = _ref13.minimumInterval,\n          transitionTime = _ref13.transitionTime,\n          _ref13$force = _ref13.force,\n          force = _ref13$force === void 0 ? false : _ref13$force;\n\n      // Make sure the animation is registered\n      if (this._managedLayers[layerName] === undefined || this._managedLayers[layerName].animations[animationName] === undefined) {\n        this.registerAnimation(layerName, animationName, {\n          holdTime: holdTime,\n          minimumInterval: minimumInterval,\n          transitionTime: transitionTime\n        });\n      }\n\n      var layer = this._managedLayers[layerName];\n      var animation = layer.animations[animationName]; // Make sure the animation is active\n\n      if (!animation.isActive) {\n        // Create warning message based on which object doesn\'t exist yet\n        var typeName = layer.isActive ? \'animation\' : \'layer\';\n        var message = "Skipping gesture ".concat(animationName, " on layer ").concat(layerName, " for host ").concat(this._host.id, ". No ").concat(typeName, " exists with this name yet.");\n        console.warn(message);\n        return core_Deferred.cancel({\n          reason: \'inactive\',\n          value: typeName\n        });\n      } // Check if the gesture is already playing\n\n\n      var currentGesture = layer.currentGesture;\n\n      if (currentGesture === animationName && !force) {\n        var _message = "Skipping gesture ".concat(animationName, " on layer ").concat(layerName, " for host ").concat(this._host.id, ". The gesture is already playing. Use options.force to force the gesture replay, which may result in a hard transition.");\n\n        console.warn(_message);\n        return core_Deferred.cancel({\n          reason: \'playing\',\n          value: animationName\n        });\n      } // Update animation options\n\n\n      if (holdTime !== undefined) {\n        animation.holdTime = holdTime;\n      }\n\n      if (minimumInterval !== undefined) {\n        animation.minimumInterval = minimumInterval;\n      } else {\n        minimumInterval = this._getMinimumInterval(layer, animation);\n      } // Check the interval\n\n\n      if (!force && layer.playTimer !== null && layer.playTimer < minimumInterval) {\n        console.warn("Skipping gesture ".concat(animationName, " on layer ").concat(layerName, " for host ").concat(this._host.id, ". Minimum interval ").concat(minimumInterval, " has not been met."));\n        return core_Deferred.cancel({\n          reason: \'minimumInterval\',\n          value: minimumInterval - layer.playTimer\n        });\n      } // Play the animation\n\n\n      layer.currentGesture = animationName;\n      layer.playTimer = 0;\n      layer.holdTimer.cancel();\n\n      if (layer.autoDisable) {\n        this.setLayerWeights(function (name) {\n          return name === layerName;\n        }, 1);\n      }\n\n      return this._host.AnimationFeature.playAnimation(layerName, animationName, transitionTime);\n    }\n  }, {\n    key: "update",\n    value: function update(deltaTime) {\n      var _this6 = this;\n\n      GestureFeature_get(GestureFeature_getPrototypeOf(GestureFeature.prototype), "update", this).call(this, deltaTime); // Increment the timers\n\n\n      Object.entries(this._managedLayers).forEach(function (_ref14) {\n        var _ref15 = GestureFeature_slicedToArray(_ref14, 2),\n            name = _ref15[0],\n            options = _ref15[1];\n\n        if (options.isActive && !_this6._host.AnimationFeature.getPaused(name)) {\n          options.holdTimer.execute(deltaTime);\n\n          if (options.playTimer !== null) {\n            options.playTimer += deltaTime / 1000;\n          }\n        }\n      });\n    }\n  }, {\n    key: "installApi",\n    value: function installApi() {\n      /**\r\n       * @inner\r\n       * @namespace GestureFeature\r\n       */\n      var api = GestureFeature_get(GestureFeature_getPrototypeOf(GestureFeature.prototype), "installApi", this).call(this);\n\n      Object.assign(api, {\n        /**\r\n         * @memberof GestureFeature\r\n         * @instance\r\n         * @method\r\n         * @see GestureFeature#createGestureMap\r\n         */\n        createGestureMap: this.createGestureMap.bind(this),\n\n        /**\r\n         * @memberof GestureFeature\r\n         * @instance\r\n         * @method\r\n         * @see GestureFeature#createGenericGestureArray\r\n         */\n        createGenericGestureArray: this.createGenericGestureArray.bind(this),\n\n        /**\r\n         * @memberof GestureFeature\r\n         * @instance\r\n         * @method\r\n         * @see GestureFeature#playGesture\r\n         */\n        playGesture: this.playGesture.bind(this)\n      });\n    }\n  }]);\n\n  return GestureFeature;\n}(core_AbstractHostFeature.mix(awspack_SSMLSpeechmarkInterface.Mixin, animpack_ManagedAnimationLayerInterface.Mixin));\n\nObject.defineProperties(GestureFeature, {\n  DEFAULT_LAYER_OPTIONS: {\n    value: GestureFeature_objectSpread(GestureFeature_objectSpread({}, GestureFeature.DEFAULT_LAYER_OPTIONS), {}, {\n      autoDisable: true\n    }),\n    writable: false\n  },\n  EVENT_DEPENDENCIES: {\n    value: GestureFeature_objectSpread(GestureFeature_objectSpread({}, GestureFeature.EVENT_DEPENDENCIES), {}, {\n      AnimationFeature: GestureFeature_objectSpread(GestureFeature_objectSpread({}, GestureFeature.EVENT_DEPENDENCIES.AnimationFeature), {}, {\n        playNextAnimation: \'_onNext\',\n        stopAnimation: \'_onStop\',\n        interruptAnimation: \'_onStop\'\n      })\n    })\n  }\n});\n/* harmony default export */ const core_GestureFeature = ((/* unused pure expression or super */ null && (GestureFeature)));\n\n;// CONCATENATED MODULE: ./src/core/animpack/AnimationUtils.js\nfunction AnimationUtils_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction AnimationUtils_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction AnimationUtils_createClass(Constructor, protoProps, staticProps) { if (protoProps) AnimationUtils_defineProperties(Constructor.prototype, protoProps); if (staticProps) AnimationUtils_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n\n/**\r\n * A collection of useful animation functions.\r\n *\r\n * @hideconstructor\r\n */\n\nvar AnimationUtils = /*#__PURE__*/function () {\n  function AnimationUtils() {\n    AnimationUtils_classCallCheck(this, AnimationUtils);\n  }\n\n  AnimationUtils_createClass(AnimationUtils, null, [{\n    key: "lerp",\n    value: function lerp(from, to, factor) {\n      console.warn("AnimationUtils.lerp is being deprecated. Use MathUtils.lerp instead.");\n      return core_MathUtils.lerp(from, to, factor);\n    }\n    /**\r\n     * Clamp a number between 2 values.\r\n     *\r\n     * @param {number} value - Value to clamp.\r\n     * @param {number} [min=0] - Minumum value.\r\n     * @param {number} [max=1] - Maximum value.\r\n     *\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: "clamp",\n    value: function clamp(value) {\n      var min = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var max = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      console.warn("AnimationUtils.clamp is being deprecated. Use MathUtils.clamp instead.");\n      return core_MathUtils.clamp(value, min, max);\n    }\n    /**\r\n     * Return a deferred promise that can be used to update the value of a numeric\r\n     * property of this object over time. Pass delta time in milliseconds to the\r\n     * deferred promise\'s execute method in an update loop to animate the property\r\n     * towards the target value.\r\n     *\r\n     * @param {Object} propertyOwner - Object that contains the property to animation.\r\n     * @param {string} propertyName - Name of the property to animate.\r\n     * @param {number} targetValue - Target value to reach.\r\n     * @param {Object=} options - Optional options object\r\n     * @param {number} [options.seconds=0] - Number of seconds it will take to reach\r\n     * the target value.\r\n     * @param {Function} [options.easingFn=Linear.InOut] - Easing function to use for animation.\r\n     * @param {Function} [options.onFinish] - Callback to execute once the animation completes.\r\n     * The target value is passed as a parameter.\r\n     * @param {Function=} options.onProgress - Callback to execute each time the animation\r\n     * property is updated during the animation. The property\'s value at the time of\r\n     * the update is passed as a parameter.\r\n     * @param {Function=} options.onCancel - Callback to execute if the user cancels the\r\n     * animation before completion. The animation property\'s value at the time of\r\n     * cancel is passed as a parameter.\r\n     * @param {Function=} options.onError - Callback to execute if the animation stops\r\n     * because an error is encountered. The error message is passed as a parameter.\r\n     *\r\n     * @returns {Deferred} Resolves with the property\'s value once it reaches the\r\n     * target value.\r\n     */\n\n  }, {\n    key: "interpolateProperty",\n    value: function interpolateProperty(propertyOwner, propertyName, targetValue) {\n      var _ref = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n          _ref$seconds = _ref.seconds,\n          seconds = _ref$seconds === void 0 ? 0 : _ref$seconds,\n          easingFn = _ref.easingFn,\n          _onFinish = _ref.onFinish,\n          _onProgress = _ref.onProgress,\n          _onCancel = _ref.onCancel,\n          onError = _ref.onError;\n\n      // Make sure property is an object\n      if (!(propertyOwner instanceof Object)) {\n        var e = new Error("Cannot interpolate property ".concat(propertyName, ". Property owner must be an object."));\n\n        if (typeof onError === \'function\') {\n          onError(e);\n        }\n\n        return core_Deferred.reject(e);\n      } // Make sure property is numeric\n\n\n      if (Number.isNaN(Number(propertyOwner[propertyName]))) {\n        var _e = new Error("Cannot interpolate property ".concat(propertyName, ". Property must be numeric."));\n\n        if (typeof onError === \'function\') {\n          onError(_e);\n        }\n\n        return core_Deferred.reject(_e);\n      } // Make sure the target value is numeric\n\n\n      if (Number.isNaN(Number(targetValue))) {\n        var _e2 = new Error("Cannot interpolate property ".concat(propertyName, " to value ").concat(targetValue, ". Target value must be numeric."));\n\n        if (typeof onError === \'function\') {\n          onError(_e2);\n        }\n\n        return core_Deferred.reject(_e2);\n      } // Resolve immediately if the target has already been reached\n\n\n      var startValue = propertyOwner[propertyName];\n\n      if (startValue === targetValue) {\n        if (typeof _onFinish === \'function\') {\n          _onFinish(targetValue);\n        }\n\n        return core_Deferred.resolve(targetValue);\n      } // Default to linear interpolation\n\n\n      if (typeof easingFn !== \'function\') {\n        if (easingFn !== undefined) {\n          console.warn("Invalid property interpolation easingFn. Defaulting to linear interpolation.");\n        }\n\n        easingFn = Linear.InOut;\n      }\n\n      var interpolator = core_Utils.wait(seconds, {\n        onFinish: function onFinish() {\n          propertyOwner[propertyName] = targetValue;\n\n          if (typeof _onFinish === \'function\') {\n            _onFinish(targetValue);\n          }\n        },\n        onCancel: function onCancel() {\n          if (typeof _onCancel === \'function\') {\n            _onCancel(propertyOwner[propertyName]);\n          }\n        },\n        onProgress: function onProgress(progress) {\n          if (propertyOwner[propertyName] !== targetValue) {\n            // Calculate the lerp factor\n            var easeFactor = easingFn(progress);\n\n            if (typeof easeFactor !== \'number\') {\n              var _e3 = new Error("Invalid property interpolation easingFn. EasingFn must return a number.");\n\n              interpolator.reject(_e3);\n              return;\n            } // Update the value\n\n\n            propertyOwner[propertyName] = core_MathUtils.lerp(startValue, targetValue, easeFactor);\n          } // Signal progress\n\n\n          if (typeof _onProgress === \'function\') {\n            _onProgress(propertyOwner[propertyName]);\n          } // Signal completion once time is up\n\n\n          if (progress === 1) {\n            propertyOwner[propertyName] = targetValue;\n            interpolator.resolve(targetValue);\n          }\n        },\n        onError: onError\n      });\n      return interpolator;\n    }\n  }]);\n\n  return AnimationUtils;\n}();\n\n/* harmony default export */ const animpack_AnimationUtils = (AnimationUtils);\n;// CONCATENATED MODULE: ./src/core/animpack/state/AbstractState.js\nfunction AbstractState_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction AbstractState_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction AbstractState_createClass(Constructor, protoProps, staticProps) { if (protoProps) AbstractState_defineProperties(Constructor.prototype, protoProps); if (staticProps) AbstractState_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n/**\r\n * Base class for a state in our animation system.\r\n *\r\n * @abstract\r\n */\n\nvar AbstractState = /*#__PURE__*/function () {\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {Object=} options - Options for the animation state.\r\n   * @param {string=} options.name - Name for the animation state. Names must be\r\n   * unique for the container the state is applied to and should be validated at\r\n   * the container level. If no name is given it will default to the constructor\r\n   * name.\r\n   * @param {weight} [options.weight=0] - The 0-1 amount of influence the state will have.\r\n   */\n  function AbstractState() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    AbstractState_classCallCheck(this, AbstractState);\n\n    this.name = options.name !== undefined ? options.name : this.constructor.name;\n    this._weight = options.weight !== undefined ? core_MathUtils.clamp(options.weight, 0, 1) : 0;\n    this._internalWeight = this._weight;\n    this._paused = false;\n    this._promises = {\n      finish: core_Deferred.resolve(),\n      weight: core_Deferred.resolve(),\n      play: core_Deferred.resolve()\n    };\n    this._playCallbacks = {\n      onFinish: undefined,\n      onError: undefined,\n      onCancel: undefined\n    };\n  }\n  /**\r\n   * Gets whether or not the state is currently paused.\r\n   *\r\n   * @type {number}\r\n   */\n\n\n  AbstractState_createClass(AbstractState, [{\n    key: "paused",\n    get: function get() {\n      return this._paused;\n    }\n    /**\r\n     * Gets and sets the user defined weight.\r\n     *\r\n     * @type {number}\r\n     */\n\n  }, {\n    key: "weight",\n    get: function get() {\n      return this._weight;\n    },\n    set: function set(weight) {\n      this._weight = core_MathUtils.clamp(weight, 0, 1);\n    }\n    /**\r\n     * Gets whether or not the weight is currently being animated.\r\n     *\r\n     * @readonly\r\n     * @type {boolean}\r\n     */\n\n  }, {\n    key: "weightPending",\n    get: function get() {\n      return this._promises.weight && this._promises.weight.pending;\n    }\n    /**\r\n     * Updates the user defined weight over time.\r\n     *\r\n     * @param {number} weight - The target weight value.\r\n     * @param {number} [seconds=0] - The amount of time it will take to reach the\r\n     * target weight.\r\n     * @param {Function=} easingFn - The easing function to use for interpolation.\r\n     *\r\n     * @returns {Deferred}\r\n     */\n\n  }, {\n    key: "setWeight",\n    value: function setWeight(weight) {\n      var seconds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var easingFn = arguments.length > 2 ? arguments[2] : undefined;\n\n      this._promises.weight.cancel();\n\n      weight = core_MathUtils.clamp(weight);\n      this._promises.weight = animpack_AnimationUtils.interpolateProperty(this, \'weight\', weight, {\n        seconds: seconds,\n        easingFn: easingFn\n      });\n      return this._promises.weight;\n    }\n    /**\r\n     * Gets the internal weight.\r\n     *\r\n     * @readonly\r\n     * @type {number}\r\n     */\n\n  }, {\n    key: "internalWeight",\n    get: function get() {\n      return this._internalWeight;\n    }\n    /**\r\n     * Multiplies the user weight by a factor to determine the internal weight.\r\n     *\r\n     * @param {number} factor - 0-1 multiplier to apply to the user weight.\r\n     */\n\n  }, {\n    key: "updateInternalWeight",\n    value: function updateInternalWeight(factor) {\n      this._internalWeight = this._weight * factor;\n    }\n    /**\r\n     * Update any values that need to be evaluated every frame.\r\n     *\r\n     * @param {number} deltaTime - Time in milliseconds since the last update.\r\n     */\n\n  }, {\n    key: "update",\n    value: function update(deltaTime) {\n      if (!this._paused) {\n        Object.values(this._promises).forEach(function (promise) {\n          promise.execute(deltaTime);\n        });\n      }\n    }\n    /**\r\n     * Start playback of the state from the beginning.\r\n     *\r\n     * @param {Function=} onFinish - Function to execute when the state finishes.\r\n     * @param {Function=} onError - Function to execute if the state encounters\r\n     * an error during playback.\r\n     * @param {Function=} onCancel - Function to execute if playback is canceled.\r\n     *\r\n     * @returns {Deferred}\r\n     */\n\n  }, {\n    key: "play",\n    value: function play(onFinish, onError, onCancel) {\n      this._paused = false;\n      this._playCallbacks.onFinish = onFinish;\n      this._playCallbacks.onError = onError;\n      this._playCallbacks.onCancel = onCancel;\n      this._promises.play = new core_Deferred(undefined, onFinish, onError, onCancel);\n      this._promises.finish = core_Deferred.all([this._promises.play, this._promises.weight]);\n      return this._promises.finish;\n    }\n    /**\r\n     * Pause playback of the state. This prevents pending promises from being executed.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "pause",\n    value: function pause() {\n      this._paused = true;\n      return true;\n    }\n    /**\r\n     * Resume playback of the state.\r\n     *\r\n     * @param {Function=} onFinish - Function to execute when the state finishes.\r\n     * @param {Function=} onError - Function to execute if the state encounters\r\n     * an error during playback.\r\n     * @param {Function=} onCancel - Function to execute if playback is canceled.\r\n     *\r\n     * @returns {Deferred}\r\n     */\n\n  }, {\n    key: "resume",\n    value: function resume(onFinish, onError, onCancel) {\n      this._paused = false;\n\n      if (!this._promises.play.pending) {\n        this._playCallbacks.onFinish = onFinish || this._playCallbacks.onFinish;\n        this._playCallbacks.onError = onError || this._playCallbacks.onError;\n        this._playCallbacks.onCancel = onCancel || this._playCallbacks.onCancel;\n        this._promises.play = new core_Deferred(undefined, this._playCallbacks.onFinish, this._playCallbacks.onError, this._playCallbacks.onCancel);\n        this._promises.finish = core_Deferred.all([this._promises.play, this._promises.weight]);\n      }\n\n      return this._promises.finish;\n    }\n    /**\r\n     * Cancel playback of the state and cancel any pending promises.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "cancel",\n    value: function cancel() {\n      this._paused = true;\n      Object.values(this._promises).forEach(function (promise) {\n        promise.cancel();\n      });\n      return true;\n    }\n    /**\r\n     * Stop playback of the state and resolve any pending promises.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "stop",\n    value: function stop() {\n      this._paused = true;\n      Object.values(this._promises).forEach(function (promise) {\n        promise.resolve();\n      });\n      return true;\n    }\n    /**\r\n     * Cancel any pending promises and remove reference to them.\r\n     */\n\n  }, {\n    key: "discard",\n    value: function discard() {\n      this.cancel();\n      delete this._promises;\n    }\n    /**\r\n     * Force the internal weight to 0. Should be called before switching or transitioning\r\n     * to a new state.\r\n     */\n\n  }, {\n    key: "deactivate",\n    value: function deactivate() {\n      this.updateInternalWeight(0);\n    }\n  }]);\n\n  return AbstractState;\n}();\n\n/* harmony default export */ const state_AbstractState = (AbstractState);\n;// CONCATENATED MODULE: ./src/core/animpack/state/TransitionState.js\nfunction TransitionState_typeof(obj) { "@babel/helpers - typeof"; return TransitionState_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, TransitionState_typeof(obj); }\n\nfunction TransitionState_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction TransitionState_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction TransitionState_createClass(Constructor, protoProps, staticProps) { if (protoProps) TransitionState_defineProperties(Constructor.prototype, protoProps); if (staticProps) TransitionState_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction TransitionState_get() { if (typeof Reflect !== "undefined" && Reflect.get) { TransitionState_get = Reflect.get; } else { TransitionState_get = function _get(target, property, receiver) { var base = TransitionState_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return TransitionState_get.apply(this, arguments); }\n\nfunction TransitionState_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = TransitionState_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction TransitionState_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) TransitionState_setPrototypeOf(subClass, superClass); }\n\nfunction TransitionState_setPrototypeOf(o, p) { TransitionState_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return TransitionState_setPrototypeOf(o, p); }\n\nfunction TransitionState_createSuper(Derived) { var hasNativeReflectConstruct = TransitionState_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = TransitionState_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = TransitionState_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return TransitionState_possibleConstructorReturn(this, result); }; }\n\nfunction TransitionState_possibleConstructorReturn(self, call) { if (call && (TransitionState_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return TransitionState_assertThisInitialized(self); }\n\nfunction TransitionState_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction TransitionState_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction TransitionState_getPrototypeOf(o) { TransitionState_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return TransitionState_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n/**\r\n * Class for smooth transitioning between states on an animation layer.\r\n *\r\n * @extends AbstractState\r\n */\n\nvar TransitionState = /*#__PURE__*/function (_AbstractState) {\n  TransitionState_inherits(TransitionState, _AbstractState);\n\n  var _super = TransitionState_createSuper(TransitionState);\n\n  function TransitionState() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    TransitionState_classCallCheck(this, TransitionState);\n\n    _this = _super.call(this, options);\n    _this._to = null;\n    _this._from = [];\n    _this._weightPromise = core_Deferred.resolve();\n    return _this;\n  }\n\n  TransitionState_createClass(TransitionState, [{\n    key: "internalWeight",\n    get: function get() {\n      // Find the combined weight of all sub-states\n      var totalWeight = 0;\n\n      if (this._to) {\n        totalWeight += this._to.weight;\n      }\n\n      this._from.forEach(function (state) {\n        totalWeight += state.weight;\n      });\n\n      return totalWeight * this._internalWeight;\n    }\n  }, {\n    key: "updateInternalWeight",\n    value: function updateInternalWeight(factor) {\n      var _this2 = this;\n\n      TransitionState_get(TransitionState_getPrototypeOf(TransitionState.prototype), "updateInternalWeight", this).call(this, factor);\n\n      this._from.forEach(function (state) {\n        state.updateInternalWeight(_this2._internalWeight);\n      });\n\n      if (this._to) {\n        this._to.updateInternalWeight(this._internalWeight);\n      }\n    }\n    /**\r\n     * Update sub-states the transition is controlling and start new weight\r\n     * animations on each one. This should be called each time the current state of\r\n     * an animation layer gets updated to a new value and a transition time greater\r\n     * that zero is specified.\r\n     *\r\n     * @param {Array.<AbstractState>} [currentStates=[]] - States whose weight values\r\n     * will be animated to 0.\r\n     * @param {AbstractState=} targetState - State whose weight will be animated\r\n     * to 1.\r\n     * @param {number} transitionTime - Amount of time it will in seconds take for\r\n     * weight animations to complete.\r\n     * @param {Function=} easingFn - Easing function to use for weight animations.\r\n     * Default is Easing.Linear.InOut.\r\n     * @param {Function=} onComplete - Function to execute once all weight animations\r\n     * complete.\r\n     */\n\n  }, {\n    key: "configure",\n    value: function configure() {\n      var currentStates = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : [];\n      var targetState = arguments.length > 1 ? arguments[1] : undefined;\n      var transitionTime = arguments.length > 2 ? arguments[2] : undefined;\n      var easingFn = arguments.length > 3 ? arguments[3] : undefined;\n      var onComplete = arguments.length > 4 ? arguments[4] : undefined;\n\n      // Deactivate any states that aren\'t in the new configuration\n      if (this._to === targetState || currentStates.includes(this._to)) {\n        this._to = null;\n      }\n\n      this._from = this._from.filter(function (state) {\n        return state !== targetState && !currentStates.includes(state);\n      });\n      this.deactivate();\n      this._from = currentStates;\n      this._to = targetState;\n      this.reset(transitionTime, easingFn, onComplete);\n    }\n    /**\r\n     * Start new weight animations state the transition controls. This should be called\r\n     * if an animation is played with a transition time greater than zero and a transtion\r\n     * to that animation was already in progress.\r\n     *\r\n     * @param {number} transitionTime - Amount of time it will in seconds take for\r\n     * weight animations to complete.\r\n     * @param {Function=} easingFn - Easing function to use for weight animations.\r\n     * Default is Easing.Linear.InOut.\r\n     * @param {Function=} onComplete - Function to execute once all weight animations\r\n     * complete.\r\n     */\n\n  }, {\n    key: "reset",\n    value: function reset(transitionTime, easingFn, onComplete) {\n      var _this3 = this;\n\n      // Stop any pending promises\n      this._weightPromise.cancel(); // Start tweening weight to 0 for the current states\n\n\n      var weightPromises = this._from.map(function (state) {\n        return state.setWeight(0, transitionTime, easingFn);\n      }); // Start tweening weight to 1 for the target state\n\n\n      if (this._to) {\n        weightPromises.push(this._to.setWeight(1, transitionTime, easingFn));\n        this.name = this._to.name;\n      } else {\n        this.name = null;\n      }\n\n      this._weightPromise = core_Deferred.all(weightPromises, function () {\n        _this3._from.forEach(function (state) {\n          state.cancel();\n          state.deactivate();\n        });\n\n        if (typeof onComplete === \'function\') {\n          onComplete();\n        }\n      });\n    }\n  }, {\n    key: "play",\n    value: function play(onFinish, onError, onCancel, onNext) {\n      this._paused = false;\n      this._playCallbacks.onFinish = onFinish;\n      this._playCallbacks.onError = onError;\n      this._playCallbacks.onCancel = onCancel;\n      var promises = [this._weightPromise];\n\n      this._from.forEach(function (state) {\n        state.resume();\n      });\n\n      if (this._to) {\n        this._promises.play = this._to.play(undefined, undefined, undefined, onNext);\n        promises.push(this._promises.play);\n      }\n\n      this._promises.finish = core_Deferred.all(promises, onFinish, onError, onCancel);\n      return this._promises.finish;\n    }\n  }, {\n    key: "pause",\n    value: function pause() {\n      this._from.forEach(function (state) {\n        state.pause();\n      });\n\n      if (this._to) {\n        this._to.pause();\n      }\n\n      return TransitionState_get(TransitionState_getPrototypeOf(TransitionState.prototype), "pause", this).call(this);\n    }\n  }, {\n    key: "resume",\n    value: function resume(onFinish, onError, onCancel, onNext) {\n      this._paused = false;\n\n      if (!this._promises.play.pending) {\n        this._playCallbacks.onFinish = onFinish || this._playCallbacks.onFinish;\n        this._playCallbacks.onError = onError || this._playCallbacks.onError;\n        this._playCallbacks.onCancel = onCancel || this._playCallbacks.onCancel;\n      }\n\n      var promises = [this._weightPromise];\n\n      this._from.forEach(function (state) {\n        state.resume();\n      });\n\n      if (this._to) {\n        this._promises.play = this._to.resume(undefined, undefined, undefined, onNext);\n        promises.push(this._promises.play);\n      }\n\n      this._promises.finish = core_Deferred.all(promises, this._playCallbacks.onFinish, this._playCallbacks.onError, this._playCallbacks.onCancel);\n      return this._promises.finish;\n    }\n  }, {\n    key: "cancel",\n    value: function cancel() {\n      this._from.forEach(function (state) {\n        state.pause();\n      });\n\n      if (this._to) {\n        this._to.cancel();\n      }\n\n      this._weightPromise.cancel();\n\n      return TransitionState_get(TransitionState_getPrototypeOf(TransitionState.prototype), "cancel", this).call(this);\n    }\n  }, {\n    key: "stop",\n    value: function stop() {\n      this._from.forEach(function (state) {\n        state.pause();\n      });\n\n      if (this._to) {\n        this._to.stop();\n      }\n\n      return TransitionState_get(TransitionState_getPrototypeOf(TransitionState.prototype), "stop", this).call(this);\n    }\n  }, {\n    key: "update",\n    value: function update(deltaTime) {\n      TransitionState_get(TransitionState_getPrototypeOf(TransitionState.prototype), "update", this).call(this, deltaTime);\n\n      this._from.forEach(function (state) {\n        state.update(deltaTime);\n      });\n\n      if (this._to) {\n        this._to.update(deltaTime);\n      }\n    }\n  }, {\n    key: "discard",\n    value: function discard() {\n      TransitionState_get(TransitionState_getPrototypeOf(TransitionState.prototype), "discard", this).call(this);\n\n      this._weightPromise.cancel();\n\n      delete this._weightPromise;\n      this._to = null;\n      this._from.length = 0;\n    }\n  }, {\n    key: "deactivate",\n    value: function deactivate() {\n      if (this._to) {\n        this._to.deactivate();\n      }\n\n      this._from.forEach(function (state) {\n        state.deactivate();\n      });\n    }\n  }]);\n\n  return TransitionState;\n}(state_AbstractState);\n\n/* harmony default export */ const state_TransitionState = (TransitionState);\n;// CONCATENATED MODULE: ./src/core/animpack/AnimationPlayerInterface.js\nfunction AnimationPlayerInterface_typeof(obj) { "@babel/helpers - typeof"; return AnimationPlayerInterface_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, AnimationPlayerInterface_typeof(obj); }\n\nfunction AnimationPlayerInterface_toConsumableArray(arr) { return AnimationPlayerInterface_arrayWithoutHoles(arr) || AnimationPlayerInterface_iterableToArray(arr) || AnimationPlayerInterface_unsupportedIterableToArray(arr) || AnimationPlayerInterface_nonIterableSpread(); }\n\nfunction AnimationPlayerInterface_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction AnimationPlayerInterface_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return AnimationPlayerInterface_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return AnimationPlayerInterface_arrayLikeToArray(o, minLen); }\n\nfunction AnimationPlayerInterface_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction AnimationPlayerInterface_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return AnimationPlayerInterface_arrayLikeToArray(arr); }\n\nfunction AnimationPlayerInterface_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction AnimationPlayerInterface_get() { if (typeof Reflect !== "undefined" && Reflect.get) { AnimationPlayerInterface_get = Reflect.get; } else { AnimationPlayerInterface_get = function _get(target, property, receiver) { var base = AnimationPlayerInterface_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return AnimationPlayerInterface_get.apply(this, arguments); }\n\nfunction AnimationPlayerInterface_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = AnimationPlayerInterface_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction AnimationPlayerInterface_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) AnimationPlayerInterface_setPrototypeOf(subClass, superClass); }\n\nfunction AnimationPlayerInterface_setPrototypeOf(o, p) { AnimationPlayerInterface_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return AnimationPlayerInterface_setPrototypeOf(o, p); }\n\nfunction AnimationPlayerInterface_createSuper(Derived) { var hasNativeReflectConstruct = AnimationPlayerInterface_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = AnimationPlayerInterface_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = AnimationPlayerInterface_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return AnimationPlayerInterface_possibleConstructorReturn(this, result); }; }\n\nfunction AnimationPlayerInterface_possibleConstructorReturn(self, call) { if (call && (AnimationPlayerInterface_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return AnimationPlayerInterface_assertThisInitialized(self); }\n\nfunction AnimationPlayerInterface_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction AnimationPlayerInterface_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction AnimationPlayerInterface_getPrototypeOf(o) { AnimationPlayerInterface_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return AnimationPlayerInterface_getPrototypeOf(o); }\n\nfunction AnimationPlayerInterface_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction AnimationPlayerInterface_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction AnimationPlayerInterface_createClass(Constructor, protoProps, staticProps) { if (protoProps) AnimationPlayerInterface_defineProperties(Constructor.prototype, protoProps); if (staticProps) AnimationPlayerInterface_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/* eslint-disable max-classes-per-file */\n\n/* eslint-disable no-unused-vars */\n\n/* eslint-disable no-empty-function */\n\n/* eslint-disable getter-return */\n\n/* eslint-disable no-useless-constructor */\n\n\n/**\r\n * Class factory interface for controlling playback of a collection of animations.\r\n * One animation can be played at any given time, crossfading between animations\r\n * will result in playing a {@link TransitionState}.\r\n *\r\n * @interface\r\n */\n\nvar AnimationPlayerInterface = /*#__PURE__*/function () {\n  function AnimationPlayerInterface() {\n    AnimationPlayerInterface_classCallCheck(this, AnimationPlayerInterface);\n  }\n\n  AnimationPlayerInterface_createClass(AnimationPlayerInterface, [{\n    key: "paused",\n    get:\n    /**\r\n     * Gets whether or not the player is updating states.\r\n     *\r\n     * @readonly\r\n     * @type {boolean}\r\n     */\n    function get() {\n      return this._paused;\n    }\n    /**\r\n     * Gets and sets the default number of seconds it takes to transition to a new\r\n     * animation.\r\n     *\r\n     * @type {number}\r\n     */\n\n  }, {\n    key: "transitionTime",\n    get: function get() {},\n    set: function set(seconds) {}\n    /**\r\n     * Gets and sets the default easing function to use when transitioning and\r\n     * setting weights.\r\n     *\r\n     * @type {Function}\r\n     */\n\n  }, {\n    key: "easingFn",\n    get: function get() {},\n    set: function set(fn) {}\n    /**\r\n     * Gets the state the layer is currently in control of.\r\n     *\r\n     * @readonly\r\n     * @type {AbstractState}\r\n     */\n\n  }, {\n    key: "currentState",\n    get: function get() {}\n    /**\r\n     * Gets the name of the state the layer is currently in control of.\r\n     *\r\n     * @readonly\r\n     * @type {string}\r\n     */\n\n  }, {\n    key: "currentAnimation",\n    get: function get() {}\n    /**\r\n     * Gets whether or not the layer is currently transitioning to a new animation.\r\n     *\r\n     * @readonly\r\n     * @type {boolean}\r\n     */\n\n  }, {\n    key: "isTransitioning",\n    get: function get() {}\n    /**\r\n     * Update the layer\'s current state to a new value. If transitionTime is defined\r\n     * and greater than zero, perform a smooth blend between any states that currently\r\n     * have non-zero weight values and the new state.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {(string|null)} name - Name of the state to transition to.\r\n     * @param {string} playMethod - Name of the operation being prepared for, to be\r\n     * used in error messaging.\r\n     * @param {number=} transitionTime - Amount of time in seconds it will take to\r\n     * switch to the new state.\r\n     * @param {Function=} easingFn - Easing function to use when transitioning to a\r\n     * new state over time.\r\n     * @param {Function=} onError - Function to execute if an error is encountered.\r\n     */\n\n  }, {\n    key: "_prepareCurrentState",\n    value: function _prepareCurrentState(name, playMethod, transitionTime, easingFn, onError) {}\n    /**\r\n     * Start playback an animation from the beginning.\r\n     *\r\n     * @param {string} name - Name of the animation to play.\r\n     * @param {number=} transitionTime - Amount of time it will take before the\r\n     * new state has full influence for the layer.\r\n     * @param {Function=} easingFn - Easing function to use for blending if transitionTime\r\n     * is greater than zero.\r\n     * @param {Function=} onFinish - Function to execute when the animation finishes.\r\n     * @param {Function=} onError - Function to execute if the animation encounters\r\n     * an error during playback.\r\n     * @param {Function=} onCancel - Function to execute if playback is canceled.\r\n     * @param {Function=} onNext - Function to execute if an animation queue is\r\n     * played and it advances to the next animation.\r\n     *\r\n     * @returns {Deferred}\r\n     */\n\n  }, {\n    key: "playAnimation",\n    value: function playAnimation(name, transitionTime, easingFn, onFinish, onError, onCancel, onNext) {}\n    /**\r\n     * Cancel playback of the current animation.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "cancelAnimation",\n    value: function cancelAnimation() {}\n    /**\r\n     * Pause playback of the current animation.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "pauseAnimation",\n    value: function pauseAnimation() {}\n    /**\r\n     * Resume playback of an animation.\r\n     *\r\n     * @param {string=} name - Name of the animation to resume playback for. Default\r\n     * is the layer\'s current animation name.\r\n     * @param {number=} transitionTime - Amount of time it will take before the\r\n     * new state has full influence for the layer.\r\n     * @param {Function=} onFinish - Function to execute when the state finishes.\r\n     * @param {Function=} onError - Function to execute if the state encounters\r\n     * an error during playback.\r\n     * @param {Function=} onCancel - Function to execute if playback is canceled.\r\n     * @param {Function=} onNext - Function to execute if an animation queue is\r\n     * played and it advances to the next animation.\r\n     *\r\n     * @returns {Deferred}\r\n     */\n\n  }, {\n    key: "resumeAnimation",\n    value: function resumeAnimation(name, transitionTime, easingFn, onFinish, onError, onCancel, onNext) {}\n    /**\r\n     * Stop playback of the current animation.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "stopAnimation",\n    value: function stopAnimation() {}\n    /**\r\n     * Update the current animation.\r\n     *\r\n     * @param {number} deltaTime - Time in milliseconds since the last update.\r\n     */\n\n  }, {\n    key: "update",\n    value: function update(deltaTime) {}\n    /**\r\n     * Discard the transition state.\r\n     */\n\n  }, {\n    key: "discard",\n    value: function discard() {}\n    /**\r\n     * Creates a class that implements {@link AnimationPlayerInterface} and extends\r\n     * a specified base class.\r\n     *\r\n     * @param {Class} [BaseClass = class{}] - The class to extend.\r\n     *\r\n     * @return {Class} A class that extends `BaseClass` and implements {@link AnimationPlayerInterface}.\r\n     */\n\n  }], [{\n    key: "Mixin",\n    value: function Mixin() {\n      var BaseClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : /*#__PURE__*/function () {\n        function _class() {\n          AnimationPlayerInterface_classCallCheck(this, _class);\n        }\n\n        return AnimationPlayerInterface_createClass(_class);\n      }();\n\n      var AnimationPlayerMixin = /*#__PURE__*/function (_BaseClass) {\n        AnimationPlayerInterface_inherits(AnimationPlayerMixin, _BaseClass);\n\n        var _super = AnimationPlayerInterface_createSuper(AnimationPlayerMixin);\n\n        function AnimationPlayerMixin() {\n          var _this;\n\n          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n          AnimationPlayerInterface_classCallCheck(this, AnimationPlayerMixin);\n\n          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            args[_key - 1] = arguments[_key];\n          }\n\n          _this = _super.call.apply(_super, [this, options].concat(args));\n          _this._transitionState = new state_TransitionState();\n          _this._states = _this._states !== undefined ? _this._states : new Map();\n          _this._currentState = null;\n          _this._paused = false;\n          _this._transitionTime = Number(options.transitionTime) >= 0 ? Number(options.transitionTime) : 0;\n          _this._easingFn = typeof options.easingFn === \'function\' ? options.easingFn : undefined;\n          return _this;\n        }\n\n        AnimationPlayerInterface_createClass(AnimationPlayerMixin, [{\n          key: "paused",\n          get: function get() {\n            return this._paused;\n          }\n        }, {\n          key: "transitionTime",\n          get: function get() {\n            return this._transitionTime;\n          },\n          set: function set(seconds) {\n            seconds = Number(seconds);\n\n            if (!(seconds >= 0)) {\n              throw new Error("Cannot set transition time for ".concat(this.constructor.name, " to ").concat(seconds, ". Seconds must be a numeric value greather than or equal to zero."));\n            }\n\n            this._transitionTime = seconds;\n          }\n        }, {\n          key: "easingFn",\n          get: function get() {\n            return this._easingFn;\n          },\n          set: function set(fn) {\n            this._easingFn = fn;\n          }\n        }, {\n          key: "currentState",\n          get: function get() {\n            return this._currentState;\n          }\n        }, {\n          key: "currentAnimation",\n          get: function get() {\n            if (this._currentState) {\n              return this._currentState.name;\n            }\n\n            return null;\n          }\n        }, {\n          key: "isTransitioning",\n          get: function get() {\n            return this._currentState === this._transitionState;\n          }\n        }, {\n          key: "_prepareCurrentState",\n          value: function _prepareCurrentState(name, playMethod, transitionTime, easingFn, onError) {\n            var _this2 = this;\n\n            if (name !== null && !this._states.has(name)) {\n              var e = new Error("Cannot ".concat(playMethod, " animation ").concat(name, ". No animation exists with this name."));\n\n              if (typeof onError === \'function\') {\n                onError(e);\n              }\n\n              throw e;\n            }\n\n            var targetState = name !== null ? this._states.get(name) : null; // Make sure the new state isn\'t already playing\n\n            if (this.currentAnimation !== name) {\n              // Switch to the new state immediately\n              if (transitionTime <= 0) {\n                // Cancel the current state and set its weight to 0\n                if (this._currentState) {\n                  this._currentState.cancel();\n\n                  this._currentState.weight = 0;\n\n                  this._currentState.deactivate();\n                }\n\n                this._currentState = targetState;\n              } // Blend to the new state over time\n              else {\n                // Make sure to transition out of any states with non-zero weight\n                var currentStates = AnimationPlayerInterface_toConsumableArray(this._states.values()).filter(function (s) {\n                  return s !== targetState && (s.weight || s.weightPending);\n                }); // Update the transition state with new inputs\n\n\n                this._transitionState.configure(currentStates, targetState, transitionTime, easingFn, function () {\n                  _this2._currentState = targetState;\n                  _this2._transitionState.weight = 0;\n                });\n\n                this._currentState = this._transitionState;\n              }\n            } else if (playMethod === \'play\') {\n              this._currentState.cancel();\n\n              if (this._currentState === this._transitionState) {\n                this._transitionState.reset(transitionTime, easingFn, function () {\n                  _this2._currentState = targetState;\n                  _this2._transitionState.weight = 0;\n                });\n              }\n            } // Update weight for the new current state so it has full influence for the player\n\n\n            this._currentState.weight = 1;\n\n            this._currentState.updateInternalWeight(this._internalWeight);\n          }\n        }, {\n          key: "playAnimation",\n          value: function playAnimation(name, transitionTime, easingFn, onFinish, onError, onCancel, onNext) {\n            var error;\n            var reject = false;\n\n            try {\n              this._prepareCurrentState(name, \'play\', transitionTime !== undefined ? transitionTime : this._transitionTime, easingFn !== undefined ? easingFn : this._easingFn, onError);\n            } catch (e) {\n              error = e;\n              reject = true;\n            }\n\n            if (reject) {\n              return core_Deferred.reject(error);\n            }\n\n            return this._currentState.play(onFinish, onError, onCancel, onNext);\n          }\n        }, {\n          key: "pauseAnimation",\n          value: function pauseAnimation() {\n            if (this._currentState) {\n              return this._currentState.pause();\n            } else {\n              return false;\n            }\n          }\n        }, {\n          key: "resumeAnimation",\n          value: function resumeAnimation(name, transitionTime, easingFn, onFinish, onError, onCancel, onNext) {\n            if (name === undefined && this._currentState) {\n              name = this._currentState.name;\n            }\n\n            var error;\n            var reject = false;\n\n            try {\n              this._prepareCurrentState(name, \'resume\', transitionTime !== undefined ? transitionTime : this._transitionTime, easingFn !== undefined ? easingFn : this._easingFn, onError);\n            } catch (e) {\n              error = e;\n              reject = true;\n            }\n\n            if (reject) {\n              return core_Deferred.reject(error);\n            }\n\n            return this._currentState.resume(onFinish, onError, onCancel, onNext);\n          }\n        }, {\n          key: "cancelAnimation",\n          value: function cancelAnimation() {\n            if (this._currentState) {\n              return this._currentState.cancel();\n            } else {\n              return false;\n            }\n          }\n        }, {\n          key: "stopAnimation",\n          value: function stopAnimation() {\n            if (this._currentState) {\n              return this._currentState.stop();\n            } else {\n              return false;\n            }\n          }\n        }, {\n          key: "update",\n          value: function update(deltaTime) {\n            if (AnimationPlayerInterface_get(AnimationPlayerInterface_getPrototypeOf(AnimationPlayerMixin.prototype), "update", this)) {\n              AnimationPlayerInterface_get(AnimationPlayerInterface_getPrototypeOf(AnimationPlayerMixin.prototype), "update", this).call(this, deltaTime);\n            }\n\n            if (this._currentState) {\n              this._currentState.update(deltaTime);\n            }\n          }\n        }, {\n          key: "discard",\n          value: function discard() {\n            if (AnimationPlayerInterface_get(AnimationPlayerInterface_getPrototypeOf(AnimationPlayerMixin.prototype), "discard", this)) {\n              AnimationPlayerInterface_get(AnimationPlayerInterface_getPrototypeOf(AnimationPlayerMixin.prototype), "discard", this).call(this);\n            }\n\n            this._transitionState.discard();\n\n            delete this._transitionState;\n          }\n        }]);\n\n        return AnimationPlayerMixin;\n      }(BaseClass);\n\n      return AnimationPlayerMixin;\n    }\n  }]);\n\n  return AnimationPlayerInterface;\n}();\n\n/* harmony default export */ const animpack_AnimationPlayerInterface = (AnimationPlayerInterface);\n;// CONCATENATED MODULE: ./src/core/animpack/state/StateContainerInterface.js\nfunction StateContainerInterface_typeof(obj) { "@babel/helpers - typeof"; return StateContainerInterface_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, StateContainerInterface_typeof(obj); }\n\nfunction StateContainerInterface_toConsumableArray(arr) { return StateContainerInterface_arrayWithoutHoles(arr) || StateContainerInterface_iterableToArray(arr) || StateContainerInterface_unsupportedIterableToArray(arr) || StateContainerInterface_nonIterableSpread(); }\n\nfunction StateContainerInterface_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction StateContainerInterface_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return StateContainerInterface_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return StateContainerInterface_arrayLikeToArray(o, minLen); }\n\nfunction StateContainerInterface_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction StateContainerInterface_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return StateContainerInterface_arrayLikeToArray(arr); }\n\nfunction StateContainerInterface_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction StateContainerInterface_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) StateContainerInterface_setPrototypeOf(subClass, superClass); }\n\nfunction StateContainerInterface_setPrototypeOf(o, p) { StateContainerInterface_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return StateContainerInterface_setPrototypeOf(o, p); }\n\nfunction StateContainerInterface_createSuper(Derived) { var hasNativeReflectConstruct = StateContainerInterface_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = StateContainerInterface_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = StateContainerInterface_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return StateContainerInterface_possibleConstructorReturn(this, result); }; }\n\nfunction StateContainerInterface_possibleConstructorReturn(self, call) { if (call && (StateContainerInterface_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return StateContainerInterface_assertThisInitialized(self); }\n\nfunction StateContainerInterface_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction StateContainerInterface_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction StateContainerInterface_getPrototypeOf(o) { StateContainerInterface_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return StateContainerInterface_getPrototypeOf(o); }\n\nfunction StateContainerInterface_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction StateContainerInterface_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction StateContainerInterface_createClass(Constructor, protoProps, staticProps) { if (protoProps) StateContainerInterface_defineProperties(Constructor.prototype, protoProps); if (staticProps) StateContainerInterface_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/* eslint-disable max-classes-per-file */\n\n/* eslint-disable no-unused-vars */\n\n/* eslint-disable no-empty-function */\n\n/* eslint-disable getter-return */\n\n/**\r\n * Class factory interface for manipulating a collection of {@link AbstractState}.\r\n *\r\n * @interface\r\n */\n\nvar StateContainerInterface = /*#__PURE__*/function () {\n  function StateContainerInterface() {\n    StateContainerInterface_classCallCheck(this, StateContainerInterface);\n  }\n\n  StateContainerInterface_createClass(StateContainerInterface, [{\n    key: "getState",\n    value:\n    /**\r\n     * Return the state with the given name.\r\n     *\r\n     * @param {string} name - Name of the state.\r\n     *\r\n     * @returns {AbstractState}\r\n     */\n    function getState(name) {}\n    /**\r\n     * Gets an array of the names of all states in the container.\r\n     *\r\n     * @type {Array.<string>}\r\n     */\n\n  }, {\n    key: "getStateNames",\n    value: function getStateNames() {}\n    /**\r\n     * Add a new state to be controlled by the container. States are stored keyed\r\n     * by their name property, which must be unique. If it isn\'t, a number will\r\n     * be added or incremented until a unique key is generated.\r\n     *\r\n     * @param {AbstractState} state - State to add to the container.\r\n     *\r\n     * @returns {string} - Unique name of the state.\r\n     */\n\n  }, {\n    key: "addState",\n    value: function addState(state) {}\n    /**\r\n     * Removes a state with the given name from the container.\r\n     *\r\n     * @param {string} name - Name of the state to remove.\r\n     *\r\n     * @returns {boolean} - Whether or not a state was removed.\r\n     */\n\n  }, {\n    key: "removeState",\n    value: function removeState(name) {}\n    /**\r\n     * Renames a state with the given name in the container. Name must be unique\r\n     * to the container, if it isn\'t the name will be incremented until it is unique.\r\n     *\r\n     * @param {string} currentName - Name of the state to rename.\r\n     * @param {string} newName - Name to update the state with.\r\n     *\r\n     * @returns {string} - Updated name for the state.\r\n     */\n\n  }, {\n    key: "renameState",\n    value: function renameState(currentName, newName) {}\n    /**\r\n     * Discards all states.\r\n     */\n\n  }, {\n    key: "discardStates",\n    value: function discardStates() {}\n    /**\r\n     * Creates a class that implements {@link StateContainerInterface} and extends\r\n     * a specified base class.\r\n     *\r\n     * @param {Class} [BaseClass = class{}] - The class to extend.\r\n     *\r\n     * @return {Class} A class that extends `BaseClass` and implements {@link StateContainerInterface}.\r\n     */\n\n  }], [{\n    key: "Mixin",\n    value: function Mixin() {\n      var BaseClass = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : /*#__PURE__*/function () {\n        function _class() {\n          StateContainerInterface_classCallCheck(this, _class);\n        }\n\n        return StateContainerInterface_createClass(_class);\n      }();\n\n      /**\r\n       * This mixin adds functionality for manipulating uniquely-named animation states in\r\n       * a map.\r\n       */\n      var StateContainerMixin = /*#__PURE__*/function (_BaseClass) {\n        StateContainerInterface_inherits(StateContainerMixin, _BaseClass);\n\n        var _super = StateContainerInterface_createSuper(StateContainerMixin);\n\n        function StateContainerMixin() {\n          var _this;\n\n          var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n          StateContainerInterface_classCallCheck(this, StateContainerMixin);\n\n          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            args[_key - 1] = arguments[_key];\n          }\n\n          _this = _super.call.apply(_super, [this, options].concat(args));\n          _this._states = _this._states !== undefined ? _this._states : new Map();\n          return _this;\n        }\n\n        StateContainerInterface_createClass(StateContainerMixin, [{\n          key: "getState",\n          value: function getState(name) {\n            return this._states.get(name);\n          }\n        }, {\n          key: "getStateNames",\n          value: function getStateNames() {\n            return StateContainerInterface_toConsumableArray(this._states.keys());\n          }\n        }, {\n          key: "addState",\n          value: function addState(state) {\n            // Make sure the state is not already in this container\n            if (StateContainerInterface_toConsumableArray(this._states.values()).includes(state)) {\n              console.warn("Cannot add animation to state ".concat(this.name, ". Animation was already added."));\n              return state.name;\n            } // Make sure the state name is unique\n\n\n            var uniqueName = core_Utils.getUniqueName(state.name, StateContainerInterface_toConsumableArray(this._states.keys()));\n\n            if (state.name !== uniqueName) {\n              console.warn("Animation name ".concat(state.name, " is not unique for state ").concat(this.name, ". New animation will be added with name ").concat(uniqueName, "."));\n              state.name = uniqueName;\n            }\n\n            this._states.set(state.name, state);\n\n            return state.name;\n          }\n        }, {\n          key: "removeState",\n          value: function removeState(name) {\n            // Check if the state is in this container\n            if (!this._states || !this._states.has(name)) {\n              console.warn("Did not remove animation ".concat(name, " from state ").concat(this.name, ". No animation exists with this name."));\n              return false;\n            }\n\n            this._states.get(name).discard();\n\n            this._states["delete"](name);\n\n            return true;\n          }\n        }, {\n          key: "renameState",\n          value: function renameState(currentName, newName) {\n            // Make sure the state is in this container\n            if (!this._states || !this._states.has(currentName)) {\n              throw new Error("Cannot rename animation ".concat(currentName, " in ").concat(this.name, ". No animation exists with this name."));\n            }\n\n            var state = this._states.get(currentName); // Exit if the names are the same\n\n\n            if (currentName === newName) {\n              return currentName;\n            } // Make sure the name is unique\n\n\n            var uniqueName = core_Utils.getUniqueName(newName, StateContainerInterface_toConsumableArray(this._states.keys()).filter(function (s) {\n              return s.name !== currentName;\n            }));\n\n            if (newName !== uniqueName) {\n              console.warn("Animation name ".concat(newName, " is not unique in state ").concat(this.name, ". Animation will be renamed to ").concat(uniqueName, "."));\n              newName = uniqueName;\n            }\n\n            state.name = newName;\n\n            this._states["delete"](currentName);\n\n            this._states.set(state.name, state);\n\n            return state.name;\n          }\n        }, {\n          key: "discardStates",\n          value: function discardStates() {\n            this._states.forEach(function (state) {\n              state.discard();\n            });\n\n            delete this._states;\n          }\n        }]);\n\n        return StateContainerMixin;\n      }(BaseClass);\n\n      return StateContainerMixin;\n    }\n  }]);\n\n  return StateContainerInterface;\n}();\n\n/* harmony default export */ const state_StateContainerInterface = (StateContainerInterface);\n;// CONCATENATED MODULE: ./src/core/animpack/state/QueueState.js\nfunction QueueState_typeof(obj) { "@babel/helpers - typeof"; return QueueState_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, QueueState_typeof(obj); }\n\nfunction QueueState_toConsumableArray(arr) { return QueueState_arrayWithoutHoles(arr) || QueueState_iterableToArray(arr) || QueueState_unsupportedIterableToArray(arr) || QueueState_nonIterableSpread(); }\n\nfunction QueueState_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction QueueState_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return QueueState_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return QueueState_arrayLikeToArray(o, minLen); }\n\nfunction QueueState_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction QueueState_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return QueueState_arrayLikeToArray(arr); }\n\nfunction QueueState_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction QueueState_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction QueueState_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction QueueState_createClass(Constructor, protoProps, staticProps) { if (protoProps) QueueState_defineProperties(Constructor.prototype, protoProps); if (staticProps) QueueState_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction QueueState_get() { if (typeof Reflect !== "undefined" && Reflect.get) { QueueState_get = Reflect.get; } else { QueueState_get = function _get(target, property, receiver) { var base = QueueState_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return QueueState_get.apply(this, arguments); }\n\nfunction QueueState_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = QueueState_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction QueueState_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) QueueState_setPrototypeOf(subClass, superClass); }\n\nfunction QueueState_setPrototypeOf(o, p) { QueueState_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return QueueState_setPrototypeOf(o, p); }\n\nfunction QueueState_createSuper(Derived) { var hasNativeReflectConstruct = QueueState_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = QueueState_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = QueueState_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return QueueState_possibleConstructorReturn(this, result); }; }\n\nfunction QueueState_possibleConstructorReturn(self, call) { if (call && (QueueState_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return QueueState_assertThisInitialized(self); }\n\nfunction QueueState_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction QueueState_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction QueueState_getPrototypeOf(o) { QueueState_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return QueueState_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n/**\r\n * Class for playing an ordered array of animation states in sequence.\r\n *\r\n * @extends AbstractState\r\n * @implements @AnimationPlayerInterface\r\n */\n\nvar QueueState = /*#__PURE__*/function (_AnimationPlayerInter) {\n  QueueState_inherits(QueueState, _AnimationPlayerInter);\n\n  var _super = QueueState_createSuper(QueueState);\n\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {Object} [options={}] - Options for the state.\r\n   * @param {boolean} [options.autoAdvance=true] - Whether to autmatically advance\r\n   * to the next state in the queue as each state completes.\r\n   * @param {Array.<AbstractState>} [queueStates=[]] - Array of states to be played\r\n   * in order.\r\n   */\n  function QueueState() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var queueStates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    QueueState_classCallCheck(this, QueueState);\n\n    _this = _super.call(this, options);\n    queueStates.forEach(function (state) {\n      _this.addState(state);\n    });\n    _this._queue = _this._states.keys();\n    _this._done = true;\n    return _this;\n  }\n  /**\r\n   * Gets whether the animation queue has reached the end.\r\n   */\n\n\n  QueueState_createClass(QueueState, [{\n    key: "done",\n    get: function get() {\n      return this._done;\n    }\n    /**\r\n     * Gets the internal weight.\r\n     *\r\n     * @readonly\r\n     * @type {number}\r\n     */\n\n  }, {\n    key: "internalWeight",\n    get: function get() {\n      return this._currentState ? this._currentState.internalWeight * this._internalWeight : 0;\n    }\n    /**\r\n     * Restart the queue iterator.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_reset",\n    value: function _reset() {\n      this._queue = this._states.keys();\n\n      var _this$_queue$next = this._queue.next(),\n          value = _this$_queue$next.value,\n          done = _this$_queue$next.done;\n\n      this._done = done;\n      return value || null;\n    }\n    /**\r\n     * Multiplies the user weight by a factor to determine the internal weight.\r\n     *\r\n     * @param {number} factor - 0-1 multiplier to apply to the user weight.\r\n     */\n\n  }, {\n    key: "updateInternalWeight",\n    value: function updateInternalWeight(factor) {\n      QueueState_get(QueueState_getPrototypeOf(QueueState.prototype), "updateInternalWeight", this).call(this, factor);\n\n      if (this._currentState) {\n        this._currentState.updateInternalWeight(this._internalWeight);\n      }\n    }\n    /**\r\n     * Start the next animation in the queue.\r\n     *\r\n     * @param {Function=} onNext - Function to execute each time an animation completes\r\n     * and the queue moves to the next animation.\r\n     * @param {boolean} [wrap=false] - Whether or not to start the queue from the\r\n     * beginning again if the end has been reached.\r\n     *\r\n     * @returns {Deferred}\r\n     */\n\n  }, {\n    key: "next",\n    value: function next(onNext) {\n      var _this2 = this;\n\n      var wrap = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n\n      // Move the queue forward\n      var _this$_queue$next2 = this._queue.next(),\n          name = _this$_queue$next2.value,\n          done = _this$_queue$next2.done;\n\n      this._done = done;\n      this._paused = false; // The queue has reached the end\n\n      if (done) {\n        // Start the queue over\n        if (wrap) {\n          return this.play(this._playCallbacks.onFinish, this._playCallbacks.onError, this._playCallbacks.onCancel, onNext);\n        } // Stop the queue\n        else {\n          this._promises.finish.resolve();\n\n          return this._promises.finish;\n        }\n      } // Signal the next animation is starting\n\n\n      if (typeof onNext === \'function\') {\n        var lastName = QueueState_toConsumableArray(this._states.keys())[this._states.size - 1];\n\n        var isQueueEnd = name === lastName;\n        onNext({\n          name: name,\n          canAdvance: this.getState(name).loopCount !== Infinity && !isQueueEnd,\n          isQueueEnd: isQueueEnd\n        });\n      } // Start the next animation\n\n\n      this.playAnimation(name, this._transitionTime, this._easingFn, function () {\n        if (!_this2._paused && !_this2.isTransitioning) {\n          _this2.next(onNext);\n        }\n      }, this._playCallbacks.onError);\n      return this._promises.finish;\n    }\n  }, {\n    key: "play",\n    value: function play(onFinish, onError, onCancel, onNext) {\n      var _this3 = this;\n\n      var name = this._reset();\n\n      QueueState_get(QueueState_getPrototypeOf(QueueState.prototype), "play", this).call(this, onFinish, onError, onCancel);\n\n      if (this._done) {\n        this._promises.finish.resolve();\n      } else {\n        // Signal the next animation is starting\n        if (name !== this.currentAnimation && typeof onNext === \'function\') {\n          var lastName = QueueState_toConsumableArray(this._states.keys())[this._states.size - 1];\n\n          var isQueueEnd = name === lastName;\n          onNext({\n            name: name,\n            canAdvance: name ? this.getState(name).loopCount !== Infinity && !isQueueEnd : true,\n            isQueueEnd: !name || isQueueEnd\n          });\n        } // Start the next animation\n\n\n        this.playAnimation(name, this._currentState ? this._transitionTime : 0, this._easingFn, function () {\n          if (!_this3._paused && !_this3.isTransitioning) {\n            _this3.next(onNext);\n          }\n        }, onError);\n      }\n\n      return this._promises.finish;\n    }\n  }, {\n    key: "pause",\n    value: function pause() {\n      var paused = QueueState_get(QueueState_getPrototypeOf(QueueState.prototype), "pause", this).call(this);\n\n      this.pauseAnimation();\n      return paused;\n    }\n  }, {\n    key: "resume",\n    value: function resume(onFinish, onError, onCancel, onNext) {\n      var _this4 = this;\n\n      if (this._done) {\n        return this.play(onFinish, onError, onCancel, onNext);\n      } else {\n        QueueState_get(QueueState_getPrototypeOf(QueueState.prototype), "resume", this).call(this, onFinish, onError, onCancel);\n\n        this.resumeAnimation(this._currentState.name, this._transitionTime, this._easingFn, function () {\n          if (!_this4._paused && !_this4.isTransitioning) {\n            _this4.next(onNext);\n          }\n        }, onError);\n        return this._promises.finish;\n      }\n    }\n  }, {\n    key: "cancel",\n    value: function cancel() {\n      var canceled = QueueState_get(QueueState_getPrototypeOf(QueueState.prototype), "cancel", this).call(this);\n\n      if (this._currentState) {\n        this._currentState.cancel();\n      }\n\n      return canceled;\n    }\n  }, {\n    key: "stop",\n    value: function stop() {\n      var stopped = QueueState_get(QueueState_getPrototypeOf(QueueState.prototype), "stop", this).call(this);\n\n      this.stopAnimation();\n      this._done = true;\n      return stopped;\n    }\n  }, {\n    key: "discard",\n    value: function discard() {\n      QueueState_get(QueueState_getPrototypeOf(QueueState.prototype), "discard", this).call(this);\n\n      this.discardStates();\n    }\n  }]);\n\n  return QueueState;\n}(animpack_AnimationPlayerInterface.Mixin(state_StateContainerInterface.Mixin(state_AbstractState)));\n\n/* harmony default export */ const state_QueueState = (QueueState);\n;// CONCATENATED MODULE: ./src/core/animpack/state/AbstractBlendState.js\nfunction AbstractBlendState_typeof(obj) { "@babel/helpers - typeof"; return AbstractBlendState_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, AbstractBlendState_typeof(obj); }\n\nfunction AbstractBlendState_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction AbstractBlendState_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction AbstractBlendState_createClass(Constructor, protoProps, staticProps) { if (protoProps) AbstractBlendState_defineProperties(Constructor.prototype, protoProps); if (staticProps) AbstractBlendState_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction AbstractBlendState_get() { if (typeof Reflect !== "undefined" && Reflect.get) { AbstractBlendState_get = Reflect.get; } else { AbstractBlendState_get = function _get(target, property, receiver) { var base = AbstractBlendState_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return AbstractBlendState_get.apply(this, arguments); }\n\nfunction AbstractBlendState_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = AbstractBlendState_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction AbstractBlendState_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) AbstractBlendState_setPrototypeOf(subClass, superClass); }\n\nfunction AbstractBlendState_setPrototypeOf(o, p) { AbstractBlendState_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return AbstractBlendState_setPrototypeOf(o, p); }\n\nfunction AbstractBlendState_createSuper(Derived) { var hasNativeReflectConstruct = AbstractBlendState_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = AbstractBlendState_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = AbstractBlendState_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return AbstractBlendState_possibleConstructorReturn(this, result); }; }\n\nfunction AbstractBlendState_possibleConstructorReturn(self, call) { if (call && (AbstractBlendState_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return AbstractBlendState_assertThisInitialized(self); }\n\nfunction AbstractBlendState_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction AbstractBlendState_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction AbstractBlendState_getPrototypeOf(o) { AbstractBlendState_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return AbstractBlendState_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n\n/**\r\n * Base class for a state that blends a collection of {@link AbstractState}.\r\n *\r\n * @abstract\r\n * @implements StateContainerInterface\r\n */\n\nvar AbstractBlendState = /*#__PURE__*/function (_StateContainerInterf) {\n  AbstractBlendState_inherits(AbstractBlendState, _StateContainerInterf);\n\n  var _super = AbstractBlendState_createSuper(AbstractBlendState);\n\n  function AbstractBlendState() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var blendStates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    AbstractBlendState_classCallCheck(this, AbstractBlendState);\n\n    for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {\n      args[_key - 2] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this, options].concat(args));\n    blendStates.forEach(function (state) {\n      _this.addState(state);\n    });\n    return _this;\n  }\n  /**\r\n   * Gets the sum of internal weights of the sub-states.\r\n   *\r\n   * @readonly\r\n   * @type {number}\r\n   */\n\n\n  AbstractBlendState_createClass(AbstractBlendState, [{\n    key: "internalWeight",\n    get: function get() {\n      var blendWeights = 0;\n\n      this._states.forEach(function (state) {\n        blendWeights += state.internalWeight;\n      });\n\n      return blendWeights;\n    }\n    /**\r\n     * Returns the weight of a state controlled by the container.\r\n     *\r\n     * @param {string} name - Name of the state to return the weight from.\r\n     *\r\n     * @returns {number} - Weight of the state.\r\n     */\n\n  }, {\n    key: "getBlendWeight",\n    value: function getBlendWeight(name) {\n      // Make sure the name is valid\n      var state = this.getState(name);\n\n      if (state === undefined) {\n        throw new Error("Cannot get weight of state ".concat(name, " from BlendState ").concat(this.name, ". No state exists with this name."));\n      }\n\n      return state.weight;\n    }\n    /**\r\n     * Sets the weight of a state controlled by the container.\r\n     *\r\n     * @param {string} name - Name of the state to set the weight of.\r\n     * @param {number} weight - Weight value to set on the state.\r\n     *\r\n     * @returns {Deferred}\r\n     */\n\n  }, {\n    key: "setBlendWeight",\n    value: function setBlendWeight(name, weight) {\n      var seconds = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var easingFn = arguments.length > 3 ? arguments[3] : undefined;\n      // Make sure the name is valid\n      var state = this.getState(name);\n\n      if (state === undefined) {\n        throw new Error("Cannot set weight of state ".concat(name, " from BlendState ").concat(this.name, ". No state exists with this name."));\n      }\n\n      weight = core_MathUtils.clamp(weight);\n      return state.setWeight(weight, seconds, easingFn);\n    }\n    /**\r\n     * Multiplies the weight of each sub-state by a factor to determine the internal weight.\r\n     *\r\n     * @param {number} factor - 0-1 multiplier to apply to the user weight.\r\n     */\n\n  }, {\n    key: "updateInternalWeight",\n    value: function updateInternalWeight(factor) {\n      var _this2 = this;\n\n      AbstractBlendState_get(AbstractBlendState_getPrototypeOf(AbstractBlendState.prototype), "updateInternalWeight", this).call(this, factor);\n\n      this._states.forEach(function (state) {\n        state.updateInternalWeight(_this2._internalWeight);\n      });\n    }\n    /**\r\n     * Update any values of the sub-states that need to be evaluated every frame.\r\n     *\r\n     * @param {number} deltaTime - Time in milliseconds since the last update.\r\n     */\n\n  }, {\n    key: "update",\n    value: function update(deltaTime) {\n      AbstractBlendState_get(AbstractBlendState_getPrototypeOf(AbstractBlendState.prototype), "update", this).call(this, deltaTime);\n\n      this._states.forEach(function (state) {\n        state.update(deltaTime);\n      });\n    }\n    /**\r\n     * Start playback of the sub-states from the beginning.\r\n     *\r\n     * @param {Function=} onFinish - Function to execute when the state finishes.\r\n     * @param {Function=} onError - Function to execute if the state encounters\r\n     * an error during playback.\r\n     * @param {Function=} onCancel - Function to execute if playback is canceled.\r\n     *\r\n     * @returns {Deferred}\r\n     */\n\n  }, {\n    key: "play",\n    value: function play(onFinish, onError, onCancel) {\n      var promises = [AbstractBlendState_get(AbstractBlendState_getPrototypeOf(AbstractBlendState.prototype), "play", this).call(this)];\n\n      this._states.forEach(function (state) {\n        promises.push(state.play());\n      });\n\n      return core_Deferred.all(promises, onFinish, onError, onCancel);\n    }\n    /**\r\n     * Pause playback of the sub-states. This prevents pending promises from being executed.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "pause",\n    value: function pause() {\n      this._states.forEach(function (state) {\n        state.pause();\n      });\n\n      return AbstractBlendState_get(AbstractBlendState_getPrototypeOf(AbstractBlendState.prototype), "pause", this).call(this);\n    }\n    /**\r\n     * Resume playback of the sub-states.\r\n     *\r\n     * @param {Function=} onFinish - Function to execute when the state finishes.\r\n     * @param {Function=} onError - Function to execute if the state encounters\r\n     * an error during playback.\r\n     * @param {Function=} onCancel - Function to execute if playback is canceled.\r\n     *\r\n     * @returns {Deferred}\r\n     */\n\n  }, {\n    key: "resume",\n    value: function resume(onFinish, onError, onCancel) {\n      var promises = [AbstractBlendState_get(AbstractBlendState_getPrototypeOf(AbstractBlendState.prototype), "resume", this).call(this)];\n\n      this._states.forEach(function (state) {\n        promises.push(state.resume());\n      });\n\n      return core_Deferred.all(promises, onFinish, onError, onCancel);\n    }\n    /**\r\n     * Cancel playback of the sub-states and cancel any pending promises.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "cancel",\n    value: function cancel() {\n      this._states.forEach(function (state) {\n        state.cancel();\n      });\n\n      return AbstractBlendState_get(AbstractBlendState_getPrototypeOf(AbstractBlendState.prototype), "cancel", this).call(this);\n    }\n    /**\r\n     * Stop playback of the sub-states and resolve any pending promises.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "stop",\n    value: function stop() {\n      this._states.forEach(function (state) {\n        state.stop();\n      });\n\n      return AbstractBlendState_get(AbstractBlendState_getPrototypeOf(AbstractBlendState.prototype), "stop", this).call(this);\n    }\n    /**\r\n     * Discards all sub-state resources.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "discard",\n    value: function discard() {\n      AbstractBlendState_get(AbstractBlendState_getPrototypeOf(AbstractBlendState.prototype), "discard", this).call(this);\n\n      this.discardStates();\n    }\n  }]);\n\n  return AbstractBlendState;\n}(state_StateContainerInterface.Mixin(state_AbstractState));\n\n/* harmony default export */ const state_AbstractBlendState = (AbstractBlendState);\n;// CONCATENATED MODULE: ./src/core/animpack/state/FreeBlendState.js\nfunction FreeBlendState_typeof(obj) { "@babel/helpers - typeof"; return FreeBlendState_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, FreeBlendState_typeof(obj); }\n\nfunction FreeBlendState_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction FreeBlendState_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction FreeBlendState_createClass(Constructor, protoProps, staticProps) { if (protoProps) FreeBlendState_defineProperties(Constructor.prototype, protoProps); if (staticProps) FreeBlendState_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction FreeBlendState_get() { if (typeof Reflect !== "undefined" && Reflect.get) { FreeBlendState_get = Reflect.get; } else { FreeBlendState_get = function _get(target, property, receiver) { var base = FreeBlendState_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return FreeBlendState_get.apply(this, arguments); }\n\nfunction FreeBlendState_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = FreeBlendState_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction FreeBlendState_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) FreeBlendState_setPrototypeOf(subClass, superClass); }\n\nfunction FreeBlendState_setPrototypeOf(o, p) { FreeBlendState_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return FreeBlendState_setPrototypeOf(o, p); }\n\nfunction FreeBlendState_createSuper(Derived) { var hasNativeReflectConstruct = FreeBlendState_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = FreeBlendState_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = FreeBlendState_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return FreeBlendState_possibleConstructorReturn(this, result); }; }\n\nfunction FreeBlendState_possibleConstructorReturn(self, call) { if (call && (FreeBlendState_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return FreeBlendState_assertThisInitialized(self); }\n\nfunction FreeBlendState_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction FreeBlendState_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction FreeBlendState_getPrototypeOf(o) { FreeBlendState_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return FreeBlendState_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/**\r\n * Class for blending N number of blend states.\r\n *\r\n * @extends AbstractBlendState\r\n */\n\nvar FreeBlendState = /*#__PURE__*/function (_AbstractBlendState) {\n  FreeBlendState_inherits(FreeBlendState, _AbstractBlendState);\n\n  var _super = FreeBlendState_createSuper(FreeBlendState);\n\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {Object} [options={}] - Options for the container state.\r\n   * @param {Array.<AbstractState>} [blendStates=[]] - Blend states to be controlled by\r\n   * this container.\r\n   */\n  function FreeBlendState() {\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var blendStates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    FreeBlendState_classCallCheck(this, FreeBlendState);\n\n    return _super.call(this, options, blendStates);\n  }\n\n  FreeBlendState_createClass(FreeBlendState, [{\n    key: "updateInternalWeight",\n    value: function updateInternalWeight(factor) {\n      var _this = this;\n\n      FreeBlendState_get(FreeBlendState_getPrototypeOf(FreeBlendState.prototype), "updateInternalWeight", this).call(this, factor); // Determine the total active weight of blend states\n\n\n      var sumWeights = 0;\n\n      this._states.forEach(function (state) {\n        sumWeights += state.weight;\n      }); // Ensure the sum of blend state internal weights does not exceed container internal weight\n\n\n      factor /= Math.max(sumWeights, 1); // Sum of blend state internal weights should not exceed container internal weight\n\n      this._states.forEach(function (state) {\n        state.updateInternalWeight(factor * _this._weight);\n      });\n    }\n  }]);\n\n  return FreeBlendState;\n}(state_AbstractBlendState);\n\n/* harmony default export */ const state_FreeBlendState = (FreeBlendState);\n;// CONCATENATED MODULE: ./src/core/animpack/state/Blend1dState.js\nfunction Blend1dState_typeof(obj) { "@babel/helpers - typeof"; return Blend1dState_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, Blend1dState_typeof(obj); }\n\nfunction Blend1dState_toConsumableArray(arr) { return Blend1dState_arrayWithoutHoles(arr) || Blend1dState_iterableToArray(arr) || Blend1dState_unsupportedIterableToArray(arr) || Blend1dState_nonIterableSpread(); }\n\nfunction Blend1dState_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Blend1dState_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Blend1dState_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Blend1dState_arrayLikeToArray(o, minLen); }\n\nfunction Blend1dState_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction Blend1dState_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return Blend1dState_arrayLikeToArray(arr); }\n\nfunction Blend1dState_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Blend1dState_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction Blend1dState_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? Blend1dState_ownKeys(Object(source), !0).forEach(function (key) { Blend1dState_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : Blend1dState_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction Blend1dState_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Blend1dState_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Blend1dState_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Blend1dState_createClass(Constructor, protoProps, staticProps) { if (protoProps) Blend1dState_defineProperties(Constructor.prototype, protoProps); if (staticProps) Blend1dState_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction Blend1dState_get() { if (typeof Reflect !== "undefined" && Reflect.get) { Blend1dState_get = Reflect.get; } else { Blend1dState_get = function _get(target, property, receiver) { var base = Blend1dState_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return Blend1dState_get.apply(this, arguments); }\n\nfunction Blend1dState_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Blend1dState_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Blend1dState_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) Blend1dState_setPrototypeOf(subClass, superClass); }\n\nfunction Blend1dState_setPrototypeOf(o, p) { Blend1dState_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Blend1dState_setPrototypeOf(o, p); }\n\nfunction Blend1dState_createSuper(Derived) { var hasNativeReflectConstruct = Blend1dState_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = Blend1dState_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = Blend1dState_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Blend1dState_possibleConstructorReturn(this, result); }; }\n\nfunction Blend1dState_possibleConstructorReturn(self, call) { if (call && (Blend1dState_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return Blend1dState_assertThisInitialized(self); }\n\nfunction Blend1dState_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Blend1dState_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction Blend1dState_getPrototypeOf(o) { Blend1dState_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Blend1dState_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n/**\r\n * Class for blending N number of blend states based on a single\r\n * parameter.\r\n *\r\n * @extends AbstractBlendState\r\n */\n\nvar Blend1dState = /*#__PURE__*/function (_AbstractBlendState) {\n  Blend1dState_inherits(Blend1dState, _AbstractBlendState);\n\n  var _super = Blend1dState_createSuper(Blend1dState);\n\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {Object} [options] - Options for the container state\r\n   * @param {Array.<AbstractBlendState>} [blendStates=[]] - Blend states to be\r\n   * controlled by this container.\r\n   * @param {Array.<number>} [blendThresholds=[]] - Threshold values for activating\r\n   * each blend state.\r\n   * @param {Array.<boolean>} [phaseMatches=[]] - Booleans indicating whether or not\r\n   * each blend state should be phase matched.\r\n   */\n  function Blend1dState() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var blendStates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var blendThresholds = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    var phaseMatches = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n\n    Blend1dState_classCallCheck(this, Blend1dState);\n\n    _this = _super.call(this, options, blendStates);\n    _this._blendValue = 0;\n    _this._promises = Blend1dState_objectSpread(Blend1dState_objectSpread({}, _this._promises), {}, {\n      blendValue: core_Deferred.resolve()\n    }); // Validate there are no duplicate thresholds\n\n    var nonZeroDifferentSize = blendStates.length !== 0 && blendStates.length !== blendThresholds.length;\n\n    if (nonZeroDifferentSize) {\n      throw new Error("Cannot create Blend1dState with blendThresholds ".concat(blendThresholds, ". BlendThresholds count does not match blendStates count."));\n    }\n\n    var containsDuplicates = new Set(blendThresholds).size !== blendThresholds.length;\n\n    if (containsDuplicates) {\n      throw new Error("Cannot create Blend1dState with blendThresholds ".concat(blendThresholds, ". BlendThresholds contains duplicate values"));\n    } // Initialize the thresholds map\n\n\n    _this._thresholds = [];\n\n    Blend1dState_toConsumableArray(_this._states.values()).forEach(function (state, index) {\n      _this._thresholds.push({\n        value: blendThresholds[index],\n        name: state.name,\n        phaseMatch: phaseMatches[index] || false\n      });\n    });\n\n    _this._sortThresholds();\n\n    _this._forceNoThresholdDupes = true;\n    _this._phaseLeadState = null;\n\n    _this._updateBlendWeights();\n\n    return _this;\n  }\n  /**\r\n   * Gets and sets the blend parameter value.\r\n   */\n\n\n  Blend1dState_createClass(Blend1dState, [{\n    key: "blendValue",\n    get: function get() {\n      return this._blendValue;\n    },\n    set: function set(value) {\n      this._blendValue = value;\n    }\n    /**\r\n     * Gets whether or not the blend value is currently being animated.\r\n     */\n\n  }, {\n    key: "blendValuePending",\n    get: function get() {\n      return this._promises.blendValue && this._promises.blendValue.pending;\n    }\n    /**\r\n     * Updates the user defined weight over time.\r\n     *\r\n     * @param {null} name - Unused parameter.\r\n     * @param {number} weight - The target weight value.\r\n     * @param {number} [seconds=0] - The amount of time it will take to reach the\r\n     * target weight.\r\n     * @param {Function=} easingFn - The easing function to use for interpolation.\r\n     *\r\n     * @returns {Deferred}\r\n     */\n\n  }, {\n    key: "setBlendWeight",\n    value: function setBlendWeight(name, value) {\n      var _this2 = this;\n\n      var seconds = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var easingFn = arguments.length > 3 ? arguments[3] : undefined;\n\n      this._promises.blendValue.cancel();\n\n      this._promises.blendValue = animpack_AnimationUtils.interpolateProperty(this, \'blendValue\', value, {\n        seconds: seconds,\n        easingFn: easingFn,\n        onProgress: function onProgress() {\n          _this2._updateBlendWeights();\n        },\n        onFinish: function onFinish() {\n          _this2._updateBlendWeights();\n        }\n      });\n      return this._promises.blendValue;\n    }\n    /**\r\n     * Gets the user defined weight.\r\n     *\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: "getBlendWeight",\n    value: function getBlendWeight() {\n      return this.blendValue;\n    }\n  }, {\n    key: "addState",\n    value: function addState(state) {\n      var thresholdValue = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var phaseMatch = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      this._thresholds = this._thresholds || []; // Make sure there is not already a state with this threshold\n\n      var sameValue = this._thresholds.find(function (threshold) {\n        return threshold.value === thresholdValue;\n      });\n\n      if (this._forceNoThresholdDupes && sameValue !== undefined) {\n        throw new Error("Cannot set blend threshold of ".concat(thresholdValue, " for state ").concat(state.name, " on ").concat(this.name, ". A state already exists with that threshold."));\n      }\n\n      Blend1dState_get(Blend1dState_getPrototypeOf(Blend1dState.prototype), "addState", this).call(this, state);\n\n      this._thresholds.push({\n        value: thresholdValue,\n        name: state.name,\n        phaseMatch: phaseMatch || false\n      });\n\n      this._sortThresholds();\n\n      return state.name;\n    }\n  }, {\n    key: "removeState",\n    value: function removeState(name) {\n      var removed = Blend1dState_get(Blend1dState_getPrototypeOf(Blend1dState.prototype), "removeState", this).call(this, name);\n\n      if (removed) {\n        var index = this._thresholds.findIndex(function (threshold) {\n          return threshold.name === name;\n        });\n\n        this._thresholds.splice(index, 1);\n      }\n\n      return removed;\n    }\n  }, {\n    key: "renameState",\n    value: function renameState(currentName, newName) {\n      newName = Blend1dState_get(Blend1dState_getPrototypeOf(Blend1dState.prototype), "renameState", this).call(this, currentName, newName);\n\n      var threshold = this._thresholds.find(function (threshold) {\n        return threshold.name === currentName;\n      });\n\n      threshold.name = newName;\n      return newName;\n    }\n    /**\r\n     * Gets the threshold value of a blend with the corresponding name.\r\n     *\r\n     * @param {string} name - Name of the blend to get the threshold of.\r\n     *\r\n     * @returns {number} Threhold value.\r\n     */\n\n  }, {\n    key: "getBlendThreshold",\n    value: function getBlendThreshold(name) {\n      var threshold = this._thresholds.find(function (threshold) {\n        return threshold.name === name;\n      });\n\n      if (threshold === undefined) {\n        throw new Error("Cannot get blend threshold of state ".concat(name, " on ").concat(this.name, ". No state exists with that name."));\n      }\n\n      return threshold.value;\n    }\n    /**\r\n     * Sets the threshold value of a blend with the corresponding name.\r\n     *\r\n     * @param {string} name - Name of the blend to set the threshold.\r\n     * @param {number} value - Value of the threshold to set.\r\n     *\r\n     * @returns {number} Set threshold value.\r\n     */\n\n  }, {\n    key: "setBlendThreshold",\n    value: function setBlendThreshold(name, value) {\n      // Make sure there is not already a state with this threshold\n      var sameValue = this._thresholds.find(function (threshold) {\n        return threshold.value === value;\n      });\n\n      if (sameValue !== undefined) {\n        throw new Error("Cannot set blend threshold of ".concat(value, " for state ").concat(name, " on ").concat(this.name, ". A state already exists with that threshold."));\n      }\n\n      var threshold = this._thresholds.find(function (threshold) {\n        return threshold.name === name;\n      });\n\n      if (threshold === undefined) {\n        throw new Error("Cannot set blend threshold of state ".concat(name, " on ").concat(this.name, ". No state exists with that name."));\n      }\n\n      threshold.value = value;\n\n      this._sortThresholds();\n\n      return threshold.value;\n    }\n  }, {\n    key: "updateInternalWeight",\n    value: function updateInternalWeight(factor) {\n      var _this3 = this;\n\n      Blend1dState_get(Blend1dState_getPrototypeOf(Blend1dState.prototype), "updateInternalWeight", this).call(this, factor);\n\n      if (this._phaseLeadState) {\n        this._states.forEach(function (state) {\n          if (state.weight !== 0) {\n            state.normalizedTime = _this3._phaseLeadState.normalizedTime;\n          }\n        });\n      }\n    }\n    /**\r\n     * Updates the blend weights based on their corresponding threshold values\r\n     * and the current blendValue. Additionally, sets a lead phase state if the\r\n     * conditions for phase-matching have been satisfied.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_updateBlendWeights",\n    value: function _updateBlendWeights() {\n      var _this4 = this;\n\n      if (this._thresholds.length === 0) return;\n\n      if (this._thresholds.length === 1) {\n        var state = this._states.get(this._thresholds[0].name);\n\n        state.setWeight(1);\n        return;\n      } // Initially set all sub-state weights to zero\n\n\n      this._states.forEach(function (state) {\n        state.setWeight(0);\n      });\n\n      this._phaseLeadState = null; // Find the first threshold that is greater than or equal to the parameter value\n\n      var targetIndex = this._thresholds.findIndex(function (threshold) {\n        return threshold.value >= _this4._blendValue;\n      });\n\n      if (targetIndex === 0 || targetIndex === -1) {\n        // Give one state full influence\n        targetIndex = targetIndex === -1 ? this._thresholds.length - 1 : 0;\n\n        var _state = this._states.get(this._thresholds[targetIndex].name);\n\n        _state.setWeight(1);\n      } else {\n        // Linear interpolate influence between two states\n        var thresholdA = this._thresholds[targetIndex - 1];\n        var thresholdB = this._thresholds[targetIndex];\n        var factorB = (this.blendValue - thresholdA.value) / (thresholdB.value - thresholdA.value);\n        var factorA = 1 - factorB;\n\n        var stateA = this._states.get(thresholdA.name);\n\n        var stateB = this._states.get(thresholdB.name);\n\n        stateA.setWeight(factorA);\n        stateB.setWeight(factorB); // Set phase-matching if needed\n\n        if (thresholdA.phaseMatch && thresholdB.phaseMatch) {\n          this._phaseLeadState = factorA > factorB ? stateA : stateB;\n        }\n      }\n    }\n    /**\r\n     * Sorts the thresholds from low to high based on value.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_sortThresholds",\n    value: function _sortThresholds() {\n      this._thresholds.sort(function (a, b) {\n        return a.value - b.value;\n      });\n    }\n  }]);\n\n  return Blend1dState;\n}(state_AbstractBlendState);\n\n/* harmony default export */ const state_Blend1dState = (Blend1dState);\n;// CONCATENATED MODULE: ./src/core/animpack/state/Blend2dState.js\nfunction Blend2dState_typeof(obj) { "@babel/helpers - typeof"; return Blend2dState_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, Blend2dState_typeof(obj); }\n\nfunction Blend2dState_toConsumableArray(arr) { return Blend2dState_arrayWithoutHoles(arr) || Blend2dState_iterableToArray(arr) || Blend2dState_unsupportedIterableToArray(arr) || Blend2dState_nonIterableSpread(); }\n\nfunction Blend2dState_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction Blend2dState_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return Blend2dState_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return Blend2dState_arrayLikeToArray(o, minLen); }\n\nfunction Blend2dState_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction Blend2dState_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return Blend2dState_arrayLikeToArray(arr); }\n\nfunction Blend2dState_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction Blend2dState_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction Blend2dState_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? Blend2dState_ownKeys(Object(source), !0).forEach(function (key) { Blend2dState_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : Blend2dState_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction Blend2dState_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction Blend2dState_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Blend2dState_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Blend2dState_createClass(Constructor, protoProps, staticProps) { if (protoProps) Blend2dState_defineProperties(Constructor.prototype, protoProps); if (staticProps) Blend2dState_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction Blend2dState_get() { if (typeof Reflect !== "undefined" && Reflect.get) { Blend2dState_get = Reflect.get; } else { Blend2dState_get = function _get(target, property, receiver) { var base = Blend2dState_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return Blend2dState_get.apply(this, arguments); }\n\nfunction Blend2dState_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Blend2dState_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Blend2dState_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) Blend2dState_setPrototypeOf(subClass, superClass); }\n\nfunction Blend2dState_setPrototypeOf(o, p) { Blend2dState_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Blend2dState_setPrototypeOf(o, p); }\n\nfunction Blend2dState_createSuper(Derived) { var hasNativeReflectConstruct = Blend2dState_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = Blend2dState_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = Blend2dState_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Blend2dState_possibleConstructorReturn(this, result); }; }\n\nfunction Blend2dState_possibleConstructorReturn(self, call) { if (call && (Blend2dState_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return Blend2dState_assertThisInitialized(self); }\n\nfunction Blend2dState_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Blend2dState_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction Blend2dState_getPrototypeOf(o) { Blend2dState_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Blend2dState_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/* eslint-disable no-underscore-dangle */\n\n\n\n\n/**\r\n * Class for blending N number of blend states based on two\r\n * paramters.\r\n *\r\n * @extends AbstractBlendState\r\n */\n\nvar Blend2dState = /*#__PURE__*/function (_AbstractBlendState) {\n  Blend2dState_inherits(Blend2dState, _AbstractBlendState);\n\n  var _super = Blend2dState_createSuper(Blend2dState);\n\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {Object} [options] - Options for the container state\r\n   * @param {Array.<AbstractBlendState>} [blendStates=[]] - Blend states to be\r\n   * controlled by this container.\r\n   * @param {Array.<Array.<number>>} [blendThresholds=[]] - Threshold values for activating\r\n   * each blend state.\r\n   * @param {Array.<boolean>} [phaseMatches=[]] - Booleans indicating whether or not\r\n   * each blend state should be phase matched.\r\n   */\n  function Blend2dState() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var blendStates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n    var blendThresholds = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    var phaseMatches = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];\n\n    Blend2dState_classCallCheck(this, Blend2dState);\n\n    _this = _super.call(this, options, blendStates);\n\n    if (blendStates.length !== blendThresholds.length) {\n      throw new Error("Cannot create Blend2dState with blendStates ".concat(blendStates, " and blendThresholds ").concat(blendThresholds, ". Count of blendStates must match count of blendThresholds."));\n    }\n\n    blendThresholds.slice(0, blendThresholds.length - 1).forEach(function (threshold, index) {\n      blendThresholds.slice(index + 1).forEach(function (otherThreshold) {\n        if (threshold[0] === otherThreshold[0] && threshold[1] === otherThreshold[1]) {\n          throw new Error("Cannot create Blend2dState with blendThresholds ".concat(blendThresholds, ". No duplicate values allowed in blendThresholds."));\n        }\n      });\n    });\n    _this._blendValueX = 0;\n    _this._blendValueY = 0;\n    _this._promises = Blend2dState_objectSpread(Blend2dState_objectSpread({}, _this._promises), {}, {\n      blendValueX: core_Deferred.resolve(),\n      blendValueY: core_Deferred.resolve()\n    });\n    _this._thresholds = [];\n\n    Blend2dState_toConsumableArray(_this._states.values()).forEach(function (state, index) {\n      _this._thresholds.push({\n        name: state.name,\n        phaseMatch: phaseMatches[index] || false\n      });\n    });\n\n    _this._vertices = blendThresholds;\n\n    if (_this._vertices.length >= 3) {\n      _this._triangles = core_MathUtils.getDelaunayTriangulation(_this._vertices);\n    }\n\n    _this._phaseLeadState = null;\n\n    _this._updateBlendWeights();\n\n    return _this;\n  }\n  /**\r\n   * Updates the user defined weight over time.\r\n   *\r\n   * @param {string} name - Name of blend weight to update.\r\n   * @param {number} weight - Target weight value.\r\n   * @param {number} [seconds=0] - The amount of time it will take to reach the\r\n   * target value.\r\n   * @param {Function=} easingFn - The easing function to use for interpolation.\r\n   *\r\n   * @returns {Deferred}\r\n   */\n\n\n  Blend2dState_createClass(Blend2dState, [{\n    key: "setBlendWeight",\n    value: function setBlendWeight(name, value) {\n      var _this2 = this;\n\n      var seconds = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      var easingFn = arguments.length > 3 ? arguments[3] : undefined;\n      var property = "blendValue".concat(name.toUpperCase());\n\n      if (property !== \'blendValueX\' && property !== \'blendValueY\') {\n        throw new Error("Cannot set blend weight for ".concat(name, " on ").concat(this.name, ". Blend2dState only accepts \'X\' or \'Y\' for setBlendWeight"));\n      }\n\n      this._promises[property].cancel();\n\n      this._promises[property] = animpack_AnimationUtils.interpolateProperty(this, property, value, {\n        seconds: seconds,\n        easingFn: easingFn,\n        onProgress: function onProgress() {\n          _this2._updateBlendWeights();\n        },\n        onFinish: function onFinish() {\n          _this2._updateBlendWeights();\n        }\n      });\n      return this._promises[property];\n    }\n    /**\r\n     * Gets the user defined weight.\r\n     *\r\n     * @param {string} name - Name of blend weight.\r\n     *\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: "getBlendWeight",\n    value: function getBlendWeight(name) {\n      var property = name.toUpperCase();\n\n      if (property !== \'X\' && property !== \'Y\') {\n        throw new Error("Cannot get blend weight for ".concat(name, " on ").concat(this.name, ". Blend2dState only accepts \'X\' or \'Y\' for getBlendWeight"));\n      }\n\n      return property === \'X\' ? this._blendValueX : this._blendValueY;\n    }\n    /**\r\n     * Gets and sets the x blend weight.\r\n     */\n\n  }, {\n    key: "blendValueX",\n    get: function get() {\n      return this._blendValueX;\n    },\n    set: function set(value) {\n      this._blendValueX = value;\n    }\n    /**\r\n     * Gets and sets the y blend weight.\r\n     */\n\n  }, {\n    key: "blendValueY",\n    get: function get() {\n      return this._blendValueY;\n    },\n    set: function set(value) {\n      this._blendValueY = value;\n    }\n    /**\r\n     * Gets whether or not the x blend value is currently being animated.\r\n     */\n\n  }, {\n    key: "blendValueXPending",\n    get: function get() {\n      return this._promises.blendValueX && this._promises.blendValueX.pending;\n    }\n    /**\r\n     * Gets whether or not the y blend value is currently being animated.\r\n     */\n\n  }, {\n    key: "blendValueYPending",\n    get: function get() {\n      return this._promises.blendValueY && this._promises.blendValueY.pending;\n    }\n  }, {\n    key: "updateInternalWeight",\n    value: function updateInternalWeight(factor) {\n      var _this3 = this;\n\n      Blend2dState_get(Blend2dState_getPrototypeOf(Blend2dState.prototype), "updateInternalWeight", this).call(this, factor);\n\n      if (this._phaseLeadState) {\n        Blend2dState_toConsumableArray(this._states.values()).forEach(function (state, index) {\n          if (state.weight !== 0 && _this3._thresholds[index].phaseMatch) {\n            state.normalizedTime = _this3._phaseLeadState.normalizedTime;\n          }\n        });\n      }\n    }\n    /**\r\n     * Updates the blend weights based on their corresponding threshold values\r\n     * and the current [x,y] blendValue. Additionally, sets a lead phase state if the\r\n     * conditions for phase-matching have been satisfied.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_updateBlendWeights",\n    value: function _updateBlendWeights() {\n      var _this4 = this;\n\n      if (!this._vertices || this._vertices.length === 0) return;\n\n      if (this._vertices.length === 1) {\n        Blend2dState_toConsumableArray(this._states.values())[0].weight = 1;\n        return;\n      } // Initially set all sub-state weights to zero\n\n\n      this._states.forEach(function (state) {\n        state.setWeight(0);\n      });\n\n      this._phaseLeadState = null;\n      var p = [this._blendValueX, this._blendValueY];\n\n      if (this._vertices.length === 2) {\n        this._setInfluenceClosestPointOnLine(p);\n      } else {\n        var triangle = this._triangles.find(function (triangle) {\n          return core_MathUtils.isPointInTriangle(_this4._vertices[triangle[0]], _this4._vertices[triangle[1]], _this4._vertices[triangle[2]], p);\n        });\n\n        if (triangle) {\n          this._setInfluenceTriangle(triangle, p);\n        } else {\n          this._setInfluenceClosestPointInTriangles(p);\n        }\n      }\n    }\n    /**\r\n     * Sets blend weights for states corresponding to a\r\n     * triangle of thresholds and a given [x,y] blendValues.\r\n     *\r\n     * @param {Array.<Array.<number>>} triangle - Set of triangluated indices\r\n     * that correspond to blend thresholds.\r\n     * @param {Array.<number>} p - Given [x,y] blendValue.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_setInfluenceTriangle",\n    value: function _setInfluenceTriangle(triangle, p) {\n      var areaA = core_MathUtils.triangleArea(this._vertices[triangle[1]], this._vertices[triangle[2]], p);\n      var areaB = core_MathUtils.triangleArea(this._vertices[triangle[0]], this._vertices[triangle[2]], p);\n      var areaC = core_MathUtils.triangleArea(this._vertices[triangle[0]], this._vertices[triangle[1]], p);\n      var totalArea = areaA + areaB + areaC;\n      var weightA = areaA / totalArea;\n      var weightB = areaB / totalArea;\n      var weightC = areaC / totalArea;\n      var thresholdA = this._thresholds[triangle[0]];\n      var thresholdB = this._thresholds[triangle[1]];\n      var thresholdC = this._thresholds[triangle[2]];\n\n      var stateA = this._states.get(thresholdA.name);\n\n      var stateB = this._states.get(thresholdB.name);\n\n      var stateC = this._states.get(thresholdC.name);\n\n      stateA.setWeight(weightA);\n      stateB.setWeight(weightB);\n      stateC.setWeight(weightC);\n\n      this._setPhaseLeadState([stateA, stateB, stateC], [thresholdA.phaseMatch, thresholdB.phaseMatch, thresholdC.phaseMatch]);\n    }\n    /**\r\n     * Determines the closest point within a triangle of\r\n     * thresholds based on the current [x,y] blendValues and\r\n     * then sets blend weights for the corresponding states.\r\n     *\r\n     * @param {Array.<number>} p - Given [x,y] blendValue.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_setInfluenceClosestPointInTriangles",\n    value: function _setInfluenceClosestPointInTriangles(p) {\n      var _this5 = this;\n\n      var globalClosestPoint = null;\n      var globalMinDist = Number.POSITIVE_INFINITY;\n      var closestTriangle = -1;\n\n      this._triangles.forEach(function (triangle, index) {\n        var pointA = core_MathUtils.closestPointOnLine(_this5._vertices[triangle[0]], _this5._vertices[triangle[1]], p);\n        var pointB = core_MathUtils.closestPointOnLine(_this5._vertices[triangle[1]], _this5._vertices[triangle[2]], p);\n        var pointC = core_MathUtils.closestPointOnLine(_this5._vertices[triangle[2]], _this5._vertices[triangle[0]], p);\n        var distA = core_MathUtils.distanceSquared(pointA, p);\n        var distB = core_MathUtils.distanceSquared(pointB, p);\n        var distC = core_MathUtils.distanceSquared(pointC, p);\n        var localClosestPoint = pointC;\n        var localMinDist = distC;\n\n        if (distA < localMinDist) {\n          localClosestPoint = pointA;\n          localMinDist = distA;\n        }\n\n        if (distB < localMinDist) {\n          localClosestPoint = pointB;\n          localMinDist = distB;\n        }\n\n        if (localMinDist < globalMinDist) {\n          globalMinDist = localMinDist;\n          globalClosestPoint = Blend2dState_toConsumableArray(localClosestPoint);\n          closestTriangle = index;\n        }\n      });\n\n      this._setInfluenceTriangle(this._triangles[closestTriangle], globalClosestPoint);\n    }\n    /**\r\n     * Determines the closest point on the line formed between the\r\n     * two blend thresholds based on the current [x,y] blendValues and\r\n     * then sets blend weights for the corresponding states.\r\n     *\r\n     * @param {Array.<number>} p - Given [x,y] blendValue.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_setInfluenceClosestPointOnLine",\n    value: function _setInfluenceClosestPointOnLine(p) {\n      var closestPoint = core_MathUtils.closestPointOnLine(this._vertices[[0]], this._vertices[[1]], p);\n      var distA = core_MathUtils.distanceSquared(this._vertices[0], closestPoint);\n      var distB = core_MathUtils.distanceSquared(this._vertices[1], closestPoint);\n      var weightA = distB / (distA + distB);\n      var weightB = distA / (distA + distB);\n      var thresholdA = this._thresholds[0];\n      var thresholdB = this._thresholds[1];\n\n      var stateA = this._states.get(thresholdA.name);\n\n      var stateB = this._states.get(thresholdB.name);\n\n      stateA.setWeight(weightA);\n      stateB.setWeight(weightB);\n\n      this._setPhaseLeadState([stateA, stateB], [thresholdA.phaseMatch, thresholdB.phaseMatch]);\n    }\n    /**\r\n     * Sets a lead phase state if the conditions\r\n     * for phase-matching are satisfied.\r\n     *\r\n     * @param {Array.<AbstractBlendState>} states - States to\r\n     * check phase-matching criteria.\r\n     * @param {Array.<boolean>} phaseMatched - List of phase-match booleans.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_setPhaseLeadState",\n    value: function _setPhaseLeadState(states, phaseMatched) {\n      var _this6 = this;\n\n      var max = 0;\n      states.forEach(function (state, index) {\n        if (phaseMatched[index] && state.weight > max) {\n          _this6._phaseLeadState = state;\n          max = state.weight;\n        }\n      });\n    }\n  }]);\n\n  return Blend2dState;\n}(state_AbstractBlendState);\n\n/* harmony default export */ const state_Blend2dState = (Blend2dState);\n;// CONCATENATED MODULE: ./src/core/animpack/AnimationLayer.js\nfunction AnimationLayer_typeof(obj) { "@babel/helpers - typeof"; return AnimationLayer_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, AnimationLayer_typeof(obj); }\n\nfunction AnimationLayer_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction AnimationLayer_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction AnimationLayer_createClass(Constructor, protoProps, staticProps) { if (protoProps) AnimationLayer_defineProperties(Constructor.prototype, protoProps); if (staticProps) AnimationLayer_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction AnimationLayer_get() { if (typeof Reflect !== "undefined" && Reflect.get) { AnimationLayer_get = Reflect.get; } else { AnimationLayer_get = function _get(target, property, receiver) { var base = AnimationLayer_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return AnimationLayer_get.apply(this, arguments); }\n\nfunction AnimationLayer_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = AnimationLayer_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction AnimationLayer_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) AnimationLayer_setPrototypeOf(subClass, superClass); }\n\nfunction AnimationLayer_setPrototypeOf(o, p) { AnimationLayer_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return AnimationLayer_setPrototypeOf(o, p); }\n\nfunction AnimationLayer_createSuper(Derived) { var hasNativeReflectConstruct = AnimationLayer_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = AnimationLayer_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = AnimationLayer_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return AnimationLayer_possibleConstructorReturn(this, result); }; }\n\nfunction AnimationLayer_possibleConstructorReturn(self, call) { if (call && (AnimationLayer_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return AnimationLayer_assertThisInitialized(self); }\n\nfunction AnimationLayer_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction AnimationLayer_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction AnimationLayer_getPrototypeOf(o) { AnimationLayer_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return AnimationLayer_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n\n\n\n/**\r\n * Enum for types of {@link AnimationLayer} blending.\r\n *\r\n * @readonly\r\n * @enum {string}\r\n */\n\nvar LayerBlendModes = {\n  Override: \'Override\',\n  Additive: \'Additive\'\n};\n/**\r\n * The default blending mode {@link AnimationLayer}.\r\n *\r\n * @readonly\r\n * @type {string}\r\n */\n\nvar DefaultLayerBlendMode = \'Override\';\n/**\r\n * Checks if a given blendMode is present in the values of {@link LayerBlendModes}.\r\n * If it is, return the original value, otherwise return {@link DefaultLayerBlendMode}.\r\n *\r\n * @param {string} blendMode - The name of the type of blending.\r\n *\r\n * @returns {(string|DefaultLayerBlendMode)}\r\n */\n\nfunction validateBlendMode(blendMode) {\n  if (Array.from(Object.values(LayerBlendModes)).includes(blendMode)) {\n    return blendMode;\n  } else {\n    return DefaultLayerBlendMode;\n  }\n}\n/**\r\n * Class for managing a set of animations where only one state can be active at\r\n * any given time.\r\n *\r\n * @implements AnimationPlayerInterface\r\n * @implements StateContainerInterface\r\n */\n\nvar AnimationLayer = /*#__PURE__*/function (_AnimationPlayerInter) {\n  AnimationLayer_inherits(AnimationLayer, _AnimationPlayerInter);\n\n  var _super = AnimationLayer_createSuper(AnimationLayer);\n\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {Object=} options -  Options for the animation layer.\r\n   * @param {string} options.name - Name of the layer. Names must be unique to the\r\n   * animation feature that contains the layer.\r\n   * @param {LayerBlendModes} [options.blendMode=DefaultLayerBlendMode] -\r\n   * Type of blending to use for all states controlled by the layer.\r\n   * @param {number} [options.weight=1] - The amount of influence the layer\'s current\r\n   * animation has over the result for the host.\r\n   * @param {number} [options.transitionTime=0] - The default amount of time to use when\r\n   * playing and resuming animations.\r\n   * @param {Function=} options.easingFn - The default easing function to use when\r\n   * transitioning between animations and setting layer weight.\r\n   */\n  function AnimationLayer() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    AnimationLayer_classCallCheck(this, AnimationLayer);\n\n    _this = _super.call(this, options);\n    _this.name = options.name === undefined ? \'AnimationLayer\' : options.name;\n    _this._blendMode = Array.from(Object.values(LayerBlendModes)).includes(options.blendMode) ? options.blendMode : DefaultLayerBlendMode;\n    _this._promises = {\n      weight: core_Deferred.resolve()\n    };\n    _this._weightPaused = false;\n    _this.weight = typeof options.weight === \'number\' ? options.weight : 1;\n    _this._internalWeight = _this._weight;\n    return _this;\n  }\n  /**\r\n   * Gets the type of blending used for states controlled by the layer.\r\n   *\r\n   * @readonly\r\n   * @type {string}\r\n   */\n\n\n  AnimationLayer_createClass(AnimationLayer, [{\n    key: "blendMode",\n    get: function get() {\n      return this._blendMode;\n    }\n    /**\r\n     * Gets and sets the amount of influence the layer\'s current animation has over\r\n     * the result for the host.\r\n     *\r\n     * @type {number}\r\n     */\n\n  }, {\n    key: "weight",\n    get: function get() {\n      return this._weight;\n    }\n    /**\r\n     * Gets whether or not the layer\'s weight value is currently being animated.\r\n     *\r\n     * @readonly\r\n     * @type {boolean}\r\n     */\n    ,\n    set: function set(weight) {\n      this._weight = core_MathUtils.clamp(weight, 0, 1);\n    }\n  }, {\n    key: "weightPending",\n    get: function get() {\n      return this._promises.weight && this._promises.weight.pending;\n    }\n    /**\r\n     * Pause the current animation state and any interpolation happening on the layer\'s\r\n     * weight property.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "pause",\n    value: function pause() {\n      this._paused = true;\n      this._weightPaused = true;\n      return this.pauseAnimation() || this.weightPending;\n    }\n    /**\r\n     * Resume the current animation state and any interpolation happening on the layer\'s\r\n     * weight property.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "resume",\n    value: function resume() {\n      this._paused = false;\n      this._weightPaused = false;\n      var isWeightActive = this.weightPending;\n\n      if (this._currentState) {\n        return this.resumeAnimation() || isWeightActive;\n      } else {\n        return isWeightActive;\n      }\n    }\n    /**\r\n     * Updates the user defined weight over time.\r\n     *\r\n     * @param {number} weight - The target weight value.\r\n     * @param {number} [seconds=0] - The amount of time it will take to reach the\r\n     * target weight.\r\n     * @param {Function=} easingFn - The easing function to use for interpolation.\r\n     *\r\n     * @returns {Deferred}\r\n     */\n\n  }, {\n    key: "setWeight",\n    value: function setWeight(weight) {\n      var seconds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var easingFn = arguments.length > 2 ? arguments[2] : undefined;\n\n      if (this.weightPending) {\n        this._promises.weight.cancel();\n      }\n\n      weight = core_MathUtils.clamp(weight);\n      this._promises.weight = animpack_AnimationUtils.interpolateProperty(this, \'weight\', weight, {\n        seconds: seconds,\n        easingFn: easingFn !== undefined ? easingFn : this._easingFn\n      });\n      return this._promises.weight;\n    }\n    /**\r\n     * Pause any interpolation happening on the layer\'s weight property.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "pauseWeight",\n    value: function pauseWeight() {\n      this._weightPaused = true;\n      return this.weightPending;\n    }\n    /**\r\n     * Resume any interpolation happening on the layer\'s weight property.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "resumeWeight",\n    value: function resumeWeight() {\n      this._weightPaused = false;\n      return this.weightPending;\n    }\n    /**\r\n     * Multiplies the user weight by a factor to determine the internal weight.\r\n     *\r\n     * @param {number} factor - 0-1 multiplier to apply to the user weight.\r\n     */\n\n  }, {\n    key: "updateInternalWeight",\n    value: function updateInternalWeight(factor) {\n      this._internalWeight = this._weight * factor;\n\n      if (this._currentState) {\n        this._currentState.updateInternalWeight(this._internalWeight);\n      }\n    }\n    /**\r\n     * Returns the names of blend states in an animation.\r\n     *\r\n     * @param {string} animationName - Name of the animation.\r\n     *\r\n     * @returns {Array.<string>} - Names of blend states.\r\n     */\n\n  }, {\n    key: "getAnimationBlendNames",\n    value: function getAnimationBlendNames(animationName) {\n      var state = this.getState(animationName);\n\n      if (state === undefined) {\n        throw new Error("Cannot get blend names of animation ".concat(animationName, " on layer ").concat(this.name, ". No animation exists with this name."));\n      }\n\n      if (state instanceof state_AbstractBlendState) {\n        return state.getStateNames();\n      }\n\n      throw new Error("Cannot get blend names of animation ".concat(animationName, " on layer ").concat(this.name, ". Animation is not an instance of AbstractBlendState."));\n    }\n    /**\r\n     * Update the weight for a blend state of an animation.\r\n     *\r\n     * @param {string} animationName - Name of the animation containing the blend state\r\n     * to update.\r\n     * @param {string} blendName - Name of the blend state to update.\r\n     * @param {number} weight - Weight value to set on the animation. This number shoudld be\r\n     * in the 0-1 range.\r\n     * @param {number=} seconds - Number of seconds it should take to reach the new weight.\r\n     * Default is zero and will set immediately.\r\n     * @param {Function=} easingFn - Easing function to use while interpolating the new\r\n     * weight. Default is Easing.Linear.InOut.\r\n     *\r\n     * @returns {Deferred} - Promise that will resolve once the animation\'s weight reaches\r\n     * the target value.\r\n     */\n\n  }, {\n    key: "setAnimationBlendWeight",\n    value: function setAnimationBlendWeight(animationName, blendName, weight) {\n      var seconds = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 0;\n      var easingFn = arguments.length > 4 ? arguments[4] : undefined;\n      var state = this.getState(animationName);\n\n      if (state === undefined) {\n        throw new Error("Cannot set blend weight of animation ".concat(animationName, " on layer ").concat(this.name, ". No animation exists with this name."));\n      }\n\n      if (state instanceof state_AbstractBlendState) {\n        return state.setBlendWeight(blendName, weight, seconds, easingFn);\n      }\n\n      throw new Error("Cannot set blend weight of animation ".concat(animationName, " on layer ").concat(this.name, ". Animation is not an instance of AbstractBlendState."));\n    }\n    /**\r\n     * Returns the weight for a blend state of an animation.\r\n     *\r\n     * @param {string} animationName - Name of the animation containing the blend state\r\n     * to update.\r\n     * @param {string} blendName - Name of the blend state to retrieve the weight of.\r\n     *\r\n     * @returns {number} - Weight of the blend state.\r\n     */\n\n  }, {\n    key: "getAnimationBlendWeight",\n    value: function getAnimationBlendWeight(animationName, blendName) {\n      var state = this.getState(animationName);\n\n      if (state === undefined) {\n        throw new Error("Cannot get blend weight of animation ".concat(animationName, " on layer ").concat(this.name, ". No animation exists with this name."));\n      }\n\n      if (state instanceof state_AbstractBlendState) {\n        return state.getBlendWeight(blendName);\n      }\n\n      throw new Error("Cannot get blend weight of animation ".concat(animationName, " on layer ").concat(this.name, ". Animation is not an instance of AbstractBlendState."));\n    }\n    /**\r\n     * Update any weight interpolators and the current animation.\r\n     *\r\n     * @param {number} deltaTime - Time in milliseconds since the last update.\r\n     */\n\n  }, {\n    key: "update",\n    value: function update(deltaTime) {\n      AnimationLayer_get(AnimationLayer_getPrototypeOf(AnimationLayer.prototype), "update", this).call(this, deltaTime);\n\n      if (!this._paused && !this._weightPaused) {\n        this._promises.weight.execute(deltaTime);\n      }\n    }\n    /**\r\n     * Cancel any pending promises and discard states controlled by the layer.\r\n     */\n\n  }, {\n    key: "discard",\n    value: function discard() {\n      AnimationLayer_get(AnimationLayer_getPrototypeOf(AnimationLayer.prototype), "discard", this).call(this);\n\n      this.discardStates();\n\n      this._promises.weight.cancel();\n\n      delete this._promises;\n    }\n  }]);\n\n  return AnimationLayer;\n}(animpack_AnimationPlayerInterface.Mixin(state_StateContainerInterface.Mixin()));\n\n/* harmony default export */ const animpack_AnimationLayer = (AnimationLayer);\n;// CONCATENATED MODULE: ./src/core/animpack/state/SingleState.js\nfunction SingleState_typeof(obj) { "@babel/helpers - typeof"; return SingleState_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, SingleState_typeof(obj); }\n\nfunction SingleState_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction SingleState_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction SingleState_createClass(Constructor, protoProps, staticProps) { if (protoProps) SingleState_defineProperties(Constructor.prototype, protoProps); if (staticProps) SingleState_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction SingleState_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) SingleState_setPrototypeOf(subClass, superClass); }\n\nfunction SingleState_setPrototypeOf(o, p) { SingleState_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return SingleState_setPrototypeOf(o, p); }\n\nfunction SingleState_createSuper(Derived) { var hasNativeReflectConstruct = SingleState_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = SingleState_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = SingleState_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return SingleState_possibleConstructorReturn(this, result); }; }\n\nfunction SingleState_possibleConstructorReturn(self, call) { if (call && (SingleState_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return SingleState_assertThisInitialized(self); }\n\nfunction SingleState_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction SingleState_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction SingleState_getPrototypeOf(o) { SingleState_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return SingleState_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n\n/**\r\n * Class for playing a single animation clip.\r\n *\r\n * @extends AbstractState\r\n * @alias core/SingleState\r\n */\n\nvar SingleState = /*#__PURE__*/function (_AbstractState) {\n  SingleState_inherits(SingleState, _AbstractState);\n\n  var _super = SingleState_createSuper(SingleState);\n\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {Object=} options - Options for the animation state.\r\n   * @param {string=} options.name - Name for the animation state. Names must be\r\n   * unique for the layer the state is applied to.\r\n   * @param {weight} [options.weight=0] - The 0-1 amount of influence the state will have.\r\n   * @param {timeScale} [options.timeScale=1] - Factor to scale the playback speed of the\r\n   * animation.\r\n   * @param {number} [options.loopCount=Infinity] - Number of times the animation should\r\n   * repeat before finishing.\r\n   * @param {string} [options.blendMode=DefaultLayerBlendMode] - Type of\r\n   * blending the animation should use.\r\n   */\n  function SingleState() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n\n    SingleState_classCallCheck(this, SingleState);\n\n    _this = _super.call(this, options);\n    _this._timeScale = options.timeScale !== undefined ? options.timeScale : 1;\n    _this._promises.timeScale = core_Deferred.resolve();\n    _this._loopCount = options.loopCount !== undefined ? options.loopCount : Infinity;\n    _this._blendMode = validateBlendMode(options.blendMode);\n    return _this;\n  }\n  /**\r\n   * Gets and sets the normalized playing time of the current animation\r\n   *\r\n   * @type {number}\r\n   */\n\n\n  SingleState_createClass(SingleState, [{\n    key: "normalizedTime",\n    get: function get() {\n      return 0;\n    },\n    set: function set(time) {}\n    /**\r\n     * Gets and sets the a factor to scale animation playback speed with.\r\n     *\r\n     * @type {number}\r\n     */\n\n  }, {\n    key: "timeScale",\n    get: function get() {\n      return this._timeScale;\n    },\n    set: function set(timeScale) {\n      this._timeScale = timeScale;\n    }\n    /**\r\n     * Gets whether or not the timeScale is currently being animated.\r\n     *\r\n     * @readonly\r\n     * @type {boolean}\r\n     */\n\n  }, {\n    key: "timeScalePending",\n    get: function get() {\n      return this._promises.timeScale.pending;\n    }\n    /**\r\n     * Updates the timeScale value over time.\r\n     *\r\n     * @param {number} weight - The target timeScale value.\r\n     * @param {number} [seconds=0] - The amount of time it will take to reach the\r\n     * target timeScale.\r\n     * @param {Function=} easingFn - The easing function to use for interpolation.\r\n     *\r\n     * @returns {Deferred}\r\n     */\n\n  }, {\n    key: "setTimeScale",\n    value: function setTimeScale(timeScale) {\n      var seconds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var easingFn = arguments.length > 2 ? arguments[2] : undefined;\n\n      this._promises.timeScale.cancel();\n\n      this._promises.timeScale = animpack_AnimationUtils.interpolateProperty(this, \'timeScale\', timeScale, {\n        seconds: seconds,\n        easingFn: easingFn\n      });\n      return this._promises.timeScale;\n    }\n    /**\r\n     * Gets and sets the number of times the animation will repeat before finishing.\r\n     *\r\n     * @type {number}\r\n     */\n\n  }, {\n    key: "loopCount",\n    get: function get() {\n      return this._loopCount;\n    },\n    set: function set(loopCount) {\n      this._loopCount = loopCount;\n    }\n    /**\r\n     * Gets the type of blending used for the animation.\r\n     *\r\n     * @readonly\r\n     * @type {string}\r\n     */\n\n  }, {\n    key: "blendMode",\n    get: function get() {\n      return this._blendMode;\n    }\n  }]);\n\n  return SingleState;\n}(state_AbstractState);\n\n/* harmony default export */ const state_SingleState = (SingleState);\n;// CONCATENATED MODULE: ./src/core/animpack/state/RandomAnimationState.js\nfunction RandomAnimationState_typeof(obj) { "@babel/helpers - typeof"; return RandomAnimationState_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, RandomAnimationState_typeof(obj); }\n\nfunction RandomAnimationState_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction RandomAnimationState_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction RandomAnimationState_createClass(Constructor, protoProps, staticProps) { if (protoProps) RandomAnimationState_defineProperties(Constructor.prototype, protoProps); if (staticProps) RandomAnimationState_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction RandomAnimationState_get() { if (typeof Reflect !== "undefined" && Reflect.get) { RandomAnimationState_get = Reflect.get; } else { RandomAnimationState_get = function _get(target, property, receiver) { var base = RandomAnimationState_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return RandomAnimationState_get.apply(this, arguments); }\n\nfunction RandomAnimationState_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = RandomAnimationState_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction RandomAnimationState_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) RandomAnimationState_setPrototypeOf(subClass, superClass); }\n\nfunction RandomAnimationState_setPrototypeOf(o, p) { RandomAnimationState_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return RandomAnimationState_setPrototypeOf(o, p); }\n\nfunction RandomAnimationState_createSuper(Derived) { var hasNativeReflectConstruct = RandomAnimationState_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = RandomAnimationState_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = RandomAnimationState_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return RandomAnimationState_possibleConstructorReturn(this, result); }; }\n\nfunction RandomAnimationState_possibleConstructorReturn(self, call) { if (call && (RandomAnimationState_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return RandomAnimationState_assertThisInitialized(self); }\n\nfunction RandomAnimationState_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction RandomAnimationState_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction RandomAnimationState_getPrototypeOf(o) { RandomAnimationState_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return RandomAnimationState_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n\n/**\r\n * Class for playing random animations at random intervals within this state.\r\n *\r\n * @extends AbstractState\r\n * @implements AnimationPlayerInterface\r\n * @implements StateContainerInterface\r\n */\n\nvar RandomAnimationState = /*#__PURE__*/function (_AnimationPlayerInter) {\n  RandomAnimationState_inherits(RandomAnimationState, _AnimationPlayerInter);\n\n  var _super = RandomAnimationState_createSuper(RandomAnimationState);\n\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {Object} [options={}] - Options for the container state.\r\n   * @param {number} [options.playInterval=3] - The base animation playback interval.\r\n   * @param {Array.<AbstractState>} [subStates=[]] - states to be randomly picked to play\r\n   */\n  function RandomAnimationState() {\n    var _this;\n\n    var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    var subStates = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n    RandomAnimationState_classCallCheck(this, RandomAnimationState);\n\n    _this = _super.call(this, options);\n    _this._playInterval = options.playInterval ? options.playInterval : 3;\n    subStates.forEach(function (state) {\n      _this.addState(state);\n    });\n    return _this;\n  }\n  /**\r\n   * Gets and sets the base animation play interval\r\n   *\r\n   * @type {float}\r\n   */\n\n\n  RandomAnimationState_createClass(RandomAnimationState, [{\n    key: "playInterval",\n    get: function get() {\n      return this._playInterval;\n    },\n    set: function set(playInterval) {\n      this._playInterval = playInterval;\n    }\n    /**\r\n     * Reset the internal timer for animation play interval\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_resetTimer",\n    value: function _resetTimer() {\n      var _this2 = this;\n\n      var playTimer = core_Utils.getRandomFloat(this._playInterval / 4, this._playInterval * 2);\n\n      var onFinish = function onFinish() {\n        _this2.playRandomAnimation(_this2._playCallbacks.onError);\n      };\n\n      this._promises.timer = core_Utils.wait(playTimer, {\n        onFinish: onFinish\n      });\n    }\n  }, {\n    key: "updateInternalWeight",\n    value: function updateInternalWeight(factor) {\n      RandomAnimationState_get(RandomAnimationState_getPrototypeOf(RandomAnimationState.prototype), "updateInternalWeight", this).call(this, factor);\n\n      if (this._currentState) {\n        this._currentState.updateInternalWeight(this._internalWeight);\n      }\n    }\n    /**\r\n     * Pick a random animation and utilize AnimationPlayerInterface to play that animation\r\n     *\r\n     * @param {Function=} onError - Function to execute if the state encounters\r\n     * an error during playback.\r\n     */\n\n  }, {\n    key: "playRandomAnimation",\n    value: function playRandomAnimation(onError) {\n      this._resetTimer();\n\n      var states = this.getStateNames();\n\n      if (this._currentState) {\n        states.splice(states.indexOf(this._currentState.name), 1);\n      }\n\n      var randomState = states[core_Utils.getRandomInt(0, states.length)];\n      this.playAnimation(randomState, this._transitionTime, this._easingFn, undefined, onError, undefined);\n    }\n  }, {\n    key: "play",\n    value: function play(onFinish, onError, onCancel) {\n      this.playRandomAnimation(onError);\n      return RandomAnimationState_get(RandomAnimationState_getPrototypeOf(RandomAnimationState.prototype), "play", this).call(this, onFinish, onError, onCancel);\n    }\n  }, {\n    key: "pause",\n    value: function pause() {\n      return RandomAnimationState_get(RandomAnimationState_getPrototypeOf(RandomAnimationState.prototype), "pause", this).call(this) && this.pauseAnimation();\n    }\n  }, {\n    key: "resume",\n    value: function resume(onFinish, onError, onCancel) {\n      if (this._currentState) {\n        this.resumeAnimation(this._currentState.name, this._transitionTime, this._easingFn, undefined, onError, undefined);\n      }\n\n      return RandomAnimationState_get(RandomAnimationState_getPrototypeOf(RandomAnimationState.prototype), "resume", this).call(this, onFinish, onError, onCancel);\n    }\n  }, {\n    key: "cancel",\n    value: function cancel() {\n      return RandomAnimationState_get(RandomAnimationState_getPrototypeOf(RandomAnimationState.prototype), "cancel", this).call(this) && this.cancelAnimation();\n    }\n  }, {\n    key: "stop",\n    value: function stop() {\n      return RandomAnimationState_get(RandomAnimationState_getPrototypeOf(RandomAnimationState.prototype), "stop", this).call(this) && this.stopAnimation();\n    }\n  }, {\n    key: "discard",\n    value: function discard() {\n      RandomAnimationState_get(RandomAnimationState_getPrototypeOf(RandomAnimationState.prototype), "discard", this).call(this);\n\n      this.discardStates();\n    }\n  }]);\n\n  return RandomAnimationState;\n}(animpack_AnimationPlayerInterface.Mixin(state_StateContainerInterface.Mixin(state_AbstractState)));\n\n/* harmony default export */ const state_RandomAnimationState = (RandomAnimationState);\n;// CONCATENATED MODULE: ./src/core/animpack/AnimationFeature.js\nfunction AnimationFeature_typeof(obj) { "@babel/helpers - typeof"; return AnimationFeature_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, AnimationFeature_typeof(obj); }\n\nfunction AnimationFeature_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction AnimationFeature_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? AnimationFeature_ownKeys(Object(source), !0).forEach(function (key) { AnimationFeature_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : AnimationFeature_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction AnimationFeature_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction AnimationFeature_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction AnimationFeature_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction AnimationFeature_createClass(Constructor, protoProps, staticProps) { if (protoProps) AnimationFeature_defineProperties(Constructor.prototype, protoProps); if (staticProps) AnimationFeature_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction AnimationFeature_get() { if (typeof Reflect !== "undefined" && Reflect.get) { AnimationFeature_get = Reflect.get; } else { AnimationFeature_get = function _get(target, property, receiver) { var base = AnimationFeature_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return AnimationFeature_get.apply(this, arguments); }\n\nfunction AnimationFeature_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = AnimationFeature_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction AnimationFeature_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) AnimationFeature_setPrototypeOf(subClass, superClass); }\n\nfunction AnimationFeature_setPrototypeOf(o, p) { AnimationFeature_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return AnimationFeature_setPrototypeOf(o, p); }\n\nfunction AnimationFeature_createSuper(Derived) { var hasNativeReflectConstruct = AnimationFeature_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = AnimationFeature_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = AnimationFeature_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return AnimationFeature_possibleConstructorReturn(this, result); }; }\n\nfunction AnimationFeature_possibleConstructorReturn(self, call) { if (call && (AnimationFeature_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return AnimationFeature_assertThisInitialized(self); }\n\nfunction AnimationFeature_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction AnimationFeature_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction AnimationFeature_getPrototypeOf(o) { AnimationFeature_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return AnimationFeature_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n\n\n\n\n\n\n\n/**\r\n * Enum for animation state classes.\r\n *\r\n * @readonly\r\n * @enum {Class}\r\n */\n\nvar AnimationTypes = {\n  single: state_SingleState,\n  freeBlend: state_FreeBlendState,\n  queue: state_QueueState,\n  randomAnimation: state_RandomAnimationState,\n  blend1d: state_Blend1dState,\n  blend2d: state_Blend2dState\n};\n/**\r\n * Feature for managing animations on an object.\r\n *\r\n * @extends AbstractHostFeature\r\n * @alias core/AnimationFeature\r\n *\r\n * @property {Object} EVENTS - Built-in messages that the feature emits. When the\r\n * feature is added to a {@link core/HostObject}, event names will be prefixed by the\r\n * name of the feature class + \'.\'.\r\n * @property {string} [EVENTS.addLayer=onAddLayerEvent] - Message that is emitted after\r\n * [addLayer]{@link core/AnimationFeature#addLayer} has been successfully executed.\r\n * An object representing the name of the layer that was added and its index in\r\n * the layer stack with the signature {name: string, index: number} is supplied\r\n * as an argument to listener functions.\r\n * @property {string} [EVENTS.removeLayer=onRemoveLayerEvent] - Message that is\r\n * emitted after [removeLayer]{@link core/AnimationFeature#removeLayer} has been\r\n * successfully executed. An object representing the name of the layer that was\r\n * removed and its index in the layer stack with the signature {name: string, index: number}\r\n * is supplied as an argument to listener functions.\r\n * @property {string} [EVENTS.renameLayer=onRenameLayerEvent] - Message that is\r\n * emitted after [renameLayer]{@link core/AnimationFeature#renameLayer} has been\r\n * successfully executed. An object representing the original name of the layer\r\n * that was renamed and its updated name with the signature {oldName: string, newName: string}\r\n * is supplied as an argument to listener functions.\r\n * @property {string} [EVENTS.addAnimation=onAddAnimationEvent] - Message that is\r\n * emitted after [addAnimation]{@link core/AnimationFeature#addAnimation} has been\r\n * successfully executed. An object representing the name of the layer that the\r\n * animation was added to and the name of the animation that was added with the\r\n * signature {layerName: string, animationName: string} is supplied as an argument\r\n * to listener functions.\r\n * @property {string} [EVENTS.removeAnimation=onRemovedAnimationEvent] - Message\r\n * that is emitted after [removeAnimation]{@link core/AnimationFeature#removeAnimation}\r\n * has been successfully executed. An object representing the name of the layer\r\n * that the animation was removed from and the name of the animation that was removed\r\n * with the signature {layerName: string, animationName: string} is supplied as\r\n * an argument to listener functions.\r\n * @property {string} [EVENTS.renameAnimation=onRenameAnimationEvent] - Message\r\n * that is emitted after [renameAnimation]{@link core/AnimationFeature#renameAnimation}\r\n * has been successfully executed. An object representing the name of the layer\r\n * that contains the animation that was renamed, the original name of the animation\r\n * that was renamed and its updated name with the signature {layerName: string, oldName: string, newName: string}\r\n * is supplied as an argument to listener functions.\r\n * @property {string} [EVENTS.play=onPlayEvent] - Message that is emitted after\r\n * each call to [play]{@link core/AnimationFeature#playAnimation}. An object representing\r\n * the name of the layer contains the animation that was played and the name of\r\n * the animation that was played with the signature {layerName: string, animationName: string}\r\n * is supplied as an argument to listener functions.\r\n * @property {string} [EVENTS.pause=onPauseEvent] - Message that is emitted after\r\n * each call to [pause]{@link core/AnimationFeature#pauseAnimation}. An object representing\r\n * the name of the layer contains the animation that was paused and the name of\r\n * the animation that was paused with the signature {layerName: string, animationName: string}\r\n * is supplied as an argument to listener functions.\r\n * @property {string} [EVENTS.resume=onResumeEvent] - Message that is emitted after\r\n * each call to [resume]{@link core/AnimationFeature#resumeAnimation}. An object representing\r\n * the name of the layer contains the animation that was resumed and the name of\r\n * the animation that was resumed with the signature {layerName: string, animationName: string}\r\n * is supplied as an argument to listener functions.\r\n * @property {string} [EVENTS.interrupt=onInterruptEvent] - Message that is emitted\r\n * if there is a current speech in progress and [play]{@link core/AnimationFeature#playAnimation}\r\n * or [resume]{@link core/AnimationFeature#resumeAnimation} are executed for a new speech.\r\n * An object representing the name of the layer contains the animation that was\r\n * interrupted and the name of the animation that was interrupted with the signature\r\n * {layerName: string, animationName: string} is supplied as an argument to listener\r\n * functions.\r\n * @property {string} [EVENTS.stop=onStopEvent] - Message that is emitted after\r\n * each call to [stop]{@link core/AnimationFeature#stopAnimation} and when a speech reaches\r\n * the end of playback. An object representing\r\n * the name of the layer contains the animation that was stopped and the name of\r\n * the animation that was stopped with the signature {layerName: string, animationName: string}\r\n * is supplied as an argument to listener functions.\r\n */\n\nvar AnimationFeature = /*#__PURE__*/function (_AbstractHostFeature) {\n  AnimationFeature_inherits(AnimationFeature, _AbstractHostFeature);\n\n  var _super = AnimationFeature_createSuper(AnimationFeature);\n\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {core/HostObject} host - Host object that owns the feature.\r\n   */\n  function AnimationFeature(host) {\n    var _this;\n\n    AnimationFeature_classCallCheck(this, AnimationFeature);\n\n    _this = _super.call(this, host);\n    _this._layers = [];\n    _this._layerMap = {};\n    _this._paused = false;\n    return _this;\n  }\n  /**\r\n   * Make sure a supplied layer index is within the range of layers.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {number} index\r\n   * @param {boolean} [existing=true] - Whether the index represents and existing\r\n   * layer or a new layer to be added.\r\n   *\r\n   * @returns {number=}\r\n   */\n\n\n  AnimationFeature_createClass(AnimationFeature, [{\n    key: "_validateIndex",\n    value: function _validateIndex(index) {\n      var existing = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n      // Index is invalid if there are no layers and we\'re checking for an existing layer index\n      if (this._layers.length === 0 && existing) {\n        return undefined;\n      }\n\n      var lastIndex = existing ? this._layers.length - 1 : this._layers.length; // Count from the end of the array for negative indices\n\n      if (index < 0) {\n        index = lastIndex + index + 1;\n      }\n\n      if (index < 0 || index > lastIndex) {\n        return undefined;\n      } else {\n        return index;\n      }\n    }\n    /**\r\n     * Re-evaluate internal weight values of layers starting from the top of the\r\n     * stack. Override layers\' weights affect the values of all layers lower in the\r\n     * stack.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_updateInternalWeights",\n    value: function _updateInternalWeights() {\n      var numLayers = this._layers.length;\n      var weightMultiplier = 1; // Update internal weight values on layers in reverse order\n\n      for (var i = numLayers - 1; i >= 0; i--) {\n        var layer = this._layers[i];\n        layer.updateInternalWeight(weightMultiplier); // If the layer is override, update the multiplier with the remainder of the full weight\n\n        if (layer.blendMode === LayerBlendModes.Override && layer.currentState) {\n          weightMultiplier *= 1 - layer.currentState.internalWeight;\n        }\n      }\n    }\n    /**\r\n     * Return a new instance of a SingleState.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {Object} options - Options to pass to the SingleState constructor.\r\n     * @param {string=} options.name - Name for the animation state. Names must be\r\n     * unique for the layer the state is applied to.\r\n     * @param {weight} [options.weight=0] - The 0-1 amount of influence the state will have.\r\n     * @param {timeScale} [options.timeScale=1] - Factor to scale the playback speed of the\r\n     * animation.\r\n     * @param {number} [options.loopCount=Infinity] - Number of times the animation should\r\n     * repeat before finishing.\r\n     * @param {string} [options.blendMode=LayerBlendModes[DefaultLayerBlendMode]] - Type of\r\n     * blending the animation should use.\r\n     *\r\n     * @returns {core/SingleState}\r\n     */\n\n  }, {\n    key: "_createSingleState",\n    value: function _createSingleState(options) {\n      return new state_SingleState(options);\n    }\n    /**\r\n     * Return a new instance of a FreeBlendState.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {Object} options - Options to pass to the FreeBlendState constructor.\r\n     * @param {string=} options.name - Name for the animation state. Names must be\r\n     * unique for the layer the state is applied to.\r\n     * @param {weight} [options.weight=0] - The 0-1 amount of influence the state will have.\r\n     * @param {timeScale} [options.timeScale=1] - Factor to scale the playback speed of the\r\n     * animation.\r\n     * @param {number} [options.loopCount=Infinity] - Number of times the animation should\r\n     * repeat before finishing.\r\n     * @param {string} [options.blendMode=LayerBlendModes[DefaultLayerBlendMode]] - Type of\r\n     * blending the animation should use.\r\n     * @param {Array.<Object>} [options.blendStateOptions] - Array of options used to create the\r\n     * blend states for this container.\r\n     *\r\n     * @returns {FreeBlendState}\r\n     */\n\n  }, {\n    key: "_createFreeBlendState",\n    value: function _createFreeBlendState(options) {\n      var _this2 = this;\n\n      var _options$blendStateOp = options.blendStateOptions,\n          blendStateOptions = _options$blendStateOp === void 0 ? [] : _options$blendStateOp;\n      var blendStates = [];\n      blendStateOptions.forEach(function (blendOptions) {\n        blendStates.push(_this2._createSingleState(AnimationFeature_objectSpread(AnimationFeature_objectSpread({}, blendOptions), {}, {\n          blendMode: options.blendMode\n        })));\n      });\n      return new state_FreeBlendState(options, blendStates);\n    }\n    /**\r\n     * Return a new instance of a QueueState.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {Object} options - Options to pass to the QueueState constructor.\r\n     * @param {string=} options.name - Name for the animation state. Names must be\r\n     * unique for the layer the state is applied to.\r\n     * @param {number} [options.weight=0] - The 0-1 amount of influence the state will have.\r\n     * @param {number=} options.transitionTime - The amount of time it takes to transition\r\n     * between queued states.\r\n     * @param {string} [options.blendMode=LayerBlendModes[DefaultLayerBlendMode]] - Type of\r\n     * blending the animation should use.\r\n     * @param {Array.<Object>} [options.queueOptions] - Array of options used to create the\r\n     * queue states for this container.\r\n     *\r\n     * @returns {QueueState}\r\n     */\n\n  }, {\n    key: "_createQueueState",\n    value: function _createQueueState(options) {\n      var _this3 = this;\n\n      var _options$queueOptions = options.queueOptions,\n          queueOptions = _options$queueOptions === void 0 ? [] : _options$queueOptions;\n      var queueStates = queueOptions.map(function (queueOption) {\n        return _this3._createSingleState(AnimationFeature_objectSpread(AnimationFeature_objectSpread({\n          transitionTime: options.transitionTime\n        }, queueOption), {}, {\n          blendMode: options.blendMode\n        }));\n      });\n      return new state_QueueState(options, queueStates);\n    }\n    /**\r\n     * Return a new instance of a Blend1dState.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {Object} options - Options to pass to the Blend1dState constructor.\r\n     * @param {string=} options.name - Name for the animation state. Names must be\r\n     * unique for the layer the state is applied to.\r\n     * @param {weight} [options.weight=0] - The 0-1 amount of influence the state will have.\r\n     * @param {timeScale} [options.timeScale=1] - Factor to scale the playback speed of the\r\n     * animation.\r\n     * @param {number} [options.loopCount=Infinity] - Number of times the animation should\r\n     * repeat before finishing.\r\n     * @param {string} [options.blendMode=LayerBlendModes[DefaultLayerBlendMode]] - Type of\r\n     * blending the animation should use.\r\n     * @param {Array.<Object>} [options.blendStateOptions] - Array of options used to create the\r\n     * blend states for this container.\r\n     * @param {Array.<number>} [options.blendThresholds] - Array of numbers used to set the\r\n     * thresholds for each blend state in this container.\r\n     * @param {Array.<boolean>} [options.blendMatchPhases=[]] - Optional array of booleans used to\r\n     * set whether or not each blend state in this container will match phases.\r\n     *\r\n     * @returns {Blend1dState}\r\n     */\n\n  }, {\n    key: "_createBlend1dState",\n    value: function _createBlend1dState(options) {\n      var _this4 = this;\n\n      var _options$blendStateOp2 = options.blendStateOptions,\n          blendStateOptions = _options$blendStateOp2 === void 0 ? [] : _options$blendStateOp2;\n      var _options$blendThresho = options.blendThresholds,\n          blendThresholds = _options$blendThresho === void 0 ? [] : _options$blendThresho;\n      var _options$blendMatchPh = options.blendMatchPhases,\n          blendMatchPhases = _options$blendMatchPh === void 0 ? [] : _options$blendMatchPh;\n      var blendStates = [];\n      blendStateOptions.forEach(function (blendOptions) {\n        blendStates.push(_this4._createSingleState(AnimationFeature_objectSpread(AnimationFeature_objectSpread({}, blendOptions), {}, {\n          blendMode: options.blendMode\n        })));\n      });\n      return new state_Blend1dState(options, blendStates, blendThresholds, blendMatchPhases);\n    }\n    /**\r\n     * Return a new instance of a Blend2dState.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {Object} options - Options to pass to the Blend1dState constructor.\r\n     * @param {string=} options.name - Name for the animation state. Names must be\r\n     * unique for the layer the state is applied to.\r\n     * @param {weight} [options.weight=0] - The 0-1 amount of influence the state will have.\r\n     * @param {timeScale} [options.timeScale=1] - Factor to scale the playback speed of the\r\n     * animation.\r\n     * @param {number} [options.loopCount=Infinity] - Number of times the animation should\r\n     * repeat before finishing.\r\n     * @param {string} [options.blendMode=LayerBlendModes[DefaultLayerBlendMode]] - Type of\r\n     * blending the animation should use.\r\n     * @param {Array.<Object>} [options.blendStateOptions] - Array of options used to create the\r\n     * blend states for this container.\r\n     * @param {Array.<Array.<number>>} [options.blendThresholds] - Array of Array of numbers used to set the\r\n     * thresholds for each blend state in this container.\r\n     * @param {Array.<boolean>} [options.blendMatchPhases=[]] - Optional array of booleans used to\r\n     * set whether or not each blend state in this container will match phases.\r\n     *\r\n     * @returns {Blend1dState}\r\n     */\n\n  }, {\n    key: "_createBlend2dState",\n    value: function _createBlend2dState(options) {\n      var _this5 = this;\n\n      var _options$blendStateOp3 = options.blendStateOptions,\n          blendStateOptions = _options$blendStateOp3 === void 0 ? [] : _options$blendStateOp3;\n      var _options$blendThresho2 = options.blendThresholds,\n          blendThresholds = _options$blendThresho2 === void 0 ? [] : _options$blendThresho2;\n      var _options$blendMatchPh2 = options.blendMatchPhases,\n          blendMatchPhases = _options$blendMatchPh2 === void 0 ? [] : _options$blendMatchPh2;\n      var blendStates = [];\n      blendStateOptions.forEach(function (blendOptions) {\n        blendStates.push(_this5._createSingleState(AnimationFeature_objectSpread(AnimationFeature_objectSpread({}, blendOptions), {}, {\n          blendMode: options.blendMode\n        })));\n      });\n      return new state_Blend2dState(options, blendStates, blendThresholds, blendMatchPhases);\n    }\n    /**\r\n     * Return a new instance of a RandomAnimationState.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {Object} options - Options to pass to the RandomAnimationState constructor.\r\n     * @param {string=} options.name - Name for the animation state. Names must be\r\n     * unique for the layer the state is applied to.\r\n     * @param {number} [options.playInterval=3] - The base animation playback interval.\r\n     * @param {Array.<Object>} [options.subStateOptions] - Array of options used to create the\r\n     * sub states for this container.\r\n     *\r\n     * @returns {RandomAnimationState}\r\n     */\n\n  }, {\n    key: "_createRandomAnimationState",\n    value: function _createRandomAnimationState(options) {\n      var _this6 = this;\n\n      var _options$subStateOpti = options.subStateOptions,\n          subStateOptions = _options$subStateOpti === void 0 ? [] : _options$subStateOpti;\n      var subStates = [];\n      subStateOptions.forEach(function (subStateOptions) {\n        subStates.push(_this6._createSingleState(AnimationFeature_objectSpread(AnimationFeature_objectSpread({}, subStateOptions), {}, {\n          blendMode: options.blendMode\n        })));\n      });\n      return new state_RandomAnimationState(options, subStates);\n    }\n    /**\r\n     * Make sure the layer with the given name exists and return a unique version\r\n     * of the animation name supplied for that layer.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} layerName - Name of the layer to check against.\r\n     * @param {string} animationName - Name of the animation to validate.\r\n     *\r\n     * @returns {string} Validated animation name.\r\n     */\n\n  }, {\n    key: "_validateNewAnimation",\n    value: function _validateNewAnimation(layerName, animationName) {\n      // Make sure the layerName is valid\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        throw new Error("Cannot add animation to layer ".concat(layerName, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      } // Make sure the animationName is unique\n\n\n      var name = core_Utils.getUniqueName(animationName, layer.getStateNames());\n\n      if (name !== animationName) {\n        console.warn("Animation name ".concat(animationName, " is not unique for layer ").concat(layer.name, ". Animation will be renamed to ").concat(name, "."));\n      }\n\n      return name;\n    }\n    /**\r\n     * Gets whether or not all animations are paused.\r\n     *\r\n     * @readonly\r\n     * @type {boolean}\r\n     */\n\n  }, {\n    key: "paused",\n    get: function get() {\n      return this._paused;\n    }\n    /**\r\n     * Gets an array of names of animation layers.\r\n     *\r\n     * @readonly\r\n     * @type {Array.<string>}\r\n     */\n\n  }, {\n    key: "layers",\n    get: function get() {\n      return this._layers.map(function (layer) {\n        return layer.name;\n      });\n    }\n    /**\r\n     * Create and store a new animation layer.\r\n     *\r\n     * @param {string} [name=\'NewLayer\'] - Name for the layer.\r\n     * @param {Object} [options={}] - Options to pass to {@link AnimationLayer#constructor}\r\n     * @param {index=} index - Index to insert the new layer at. If none is provided\r\n     * it will be added to the end of the stack.\r\n     *\r\n     * @returns {number} Index of the new layer.\r\n     */\n\n  }, {\n    key: "addLayer",\n    value: function addLayer() {\n      var name = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \'NewLayer\';\n      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n      var index = arguments.length > 2 ? arguments[2] : undefined;\n      var numLayers = this._layers.length;\n      var layerIndex = index; // Make sure the given index is within the range of layers\n\n      if (index === undefined || index === -1) {\n        layerIndex = this._layers.length;\n      } else {\n        layerIndex = this._validateIndex(index, false);\n\n        if (layerIndex === undefined) {\n          // Insert at the beginning if the user passed in a negative index\n          if (index < 0) {\n            layerIndex = 0;\n          } // Otherwise append to the end\n          else {\n            layerIndex = this._layers.length;\n          }\n\n          console.warn("Index ".concat(index, " is invalid for host ").concat(this._host.id, ". New layer will be added at the closest valid index: ").concat(layerIndex, "."));\n        }\n      } // Make sure the layer name is unique\n\n\n      var layerName = core_Utils.getUniqueName(name, Object.keys(this._layerMap));\n\n      if (name !== layerName) {\n        console.warn("Layer name ".concat(name, " is not unique. New layer will be added with the name ").concat(layerName, "."));\n      }\n\n      var layer = new animpack_AnimationLayer(AnimationFeature_objectSpread(AnimationFeature_objectSpread({}, options), {}, {\n        name: layerName\n      }));\n      this._layerMap[layerName] = layer;\n\n      if (layerIndex === numLayers) {\n        this._layers.push(layer);\n      } else {\n        this._layers.splice(layerIndex, 0, layer);\n      } // Notify that a layer has been added to the feature\n\n\n      var eventData = {\n        name: layerName,\n        index: layerIndex\n      };\n      this.emit(this.constructor.EVENTS.addLayer, eventData);\n      return eventData;\n    }\n    /**\r\n     * Remove an animation layer from the stack. Animations on this layer will no\r\n     * longer be evaluated.\r\n     *\r\n     * @param {string} name - Name for the layer to remove.\r\n     *\r\n     * @returns {boolean} Whether or not removal was successful.\r\n     */\n\n  }, {\n    key: "removeLayer",\n    value: function removeLayer(name) {\n      var layer = this._layerMap[name];\n\n      if (layer === undefined) {\n        console.warn("Did not remove layer ".concat(name, " from host ").concat(this._host.id, ". No layer exists with this name."));\n        return false;\n      }\n\n      layer.discard();\n\n      var index = this._layers.indexOf(layer);\n\n      this._layers.splice(index, 1);\n\n      delete this._layerMap[name]; // Notify that a layer has been removed from the feature\n\n      this.emit(this.constructor.EVENTS.removeLayer, {\n        name: name,\n        index: index\n      });\n      return true;\n    }\n    /**\r\n     * Re-order the layer stack so that the layer with the given name is positioned\r\n     * at the given index.\r\n     *\r\n     * @param {string} name - Name of the layer to move.\r\n     * @param {number} index - New index to position the layer at.\r\n     *\r\n     * @returns {number} The new index of the layer\r\n     */\n\n  }, {\n    key: "moveLayer",\n    value: function moveLayer(name, index) {\n      // Make sure the name is valid\n      var layer = this._layerMap[name];\n\n      if (layer === undefined) {\n        throw new Error("Cannot move layer ".concat(name, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      } // Make sure the index falls in the range of existing layers\n\n\n      var layerIndex = this._validateIndex(index, true);\n\n      var lastIndex = this._layers.length - 1;\n\n      if (layerIndex === undefined) {\n        throw new Error("Cannot move layer ".concat(name, " from host ").concat(this._host.id, " to index ").concat(index, ". Index must be in the 0 - ").concat(lastIndex, " range."));\n      }\n\n      var currentIndex = this._layers.indexOf(layer);\n\n      if (currentIndex === layerIndex) {\n        return;\n      } // Remove from the current position\n\n\n      this._layers.splice(currentIndex, 1); // Insert at the new position\n\n\n      if (layerIndex === lastIndex) {\n        this._layers.push(layer);\n      } else {\n        this._layers.splice(layerIndex, 0, layer);\n      }\n\n      return layerIndex;\n    }\n    /**\r\n     * Update the name of a layer. Names must be unique, if the new name is not\r\n     * unique it will have trailing numbers appended until it is unique.\r\n     *\r\n     * @param {string} currentName - Current name of the layer.\r\n     * @param {string} newName - New name to set on the layer.\r\n     *\r\n     * @returns {string} The new name of the layer\r\n     */\n\n  }, {\n    key: "renameLayer",\n    value: function renameLayer(currentName, newName) {\n      // Make sure the name is valid\n      var layer = this._layerMap[currentName];\n\n      if (layer === undefined) {\n        throw new Error("Cannot rename layer ".concat(currentName, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      } // Make sure the layer name is unique\n\n\n      var name = core_Utils.getUniqueName(newName, Object.keys(this._layerMap));\n\n      if (name !== newName) {\n        console.warn("Layer name ".concat(newName, " is not unique. Layer will be renamed to ").concat(name, "."));\n      }\n\n      delete this._layerMap[currentName];\n      this._layerMap[name] = layer;\n      layer.name = name; // Notify that a layer has been renamed on the feature\n\n      this.emit(this.constructor.EVENTS.renameLayer, {\n        oldName: currentName,\n        newName: name\n      });\n      return name;\n    }\n    /**\r\n     * Return the weight of an animation layer.\r\n     *\r\n     * @param {string} name - Name of the layer to return weight from.\r\n     *\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: "getLayerWeight",\n    value: function getLayerWeight(name) {\n      // Make sure the name is valid\n      var layer = this._layerMap[name];\n\n      if (layer === undefined) {\n        throw new Error("Cannot get weight on layer ".concat(name, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      return layer.weight;\n    }\n    /**\r\n     * Update the weight of an animation layer.\r\n     *\r\n     * @param {string} name - The name of the layer to update.\r\n     * @param {number} weight - The weight value to set on the layer. This number\r\n     * should be in the 0-1 range.\r\n     * @param {number=} seconds - The number of seconds it should take to reach the\r\n     * new weight. Default is zero and will set immediately.\r\n     * @param {Function=} easingFn - The easing function to use while interpolating\r\n     * the weight. Default is Easing.Linear.InOut.\r\n     *\r\n     * @returns {Deferred} A promise that will resolve once the layer\'s weight reaches\r\n     * the target value.\r\n     */\n\n  }, {\n    key: "setLayerWeight",\n    value: function setLayerWeight(name, weight, seconds, easingFn) {\n      // Make sure the name is valid\n      var layer = this._layerMap[name];\n\n      if (layer === undefined) {\n        var e = "Cannot set weight on layer ".concat(name, " from host ").concat(this._host.id, ". No layer exists with this name.");\n        return core_Deferred.reject(e);\n      }\n\n      return layer.setWeight(weight, seconds, easingFn);\n    }\n    /**\r\n     * Returns the names of blend states in an animation in a layer.\r\n     *\r\n     * @param {string} layerName - Name of the layer containing the animation containing\r\n     * the blend state to update.\r\n     * @param {string} animationName - Name of the animation containing the blend state\r\n     * to update.\r\n     *\r\n     * @returns {Array.<string>} - Names of blend states.\r\n     */\n\n  }, {\n    key: "getAnimationBlendNames",\n    value: function getAnimationBlendNames(layerName, animationName) {\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        throw new Error("Cannot get blend names on layer ".concat(layerName, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      return layer.getAnimationBlendNames(animationName);\n    }\n    /**\r\n     * Update the weight for a blend state in an animation in a layer.\r\n     *\r\n     * @param {string} layerName - Name of the layer containing the animation containing\r\n     * the blend state to update.\r\n     * @param {string} animationName - Name of the animation containing the blend state\r\n     * to update.\r\n     * @param {string} blendName - Name of the blend state to update.\r\n     * @param {number} weight - Weight value to set on the animation. This number shoudld be\r\n     * in the 0-1 range.\r\n     * @param {number=} seconds - Number of seconds it should take to reach the new weight.\r\n     * Default is zero and will set immediately.\r\n     * @param {Function=} easingFn - Easing function to use while interpolating the new\r\n     * weight. Default is Easing.Linear.InOut.\r\n     *\r\n     * @returns {Deferred} - Promise that will resolve once the animation\'s weight reaches\r\n     * the target value.\r\n     */\n\n  }, {\n    key: "setAnimationBlendWeight",\n    value: function setAnimationBlendWeight(layerName, animationName, blendName, weight, seconds, easingFn) {\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        var e = "Cannot set blend weight on layer ".concat(layerName, " from host ").concat(this._host.id, ". No layer exists with this name.");\n        return core_Deferred.reject(e);\n      }\n\n      return layer.setAnimationBlendWeight(animationName, blendName, weight, seconds, easingFn);\n    }\n    /**\r\n     * Returns the weight for a blend state in an animation in a layer.\r\n     *\r\n     * @param {string} layerName - Name of the layer containing the animation containing\r\n     * the blend state to update.\r\n     * @param {string} animationName - Name of the animation containing the blend state\r\n     * to update.\r\n     * @param {string} blendName - Name of the blend state to update.\r\n     *\r\n     * @returns {number} - Weight of the blend state.\r\n     */\n\n  }, {\n    key: "getAnimationBlendWeight",\n    value: function getAnimationBlendWeight(layerName, animationName, blendName) {\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        throw new Error("Cannot get blend weight on layer ".concat(layerName, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      return layer.getAnimationBlendWeight(animationName, blendName);\n    }\n    /**\r\n     * Pause weight interpolation animation on a layer with the given name.\r\n     *\r\n     * @param {string} name - Name of the layer to pause.\r\n     *\r\n     * @returns {boolean} - Whether or not there was an existing interpolation to pause.\r\n     */\n\n  }, {\n    key: "pauseLayerWeight",\n    value: function pauseLayerWeight(name) {\n      // Make sure the name is valid\n      var layer = this._layerMap[name];\n\n      if (layer === undefined) {\n        throw new Error("Cannot pause weight interpolation on layer ".concat(name, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      return layer.pauseWeight();\n    }\n    /**\r\n     * Resume weight interpolation animation on a layer with the given name.\r\n     *\r\n     * @param {string} name - Name of the layer to resume.\r\n     *\r\n     * @returns {Deferred} - Resolves once the layer\'s weight reaches its target value.\r\n     */\n\n  }, {\n    key: "resumeLayerWeight",\n    value: function resumeLayerWeight(name) {\n      // Make sure the name is valid\n      var layer = this._layerMap[name];\n\n      if (layer === undefined) {\n        var e = "Cannot resume weight interpolation on layer ".concat(name, " from host ").concat(this._host.id, ". No layer exists with this name.");\n        return core_Deferred.reject(e);\n      }\n\n      return layer.resumeWeight();\n    }\n    /**\r\n     * Pause current animation and weight interpolation animation on a layer with\r\n     * the given name.\r\n     *\r\n     * @param {string} name - Name of the layer to pause.\r\n     *\r\n     * @returns {boolean} - Whether or not there was an existing interpolation or\r\n     * current animation to pause.\r\n     */\n\n  }, {\n    key: "pauseLayer",\n    value: function pauseLayer(name) {\n      // Make sure the name is valid\n      var layer = this._layerMap[name];\n\n      if (layer === undefined) {\n        throw new Error("Cannot pause layer ".concat(name, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      return layer.pause();\n    }\n    /**\r\n     * Resume current animation and weight interpolation animation on a layer with\r\n     * the given name.\r\n     *\r\n     * @param {string} name - Name of the layer to resume.\r\n     *\r\n     * @returns {Deferred} - Resolves once the layer\'s weight reaches its target value\r\n     * and it\'s current animation finishes playing.\r\n     */\n\n  }, {\n    key: "resumeLayer",\n    value: function resumeLayer(name) {\n      // Make sure the name is valid\n      var layer = this._layerMap[name];\n\n      if (layer === undefined) {\n        var e = "Cannot resume layer ".concat(name, " from host ").concat(this._host.id, ". No layer exists with this name.");\n        return core_Deferred.reject(e);\n      }\n\n      return layer.resume();\n    }\n    /**\r\n     * Return whether or not the animation layer with the given name is currently\r\n     * transitioning between animations.\r\n     *\r\n     * @param {string} layerName - Name of the layer to check.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "getTransitioning",\n    value: function getTransitioning(layerName) {\n      // Make sure the layerName is valid\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        throw new Error("Get transitioning on layer ".concat(layerName, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      return layer.isTransitioning;\n    }\n    /**\r\n     * Return an array of the names of all states the layer with the given name controls.\r\n     *\r\n     * @param {string} layerName - Name of the layer to search.\r\n     *\r\n     * @returns {Array.<string>}\r\n     */\n\n  }, {\n    key: "getAnimations",\n    value: function getAnimations(layerName) {\n      // Make sure the layerName is valid\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        throw new Error("Get animations on layer ".concat(layerName, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      return layer.getStateNames();\n    }\n    /**\r\n     * Return the name of the state currently active on the layer with the given name.\r\n     * Return null if there is no current animation for the layer.\r\n     *\r\n     * @param {string} layerName - Name of the layer.\r\n     *\r\n     * @returns {(string|null)}\r\n     */\n\n  }, {\n    key: "getCurrentAnimation",\n    value: function getCurrentAnimation(layerName) {\n      // Make sure the layerName is valid\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        throw new Error("Get current animation on layer ".concat(layerName, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      return layer.currentAnimation;\n    }\n    /**\r\n     * Return whether or not a layer with the given name is currently playing an\r\n     * animation and that animation is paused.\r\n     *\r\n     * @param {string} layerName - Name of the layer.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "getPaused",\n    value: function getPaused(layerName) {\n      // Make sure the layerName is valid\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        throw new Error("Get paused on layer ".concat(layerName, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      return layer.currentState && layer.currentState.paused;\n    }\n    /**\r\n     * Return the type name of the given animation. @see AnimationTypes.\r\n     *\r\n     * @param {string} layerName - Name of the layer that contains the animation.\r\n     * @param {string} animationName - Name of the animation to check.\r\n     *\r\n     * @returns {string}\r\n     */\n\n  }, {\n    key: "getAnimationType",\n    value: function getAnimationType(layerName, animationName) {\n      // Make sure the layerName is valid\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        throw new Error("Get animation type on layer ".concat(layerName, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      var state = layer.getState(animationName);\n\n      if (state === undefined) {\n        throw new Error("Get animation type for animation ".concat(animationName, " on layer ").concat(layerName, " from host ").concat(this._host.id, ". No animation exists with this name."));\n      }\n\n      var constructor = state.constructor;\n      return Object.keys(AnimationTypes).find(function (typeName) {\n        return AnimationTypes[typeName] === constructor;\n      });\n    }\n    /**\r\n     * Add a new animation to an animation layer.\r\n     *\r\n     * @param {string} layerName - Name of the layer to add the animation to.\r\n     * @param {string} animationName - Name to use when calling the animation.\r\n     * @param {Object=} options - Options to pass to the constructor for the new\r\n     * SingleState animation.\r\n     *\r\n     * @returns {string} - The name of the animation that was added\r\n     */\n\n  }, {\n    key: "addAnimation",\n    value: function addAnimation(layerName, animationName) {\n      var animationType = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : AnimationTypes.single;\n      var options = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {};\n      options.name = this._validateNewAnimation(layerName, animationName); // Make sure the animation type is valid\n\n      if (!Object.values(AnimationTypes).includes(animationType)) {\n        throw new Error("Cannot add animation ".concat(animationName, " to layer ").concat(layerName, " on host ").concat(this._host.id, ". Invalid animation type."));\n      }\n\n      var layer = this._layerMap[layerName];\n      options.blendMode = layer.blendMode;\n      options.transitionTime = layer.transitionTime;\n      var state = this["_create".concat(animationType.name)](options);\n      var name = layer.addState(state); // Notify that an animation has been added to the feature\n\n      this.emit(this.constructor.EVENTS.addAnimation, {\n        layerName: layerName,\n        animationName: name\n      });\n      return name;\n    }\n    /**\r\n     * Remove an animation from an animation layer.\r\n     *\r\n     * @param {string} layerName - Name of the layer to remove the animation from.\r\n     * @param {string} name - Name of the animation to remove.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "removeAnimation",\n    value: function removeAnimation(layerName, animationName) {\n      // Make sure the name is valid\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        throw new Error("Cannot remove animation from layer ".concat(layerName, " from host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      var removed = layer.removeState(animationName); // Notify that an animation has been removed from the feature\n\n      if (removed === true) {\n        this.emit(this.constructor.EVENTS.removeAnimation, {\n          layerName: layerName,\n          animationName: animationName\n        });\n      }\n\n      return removed;\n    }\n    /**\r\n     * Update the name of an animation. Names must be unique on each layer, if the new\r\n     * name is not unique it will have trailing numbers appended until it is unique.\r\n     *\r\n     * @param {string} layerName - Name of the layer that contains the animation that\r\n     * will be renamed,\r\n     * @param {string} currentAnimationName - Current name of the animation.\r\n     * @param {string} newAnimationName - New name to set on the animation.\r\n     *\r\n     * @returns {string} - The new name of the animation\r\n     */\n\n  }, {\n    key: "renameAnimation",\n    value: function renameAnimation(layerName, currentAnimationName, newAnimationName) {\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        throw new Error("Cannot rename animation ".concat(currentAnimationName, " on layer ").concat(layerName, " for host ").concat(this._host.id, ". No layer exists with this name."));\n      }\n\n      var name = layer.renameState(currentAnimationName, newAnimationName); // Notify that an animation has been renamed on the feature\n\n      this.emit(this.constructor.EVENTS.renameAnimation, {\n        layerName: layerName,\n        oldName: currentAnimationName,\n        newName: name\n      });\n      return name;\n    }\n    /**\r\n     * Pause the currently playing animation and play a new animation from the beginning.\r\n     *\r\n     * @param {string} layerName - Name of the layer that contains the animation.\r\n     * @param {string} animationName - Name of the animation state to play.\r\n     * @param {number=} seconds - The number of seconds it should take to transition\r\n     * to the new animation. Default is zero and will set immediately.\r\n     * @param {Function=} easingFn - The easing function to use while transitioning\r\n     * between animations. Default is Easing.Linear.InOut.\r\n     *\r\n     * @returns {Deferred} - Resolves once the animation reaches the end of its\r\n     * timeline. Looping animations can only resolve if they are interrupted or\r\n     * manually stopped.\r\n     */\n\n  }, {\n    key: "playAnimation",\n    value: function playAnimation(layerName, animationName, seconds, easingFn) {\n      var _this7 = this;\n\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        var e = "Cannot play animation ".concat(animationName, " on layer ").concat(layerName, " for host ").concat(this._host.id, ". No layer exists with this name.");\n        return core_Deferred.reject(e);\n      } // Notify that a new animation has begun\n\n\n      this.emit(this.constructor.EVENTS.playAnimation, {\n        layerName: layerName,\n        animationName: animationName\n      });\n      return layer.playAnimation(animationName, seconds, easingFn, function () {\n        // Notify that an animation has stopped\n        _this7.emit(_this7.constructor.EVENTS.stopAnimation, {\n          layerName: layerName,\n          animationName: animationName\n        });\n      }, undefined, function () {\n        // Notify that an animation has been interrupted\n        _this7.emit(_this7.constructor.EVENTS.interruptAnimation, {\n          layerName: layerName,\n          animationName: animationName\n        });\n      }, function (_ref) {\n        var name = _ref.name,\n            canAdvance = _ref.canAdvance,\n            isQueueEnd = _ref.isQueueEnd;\n\n        if (layer.currentAnimation === animationName) {\n          // Notify that a new animation has begun\n          _this7.emit(_this7.constructor.EVENTS.playNextAnimation, {\n            layerName: layerName,\n            animationName: animationName,\n            nextQueuedAnimation: name,\n            canAdvance: canAdvance,\n            isQueueEnd: isQueueEnd\n          });\n        }\n      });\n    }\n    /**\r\n     * Play the next animation in the queue of a QueueState animation.\r\n     *\r\n     * @param {string} layerName - Name of the layer that contains the queue animation.\r\n     * @param {string=} animationName - Name of the animation queue animation. Defaults\r\n     * to the name of the current animation for the layer.\r\n     * @param {number=} seconds - The number of seconds it should take to transition\r\n     * to the queue animation if it\'s not already currently playing. Default is zero\r\n     * and will set immediately.\r\n     * @param {Function=} easingFn - The easing function to use while transitioning\r\n     * to the queue animation if it isn\'t already playing. Default is Easing.Linear.InOut.\r\n     *\r\n     * @returns {Deferred} - Resolves once the last animation in the queue finishes\r\n     * playing.\r\n     */\n\n  }, {\n    key: "playNextAnimation",\n    value: function playNextAnimation(layerName, animationName, transitionTime, easingFn) {\n      var _this8 = this;\n\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        var e = "Cannot play next animation on layer ".concat(layerName, " for host ").concat(this._host.id, ". No layer exists with this name.");\n        return core_Deferred.reject(e);\n      }\n\n      if (animationName === undefined) {\n        animationName = layer.currentAnimation;\n      }\n\n      var animation = layer.getState(layer.currentAnimation);\n\n      if (animation === null) {\n        var _e = "Cannot play next animation on layer ".concat(layerName, " for host ").concat(this._host.id, ". No animation exists with name ").concat(animationName, ".");\n\n        return core_Deferred.reject(_e);\n      } else if (this.getAnimationType(layerName, animationName) !== \'queue\') {\n        var _e2 = "Cannot play next animation on layer ".concat(layerName, " for host ").concat(this._host.id, ". ").concat(animationName, " is not a queue state.");\n\n        return core_Deferred.reject(_e2);\n      }\n\n      var onNext = function onNext(_ref2) {\n        var name = _ref2.name,\n            canAdvance = _ref2.canAdvance,\n            isQueueEnd = _ref2.isQueueEnd;\n\n        if (layer.currentAnimation === animationName) {\n          // Notify that a new animation has begun\n          _this8.emit(_this8.constructor.EVENTS.playNextAnimation, {\n            layerName: layerName,\n            animationName: animationName,\n            nextQueuedAnimation: name,\n            canAdvance: canAdvance,\n            isQueueEnd: isQueueEnd\n          });\n        }\n      }; // Make the queue animation current if it wasn\'t already\n\n\n      if (layer.currentAnimation === null) {\n        layer.resumeAnimation(animation.name, transitionTime, easingFn, undefined, undefined, undefined, onNext);\n      }\n\n      return animation.next(onNext, true);\n    }\n    /**\r\n     * Pause the current animation on a layer.\r\n     *\r\n     * @param {string} name - Name of the layer to pause.\r\n     *\r\n     * @returns {boolean} Whether or not an animation was successfully paused.\r\n     */\n\n  }, {\n    key: "pauseAnimation",\n    value: function pauseAnimation(name) {\n      var layer = this._layerMap[name];\n\n      if (layer === undefined) {\n        console.warn("Did not pause animation on layer ".concat(name, " for host ").concat(this._host.id, ". No layer exists with this name."));\n        return false;\n      }\n\n      var paused = layer.pauseAnimation(); // Notify that an animation was paused\n\n      if (paused) {\n        var animationName = layer.currentAnimation;\n        this.emit(this.constructor.EVENTS.pauseAnimation, {\n          layerName: name,\n          animationName: animationName\n        });\n      }\n\n      return paused;\n    }\n    /**\r\n     * Pause the currently playing animation and play a new animation from where it\r\n     * last left off.\r\n     *\r\n     * @param {string} layerName - Name of the layer that contains the animation.\r\n     * @param {string=} animationName - Name of the animation state to resume. Defaults\r\n     * to the name of the current animation for the layer.\r\n     * @param {number=} seconds - The number of seconds it should take to transition\r\n     * to the new animation. Default is zero and will set immediately.\r\n     * @param {Function=} easingFn - The easing function to use while transitioning\r\n     * between animations. Default is Easing.Linear.InOut.\r\n     *\r\n     * @returns {Deferred} - Resolves once the animation reaches the end of its\r\n     * timeline. Looping animations can only resolve if they are interrupted or\r\n     * manually stopped.\r\n     */\n\n  }, {\n    key: "resumeAnimation",\n    value: function resumeAnimation(layerName, animationName, seconds, easingFn) {\n      var _this9 = this;\n\n      var layer = this._layerMap[layerName];\n\n      if (layer === undefined) {\n        var e = "Cannot resume animation ".concat(animationName, " on layer ").concat(layerName, " for host ").concat(this._host.id, ". No layer exists with this name.");\n        return core_Deferred.reject(e);\n      } // Notify that an animation was resumed\n\n\n      this.emit(this.constructor.EVENTS.resumeAnimation, {\n        layerName: layerName,\n        animationName: animationName\n      });\n      return layer.resumeAnimation(animationName, seconds, easingFn, function () {\n        // Notify that an animation has stopped\n        _this9.emit(_this9.constructor.EVENTS.stopAnimation, {\n          layerName: layerName,\n          animationName: animationName\n        });\n      }, undefined, function () {\n        // Notify that an animation has been interrupted\n        _this9.emit(_this9.constructor.EVENTS.interruptAnimation, {\n          layerName: layerName,\n          animationName: animationName\n        });\n      }, function (_ref3) {\n        var name = _ref3.name,\n            canAdvance = _ref3.canAdvance,\n            isQueueEnd = _ref3.isQueueEnd;\n\n        if (layer.currentAnimation === animationName) {\n          // Notify that a new animation has begun\n          _this9.emit(_this9.constructor.EVENTS.playNextAnimation, {\n            layerName: layerName,\n            animationName: animationName,\n            nextQueuedAnimation: name,\n            canAdvance: canAdvance,\n            isQueueEnd: isQueueEnd\n          });\n        }\n      });\n    }\n    /**\r\n     * Stop the current animation on a layer. Stop rewinds the animation to the\r\n     * beginning and prevents it from progressing forward.\r\n     *\r\n     * @param {string} name - Name of the layer that contains the animation.\r\n     *\r\n     * @returns {boolean} Whether or not an animation was successfully stopped.\r\n     */\n\n  }, {\n    key: "stopAnimation",\n    value: function stopAnimation(name) {\n      var layer = this._layerMap[name];\n\n      if (layer === undefined) {\n        console.warn("Did not stop animation on layer ".concat(name, " for host ").concat(this._host.id, ". No layer exists with this name."));\n        return false;\n      }\n\n      return layer.stopAnimation();\n    }\n    /**\r\n     * Pause current animation and weight interpolation animation on all layers.\r\n       * @returns {boolean} - Whether or not there was an existing interpolation or\r\n     * current animations to pause.\r\n     */\n\n  }, {\n    key: "pause",\n    value: function pause() {\n      this._paused = true;\n      var paused = false;\n\n      this._layers.forEach(function (l) {\n        if (l.pause()) {\n          paused = true;\n        }\n      });\n\n      return paused;\n    }\n    /**\r\n     * Resume current animation and weight interpolation animation on all layers.\r\n       * @returns {boolean} - Whether or not there was an existing interpolation or\r\n     * current animations to resume.\r\n     */\n\n  }, {\n    key: "resume",\n    value: function resume() {\n      this._paused = false;\n      var resumed = false;\n\n      this._layers.forEach(function (l) {\n        if (l.resume()) {\n          resumed = true;\n        }\n      });\n\n      return resumed;\n    }\n    /**\r\n     * Adds a namespace to the host with the name of the feature to contain properties\r\n     * and methods from the feature that users of the host need access to.\r\n     *\r\n     * @see AnimationFeature\r\n     */\n\n  }, {\n    key: "installApi",\n    value: function installApi() {\n      var _this10 = this;\n\n      /**\r\n       * @inner\r\n       * @namespace AnimationFeature\r\n       */\n      var api = AnimationFeature_get(AnimationFeature_getPrototypeOf(AnimationFeature.prototype), "installApi", this).call(this);\n\n      Object.defineProperties(api, {\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @see core/AnimationFeature#paused\r\n         */\n        paused: {\n          get: function get() {\n            return _this10.paused;\n          }\n        },\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @see core/AnimationFeature#layers\r\n         */\n        layers: {\n          get: function get() {\n            return _this10.layers;\n          }\n        }\n      });\n      Object.assign(api, {\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#addLayer\r\n         */\n        addLayer: this.addLayer.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#removeLayer\r\n         */\n        removeLayer: this.removeLayer.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#moveLayer\r\n         */\n        moveLayer: this.moveLayer.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#renameLayer\r\n         */\n        renameLayer: this.renameLayer.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#getLayerWeight\r\n         */\n        getLayerWeight: this.getLayerWeight.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#setLayerWeight\r\n         */\n        setLayerWeight: this.setLayerWeight.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#pauseLayerWeight\r\n         */\n        pauseLayerWeight: this.pauseLayerWeight.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#resumeLayerWeight\r\n         */\n        resumeLayerWeight: this.resumeLayerWeight.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#pauseLayer\r\n         */\n        pauseLayer: this.pauseLayer.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#resumeLayer\r\n         */\n        resumeLayer: this.resumeLayer.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#getTransitioning\r\n         */\n        getTransitioning: this.getTransitioning.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#getAnimations\r\n         */\n        getAnimations: this.getAnimations.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#getCurrentAnimation\r\n         */\n        getCurrentAnimation: this.getCurrentAnimation.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#getPaused\r\n         */\n        getPaused: this.getPaused.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#getAnimationType\r\n         */\n        getAnimationType: this.getAnimationType.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#addAnimation\r\n         */\n        addAnimation: this.addAnimation.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#removeAnimation\r\n         */\n        removeAnimation: this.removeAnimation.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#renameAnimation\r\n         */\n        renameAnimation: this.renameAnimation.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#getAnimationBlendNames\r\n         */\n        getAnimationBlendNames: this.getAnimationBlendNames.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#getAnimationBlendWeight\r\n         */\n        getAnimationBlendWeight: this.getAnimationBlendWeight.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#setAnimationBlendWeight\r\n         */\n        setAnimationBlendWeight: this.setAnimationBlendWeight.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#playAnimation\r\n         */\n        playAnimation: this.playAnimation.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#playNextAnimation\r\n         */\n        playNextAnimation: this.playNextAnimation.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#pauseAnimation\r\n         */\n        pauseAnimation: this.pauseAnimation.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#resumeAnimation\r\n         */\n        resumeAnimation: this.resumeAnimation.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#stopAnimation\r\n         */\n        stopAnimation: this.stopAnimation.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#pause\r\n         */\n        pause: this.pause.bind(this),\n\n        /**\r\n         * @memberof AnimationFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/AnimationFeature#resume\r\n         */\n        resume: this.resume.bind(this)\n      });\n    }\n    /**\r\n     * Update each animation layer.\r\n     *\r\n     * @param {number} deltaTime - Time since the last update.\r\n     */\n\n  }, {\n    key: "update",\n    value: function update(deltaTime) {\n      if (!this._layers.length) {\n        return;\n      }\n\n      if (this._paused) {\n        deltaTime = 0;\n      } // Re-evaluate internal weights for layers\n\n\n      this._updateInternalWeights(); // Update layers\n\n\n      this._layers.forEach(function (layer) {\n        layer.update(deltaTime);\n      });\n\n      AnimationFeature_get(AnimationFeature_getPrototypeOf(AnimationFeature.prototype), "update", this).call(this, deltaTime);\n    }\n  }, {\n    key: "discard",\n    value: function discard() {\n      this._layers.forEach(function (layer) {\n        layer.discard();\n      });\n\n      delete this._layers;\n      delete this._layerMap;\n\n      AnimationFeature_get(AnimationFeature_getPrototypeOf(AnimationFeature.prototype), "discard", this).call(this);\n    }\n  }]);\n\n  return AnimationFeature;\n}(core_AbstractHostFeature);\n\nObject.defineProperty(AnimationFeature, \'EVENTS\', {\n  value: AnimationFeature_objectSpread(AnimationFeature_objectSpread({}, Object.getPrototypeOf(core_AbstractHostFeature).EVENTS), {}, {\n    addLayer: \'onAddLayerEvent\',\n    removeLayer: \'onRemoveLayerEvent\',\n    renameLayer: \'onRenameLayerEvent\',\n    addAnimation: \'onAddAnimationEvent\',\n    removeAnimation: \'onRemovedAnimationEvent\',\n    renameAnimation: \'onRenameAnimationEvent\',\n    playAnimation: \'onPlayEvent\',\n    playNextAnimation: \'onNextEvent\',\n    pauseAnimation: \'onPauseEvent\',\n    resumeAnimation: \'onResumeEvent\',\n    interruptAnimation: \'onInterruptEvent\',\n    stopAnimation: \'onStopEvent\'\n  })\n});\n/* harmony default export */ const animpack_AnimationFeature = ((/* unused pure expression or super */ null && (AnimationFeature)));\n;// CONCATENATED MODULE: ./src/core/PointOfInterestFeature.js\nfunction PointOfInterestFeature_typeof(obj) { "@babel/helpers - typeof"; return PointOfInterestFeature_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, PointOfInterestFeature_typeof(obj); }\n\nfunction PointOfInterestFeature_slicedToArray(arr, i) { return PointOfInterestFeature_arrayWithHoles(arr) || PointOfInterestFeature_iterableToArrayLimit(arr, i) || PointOfInterestFeature_unsupportedIterableToArray(arr, i) || PointOfInterestFeature_nonIterableRest(); }\n\nfunction PointOfInterestFeature_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction PointOfInterestFeature_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction PointOfInterestFeature_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction PointOfInterestFeature_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction PointOfInterestFeature_toConsumableArray(arr) { return PointOfInterestFeature_arrayWithoutHoles(arr) || PointOfInterestFeature_iterableToArray(arr) || PointOfInterestFeature_unsupportedIterableToArray(arr) || PointOfInterestFeature_nonIterableSpread(); }\n\nfunction PointOfInterestFeature_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction PointOfInterestFeature_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return PointOfInterestFeature_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return PointOfInterestFeature_arrayLikeToArray(o, minLen); }\n\nfunction PointOfInterestFeature_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction PointOfInterestFeature_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return PointOfInterestFeature_arrayLikeToArray(arr); }\n\nfunction PointOfInterestFeature_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction PointOfInterestFeature_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction PointOfInterestFeature_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction PointOfInterestFeature_createClass(Constructor, protoProps, staticProps) { if (protoProps) PointOfInterestFeature_defineProperties(Constructor.prototype, protoProps); if (staticProps) PointOfInterestFeature_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction PointOfInterestFeature_get() { if (typeof Reflect !== "undefined" && Reflect.get) { PointOfInterestFeature_get = Reflect.get; } else { PointOfInterestFeature_get = function _get(target, property, receiver) { var base = PointOfInterestFeature_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return PointOfInterestFeature_get.apply(this, arguments); }\n\nfunction PointOfInterestFeature_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = PointOfInterestFeature_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction PointOfInterestFeature_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) PointOfInterestFeature_setPrototypeOf(subClass, superClass); }\n\nfunction PointOfInterestFeature_setPrototypeOf(o, p) { PointOfInterestFeature_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return PointOfInterestFeature_setPrototypeOf(o, p); }\n\nfunction PointOfInterestFeature_createSuper(Derived) { var hasNativeReflectConstruct = PointOfInterestFeature_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = PointOfInterestFeature_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = PointOfInterestFeature_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return PointOfInterestFeature_possibleConstructorReturn(this, result); }; }\n\nfunction PointOfInterestFeature_possibleConstructorReturn(self, call) { if (call && (PointOfInterestFeature_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return PointOfInterestFeature_assertThisInitialized(self); }\n\nfunction PointOfInterestFeature_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction PointOfInterestFeature_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction PointOfInterestFeature_getPrototypeOf(o) { PointOfInterestFeature_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return PointOfInterestFeature_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/* eslint-disable no-underscore-dangle */\n\n/* eslint-disable no-unused-vars */\n\n\n\n\n\n\n\n/**\r\n * Enum for axis directions.\r\n *\r\n * @readonly\r\n * @enum {Class}\r\n */\n\nvar AxisMap = {\n  PositiveX: [1, 0, 0],\n  NegativeX: [-1, 0, 0],\n  PositiveY: [0, 1, 0],\n  NegativeY: [0, -1, 0],\n  PositiveZ: [0, 0, 1],\n  NegativeZ: [0, 0, -1]\n};\nvar FaceTargetTypes = {\n  EyeCenter: 0,\n  EyeLeft: 1,\n  EyeRight: 2,\n  Mouth: 3\n}; // Average distance between pupils is .064m, golden ratio says that the distance\n// from center of the pupils to the center of the mouth should be about the same.\n\nvar FaceVectors = [[0, 0, 0], [-.032, 0, 0], [.032, 0, 0], [0, -.064, 0]]; // Time ranges to use when choosing a new random wait time between saccades\n\nvar MicroSaccadeWaitRanges = {\n  "default": [0.8, 1.75],\n  postMacro: [0.6, 1.3125]\n};\nvar MacroSaccadeWaitRanges = {\n  "default": [5.0, 8.0],\n  mouthTarget: [0.2, 0.75],\n  // Look away from a mouth target the fastest\n  eyeTarget: [1.5, 4.0]\n}; // Minimum angle in degrees the eye direction must change to trigger a blink animation\n\nvar BlinkThreshold = 35; // Maximum number of milliseconds to use for calculating look speed\n\nvar MaxDelta = 100 / 3;\n/**\r\n * PointOfInterest controls the gaze direction of the host. Given one or more\r\n * animations of type Blend2dState, it calculates the angles between the lookTracker\r\n * object (generally a joint in the host\'s skeleton) and the lookTarget (the object\r\n * the host should look at) and drives the managed Blend2dStates\' X and Y blend\r\n * values using the result. You can optionally add saccadic movement to any managed\r\n * animation to help make the host\'s eyes appear alive when focused on the same\r\n * point for exteded periods of time. If blink animations are specified, a blink\r\n * will be played during large changes in gaze direction.\r\n *\r\n * @extends AbstractHostFeature\r\n * @alias core/PointOfInterestFeature\r\n * @implements SSMLSpeechmarkInterface\r\n * @implements ManagedAnimationLayerInterface\r\n */\n\nvar PointOfInterestFeature = /*#__PURE__*/function (_AbstractHostFeature$) {\n  PointOfInterestFeature_inherits(PointOfInterestFeature, _AbstractHostFeature$);\n\n  var _super = PointOfInterestFeature_createSuper(PointOfInterestFeature);\n\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {core/HostObject} host - Host that owns the feature.\r\n   * @param {Object=} options - Options for the feature.\r\n   * @param {Object=} target - 3D transformation node that the host should try to\r\n   * look at.\r\n   * @param {Object} options.lookTracker - 3D transformation node that represents\r\n   * the direction the host is currently looking during animation.\r\n   * @param {Object=} options.scene - Engine-specific scene object that contains\r\n   * the host. This object must be defined if using \'setTargetByName\' or \'SetTargetById\'\r\n   * methods.\r\n   * @param {Object=} lookOptions - Options for the look animation layers.\r\n   * @param {number} [lookOptions.blendTime=0.1] - Default amount of time it will\r\n   * take to manipulate the weights of the look layers.\r\n   * @param {number} [lookOptions.easingFn=Quadratic.InOut] - Default easing function\r\n   * to use when manipulating look layer weights.\r\n   * @param {Array.<Object>} [lookOptions.layers=[]] - An array of layer options\r\n   * objects to register as look layers.\r\n   * @param {Object=} blinkOptions - Options for the blink animation layers.\r\n   * @param {number} [blinkOptions.blendTime=0.075] - Default amount of time it\r\n   * will take to manipulate the weights of the blink layers.\r\n   * @param {number} [blinkOptions.easingFn=Quadratic.InOut] - Default easing function\r\n   * to use when manipulating blink layer weights.\r\n   * @param {Array.<Object>} [blinkOptions.layers=[]] - An array of layer options\r\n   * objects to register as blink layers.\r\n   */\n  function PointOfInterestFeature(host) {\n    var _this;\n\n    var _ref = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n        target = _ref.target,\n        lookTracker = _ref.lookTracker,\n        scene = _ref.scene;\n\n    var _ref2 = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {},\n        _ref2$blendTime = _ref2.blendTime,\n        lookBlendTime = _ref2$blendTime === void 0 ? 0.1 : _ref2$blendTime,\n        _ref2$easingFn = _ref2.easingFn,\n        lookEasingFn = _ref2$easingFn === void 0 ? Quadratic.InOut : _ref2$easingFn,\n        _ref2$layers = _ref2.layers,\n        lookLayers = _ref2$layers === void 0 ? [] : _ref2$layers;\n\n    var _ref3 = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : {},\n        _ref3$blendTime = _ref3.blendTime,\n        blinkBlendTime = _ref3$blendTime === void 0 ? 0.075 : _ref3$blendTime,\n        _ref3$easingFn = _ref3.easingFn,\n        blinkEasingFn = _ref3$easingFn === void 0 ? Quadratic.InOut : _ref3$easingFn,\n        _ref3$layers = _ref3.layers,\n        blinkLayers = _ref3$layers === void 0 ? [] : _ref3$layers;\n\n    PointOfInterestFeature_classCallCheck(this, PointOfInterestFeature);\n\n    _this = _super.call(this, host);\n\n    if (!_this.constructor._validateTransformObject(lookTracker)) {\n      throw new Error("Cannot initialize PointOfInterestFeature on host ".concat(_this._host.id, ". LookTracker must be defined as a valid transformation object."));\n    }\n\n    _this._lookTracker = lookTracker;\n    _this._scene = scene;\n    _this._target = target || null;\n    _this._prevTargetPos = [0, 0, 0];\n    _this._isTargetMoving = false;\n    _this._lookLayers = _this._lookLayers || {};\n    _this._trackingConfigs = _this._trackingConfigs || [];\n    _this._blinkLayers = _this._blinkLayers || {}; // Register the look layers\n\n    lookLayers.forEach(function (_ref4) {\n      var name = _ref4.name,\n          animation = _ref4.animation,\n          maxSpeed = _ref4.maxSpeed,\n          reference = _ref4.reference,\n          forwardAxis = _ref4.forwardAxis,\n          hasSaccade = _ref4.hasSaccade,\n          blendTime = _ref4.blendTime,\n          easingFn = _ref4.easingFn;\n\n      _this.registerLookLayer(name, {\n        animation: animation,\n        maxSpeed: maxSpeed,\n        reference: reference,\n        forwardAxis: forwardAxis,\n        hasSaccade: hasSaccade,\n        blendTime: blendTime !== undefined ? blendTime : lookBlendTime,\n        easingFn: easingFn !== undefined ? easingFn : lookEasingFn\n      });\n    }); // Register the blink layers\n\n    blinkLayers.forEach(function (_ref5) {\n      var name = _ref5.name,\n          animation = _ref5.animation,\n          blendTime = _ref5.blendTime,\n          easingFn = _ref5.easingFn;\n\n      _this.registerBlinkLayer(name, {\n        animation: animation,\n        blendTime: blendTime !== undefined ? blendTime : blinkBlendTime,\n        easingFn: easingFn !== undefined ? easingFn : blinkEasingFn\n      });\n    });\n    return _this;\n  }\n  /**\r\n   * Gets and sets the target object the host should look at.\r\n   *\r\n   * @type {Object|null}\r\n   */\n\n\n  PointOfInterestFeature_createClass(PointOfInterestFeature, [{\n    key: "target",\n    get: function get() {\n      return this._target;\n    },\n    set: function set(target) {\n      this._target = target || null;\n    }\n    /**\r\n     * Return a vector representing the global position of an object. Should be\r\n     * overloaded for each rendering engine implementation.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {any} _obj - Engine-specific 3D transform object.\r\n     *\r\n     * @returns {Array.<number>} - An array consisting of three numbers representing\r\n     * x, y and z coordinates.\r\n     */\n\n  }, {\n    key: "_onLayerAdded",\n    value: function _onLayerAdded(_ref6) {\n      var name = _ref6.name;\n      this._lookLayers = this._lookLayers || {};\n      this._blinkLayers = this._blinkLayers || {};\n\n      PointOfInterestFeature_get(PointOfInterestFeature_getPrototypeOf(PointOfInterestFeature.prototype), "_onLayerAdded", this).call(this, {\n        name: name\n      }); // Validate the look animation\n\n\n      if (this._lookLayers[name] !== undefined) {\n        this._registerLookAnimation(name, this._lookLayers[name]);\n      }\n    }\n  }, {\n    key: "_onAnimationAdded",\n    value: function _onAnimationAdded(_ref7) {\n      var layerName = _ref7.layerName,\n          animationName = _ref7.animationName;\n      this._lookLayers = this._lookLayers || {};\n      this._blinkLayers = this._blinkLayers || {};\n\n      PointOfInterestFeature_get(PointOfInterestFeature_getPrototypeOf(PointOfInterestFeature.prototype), "_onAnimationAdded", this).call(this, {\n        layerName: layerName\n      }); // Validate the look animation\n\n\n      if (this._lookLayers[layerName] === animationName) {\n        this._registerLookAnimation(layerName, animationName);\n      }\n    }\n    /**\r\n     * Ensure that registered look animations are Blend2dStates.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} layerName - Name of the layer that contains the look animation.\r\n     * @param {string} animationName - Name of the animation.\r\n     */\n\n  }, {\n    key: "_registerLookAnimation",\n    value: function _registerLookAnimation(layerName, animationName) {\n      if (this._managedLayers[layerName].animations[animationName].isActive) {\n        if (AnimationTypes[this._host.AnimationFeature.getAnimationType(layerName, animationName)] !== AnimationTypes.blend2d) {\n          // Warn and deactivate if the registered state is not blend2d\n          console.warn("Cannot register Point of Interest look animation ".concat(animationName, " on layer ").concat(layerName, " for host ").concat(this._host.id, ". Look animations must be of type \'blend2d\'."));\n          this._managedLayers[layerName].animations[animationName].isActive = false;\n        }\n      }\n    }\n    /**\r\n     * Check if the given object is not of an engine-specific type. Should\r\n     * be overloaded for each rendering engine implementation.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {any} obj - Object to validate.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "_addTrackingConfig",\n    value:\n    /**\r\n     * Check if the given configuration object has already been stored as a tracking\r\n     * config. If it has, return the stored configuration. Otherwise, store and\r\n     * return it.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {Object} config - Object containing tracker, reference and forwardAxis\r\n     * properties.\r\n     *\r\n     * @returns {Object}\r\n     */\n    function _addTrackingConfig(config) {\n      var trackingConfig = this._trackingConfigs.find(function (c) {\n        return c.reference === config.reference && c.forwardAxis === config.forwardAxis;\n      });\n\n      if (trackingConfig) {\n        return trackingConfig;\n      } else {\n        config.angles = {\n          h: 0,\n          v: 0\n        };\n        config.prevAngles = {\n          h: 0,\n          v: 0\n        };\n\n        this._trackingConfigs.push(config);\n\n        return config;\n      }\n    }\n    /**\r\n     * Return the distance between the look tracker and the look target.\r\n     *\r\n     * @private\r\n     *\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: "_getTargetDistance",\n    value: function _getTargetDistance() {\n      // Find the vector between the global positions of tracker and target\n      var sourcePosition = this.constructor._getWorldPosition(this._lookTracker);\n\n      var targetPosition = this.constructor._getWorldPosition(this._target);\n\n      var lookVector = [targetPosition[0] - sourcePosition[0], targetPosition[1] - sourcePosition[1], targetPosition[2] - sourcePosition[2]];\n      return core_MathUtils.getVectorMagnitude(lookVector);\n    }\n    /**\r\n     * Reset all stored tracking angles to 0.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_resetLookAngles",\n    value: function _resetLookAngles() {\n      this._trackingConfigs.forEach(function (_ref8) {\n        var angles = _ref8.angles;\n        angles.h = 0;\n        angles.v = 0;\n      });\n    }\n    /**\r\n     * Store the difference in horizontal and vertical rotation for the tracker\'s\r\n     * reference rotation and the direction of the target from the tracker.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_setLookAngles",\n    value: function _setLookAngles() {\n      var _this2 = this;\n\n      // Get the current positions of the tracker and target objects\n      var targetPos = this.constructor._getWorldPosition(this._target);\n\n      var trackerPos = this.constructor._getWorldPosition(this._lookTracker); // Check if the target has moved\n\n\n      this._isTargetMoving = core_MathUtils.getVectorMagnitude([targetPos[0] - this._prevTargetPos[0], targetPos[1] - this._prevTargetPos[1], targetPos[2] - this._prevTargetPos[2]]) > 0;\n      Object.assign(this._prevTargetPos, targetPos); // Calculate the horizontal and vertical angles to rotate to the target\n\n      var targetSpherical = core_MathUtils.cartesianToSpherical(targetPos[0] - trackerPos[0], targetPos[1] - trackerPos[1], targetPos[2] - trackerPos[2]);\n\n      var targetAngles = this.constructor._sphericalToBlendValue(targetSpherical[1], targetSpherical[2]); // Calculate angles relative to the reference objects\n\n\n      this._trackingConfigs.forEach(function (_ref9) {\n        var reference = _ref9.reference,\n            forwardAxis = _ref9.forwardAxis,\n            angles = _ref9.angles;\n\n        // Calculate the horizontal and vertical angles to rotate to the direction of the tracker\n        var refDirection = _this2.constructor._getObjectDirection(reference, forwardAxis);\n\n        var refSpherical = core_MathUtils.cartesianToSpherical.apply(core_MathUtils, PointOfInterestFeature_toConsumableArray(refDirection));\n\n        var refAngles = _this2.constructor._sphericalToBlendValue(refSpherical[1], refSpherical[2]); // Store the difference\n\n\n        angles.h = targetAngles.h - refAngles.h;\n        angles.v = targetAngles.v - refAngles.v;\n      });\n    }\n    /**\r\n     * Return the horizontal and vertical angles it would require to simulate looking\r\n     * at the given type of face target\r\n     *\r\n     * @private\r\n     *\r\n     * @param {number} targetType - Integer representing the FaceTargetType.\r\n     *\r\n     * @returns {Object}- An object with signature {r: number, h: number, v: number}\r\n     * where \'r\' represents radius, h represents the horizontal/azimuthal angle and\r\n     * v represents the vertical/polar angle.\r\n     */\n\n  }, {\n    key: "_getFaceTargetAngles",\n    value: function _getFaceTargetAngles(targetType) {\n      // No offset when the target is the center of the eyes\n      if (targetType === 0) {\n        return {\n          h: 0,\n          v: 0\n        };\n      } // Build a vector to the face target type using the current distance to the target\n\n\n      var distance = this._getTargetDistance(this._lookTracker);\n\n      var faceVector = PointOfInterestFeature_toConsumableArray(FaceVectors[targetType]);\n\n      faceVector[2] = distance;\n      var spherical = core_MathUtils.cartesianToSpherical.apply(core_MathUtils, PointOfInterestFeature_toConsumableArray(faceVector)); // Make sure values are clamped within the range of motion of the human eye, in case the target is very close\n\n      var blendValues = this.constructor._sphericalToBlendValue(spherical[1], spherical[2]);\n\n      blendValues.h = core_MathUtils.clamp(blendValues.h, -35, 35);\n      blendValues.v = core_MathUtils.clamp(blendValues.v, -25, 30);\n      return blendValues;\n    }\n    /**\r\n     * Updated the stored speed and duration variables for a layer based on the\r\n     * change in horizontal and vertical angles of the tracker.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} layerName - Name of the layer to store values on.\r\n     * @param {number} h - Change in horizontal angle, in degrees.\r\n     * @param {number} v - Change in vertical angle, in degrees.\r\n     */\n\n  }, {\n    key: "_updateLayerSpeed",\n    value: function _updateLayerSpeed(layerName, h, v) {\n      var layer = this._managedLayers[layerName]; // From "Realistic Avatar and head Animation Using a Neurobiological Model of Visual Attention", Itti, Dhavale, Pighin\n\n      layer.maxHSpeed = 473 * (1 - Math.exp(-h / 7.8));\n      layer.maxVSpeed = 473 * (1 - Math.exp(-v / 7.8)); // From "Eyes Alive", Lee, Badler\n\n      var D0 = 0.025;\n      var d = 0.00235;\n      layer.hDuration = D0 + d * h;\n      layer.vDuration = D0 + d * v;\n    }\n    /**\r\n     * Set the microSaccade object with new randomized values.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} layerName - Name of the layer that owns the saccade motion.\r\n     */\n\n  }, {\n    key: "_setMicroSaccade",\n    value: function _setMicroSaccade(layerName) {\n      var layer = this._managedLayers[layerName];\n      var microSaccade = layer.microSaccade;\n\n      if (this._target) {\n        // Micro movements should be smaller when focused on a target\n        microSaccade.h = core_Utils.getRandomFloat(.01, .15);\n        microSaccade.v = core_Utils.getRandomFloat(.01, .15);\n      } else {\n        // Microsaccades. Encyclopedia of Neuroscience. (2009) Springer, Berlin, Heidelberg. https://doi.org/10.1007/978-3-540-29678-2_3492\n        microSaccade.h = core_Utils.getRandomFloat(.01, .3);\n        microSaccade.v = core_Utils.getRandomFloat(.01, .3);\n      }\n\n      this._updateLayerSpeed(layerName, microSaccade.h, microSaccade.v); // Restart the timer\n\n\n      this._initializeMicroTimer.apply(this, [layerName].concat(PointOfInterestFeature_toConsumableArray(MicroSaccadeWaitRanges["default"])));\n    }\n    /**\r\n     * Set the macroSaccade object with new randomized values.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} layerName - Name of the layer that owns the saccade motion.\r\n     */\n\n  }, {\n    key: "_setMacroSaccade",\n    value: function _setMacroSaccade(layerName) {\n      var layer = this._managedLayers[layerName];\n      var macroSaccade = layer.macroSaccade;\n      var macroSaccadeWaitRange; // Increase random value range when not focused on a target\n\n      if (!this._target) {\n        macroSaccadeWaitRange = MacroSaccadeWaitRanges["default"]; // Normal human horizontal eye rotation limit is about 35 degrees\n\n        var hLimit = core_Utils.getRandomFloat(.143, .286);\n        var hFactor = core_Utils.getRandomFloat(-hLimit, hLimit);\n        macroSaccade.h = hFactor * 35; // Normal human vertical eye rotation limit is about 25 degrees upward and 30 degrees downward\n\n        var vLimit = core_Utils.getRandomFloat(.093, .186);\n        var vFactor = core_Utils.getRandomFloat(-vLimit, vLimit);\n        macroSaccade.v = vFactor > 0 ? vFactor * 25 : vFactor * 30;\n      } // Pick a new face target\n      else {\n        // Social triangle - saccade between eyes and mouth, weighted to look at eyes more often\n        switch (layer.saccadeTarget) {\n          case 1:\n            macroSaccadeWaitRange = MacroSaccadeWaitRanges.eyeTarget;\n            layer.saccadeTarget = Math.random() < 0.75 ? FaceTargetTypes.EyeRight : FaceTargetTypes.Mouth;\n            break;\n\n          case 2:\n            macroSaccadeWaitRange = MacroSaccadeWaitRanges.eyeTarget;\n            layer.saccadeTarget = Math.random() < 0.75 ? FaceTargetTypes.EyeLeft : FaceTargetTypes.Mouth;\n            break;\n\n          case 3:\n            macroSaccadeWaitRange = MacroSaccadeWaitRanges.mouthTarget;\n            layer.saccadeTarget = Math.random() < 0.5 ? FaceTargetTypes.EyeLeft : FaceTargetTypes.EyeRight;\n            break;\n\n          case 0:\n          default:\n            macroSaccadeWaitRange = MacroSaccadeWaitRanges.eyeTarget;\n            layer.saccadeTarget = Math.random() < 0.5 ? FaceTargetTypes.EyeLeft : FaceTargetTypes.EyeRight;\n            break;\n        }\n\n        var _this$_getFaceTargetA = this._getFaceTargetAngles(layer.saccadeTarget),\n            h = _this$_getFaceTargetA.h,\n            v = _this$_getFaceTargetA.v;\n\n        macroSaccade.h = h;\n        macroSaccade.v = v;\n      }\n\n      this._updateLayerSpeed(layerName, macroSaccade.h, macroSaccade.v); // Restart the timers\n\n\n      this._initializeMicroTimer.apply(this, [layerName].concat(PointOfInterestFeature_toConsumableArray(MicroSaccadeWaitRanges.postMacro)));\n\n      this._initializeMacroTimer.apply(this, [layerName].concat(PointOfInterestFeature_toConsumableArray(macroSaccadeWaitRange)));\n    }\n    /**\r\n     * Start a new wait timer that will set a new micro saccade movement when it\r\n     * resolves.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} layerName - Name of the layer that owns the saccade motion.\r\n     * @param {number} minWaitTime - Minimum number of seconds before a new saccade\r\n     * will be triggered.\r\n     * @param {number} maxWaitTime - Maximum number of seconds before a new saccade\r\n     * will be triggered.\r\n     */\n\n  }, {\n    key: "_initializeMicroTimer",\n    value: function _initializeMicroTimer(layerName, minWaitTime, maxWaitTime) {\n      var _this3 = this;\n\n      var layer = this._managedLayers[layerName];\n      var waitTime = core_Utils.getRandomFloat(minWaitTime, maxWaitTime);\n\n      if (layer.microSaccadeTimer) {\n        layer.microSaccadeTimer.cancel();\n      }\n\n      layer.microSaccadeTimer = core_Utils.wait(waitTime, {\n        onFinish: function onFinish() {\n          _this3._setMicroSaccade(layerName);\n        }\n      });\n    }\n    /**\r\n     * Start a new wait timer that will set a new macro saccade movement when it\r\n     * resolves.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} layerName - Name of the layer that owns the saccade motion.\r\n     * @param {number} minWaitTime - Minimum number of seconds before a new saccade\r\n     * will be triggered.\r\n     * @param {number} maxWaitTime - Maximum number of seconds before a new saccade\r\n     * will be triggered.\r\n     */\n\n  }, {\n    key: "_initializeMacroTimer",\n    value: function _initializeMacroTimer(layerName, minWaitTime, maxWaitTime) {\n      var _this4 = this;\n\n      var layer = this._managedLayers[layerName];\n      var waitTime = core_Utils.getRandomFloat(minWaitTime, maxWaitTime);\n\n      if (layer.macroSaccadeTimer) {\n        layer.macroSaccadeTimer.cancel();\n      }\n\n      layer.macroSaccadeTimer = core_Utils.wait(waitTime, {\n        onFinish: function onFinish() {\n          _this4._setMacroSaccade(layerName);\n        }\n      });\n    }\n    /**\r\n     * Sets a new target to look at.\r\n     *\r\n     * @param {Object|null} target - The new target to look at.\r\n     */\n\n  }, {\n    key: "setTarget",\n    value: function setTarget(target) {\n      this.target = target;\n    }\n    /**\r\n     * Finds an object given its name and sets it as the new target to look at.\r\n     * Should be overloaded for each rendering engine implementation.\r\n     *\r\n     * @param {string} target - Name to search for.\r\n     */\n\n  }, {\n    key: "setTargetByName",\n    value: function setTargetByName(name) {\n      if (!name) {\n        this._target = null;\n      }\n\n      if (!this._scene) {\n        throw new Error("Cannot set PointOfInterestFeature target using name ".concat(name, " on host ").concat(this._host.id, ". Scene must be defined."));\n      }\n    }\n    /**\r\n     * Finds an object given its id and sets it as the new target to look at.\r\n     * Should be overloaded for each rendering engine implementation.\r\n     *\r\n     * @param {string|number} target - Id to search for.\r\n     */\n\n  }, {\n    key: "setTargetById",\n    value: function setTargetById(id) {\n      if (!id) {\n        this._target = null;\n      }\n\n      if (!this._scene) {\n        throw new Error("Cannot set PointOfInterestFeature target using id ".concat(id, " on host ").concat(this._host.id, ". Scene must be defined."));\n      }\n    }\n    /**\r\n     * Start keeping track of an animation layer that owns a blend2d animation with\r\n     * blendWeights corresponding to horizontal and vertical look angles.\r\n     *\r\n     * @param {string} layerName - Name of the layer to keep track of.\r\n     * @param {Object=} options - Options for the layer.\r\n     * @param {string} [options.animation = \'look\'] - Name of the animation on the\r\n     * layer whose blendWeights will be driven based on the angle between the lookTracker\r\n     * and the lookTarget. This animation must be of type blend2d.\r\n     * @param {number} [options.maxSpeed = 25] - The maximum speed at which the blend2d\r\n     * blendWeights can be manipulated.\r\n     * @param {string} [options.forwardAxis = \'PositiveZ\'] - Axis pointing from the\r\n     * front of the lookReference object. Valid options are \'PositiveX\', \'NegativeX\',\r\n     * \'PositiveY\', \'NegativeY\', \'PositiveZ\', \'NegativeZ\'.\r\n     * @param {Object=} options.lookReference - 3D transformation node that the lookTracker\r\n     * rotation limits should be calculated relative to. Defaults to the host owner.\r\n     * @param {number} [options.hasSaccade = false] - Whether or not to include\r\n     * saccadic motion onto the blendWeight animation. This should only be set to\r\n     * true for blend2d animations representing eye animation.\r\n     * @param {number=} [options.blendTime=[PointOfInterestFeature.DEFAULT_LAYER_OPTIONS.blendTime]{@link PointOfInterestFeature#DEFAULT_LAYER_OPTIONS#blendTime}] -\r\n     * Default amount of time to use when manipulating layer weight.\r\n     * @param {Function=} options.easingFn - Default easing function to use when\r\n     * manipulating layer weight.\r\n     */\n\n  }, {\n    key: "registerLookLayer",\n    value: function registerLookLayer(layerName) {\n      var _ref10 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref10$animation = _ref10.animation,\n          animation = _ref10$animation === void 0 ? \'look\' : _ref10$animation,\n          _ref10$maxSpeed = _ref10.maxSpeed,\n          maxSpeed = _ref10$maxSpeed === void 0 ? 25 : _ref10$maxSpeed,\n          reference = _ref10.reference,\n          _ref10$forwardAxis = _ref10.forwardAxis,\n          forwardAxis = _ref10$forwardAxis === void 0 ? \'PositiveZ\' : _ref10$forwardAxis,\n          _ref10$hasSaccade = _ref10.hasSaccade,\n          hasSaccade = _ref10$hasSaccade === void 0 ? false : _ref10$hasSaccade,\n          _ref10$blendTime = _ref10.blendTime,\n          blendTime = _ref10$blendTime === void 0 ? PointOfInterestFeature.DEFAULT_LAYER_OPTIONS.blendTime : _ref10$blendTime,\n          easingFn = _ref10.easingFn;\n\n      // Validate reference object\n      reference = reference || this._host.owner;\n\n      if (!this.constructor._validateTransformObject(reference)) {\n        throw new Error("Cannot initialize register look layer ".concat(layerName, " for PointOfInterestFeature on host ").concat(this._host.id, ". Reference must be defined as a valid transformation object."));\n      } // Find vector associated with axis string\n\n\n      forwardAxis = AxisMap[forwardAxis] !== undefined ? AxisMap[forwardAxis] : AxisMap.PositiveZ; // Store tracking configuration\n\n      var trackingConfig = this._addTrackingConfig({\n        reference: reference,\n        forwardAxis: forwardAxis\n      }); // Register the layer and animation\n\n\n      this.registerLayer(layerName, {\n        trackingConfig: trackingConfig,\n        maxSpeed: maxSpeed,\n        maxHSpeed: undefined,\n        maxVSpeed: undefined,\n        hDuration: undefined,\n        vDuration: undefined,\n        hVelocity: [0, 0],\n        vVelocity: [0, 0],\n        hasSaccade: hasSaccade,\n        blendTime: blendTime,\n        easingFn: easingFn,\n        microSaccade: {\n          h: 0,\n          v: 0\n        },\n        macroSaccade: {\n          h: 0,\n          v: 0\n        },\n        saccadeTarget: FaceTargetTypes.EyeCenter,\n        animations: PointOfInterestFeature_defineProperty({}, animation, {})\n      });\n      this._lookLayers[layerName] = animation; // Validate the look animation\n\n      this._registerLookAnimation(layerName, animation); // Initialize saccade timers\n\n\n      if (hasSaccade) {\n        var macroSaccadeWaitRange = this._target ? MacroSaccadeWaitRanges.eyeTarget : MacroSaccadeWaitRanges["default"];\n\n        this._initializeMicroTimer.apply(this, [layerName].concat(PointOfInterestFeature_toConsumableArray(MicroSaccadeWaitRanges["default"])));\n\n        this._initializeMacroTimer.apply(this, [layerName].concat(PointOfInterestFeature_toConsumableArray(macroSaccadeWaitRange)));\n      }\n    }\n    /**\r\n     * Start keeping track of an animation layer that owns a blink animation. Blink\r\n     * animations can be of any type, but if it is of type randomAnimation then a\r\n     * it will be randomized each time a blink is called.\r\n     *\r\n     * @param {string} layerName - Name of the layer to keep track of.\r\n     * @param {Object=} options - Options for the layer.\r\n     * @param {string} [options.animation = \'blink\'] - Name of the blink animation\r\n     * on the layer.\r\n     * @param {number} [options.blendTime=[PointOfInterestFeature.DEFAULT_LAYER_OPTIONS.blendTime]{@link PointOfInterestFeature#DEFAULT_LAYER_OPTIONS#blendTime}] -\r\n     * Default amount of time to use when manipulating the layer\'s weight.\r\n     * @param {Function=} options.easingFn - Default easing function to use when\r\n     * manipulating the layer\'s weight.\r\n     */\n\n  }, {\n    key: "registerBlinkLayer",\n    value: function registerBlinkLayer(layerName) {\n      var _ref11 = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {},\n          _ref11$animation = _ref11.animation,\n          animation = _ref11$animation === void 0 ? \'blink\' : _ref11$animation,\n          _ref11$blendTime = _ref11.blendTime,\n          blendTime = _ref11$blendTime === void 0 ? PointOfInterestFeature.DEFAULT_LAYER_OPTIONS.blendTime : _ref11$blendTime,\n          easingFn = _ref11.easingFn;\n\n      // Register the layer and animation\n      this.registerLayer(layerName, {\n        blendTime: blendTime,\n        easingFn: easingFn,\n        animations: PointOfInterestFeature_defineProperty({}, animation, {})\n      });\n      this._blinkLayers[layerName] = animation;\n    }\n  }, {\n    key: "update",\n    value: function update(deltaTime) {\n      var _this5 = this;\n\n      PointOfInterestFeature_get(PointOfInterestFeature_getPrototypeOf(PointOfInterestFeature.prototype), "update", this).call(this, deltaTime); // Update the look angles\n\n\n      if (this._target) {\n        this._setLookAngles();\n      } else {\n        this._resetLookAngles();\n      }\n\n      var deltaSeconds = Math.min(deltaTime, MaxDelta) / 1000;\n      var triggerBlink = false; // Set look blend values\n\n      Object.entries(this._lookLayers).forEach(function (_ref12) {\n        var _ref13 = PointOfInterestFeature_slicedToArray(_ref12, 2),\n            layerName = _ref13[0],\n            animName = _ref13[1];\n\n        var options = _this5._managedLayers[layerName]; // Increment the saccade timers\n\n        if (options.isActive && options.hasSaccade) {\n          options.microSaccadeTimer.execute(deltaTime);\n          options.macroSaccadeTimer.execute(deltaTime);\n        } // Set the blend values\n\n\n        if (options.animations[animName].isActive) {\n          var currentH = _this5._host.AnimationFeature.getAnimationBlendWeight(layerName, animName, \'X\');\n\n          var currentV = _this5._host.AnimationFeature.getAnimationBlendWeight(layerName, animName, \'Y\');\n\n          var targetH = options.trackingConfig.angles.h;\n          var targetV = options.trackingConfig.angles.v; // Check if the look angle has changed enough to trigger a blink\n\n          if (_this5._isTargetMoving && !triggerBlink) {\n            var prevTargetH = options.trackingConfig.prevAngles.h;\n            var prevTargetV = options.trackingConfig.prevAngles.v;\n            var changeAmount = core_MathUtils.toDegrees(core_MathUtils.getAngleBetween([prevTargetH, prevTargetV], [targetH, targetV]));\n\n            if (changeAmount >= BlinkThreshold) {\n              triggerBlink = true;\n            }\n          }\n\n          options.trackingConfig.prevAngles.h = targetH;\n          options.trackingConfig.prevAngles.v = targetV; // Add in the saccade movement\n\n          if (options.hasSaccade) {\n            core_MathUtils.dampValue(0, options.macroSaccade.h + options.macroSaccade.h, options.hVelocity, options.hDuration, options.maxHSpeed);\n            targetH += options.hVelocity[0];\n            core_MathUtils.dampValue(0, options.macroSaccade.v + options.macroSaccade.v, options.vVelocity, options.vDuration, options.maxVSpeed);\n            targetV += options.vVelocity[0];\n          } // Clamp to max speed\n\n\n          var factor = core_MathUtils.clamp(deltaSeconds * options.maxSpeed, 0, 1);\n          targetH = core_MathUtils.lerp(currentH, targetH, factor);\n          targetV = core_MathUtils.lerp(currentV, targetV, factor); // Update the blend values\n\n          _this5._host.AnimationFeature.setAnimationBlendWeight(layerName, animName, \'X\', targetH);\n\n          _this5._host.AnimationFeature.setAnimationBlendWeight(layerName, animName, \'Y\', targetV);\n        }\n      });\n\n      if (!triggerBlink || !this._isTargetMoving) {\n        return;\n      } // Execute blink\n\n\n      Object.entries(this._blinkLayers).forEach(function (_ref14) {\n        var _ref15 = PointOfInterestFeature_slicedToArray(_ref14, 2),\n            layerName = _ref15[0],\n            animName = _ref15[1];\n\n        var animation = _this5._managedLayers[layerName].animations[animName];\n\n        if (animation.isActive) {\n          _this5._host.AnimationFeature.playAnimation(layerName, animName);\n        }\n      });\n    }\n  }, {\n    key: "installApi",\n    value: function installApi() {\n      var _this6 = this;\n\n      /**\r\n       * @inner\r\n       * @namespace PointOfInterestFeature\r\n       */\n      var api = PointOfInterestFeature_get(PointOfInterestFeature_getPrototypeOf(PointOfInterestFeature.prototype), "installApi", this).call(this);\n\n      Object.defineProperties(api, {\n        /**\r\n         * @memberof PointOfInterestFeature\r\n         * @instance\r\n         * @see core/PointOfInterestFeature#target\r\n         */\n        target: {\n          get: function get() {\n            return _this6.target;\n          },\n          set: function set(target) {\n            _this6.target = target;\n          }\n        }\n      });\n      Object.assign(api, {\n        /**\r\n         * @memberof PointOfInterestFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/PointOfInterestFeature#registerLookLayer\r\n         */\n        registerLookLayer: this.registerLookLayer.bind(this),\n\n        /**\r\n         * @memberof PointOfInterestFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/PointOfInterestFeature#registerBlinkLayer\r\n         */\n        registerBlinkLayer: this.registerBlinkLayer.bind(this),\n\n        /**\r\n         * @memberof PointOfInterestFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/PointOfInterestFeature#setTarget\r\n         */\n        setTarget: this.setTarget.bind(this),\n\n        /**\r\n         * @memberof PointOfInterestFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/PointOfInterestFeature#setTargetByName\r\n         */\n        setTargetByName: this.setTargetByName.bind(this),\n\n        /**\r\n         * @memberof PointOfInterestFeature\r\n         * @instance\r\n         * @method\r\n         * @see core/PointOfInterestFeature#setTargetById\r\n         */\n        setTargetById: this.setTargetById.bind(this)\n      });\n      return api;\n    }\n  }], [{\n    key: "_getWorldPosition",\n    value: function _getWorldPosition(obj) {\n      return [0, 0, 0];\n    }\n    /**\r\n     * Return a matrix representing the global transformation matrix of an object.\r\n     * Should be overloaded for each rendering engine implementation.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {any} obj - Engine-specific 3D transform object.\r\n     *\r\n     * @returns {Array.<number>} - An array consisting of 16 numbers representing\r\n     * the 3d transformation.\r\n     */\n\n  }, {\n    key: "_getWorldMatrix",\n    value: function _getWorldMatrix(obj) {\n      return [1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1];\n    }\n    /**\r\n     * Rotate the given local direction vector by the object\'s world rotation matrix.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {any} obj - Engine-specific 3D transform object.\r\n     * @param {Array.<number>} forwardVector - Unit vector representing the local\r\n     * forward direction of the object.\r\n     *\r\n     * @returns {Array.<number>}\r\n     */\n\n  }, {\n    key: "_getObjectDirection",\n    value: function _getObjectDirection(obj) {\n      var forwardVector = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : AxisMap.PositiveZ;\n      var rotation = core_MathUtils.getRotationMatrix(this._getWorldMatrix(obj));\n      return core_MathUtils.rotateVector(forwardVector, rotation);\n    }\n    /**\r\n     * Calculate horizontal and vertical look angles in degrees given spherical theta\r\n     * and phi angles in radians.\r\n     *\r\n     * @param {number} theta - Vertical/polar angle in radians where 0 points directly\r\n     * along positive Y axis.\r\n     * @param {number} phi - Horizontal/azimuthal angle in radians.\r\n     *\r\n     * @returns {Object} - An object with the signature {h: number, v: number} where\r\n     * h represents horizontal rotation in degrees and v represents vertical rotation\r\n     * in degrees.\r\n     */\n\n  }, {\n    key: "_sphericalToBlendValue",\n    value: function _sphericalToBlendValue(theta, phi) {\n      var h = core_MathUtils.toDegrees(phi); // Offset the vertical angle so 0 is pointing forward instead of up\n\n      var v = core_MathUtils.toDegrees(theta) - 90; // Convert vertical angle to -180, 180 range\n\n      return {\n        h: h,\n        v: v\n      };\n    }\n  }, {\n    key: "_validateTransformObject",\n    value: function _validateTransformObject(obj) {\n      return obj instanceof Object;\n    }\n  }]);\n\n  return PointOfInterestFeature;\n}(core_AbstractHostFeature.mix(awspack_SSMLSpeechmarkInterface.Mixin, animpack_ManagedAnimationLayerInterface.Mixin));\n\n/* harmony default export */ const core_PointOfInterestFeature = ((/* unused pure expression or super */ null && (PointOfInterestFeature)));\n\n;// CONCATENATED MODULE: ./src/core/animpack/index.js\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/**\r\n * @module core/animpack\r\n */\n\n\n\n\n\n\n\n\n\n\n\n/**\r\n * @namespace\r\n */\n\nvar Easing = {\n  /**\r\n   * @see Linear\r\n   */\n  Linear: Linear,\n\n  /**\r\n   * @see Quadratic\r\n   */\n  Quadratic: Quadratic,\n\n  /**\r\n   * @see Cubic\r\n   */\n  Cubic: Cubic,\n\n  /**\r\n   * @see Quartic\r\n   */\n  Quartic: Quartic,\n\n  /**\r\n   * @see Quintic\r\n   */\n  Quintic: Quintic,\n\n  /**\r\n   * @see Sinusoidal\r\n   */\n  Sinusoidal: Sinusoidal,\n\n  /**\r\n   * @see Exponential\r\n   */\n  Exponential: Exponential,\n\n  /**\r\n   * @see Circular\r\n   */\n  Circular: Circular,\n\n  /**\r\n   * @see Elastic\r\n   */\n  Elastic: Elastic,\n\n  /**\r\n   * @see Back\r\n   */\n  Back: Back,\n\n  /**\r\n   * @see Bounce\r\n   */\n  Bounce: Bounce\n};\n\n;// CONCATENATED MODULE: ./src/core/awspack/AbstractSpeech.js\nfunction AbstractSpeech_toConsumableArray(arr) { return AbstractSpeech_arrayWithoutHoles(arr) || AbstractSpeech_iterableToArray(arr) || AbstractSpeech_unsupportedIterableToArray(arr) || AbstractSpeech_nonIterableSpread(); }\n\nfunction AbstractSpeech_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction AbstractSpeech_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return AbstractSpeech_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return AbstractSpeech_arrayLikeToArray(o, minLen); }\n\nfunction AbstractSpeech_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction AbstractSpeech_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return AbstractSpeech_arrayLikeToArray(arr); }\n\nfunction AbstractSpeech_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction AbstractSpeech_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction AbstractSpeech_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction AbstractSpeech_createClass(Constructor, protoProps, staticProps) { if (protoProps) AbstractSpeech_defineProperties(Constructor.prototype, protoProps); if (staticProps) AbstractSpeech_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/**\r\n * Class that can play back audio generated by AWS Polly and synchronized emit\r\n * speechmark messages.\r\n *\r\n * @abstract\r\n */\n\nvar AbstractSpeech = /*#__PURE__*/function () {\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {core/TextToSpeechFeature} speaker - The feature that owns the Speech and\r\n   * will emit speechmark messages.\r\n   * @param {string} text - The text of the speech.\r\n   * @param {Array.<Object>} [speechmarks=[]] - An array of speechmark objects representing\r\n   * the text and timing of the speech.\r\n   */\n  function AbstractSpeech(speaker, text) {\n    var speechmarks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n    AbstractSpeech_classCallCheck(this, AbstractSpeech);\n\n    this._speaker = speaker;\n    this._text = text;\n    this._speechmarks = speechmarks;\n    this._speechmarkOffset = 0;\n\n    this._reset();\n  }\n  /**\r\n   * Reset tracking properties.\r\n   *\r\n   * @private\r\n   *\r\n   * @param {number} [currentTime=0] - Time to use for _startTime.\r\n   */\n\n\n  AbstractSpeech_createClass(AbstractSpeech, [{\n    key: "_reset",\n    value: function _reset() {\n      var currentTime = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      this._startTime = currentTime;\n      this._localTime = 0;\n      this._pauseTime = 0;\n      this._playing = false;\n      this._markIter = this._speechmarks.values();\n\n      var _this$_markIter$next = this._markIter.next(),\n          value = _this$_markIter$next.value,\n          done = _this$_markIter$next.done;\n\n      this._currentMark = value;\n      this._endTime = this._speechmarks.length ? this._speechmarks[this._speechmarks.length - 1].time : 0;\n      this._done = done;\n      this._promise = null;\n    }\n    /**\r\n     * Create a new promise that will stop playback and emit messages for this speech.\r\n     *\r\n     * @param {Function=} onFinish - Funciton to execute once the speech stops.\r\n     * @param {onError=} onError - Function to execute if the speech encounters an\r\n     * error.\r\n     * @param {Function=} onInterrupt - Function to execute if the speech is canceled.\r\n     *\r\n     * @returns {Deferred}\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_createPromise",\n    value: function _createPromise(onFinish, onError, onInterrupt) {\n      var _this = this;\n\n      var onResolve = function onResolve(value) {\n        _this._playing = false;\n\n        _this._speaker.emit(_this._speaker.constructor.EVENTS.stop, _this);\n\n        _this._speaker.constructor.emit(_this._speaker.constructor.EVENTS.stop, _this);\n\n        if (typeof onFinish === \'function\') {\n          onFinish(value);\n        }\n      };\n\n      var onReject = function onReject(e) {\n        _this._playing = false;\n\n        _this._speaker.emit(_this._speaker.constructor.EVENTS.stop, _this);\n\n        _this._speaker.constructor.emit(_this._speaker.constructor.EVENTS.stop, _this);\n\n        console.error("".concat(_this.constructor.name, " encountered an unexpected error: ").concat(e));\n\n        if (typeof onError === \'function\') {\n          onError(e);\n        }\n      };\n\n      var onCancel = function onCancel(value) {\n        _this._playing = false;\n\n        _this._speaker.emit(_this._speaker.constructor.EVENTS.interrupt, _this);\n\n        _this._speaker.constructor.emit(_this._speaker.constructor.EVENTS.interrupt, _this);\n\n        if (typeof onInterrupt === \'function\') {\n          onInterrupt(value);\n        }\n      };\n\n      this._promise = new core_Deferred(undefined, onResolve, onReject, onCancel);\n      return this._promise;\n    }\n    /**\r\n     * Return whether or not the speech has reached it\'s end.\r\n     *\r\n     * @private\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "_checkFinished",\n    value: function _checkFinished() {\n      return this._done && this._localTime >= this._endTime;\n    }\n    /**\r\n     * Gets the playback state of the audio.\r\n     *\r\n     * @readonly\r\n     * @type {boolean}\r\n     */\n\n  }, {\n    key: "playing",\n    get: function get() {\n      return this._playing;\n    }\n    /**\r\n     * Gets the text of the speech.\r\n     *\r\n     * @readonly\r\n     * @type {string}\r\n     */\n\n  }, {\n    key: "text",\n    get: function get() {\n      return this._text;\n    }\n    /**\r\n     * Gets a shallow copy of the speechmarks array for the speech.\r\n     *\r\n     * @readonly\r\n     * @type {Array.<Object>}\r\n     */\n\n  }, {\n    key: "speechmarks",\n    get: function get() {\n      return AbstractSpeech_toConsumableArray(this._speechmarks);\n    }\n    /**\r\n     * Gets and sets the number of seconds to offset speechmark emission.\r\n     * @type {number}\r\n     */\n\n  }, {\n    key: "speechmarkOffset",\n    get: function get() {\n      return this._speechmarkOffset / 1000;\n    },\n    set: function set(offset) {\n      this._speechmarkOffset = offset * 1000; // Store as milliseconds\n    }\n    /**\r\n     * Emit speechmark messages as they are encountered in sync with audio.\r\n     *\r\n     * @param {number} currentTime - Current global time when update was called.\r\n     */\n\n  }, {\n    key: "update",\n    value: function update(currentTime) {\n      if (!this._playing) {\n        return;\n      } // Update local audio time\n\n\n      this._localTime = currentTime - this._startTime;\n\n      if (!this._done) {\n        // Emit speechmark messages for marks up to the current time\n        while (!this._done && this._currentMark.time + this._speechmarkOffset <= this._localTime) {\n          this._speaker.emit(this._speaker.constructor.EVENTS[this._currentMark.type], {\n            speech: this,\n            mark: this._currentMark\n          });\n\n          var _this$_markIter$next2 = this._markIter.next(),\n              value = _this$_markIter$next2.value,\n              done = _this$_markIter$next2.done;\n\n          this._currentMark = value;\n          this._done = done;\n        }\n      } // End playback\n\n\n      if (this._checkFinished()) {\n        this.stop();\n\n        this._reset();\n      }\n    }\n    /**\r\n     * Play the speech from the beginning.\r\n     *\r\n     * @param {number} currentTime - Current global time when play was called.\r\n     * @param {Function=} onFinish - Optional function to execute once the speech\r\n     * promise resolves.\r\n     * @param {Function=} onError - Optional function to execute if the speech\r\n     * encounters and error during playback.\r\n     * @param {Function=} onInterrupt - Optional function to execute if the speech\r\n     * is canceled.\r\n     *\r\n     * @returns {Deferred} Resolves once the speech reaches the end of playback.\r\n     */\n\n  }, {\n    key: "play",\n    value: function play(currentTime, onFinish, onError, onInterrupt) {\n      this._reset(currentTime);\n\n      this._playing = true;\n\n      this._speaker.emit(this._speaker.constructor.EVENTS.play, this);\n\n      this._speaker.constructor.emit(this._speaker.constructor.EVENTS.play, this);\n\n      return this._createPromise(onFinish, onError, onInterrupt);\n    }\n    /**\r\n     * Pause the speech at the current time.\r\n     *\r\n     * @param {number} currentTime - Current global time when pause was called.\r\n     */\n\n  }, {\n    key: "pause",\n    value: function pause(currentTime) {\n      this._playing = false;\n      this._pauseTime = currentTime;\n\n      this._speaker.emit(this._speaker.constructor.EVENTS.pause, this);\n\n      this._speaker.constructor.emit(this._speaker.constructor.EVENTS.pause, this);\n    }\n    /**\r\n     * Resume the speech at the current time.\r\n     *\r\n     * @param {number} currentTime - Current global time when resume was called.\r\n     * @param {Function=} onFinish - Optional function to execute once the speech\r\n     * promise resolves.\r\n     * @param {Function=} onError - Optional function to execute if the speech\r\n     * encounters and error during playback.\r\n     * @param {Function=} onInterrupt - Optional function to execute if the speech\r\n     * is canceled.\r\n     *\r\n     * @returns {Deferred} Resolves once the speech reaches the end of playback.\r\n     */\n\n  }, {\n    key: "resume",\n    value: function resume(currentTime, onFinish, onError, onInterrupt) {\n      // Play from the beginning if the speech hasn\'t played yet\n      if (!this._promise) {\n        this._reset(currentTime);\n\n        this._createPromise(onFinish, onError, onInterrupt);\n      }\n\n      this._playing = true;\n      this._startTime += currentTime - this._pauseTime;\n\n      this._speaker.emit(this._speaker.constructor.EVENTS.resume, this);\n\n      this._speaker.constructor.emit(this._speaker.constructor.EVENTS.resume, this);\n\n      return this._promise;\n    }\n    /**\r\n     * Cancels playback of the speech at the current time. Cancel the speech promise.\r\n     */\n\n  }, {\n    key: "cancel",\n    value: function cancel() {\n      if (this._promise) {\n        this._promise.cancel();\n\n        this._promise = null;\n      }\n\n      this._playing = false;\n    }\n    /**\r\n     * Stop the speech and reset time to the beginning. Resolve the speech promise.\r\n     */\n\n  }, {\n    key: "stop",\n    value: function stop() {\n      if (this._promise) {\n        this._promise.resolve();\n\n        this._promise = null;\n      }\n\n      this._playing = false;\n    }\n  }]);\n\n  return AbstractSpeech;\n}();\n\n/* harmony default export */ const awspack_AbstractSpeech = (AbstractSpeech);\n;// CONCATENATED MODULE: ./src/core/awspack/Speech.js\nfunction Speech_typeof(obj) { "@babel/helpers - typeof"; return Speech_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, Speech_typeof(obj); }\n\nfunction Speech_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction Speech_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction Speech_createClass(Constructor, protoProps, staticProps) { if (protoProps) Speech_defineProperties(Constructor.prototype, protoProps); if (staticProps) Speech_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction Speech_get() { if (typeof Reflect !== "undefined" && Reflect.get) { Speech_get = Reflect.get; } else { Speech_get = function _get(target, property, receiver) { var base = Speech_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return Speech_get.apply(this, arguments); }\n\nfunction Speech_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = Speech_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction Speech_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) Speech_setPrototypeOf(subClass, superClass); }\n\nfunction Speech_setPrototypeOf(o, p) { Speech_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return Speech_setPrototypeOf(o, p); }\n\nfunction Speech_createSuper(Derived) { var hasNativeReflectConstruct = Speech_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = Speech_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = Speech_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return Speech_possibleConstructorReturn(this, result); }; }\n\nfunction Speech_possibleConstructorReturn(self, call) { if (call && (Speech_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return Speech_assertThisInitialized(self); }\n\nfunction Speech_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction Speech_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction Speech_getPrototypeOf(o) { Speech_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return Speech_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/**\r\n * The built-in class for asynchronous Promises.\r\n * @external Audio\r\n * @see https://developer.mozilla.org/en-US/docs/Web/API/HTMLAudioElement/Audio\r\n */\n\n/**\r\n * @extends AbstractSpeech\r\n * @alias core/Speech\r\n */\n\nvar Speech = /*#__PURE__*/function (_AbstractSpeech) {\n  Speech_inherits(Speech, _AbstractSpeech);\n\n  var _super = Speech_createSuper(Speech);\n\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {TextToSpeech} speaker - The owner of the Speech that will emit speechmark\r\n   * messages.\r\n   * @param {string} text - The text of the speech.\r\n   * @param {Array.<Object>} [speechmarks=[]] - An array of speechmark objects representing\r\n   * the text and timing of the speech.\r\n   * @param {Object} audioConfig - Object containing audio and url.\r\n   * @param {external:Audio} audioConfig.audio - Playable audio object.\r\n   */\n  function Speech(speaker, text) {\n    var _this;\n\n    var speechmarks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n    var audioConfig = arguments.length > 3 ? arguments[3] : undefined;\n\n    Speech_classCallCheck(this, Speech);\n\n    _this = _super.call(this, speaker, text, speechmarks);\n    _this._audio = audioConfig.audio; // Keep track of whether the audio has finished playing through\n\n    _this._audio.onended = function () {\n      _this._audioFinished = true;\n    };\n\n    _this._audioFinished = true;\n    return _this;\n  }\n\n  Speech_createClass(Speech, [{\n    key: "_checkFinished",\n    value: function _checkFinished() {\n      return this._audioFinished && Speech_get(Speech_getPrototypeOf(Speech.prototype), "_checkFinished", this).call(this);\n    }\n    /**\r\n     * Gets the playable audio for the speech.\r\n     *\r\n     * @readonly\r\n     * @type {external:Audio}\r\n     */\n\n  }, {\n    key: "audio",\n    get: function get() {\n      return this._audio;\n    }\n    /**\r\n     * Gets the audio volume for the speech.\r\n     *\r\n     * @type {number}\r\n     */\n\n  }, {\n    key: "volume",\n    get: function get() {\n      return this._audio.volume;\n    }\n    /**\r\n     * Sets the audio volume for the speech.\r\n     */\n    ,\n    set: function set(volume) {\n      this._audio.volume = volume;\n    }\n    /**\r\n     * Set the audio\'s current local time and play it.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_playAudio",\n    value: function _playAudio() {\n      var _this2 = this;\n\n      if (this._speechmarkOffset < 0) {\n        this._audio.currentTime = this._speechmarkOffset;\n        setTimeout(function () {\n          if (_this2._playing) {\n            _this2._audio.currentTime = (_this2._localTime + _this2._speechmarkOffset) / 1000;\n\n            _this2._audio.play();\n          }\n        }, -this._speechmarkOffset);\n      } else {\n        this._audio.currentTime = 0;\n\n        this._audio.play();\n      }\n    }\n    /**\r\n     * Pause the audio once it is playable.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_pauseAudio",\n    value: function _pauseAudio() {\n      var _this3 = this;\n\n      this._audio.play().then(function () {\n        if (!_this3._playing) {\n          _this3._audio.pause();\n        }\n      });\n    }\n  }, {\n    key: "play",\n    value: function play(currentTime, onFinish, onError, onInterrupt) {\n      this._audioFinished = false;\n\n      this._playAudio();\n\n      return Speech_get(Speech_getPrototypeOf(Speech.prototype), "play", this).call(this, currentTime, onFinish, onError, onInterrupt);\n    }\n  }, {\n    key: "pause",\n    value: function pause(currentTime) {\n      this._pauseAudio();\n\n      Speech_get(Speech_getPrototypeOf(Speech.prototype), "pause", this).call(this, currentTime);\n    }\n  }, {\n    key: "resume",\n    value: function resume(currentTime, onFinish, onError, onInterrupt) {\n      this._audioFinished = false;\n\n      this._audio.play();\n\n      return Speech_get(Speech_getPrototypeOf(Speech.prototype), "resume", this).call(this, currentTime, onFinish, onError, onInterrupt);\n    }\n  }, {\n    key: "cancel",\n    value: function cancel() {\n      this._pauseAudio();\n\n      Speech_get(Speech_getPrototypeOf(Speech.prototype), "cancel", this).call(this);\n    }\n  }, {\n    key: "stop",\n    value: function stop() {\n      this._pauseAudio();\n\n      this._audio.currentTime = 0;\n\n      Speech_get(Speech_getPrototypeOf(Speech.prototype), "stop", this).call(this);\n    }\n  }]);\n\n  return Speech;\n}(awspack_AbstractSpeech);\n\n/* harmony default export */ const awspack_Speech = (Speech);\n;// CONCATENATED MODULE: ./src/core/awspack/TextToSpeechUtils.js\nfunction TextToSpeechUtils_toConsumableArray(arr) { return TextToSpeechUtils_arrayWithoutHoles(arr) || TextToSpeechUtils_iterableToArray(arr) || TextToSpeechUtils_unsupportedIterableToArray(arr) || TextToSpeechUtils_nonIterableSpread(); }\n\nfunction TextToSpeechUtils_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction TextToSpeechUtils_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction TextToSpeechUtils_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return TextToSpeechUtils_arrayLikeToArray(arr); }\n\nfunction TextToSpeechUtils_slicedToArray(arr, i) { return TextToSpeechUtils_arrayWithHoles(arr) || TextToSpeechUtils_iterableToArrayLimit(arr, i) || TextToSpeechUtils_unsupportedIterableToArray(arr, i) || TextToSpeechUtils_nonIterableRest(); }\n\nfunction TextToSpeechUtils_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction TextToSpeechUtils_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return TextToSpeechUtils_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return TextToSpeechUtils_arrayLikeToArray(o, minLen); }\n\nfunction TextToSpeechUtils_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction TextToSpeechUtils_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction TextToSpeechUtils_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction TextToSpeechUtils_typeof(obj) { "@babel/helpers - typeof"; return TextToSpeechUtils_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, TextToSpeechUtils_typeof(obj); }\n\nfunction TextToSpeechUtils_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction TextToSpeechUtils_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction TextToSpeechUtils_createClass(Constructor, protoProps, staticProps) { if (protoProps) TextToSpeechUtils_defineProperties(Constructor.prototype, protoProps); if (staticProps) TextToSpeechUtils_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/**\r\n * A collection of useful text-to-speech functions.\r\n *\r\n * @hideconstructor\r\n */\n\nvar TextToSpeechUtils = /*#__PURE__*/function () {\n  function TextToSpeechUtils() {\n    TextToSpeechUtils_classCallCheck(this, TextToSpeechUtils);\n  }\n\n  TextToSpeechUtils_createClass(TextToSpeechUtils, null, [{\n    key: "autoGenerateSSMLMarks",\n    value:\n    /**\r\n     * Returns a new string with SSML marks inserted based on\r\n     * matches between the input string and the input map. The\r\n     * word matches are case-insensitive. Words within existing\r\n     * SSML tags will not be affected. Input text will be surrounded\r\n     * by <speak></speak> tags if needed.\r\n     *\r\n     * @param {string} text - Input string.\r\n     * @param {object} map - Input object that maps mark keys\r\n     * to arrays of words. Example:\r\n     *\r\n     *  {\r\n     *    \'mark:sad\' : [\'sad\', \'blue\', \'down\'],\r\n     *    \'mark:happy\' : [\'joy\', \'glad\', \'great\'],\r\n     *    \'mark:no\' : [\'no\', \'nah\', \'nay\', \'sure\']\r\n     *  }\r\n     * @param {Array.<string>} [randomMarks = []] - If there are sentences that don\'t\r\n     * match any words from the map object, marks from this array will be randomly\r\n     * chosen and inserted.\r\n     *\r\n     * @returns {string} - Updated input string.\r\n     */\n    function autoGenerateSSMLMarks(text, map) {\n      var _this = this;\n\n      var randomMarks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n      if (TextToSpeechUtils_typeof(map) !== \'object\' || map === null) {\n        throw new Error("Cannot generate SSML marks for text \\"".concat(text, "\\" because map is not an object."));\n      } // process the input map into an internal format\n\n\n      var internalMap = this._processInputMap(map);\n\n      var speakTags = [\'<speak>\', \'</speak>\'];\n      var ssmlMarkRegex = /<mark name=(?:"|\')(.*?)(?:"|\')\\/>/;\n      var ssmlTagRegex = /<[^>]*>/g; // Identify any existing SSML tags\n\n      var existingTags = [];\n      var result = ssmlTagRegex.exec(text);\n\n      while (result !== null) {\n        existingTags.push({\n          start: result.index,\n          end: result.index + result[0].length,\n          text: result[0]\n        });\n        result = ssmlTagRegex.exec(text);\n      }\n\n      var chunks = [];\n      var index = 0;\n      var ssmlMarkResult;\n      var duplicateMarkToCheck = [];\n      existingTags.forEach(function (existingTag) {\n        var substr = text.slice(index, existingTag.start);\n\n        if (substr !== \'\') {\n          // auto-mark non-tag text\n          chunks.push(_this._insertMarks(substr, internalMap, duplicateMarkToCheck));\n          duplicateMarkToCheck = [];\n        }\n\n        ssmlMarkResult = ssmlMarkRegex.exec(existingTag.text);\n\n        if (ssmlMarkResult !== null) {\n          var markText = ssmlMarkResult[1];\n          duplicateMarkToCheck.push(markText);\n        } else if (!speakTags.includes(existingTag.text)) {\n          chunks.push(existingTag.text);\n        } // advance the index\n\n\n        index = existingTag.end;\n      });\n      chunks.push(this._insertMarks(text.slice(index), internalMap, duplicateMarkToCheck));\n      var markedText = chunks.join(\'\');\n\n      if (randomMarks && randomMarks.length > 0) {\n        // add random marks to any unmarked sentences\n        markedText = this.addMarksToUnmarkedSentences(markedText, randomMarks);\n      }\n\n      return TextToSpeechUtils.validateText(markedText);\n    }\n    /**\r\n     * Returns a new string with a random SSML mark inserted at each sentence that\r\n     * does not already contain an SSML mark.\r\n     *\r\n     * @param {string} text - Input string.\r\n     * @param {Array.<string>} marks - Any array of random SSML marks to choose from\r\n     * when modifying the text.\r\n     *\r\n     * @returns {string}\r\n     */\n\n  }, {\n    key: "addMarksToUnmarkedSentences",\n    value: function addMarksToUnmarkedSentences(text, marks) {\n      if (!marks || marks.length === 0) return text;\n      var ssmlMarkRegex = /<mark name=(?:"|\')(.*?)(?:"|\')\\/>/g;\n      var ssmlTagRegex = /<[^>]*>/g; // Find the indices of any marks in the text\n\n      var markIndices = [];\n      var markResult = ssmlMarkRegex.exec(text);\n\n      while (markResult !== null) {\n        markIndices.push(markResult.index);\n        markResult = ssmlMarkRegex.exec(text);\n      } // Find all SSML tags in the text\n\n\n      var existingTags = [];\n      var ssmlResult = ssmlTagRegex.exec(text);\n\n      while (ssmlResult !== null) {\n        existingTags.push({\n          start: ssmlResult.index,\n          end: ssmlResult.index + ssmlResult[0].length,\n          text: ssmlResult[0]\n        });\n        ssmlResult = ssmlTagRegex.exec(text);\n      } // Create a copy of the text with all SSML marks replaces with whitespace\n\n\n      var cleanedText = text.slice();\n      existingTags.forEach(function (existingSsml) {\n        var whitespace = new Array(existingSsml.text.length + 1).join(\' \');\n        cleanedText = [cleanedText.slice(0, existingSsml.start), whitespace, cleanedText.slice(existingSsml.end)].join(\'\');\n      });\n\n      var sentenceEndIndices = this._getSentenceEnds(cleanedText); // Only insert random marks into sentences that don\'t already have any\n\n\n      var prevIndex = 0;\n      var targetIndices = sentenceEndIndices.filter(function (index) {\n        var containsMark = markIndices.findIndex(function (markIndex) {\n          return prevIndex <= markIndex && index > markIndex;\n        }) !== -1;\n        prevIndex = index;\n        return !containsMark;\n      });\n\n      var randomMarkedText = this._insertRandomMarksAt(text, targetIndices, marks);\n\n      return randomMarkedText;\n    }\n    /**\r\n     * Generate a version of given text that is enclosed by Polly ssml speak tags.\r\n     *\r\n     * @param {string} text - The text to validate.\r\n     *\r\n     * @returns {string} - Updated input string.\r\n     */\n\n  }, {\n    key: "validateText",\n    value: function validateText(text) {\n      if (!text) {\n        text = \'<speak></speak>\';\n      } else {\n        text = text.replace(/(^\\s*<\\s*speak\\s*)>\\s*|(^\\s*)/, \'<speak>\').replace(/(\\s*<\\s*\\/\\s*speak\\s*>\\s*$|\\s*$)/, \'</speak>\');\n      }\n\n      return text;\n    }\n    /**\r\n     * Parse an input string and insert SSML marks based on\r\n     * word matches in a map.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} text - Input string.\r\n     * @param {Array.<number>} [indices = []] - An array of indices in the text input\r\n     * where random marks should be inserted.\r\n     * @param {Array.<string>} [marks = []] - An array of mark strings to choose\r\n     * from when inserting random marks.\r\n     *\r\n     * @returns {string} - Updated input string.\r\n     */\n\n  }, {\n    key: "_insertRandomMarksAt",\n    value: function _insertRandomMarksAt(text) {\n      var indices = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n      var marks = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];\n\n      if (!marks || marks.length === 0 || !indices || indices.length === 0) {\n        return text;\n      }\n\n      var offset = 0;\n      indices.forEach(function (index) {\n        var randomMark = "<mark name=\'".concat(marks[core_Utils.getRandomInt(0, marks.length)], "\'/>");\n        text = [text.slice(0, index + offset), randomMark, text.slice(index + offset)].join(\'\');\n        offset += randomMark.length;\n      });\n      return text;\n    }\n    /**\r\n     * Parses a string of text and returns an array containing the indices\r\n     * of the last character in a sentence that is not in the following list:\r\n     *  (\'.\', \'?\', \'!\')\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} text - Text to process for end of sentence\r\n     * indices.\r\n     *\r\n     * @returns {Array.<number>} - Array of end of sentence indices.\r\n     */\n\n  }, {\n    key: "_getSentenceEnds",\n    value: function _getSentenceEnds(text) {\n      var sentenceRegex = /[^.!?]+[.!?]+/g;\n      var endSentenceRegex = /[.!?]+/;\n      var result = sentenceRegex.exec(text);\n      var sentenceEnds = [];\n\n      while (result !== null) {\n        // find the last non-punctuation character\n        var punctResult = endSentenceRegex.exec(result[0]);\n        sentenceEnds.push(result.index + result[0].length - punctResult[0].length);\n        result = sentenceRegex.exec(text);\n      }\n\n      return sentenceEnds;\n    }\n    /**\r\n     * Parse an input string and insert SSML marks based on\r\n     * word matches in a map.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} text - Input string.\r\n     * @param {Map} map - Mapping of words to mark values that\r\n     * will be inserted as the value for a mark\'s \'name\' attribute.\r\n     * @param {Array} duplicatesToCheck - A list of mark values to check for duplicate against the first word\r\n     *\r\n     * @returns {string} - Updated input string.\r\n     */\n\n  }, {\n    key: "_insertMarks",\n    value: function _insertMarks(text, map, duplicatesToCheck) {\n      if (text === \'\') return text;\n      var wordRegex = /\\w+|\\s+|[^\\s\\w]+/g;\n      var lowerCaseWord;\n      var checkDuplicate = true;\n      var markedWords = text.match(wordRegex).map(function (word) {\n        lowerCaseWord = word.toLowerCase();\n\n        if (map.has(lowerCaseWord)) {\n          var marks = map.get(lowerCaseWord).map(function (mark) {\n            if (checkDuplicate) {\n              checkDuplicate = false;\n              return duplicatesToCheck.includes(mark) ? \'\' : "<mark name=\'".concat(mark, "\'/>");\n            } else {\n              return "<mark name=\'".concat(mark, "\'/>");\n            }\n          });\n          return "".concat(marks.join(\'\')).concat(word);\n        } else {\n          checkDuplicate = false;\n          return word;\n        }\n      });\n      var existingMarks = duplicatesToCheck.map(function (mark) {\n        return "<mark name=\'".concat(mark, "\'/>");\n      });\n      return "".concat(existingMarks.join(\'\')).concat(markedWords.join(\'\'));\n    }\n    /**\r\n     * Processes an input object for mapping an array\r\n     * of words to specific mark keys. Converts the input\r\n     * map into a Map with a more efficient format for\r\n     * performing mark injection.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {object} map - Input object that maps mark keys\r\n     * to arrays of words.\r\n     *\r\n     * @returns {Map} - Map for internal use.\r\n     */\n\n  }, {\n    key: "_processInputMap",\n    value: function _processInputMap(map) {\n      var internalMap = new Map();\n      var list = [];\n      Object.entries(map).forEach(function (_ref) {\n        var _ref2 = TextToSpeechUtils_slicedToArray(_ref, 2),\n            key = _ref2[0],\n            value = _ref2[1];\n\n        if (!Array.isArray(value)) {\n          throw new Error("Cannot generate SSML marks from map \\"".concat(map, "\\" because value for key \'").concat(key, "\' is not an array."));\n        }\n\n        value.forEach(function (word) {\n          var lowerCaseWord = word.toLowerCase();\n          list = internalMap.get(lowerCaseWord);\n\n          if (list !== undefined && !list.includes(key)) {\n            internalMap.set(lowerCaseWord, [].concat(TextToSpeechUtils_toConsumableArray(list), [key]));\n          } else {\n            internalMap.set(lowerCaseWord, [key]);\n          }\n        });\n      });\n      return internalMap;\n    }\n  }]);\n\n  return TextToSpeechUtils;\n}();\n\n/* harmony default export */ const awspack_TextToSpeechUtils = (TextToSpeechUtils);\n;// CONCATENATED MODULE: ./src/core/awspack/AbstractTextToSpeechFeature.js\nfunction AbstractTextToSpeechFeature_typeof(obj) { "@babel/helpers - typeof"; return AbstractTextToSpeechFeature_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, AbstractTextToSpeechFeature_typeof(obj); }\n\nfunction AbstractTextToSpeechFeature_ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction AbstractTextToSpeechFeature_objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? AbstractTextToSpeechFeature_ownKeys(Object(source), !0).forEach(function (key) { AbstractTextToSpeechFeature_defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : AbstractTextToSpeechFeature_ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nfunction AbstractTextToSpeechFeature_defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction AbstractTextToSpeechFeature_slicedToArray(arr, i) { return AbstractTextToSpeechFeature_arrayWithHoles(arr) || AbstractTextToSpeechFeature_iterableToArrayLimit(arr, i) || AbstractTextToSpeechFeature_unsupportedIterableToArray(arr, i) || AbstractTextToSpeechFeature_nonIterableRest(); }\n\nfunction AbstractTextToSpeechFeature_nonIterableRest() { throw new TypeError("Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction AbstractTextToSpeechFeature_iterableToArrayLimit(arr, i) { var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"]; if (_i == null) return; var _arr = []; var _n = true; var _d = false; var _s, _e; try { for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }\n\nfunction AbstractTextToSpeechFeature_arrayWithHoles(arr) { if (Array.isArray(arr)) return arr; }\n\nfunction AbstractTextToSpeechFeature_toConsumableArray(arr) { return AbstractTextToSpeechFeature_arrayWithoutHoles(arr) || AbstractTextToSpeechFeature_iterableToArray(arr) || AbstractTextToSpeechFeature_unsupportedIterableToArray(arr) || AbstractTextToSpeechFeature_nonIterableSpread(); }\n\nfunction AbstractTextToSpeechFeature_nonIterableSpread() { throw new TypeError("Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method."); }\n\nfunction AbstractTextToSpeechFeature_unsupportedIterableToArray(o, minLen) { if (!o) return; if (typeof o === "string") return AbstractTextToSpeechFeature_arrayLikeToArray(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return AbstractTextToSpeechFeature_arrayLikeToArray(o, minLen); }\n\nfunction AbstractTextToSpeechFeature_iterableToArray(iter) { if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) return Array.from(iter); }\n\nfunction AbstractTextToSpeechFeature_arrayWithoutHoles(arr) { if (Array.isArray(arr)) return AbstractTextToSpeechFeature_arrayLikeToArray(arr); }\n\nfunction AbstractTextToSpeechFeature_arrayLikeToArray(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }\n\nfunction AbstractTextToSpeechFeature_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction AbstractTextToSpeechFeature_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction AbstractTextToSpeechFeature_createClass(Constructor, protoProps, staticProps) { if (protoProps) AbstractTextToSpeechFeature_defineProperties(Constructor.prototype, protoProps); if (staticProps) AbstractTextToSpeechFeature_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction AbstractTextToSpeechFeature_get() { if (typeof Reflect !== "undefined" && Reflect.get) { AbstractTextToSpeechFeature_get = Reflect.get; } else { AbstractTextToSpeechFeature_get = function _get(target, property, receiver) { var base = AbstractTextToSpeechFeature_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return AbstractTextToSpeechFeature_get.apply(this, arguments); }\n\nfunction AbstractTextToSpeechFeature_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = AbstractTextToSpeechFeature_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction AbstractTextToSpeechFeature_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) AbstractTextToSpeechFeature_setPrototypeOf(subClass, superClass); }\n\nfunction AbstractTextToSpeechFeature_setPrototypeOf(o, p) { AbstractTextToSpeechFeature_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return AbstractTextToSpeechFeature_setPrototypeOf(o, p); }\n\nfunction AbstractTextToSpeechFeature_createSuper(Derived) { var hasNativeReflectConstruct = AbstractTextToSpeechFeature_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = AbstractTextToSpeechFeature_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = AbstractTextToSpeechFeature_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return AbstractTextToSpeechFeature_possibleConstructorReturn(this, result); }; }\n\nfunction AbstractTextToSpeechFeature_possibleConstructorReturn(self, call) { if (call && (AbstractTextToSpeechFeature_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return AbstractTextToSpeechFeature_assertThisInitialized(self); }\n\nfunction AbstractTextToSpeechFeature_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction AbstractTextToSpeechFeature_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction AbstractTextToSpeechFeature_getPrototypeOf(o) { AbstractTextToSpeechFeature_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return AbstractTextToSpeechFeature_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n\n\n\n/**\r\n * The Amazon Polly service object.\r\n * @external Polly\r\n * @see https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/Polly.html\r\n */\n\n/**\r\n * The presigner object that can be used to generate presigned urls for the Polly service.\r\n * @external Presigner\r\n * @see https://docs.aws.amazon.com/AWSJavaScriptSDK/latest/AWS/Polly/Presigner.html\r\n */\n// Available options for Polly\n\nvar engines = [\'standard\', \'neural\'];\nvar audioFormats = [\'mp3\', \'ogg_vorbis\', \'pcm\'];\nvar speechmarkTypes = [\'sentence\', \'ssml\', \'viseme\', \'word\'];\nvar sampleRates = {\n  mp3: {\n    rates: [\'8000\', \'16000\', \'22050\', \'24000\'],\n    defaults: {\n      standard: \'2050\',\n      neural: \'2400\'\n    }\n  },\n  pcm: {\n    rates: [\'8000\', \'16000\'],\n    defaults: {\n      standard: \'1600\',\n      neural: \'1600\'\n    }\n  }\n};\nsampleRates.ogg_vorbis = sampleRates.mp3;\nvar awsVersion;\n/**\r\n * Base class for turning text input into playable audio. There should be one instance\r\n * per speaker, each instance can play only one piece of text at a time.\r\n *\r\n * @extends AbstractHostFeature\r\n * @abstract\r\n *\r\n * @property {(number|undefined)} AWS_VERSION - Gets the version of AWS SDK being\r\n * used. Will be undefined until [initializeService]{@link AbstractTextToSpeechFeature.initializeService}\r\n * has been successfully executed.\r\n * @property {string} [POLLY_MIN_NEURAL_VERSION=\'2.503\'] - Gets the minimum version\r\n * of the AWS SDK that is necessary to use neural voices with AWS Polly.\r\n * @property {Object} POLLY_DEFAULTS - Default values to use with calls to {@link external:Polly}.\r\n * @property {string} [POLLY_DEFAULTS.Engine=\'standard\']\r\n * @property {Array.<string>} [POLLY_DEFAULTS.LexiconNames=[]]\r\n * @property {string} [POLLY_DEFAULTS.OutputFormat=\'mp3\']\r\n * @property {string} [POLLY_DEFAULTS.SampleRate=\'22050\']\r\n * @property {string} [POLLY_DEFAULTS.Text=\'\']\r\n * @property {string} [POLLY_DEFAULTS.TextType=\'ssml\']\r\n * @property {string} [POLLY_DEFAULTS.VoiceId=\'Amy\']\r\n * @property {string} [POLLY_DEFAULTS.LanguageCode=\'en-GB\']\r\n * @property {string} [POLLY_DEFAULTS.LanguageName=\'British English\']\r\n * @property {Array.<string>} [POLLY_VOICES=[]] - An array of voices available in\r\n * Polly. Will be empty until [initializeService]{@link AbstractTextToSpeechFeature.initializeService}\r\n * has been successfully executed. See [Polly Documentation]{@link https://docs.aws.amazon.com/polly/latest/dg/voicelist.html}\r\n * for a full list of available voices.\r\n * @property {Object} [POLLY_LANGUAGES={}] - An object that maps language names\r\n * to language codes that are available in Polly. Will be empty until\r\n * [initializeService]{@link AbstractTextToSpeechFeature.initializeService}\r\n * has been successfully executed. See [Polly Documentation]{@link https://docs.aws.amazon.com/polly/latest/dg/SupportedLanguage.html}\r\n * for a full list of available languages and corresponding codes.\r\n * @property {Object} [POLLY_LANGUAGE_CODES={}] - An object that maps language codes\r\n * to language names that are available in Polly. Will be empty until\r\n * [initializeService]{@link AbstractTextToSpeechFeature.initializeService}\r\n * has been successfully executed. See [Polly Documentation]{@link https://docs.aws.amazon.com/polly/latest/dg/SupportedLanguage.html}\r\n * for a full list of available languages and corresponding codes.\r\n * @property {Object} EVENTS - Built-in messages that the feature emits. When the\r\n * feature is added to a {@link core/HostObject}, event names will be prefixed by the\r\n * name of the feature class + \'.\'.\r\n * @property {string} [EVENTS.ready=onReadyEvent] - Message that is emitted after\r\n * [initializeService]{@link AbstractTextToSpeechFeature.initializeService} has been\r\n * successfully executed.\r\n * @property {string} [EVENTS.play=onPlayEvent] - Message that is emitted after\r\n * each call to [play]{@link AbstractTextToSpeechFeature#play}. The speech that was played\r\n * is supplied as an argument to listener functions.\r\n * @property {string} [EVENTS.pause=onPauseEvent] - Message that is emitted after\r\n * each call to [pause]{@link AbstractTextToSpeechFeature#pause}. The speech that was paused\r\n * is supplied as an argument to listener functions.\r\n * @property {string} [EVENTS.resume=onResumeEvent] - Message that is emitted after\r\n * each call to [resume]{@link AbstractTextToSpeechFeature#resume}. The speech that was\r\n * resumed is supplied as an argument to listener functions.\r\n * @property {string} [EVENTS.interrupt=onInterruptEvent] - Message that is emitted\r\n * if there is a current speech in progress and [play]{@link AbstractTextToSpeechFeature#play}\r\n * or [resume]{@link AbstractTextToSpeechFeature#resume} are executed for a new speech.\r\n * The speech that was interrupted is supplied as an argument to listener functions.\r\n * @property {string} [EVENTS.stop=onStopEvent] - Message that is emitted after\r\n * each call to [stop]{@link AbstractTextToSpeechFeature#stop} and when a speech reaches\r\n * the end of playback. The speech that was stopped is supplied as an argument\r\n * to listener functions.\r\n * @property {string} [EVENTS.sentence=onSentenceEvent] - Message that is emitted\r\n * each time a sentence speechmark is encountered whose timestamp matches up with\r\n * the speech audio\'s current time. The sentence speechmark object is supplied as\r\n * an argument to listener functions.\r\n * @property {string} [EVENTS.word=onWordEvent] - Message that is emitted\r\n * each time a word speechmark is encountered whose timestamp matches up with\r\n * the speech audio\'s current time. The word speechmark object is supplied as\r\n * an argument to listener functions.\r\n * @property {string} [EVENTS.viseme=onVisemeEvent] - Message that is emitted\r\n * each time a viseme speechmark is encountered whose timestamp matches up with\r\n * the speech audio\'s current time. The viseme speechmark object is supplied as\r\n * an argument to listener functions.\r\n * @property {string} [EVENTS.ssml=onSsmlEvent] - Message that is emitted\r\n * each time a ssml speechmark is encountered whose timestamp matches up with\r\n * the speech audio\'s current time. The ssml speechmark object is supplied as\r\n * an argument to listener functions.\r\n * @property {Object} SERVICES - AWS services that are necessary for the feature\r\n * to function.\r\n * @property {external:Polly} SERVICES.polly - The Polly service that is used\r\n * to synthesize speechmarks. Will be undefined until [initializeService]{@link AbstractTextToSpeechFeature.initializeService}\r\n * has been successfully executed\r\n * @property {external:Presigner} SERVICES.presigner - The Polly Presigner\r\n * object that is used to synthesize speech audio. Will be undefined until\r\n * [initializeService]{@link AbstractTextToSpeechFeature.initializeService}\r\n * has been successfully executed.\r\n */\n\nvar AbstractTextToSpeechFeature = /*#__PURE__*/function (_AbstractHostFeature) {\n  AbstractTextToSpeechFeature_inherits(AbstractTextToSpeechFeature, _AbstractHostFeature);\n\n  var _super = AbstractTextToSpeechFeature_createSuper(AbstractTextToSpeechFeature);\n\n  /**\r\n   * @constructor\r\n   *\r\n   * @param {core/HostObject} host - Host object managing the feature.\r\n   * @param {Object=} options - Options that will be sent to Polly for each speech.\r\n   * @param {string=} options.voice - The name of the Polly voice to use for all speech.\r\n   * @param {string=} options.engine - The name of the Polly engine to use for all speech.\r\n   * @param {string=} options.language - The name of the language to use for all speech.\r\n   * @param {audioFormat} [options.audioFormat=\'mp3\'] - The format to use for generated\r\n   * audio for all speeches.\r\n   * @param {string=} options.sampleRate - The sample rate for audio files for all\r\n   * speeches.\r\n   * @param {number} [options.speechmarkOffset=0] - Amount of time in seconds to\r\n   * offset speechmark event emission from the audio.\r\n   * @param {number} [options.minEndMarkDuration=.05] - The minimum amount of time\r\n   * in seconds that the last speechmark of each type in a speech can have its\r\n   * duration property set to.\r\n   * @param {number} [options.volume=1] - The default volume to play speech audio\r\n   * with.\r\n   * @param {boolean} [options.isGlobal=false] - Whether the audio source should default\r\n   * to global regardless of whether or not it is attached to an object.\r\n   */\n  function AbstractTextToSpeechFeature(host) {\n    var _this;\n\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {\n      voice: undefined,\n      engine: undefined,\n      language: undefined,\n      audioFormat: \'mp3\',\n      sampleRate: undefined,\n      speechmarkOffset: 0,\n      minEndMarkDuration: 0.05,\n      volume: 1,\n      isGlobal: false\n    };\n\n    AbstractTextToSpeechFeature_classCallCheck(this, AbstractTextToSpeechFeature);\n\n    _this = _super.call(this, host);\n    _this._speechCache = {};\n    _this._currentSpeech = null;\n    _this._currentPromise = null;\n    _this._isValidated = false;\n    _this.speechmarkOffset = Number.isNaN(Number(options.speechmarkOffset)) ? 0 : Number(options.speechmarkOffset);\n    _this.minEndMarkDuration = Number.isNaN(Number(options.minEndMarkDuration)) ? 0 : Number(options.minEndMarkDuration);\n    _this.volume = Number.isNaN(Number(options.volume)) ? 1 : Number(options.volume);\n    _this._isGlobal = options.isGlobal || false;\n    _this._promises = {\n      volume: core_Deferred.resolve()\n    };\n    _this._volumePaused = false; // Set default options for each speech\n\n    _this._voice = options.voice || _this.constructor.POLLY_DEFAULTS.VoiceId;\n    _this._language = options.language || _this.constructor.POLLY_DEFAULTS.LanguageName;\n    _this._engine = engines.includes(options.engine) ? options.engine : _this.constructor.POLLY_DEFAULTS.Engine;\n    _this._audioFormat = audioFormats.includes(options.audioFormat) ? options.audioFormat : _this.constructor.POLLY_DEFAULTS.OutputFormat;\n    _this._sampleRate = sampleRates[_this._audioFormat].rates.includes(options.sampleRate) ? options.sampleRate : _this.constructor.POLLY_DEFAULTS.SampleRate;\n    return _this;\n  }\n  /**\r\n   * Store Polly, Presigner and AWS SDK Version for use across all instances.\r\n   *\r\n   * @param {external:Polly} polly - Polly instance to use to generate speechmarks.\r\n   * @param {external:Presigner} presigner - Presigner instance to use to generate\r\n   * audio URLs.\r\n   * @param {string} version - Version of the AWS SDK to use to validate voice options.\r\n   */\n\n\n  AbstractTextToSpeechFeature_createClass(AbstractTextToSpeechFeature, [{\n    key: "currentSpeech",\n    get:\n    /**\r\n     * Gets the text of the currently playing speech.\r\n     *\r\n     * @readonly\r\n     * @type {string}\r\n     */\n    function get() {\n      if (this._currentSpeech) {\n        return this._currentSpeech.text;\n      } else {\n        return null;\n      }\n    }\n    /**\r\n     * Gets and sets the number of seconds to offset speechmark emission.\r\n     *\r\n     * @type {number}\r\n     */\n\n  }, {\n    key: "speechmarkOffset",\n    get: function get() {\n      return this._speechmarkOffset;\n    },\n    set: function set(offset) {\n      this._speechmarkOffset = offset;\n\n      if (this._currentSpeech) {\n        this._currentSpeech.speechmarkOffset = offset;\n      }\n    }\n    /**\r\n     * Gets and sets the The minimum amount of time in seconds that the last\r\n     * speechmark of each type in a speech can have its duration property set to.\r\n     *\r\n     * @type number\r\n     */\n\n  }, {\n    key: "minEndMarkDuration",\n    get: function get() {\n      return this._minEndMarkDuration / 1000;\n    },\n    set: function set(duration) {\n      this._minEndMarkDuration = duration * 1000;\n    }\n    /**\r\n     * Appends the Sumerian Hosts custom user-agent to a string if it is not\r\n     * already present.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} currentUserAgent - String to append to if needed.\r\n     *\r\n     * @returns {string}\r\n     */\n\n  }, {\n    key: "_validateEngine",\n    value:\n    /**\r\n     * Checks if a given engine type is compatible with the AWS SDK version. If it\r\n     * is, return the original value. Otherwise return a default.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} engine - The type of Polly voice engine to validate.\r\n     *\r\n     * @returns {string}\r\n     */\n    function _validateEngine(engine) {\n      // Default to the standard engine if neural is not available for this version\n      if (engine === undefined || this.constructor.AWS_VERSION < this.constructor.POLLY_MIN_NEURAL_VERSION) {\n        engine = this.constructor.POLLY_DEFAULTS.Engine;\n      }\n\n      return engine;\n    }\n    /**\r\n     * Checks if a given audio format type is compatible with Polly. If it is, return\r\n     * the original value. Otherwise return a default.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} engine - The type of Polly voice engine to validate.\r\n     *\r\n     * @returns {string}\r\n     */\n\n  }, {\n    key: "_validateFormat",\n    value: function _validateFormat(format) {\n      if (format === undefined || !audioFormats.includes(format)) {\n        format = this.constructor.POLLY_DEFAULTS.OutputFormat;\n      }\n\n      return format;\n    }\n    /**\r\n     * Checks if a given audio sampling rate is compatible with the current audio\r\n     * format. If it is, return the original value. Otherwise return a default.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} engine - The type of Polly voice engine to validate.\r\n     *\r\n     * @returns {string}\r\n     */\n\n  }, {\n    key: "_validateRate",\n    value: function _validateRate(rate) {\n      // Use default if specified sample rate is not valid for the audio format\n      if (rate === undefined || !sampleRates[this._audioFormat].rates.includes(rate)) {\n        rate = sampleRates[this._audioFormat].defaults[this._engine];\n      }\n\n      return rate;\n    }\n    /**\r\n     * Checks if a given Polly voice id is compatible with the current Polly engine.\r\n     * If it is, return the original value. Otherwise return a default.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} engine - The type of Polly voice engine to validate.\r\n     *\r\n     * @returns {string}\r\n     */\n\n  }, {\n    key: "_validateVoice",\n    value: function _validateVoice(voiceId) {\n      var voice = this.constructor.POLLY_VOICES.find(function (v) {\n        return v.Id === voiceId;\n      }); // Use the default voice if the voice isn\'t supported by the engine\n\n      if (voice === undefined || !voice.SupportedEngines.includes(this._engine)) {\n        voiceId = this.constructor.POLLY_DEFAULTS.VoiceId;\n      }\n\n      return voiceId;\n    }\n    /**\r\n     * Checks if a given Polly language is compatible with the current Polly voice.\r\n     * If it is, return the original value. Otherwise return a default.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} engine - The type of Polly voice engine to validate.\r\n     *\r\n     * @returns {string}\r\n     */\n\n  }, {\n    key: "_validateLanguage",\n    value: function _validateLanguage(language) {\n      var _this2 = this;\n\n      var voice = this.constructor.POLLY_VOICES.find(function (v) {\n        return v.Id === _this2._voice;\n      });\n      var languageCode = this.constructor.POLLY_LANGUAGES[language]; // Find the languages available for the current voice\n\n      var availableCodes = [voice.LanguageCode];\n\n      if (voice.AdditionalLanguageCodes) {\n        availableCodes.push.apply(availableCodes, AbstractTextToSpeechFeature_toConsumableArray(voice.AdditionalLanguageCodes));\n      } // If the current voice doesn\'t support the language, use its default\n\n\n      if (!availableCodes.includes(languageCode)) {\n        language = this.constructor.POLLY_LANGUAGE_CODES[voice.LanguageCode];\n      }\n\n      return language;\n    }\n    /**\r\n     * Validate the current Polly options to make sure they are compatible with each\r\n     * other.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_validate",\n    value: function _validate() {\n      // Validate speech parameters\n      this._engine = this._validateEngine(this._engine);\n      this._audioFormat = this._validateFormat(this._audioFormat);\n      this._sampleRate = this._validateRate(this._sampleRate);\n      this._voice = this._validateVoice(this._voice);\n      this._language = this._validateLanguage(this._language);\n      this._isValidated = true;\n    }\n    /**\r\n     * Return an object containing parameters compatible with Polly.synthesizeSpeech.\r\n     *\r\n     * @private\r\n     *\r\n     * @returns {Object}\r\n     */\n\n  }, {\n    key: "_getConfig",\n    value: function _getConfig() {\n      // Make sure parameters have been validated\n      if (this.constructor.isReady && !this._isValidated) {\n        this._validate();\n      } // Create a config object compatible with Polly\n\n\n      return {\n        Engine: this._engine,\n        OutputFormat: this._audioFormat,\n        SampleRate: this._sampleRate,\n        VoiceId: this._voice,\n        LanguageCode: this.constructor.POLLY_LANGUAGES[this._language]\n      };\n    }\n    /**\r\n     * Update Polly parameters with options from a given config. All stored speeches\r\n     * will be updated to use the new parameters, unless the speech text is contained\r\n     * in the \'skipSpeeches\' parameter.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {Object} config - Polly parameter options to overwrite.\r\n     * @param {Array.<string>} skipSpeeches - Text of any speeches that should not\r\n     * have parameters updated.\r\n     *\r\n     * @returns {Object}\r\n     */\n\n  }, {\n    key: "_updateConfig",\n    value: function _updateConfig(config) {\n      var _this3 = this;\n\n      var skipSpeeches = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : [];\n\n      var currentConfig = this._getConfig();\n\n      if (!config) {\n        return currentConfig;\n      }\n\n      this._isValidated = false;\n      var currentConfigStr = JSON.stringify(currentConfig); // Update options\n\n      if (config.Engine) {\n        this._engine = config.Engine;\n      }\n\n      if (config.audioFormat) {\n        this._audioFormat = config.audioFormat;\n      }\n\n      if (config.SampleRate) {\n        this._sampleRate = config.SampleRate;\n      }\n\n      if (config.VoiceId) {\n        this._voice = config.VoiceId;\n      }\n\n      if (config.Language) {\n        this._language = config.Language;\n      } // Validate the config\n\n\n      var validConfig = this._getConfig(); // Exit if nothing has changed\n\n\n      var configStr = JSON.stringify(validConfig);\n\n      if (currentConfigStr === configStr) {\n        this._isValidated = true;\n        return validConfig;\n      } // Update all cached configs\n\n\n      Object.entries(this._speechCache).forEach(function (_ref) {\n        var _ref2 = AbstractTextToSpeechFeature_slicedToArray(_ref, 2),\n            text = _ref2[0],\n            speech = _ref2[1];\n\n        // Check if this is a skipped speech\n        if (skipSpeeches.includes(text)) {\n          return;\n        }\n\n        var speechConfigStr = JSON.stringify(speech.config); // Update the speech with new parameters\n\n        if (speechConfigStr !== configStr) {\n          _this3._updateSpeech(text, validConfig);\n        }\n      });\n      return validConfig;\n    }\n    /**\r\n     * Update an existing speech, or add a new speech with new Polly parameters with\r\n     * options from a given config.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} text - The text of the speech to update.\r\n     * @param {Object} config - Polly parameter options to update.\r\n     * @param {boolean} [force=false] - Whether to force the speech to be updated\r\n     * if no parameters have changes.\r\n     *\r\n     * @returns {AbstractSpeech}\r\n     */\n\n  }, {\n    key: "_updateSpeech",\n    value: function _updateSpeech(text, config) {\n      var _this4 = this;\n\n      var force = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;\n      var speech = this._speechCache[text] || {}; // Exit if nothing has changed and force is false\n\n      if (!force && config !== undefined && speech.config && JSON.stringify(config) === JSON.stringify(speech.config)) {\n        return speech;\n      } // Create separate parameters for audio and speechmark generation\n\n\n      var audioParams = AbstractTextToSpeechFeature_objectSpread(AbstractTextToSpeechFeature_objectSpread({}, config), {}, {\n        Text: text,\n        TextType: \'ssml\'\n      });\n\n      var speechmarkParams = AbstractTextToSpeechFeature_objectSpread(AbstractTextToSpeechFeature_objectSpread({}, audioParams), {}, {\n        OutputFormat: \'json\',\n        SpeechMarkTypes: speechmarkTypes\n      }); // Generate audio and speechmarks\n\n\n      speech.config = config;\n      speech.promise = Promise.all([this._synthesizeSpeechmarks(speechmarkParams), this._synthesizeAudio(audioParams)]).then(function (results) {\n        return _this4._createSpeech.apply(_this4, [text].concat(AbstractTextToSpeechFeature_toConsumableArray(results)));\n      });\n      this._speechCache[text] = speech;\n      return speech;\n    }\n    /**\r\n     * Create a new Speech object for the speaker.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {TextToSpeech} speaker - The TextToSpeech instance that will own the speech.\r\n     * @param {string} text - Text of the speech.\r\n     * @param {Object} speechmarks - Speechmarks for the speech.\r\n     * @param {Object} audioConfig - Audio for the speech.\r\n     *\r\n     * @returns {AbstractSpeech}\r\n     */\n\n  }, {\n    key: "_createSpeech",\n    value: function _createSpeech(text, speechmarks, audioConfig) {\n      return new awspack_AbstractSpeech(this, text, speechmarks, audioConfig);\n    }\n    /**\r\n     * Create presigned URL of speech audio for the given speech text.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {Object} params - Parameters object compatible with Polly.synthesizeSpeech.\r\n     *\r\n     * @returns {Deferred} Resolves with an object containing the audio URL.\r\n     */\n\n  }, {\n    key: "_synthesizeAudio",\n    value: function _synthesizeAudio(params) {\n      var _this5 = this;\n\n      return new core_Deferred(function (resolve, reject) {\n        _this5.constructor.SERVICES.presigner.getSynthesizeSpeechUrl(params, function (error, url) {\n          if (!error) {\n            resolve({\n              url: url\n            });\n          } else {\n            reject(error);\n          }\n        });\n      });\n    }\n    /**\r\n     * Retrieves and parses speechmarks for the given speech text.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {Object} params - Parameters object compatible with Polly.synthesizeSpeech.\r\n     *\r\n     * @returns {Deferred} Resolves with an array of speechmark objects\r\n     */\n\n  }, {\n    key: "_synthesizeSpeechmarks",\n    value: function _synthesizeSpeechmarks(params) {\n      var _this6 = this;\n\n      return this.constructor.SERVICES.polly.synthesizeSpeech(params).promise().then(function (result) {\n        // Convert charcodes to string\n        var jsonString = JSON.stringify(result.AudioStream);\n        var json = JSON.parse(jsonString);\n        var dataStr = json.data.map(function (c) {\n          return String.fromCharCode(c);\n        }).join(\'\');\n        var markTypes = {\n          sentence: [],\n          word: [],\n          viseme: [],\n          ssml: []\n        };\n        var endMarkTypes = {\n          sentence: null,\n          word: null,\n          viseme: null,\n          ssml: null\n        }; // Split by enclosing {} to create speechmark objects\n\n        var speechMarks = AbstractTextToSpeechFeature_toConsumableArray(dataStr.matchAll(/\\{.*?\\}(?=\\n|$)/gm)).map(function (match) {\n          var mark = JSON.parse(match[0]); // Set the duration of the last speechmark stored matching this one\'s type\n\n          var numMarks = markTypes[mark.type].length;\n\n          if (numMarks > 0) {\n            var lastMark = markTypes[mark.type][numMarks - 1];\n            lastMark.duration = mark.time - lastMark.time;\n          }\n\n          markTypes[mark.type].push(mark);\n          endMarkTypes[mark.type] = mark;\n          return mark;\n        }); // Find the time of the latest speechmark\n\n\n        var endTimes = [];\n\n        if (endMarkTypes.sentence) {\n          endTimes.push(endMarkTypes.sentence.time);\n        }\n\n        if (endMarkTypes.word) {\n          endTimes.push(endMarkTypes.word.time);\n        }\n\n        if (endMarkTypes.viseme) {\n          endTimes.push(endMarkTypes.viseme.time);\n        }\n\n        if (endMarkTypes.ssml) {\n          endTimes.push(endMarkTypes.ssml.time);\n        }\n\n        var endTime = Math.max.apply(Math, endTimes); // Calculate duration for the ending speechMarks of each type\n\n        if (endMarkTypes.sentence) {\n          endMarkTypes.sentence.duration = Math.max(_this6._minEndMarkDuration, endTime - endMarkTypes.sentence.time);\n        }\n\n        if (endMarkTypes.word) {\n          endMarkTypes.word.duration = Math.max(_this6._minEndMarkDuration, endTime - endMarkTypes.word.time);\n        }\n\n        if (endMarkTypes.viseme) {\n          endMarkTypes.viseme.duration = Math.max(_this6._minEndMarkDuration, endTime - endMarkTypes.viseme.time);\n        }\n\n        if (endMarkTypes.ssml) {\n          endMarkTypes.ssml.duration = Math.max(_this6._minEndMarkDuration, endTime - endMarkTypes.ssml.time);\n        }\n\n        return speechMarks;\n      });\n    }\n    /**\r\n     * Returns a Speech object that has the given text.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} text - The text content of the Speech.\r\n     * @param {Object=} config - Options to update the Speech with.\r\n     *\r\n     * @returns {Deferred} Resolves with Speech or null;\r\n     */\n\n  }, {\n    key: "_getSpeech",\n    value: function _getSpeech(text, config) {\n      // Make sure AWS services exist\n      if (!this.constructor.isReady) {\n        var e = \'AWS services have not been initialized.\';\n        return core_Deferred.reject(e);\n      } // Make sure its possible to generate speeches\n\n\n      if (!text) {\n        var _e2 = \'Cannot play a speech with no text.\';\n        return core_Deferred.reject(_e2);\n      } // Update the speech with options\n\n\n      text = awspack_TextToSpeechUtils.validateText(text);\n      config = this._updateConfig(config, text);\n      return this._updateSpeech(text, config).promise;\n    }\n    /**\r\n     * Adds a namespace to the host with the name of the feature to contain properties\r\n     * and methods from the feature that users of the host need access to.\r\n     *\r\n     * @see TextToSpeechFeature\r\n     */\n\n  }, {\n    key: "installApi",\n    value: function installApi() {\n      var _this7 = this;\n\n      /**\r\n       * @inner\r\n       * @namespace TextToSpeechFeature\r\n       */\n      var api = AbstractTextToSpeechFeature_get(AbstractTextToSpeechFeature_getPrototypeOf(AbstractTextToSpeechFeature.prototype), "installApi", this).call(this);\n\n      Object.assign(api, {\n        /**\r\n         * @memberof TextToSpeechFeature\r\n         * @instance\r\n         * @method\r\n         * @see AbstractTextToSpeechFeature#play\r\n         */\n        play: this.play.bind(this),\n\n        /**\r\n         * @memberof TextToSpeechFeature\r\n         * @instance\r\n         * @method\r\n         * @see AbstractTextToSpeechFeature#pause\r\n         */\n        pause: this.pause.bind(this),\n\n        /**\r\n         * @memberof TextToSpeechFeature\r\n         * @instance\r\n         * @method\r\n         * @see AbstractTextToSpeechFeature#resume\r\n         */\n        resume: this.resume.bind(this),\n\n        /**\r\n         * @memberof TextToSpeechFeature\r\n         * @instance\r\n         * @method\r\n         * @see AbstractTextToSpeechFeature#stop\r\n         */\n        stop: this.stop.bind(this),\n\n        /**\r\n         * @memberof TextToSpeechFeature\r\n         * @instance\r\n         * @method\r\n         * @see AbstractTextToSpeechFeature#getVolume\r\n         */\n        getVolume: this.getVolume.bind(this),\n\n        /**\r\n         * @memberof TextToSpeechFeature\r\n         * @instance\r\n         * @method\r\n         * @see AbstractTextToSpeechFeature#setVolume\r\n         */\n        setVolume: this.setVolume.bind(this),\n\n        /**\r\n         * @memberof TextToSpeechFeature\r\n         * @instance\r\n         * @method\r\n         * @see AbstractTextToSpeechFeature#pauseVolume\r\n         */\n        pauseVolume: this.pauseVolume.bind(this),\n\n        /**\r\n         * @memberof TextToSpeechFeature\r\n         * @instance\r\n         * @method\r\n         * @see AbstractTextToSpeechFeature#resumeVolume\r\n         */\n        resumeVolume: this.resumeVolume.bind(this)\n      });\n      Object.defineProperties(api, {\n        /**\r\n         * @memberof TextToSpeechFeature\r\n         * @instance\r\n         * @see AbstractTextToSpeechFeature#speechmarkOffset\r\n         */\n        speechmarkOffset: {\n          get: function get() {\n            return _this7.speechmarkOffset;\n          },\n          set: function set(offset) {\n            _this7.speechmarkOffset = offset;\n          }\n        }\n      });\n      return api;\n    }\n    /**\r\n     * Gets and sets the volume used for all audio clips played by the speaker.\r\n     *\r\n     * @type {number}\r\n     */\n\n  }, {\n    key: "volume",\n    get: function get() {\n      return this._volume;\n    }\n    /**\r\n     * Gets whether or not the speaker\'s volume value is currently being tweened.\r\n     *\r\n     * @readonly\r\n     * @type {boolean}\r\n     */\n    ,\n    set: function set(volume) {\n      this._volume = core_MathUtils.clamp(volume);\n    }\n  }, {\n    key: "volumePending",\n    get: function get() {\n      return this._promises.volume && this._promises.volume.pending;\n    }\n    /**\r\n     * Gets the volume used for all audio clips played by the speaker.\r\n     *\r\n     * @returns {number}\r\n     */\n\n  }, {\n    key: "getVolume",\n    value: function getVolume() {\n      return this.volume;\n    }\n    /**\r\n     * Updates the volume used for all audio clips played by the speaker over time.\r\n     *\r\n     * @param {number} volume - Target volume value.\r\n     * @param {number} [seconds=0] - Amount of time it will take to reach the target\r\n     * volume.\r\n     * @param {Function=} easingFn - Easing function used for interpolation.\r\n     *\r\n     * @returns {Deferred}\r\n     */\n\n  }, {\n    key: "setVolume",\n    value: function setVolume(volume) {\n      var seconds = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var easingFn = arguments.length > 2 ? arguments[2] : undefined;\n\n      if (this.volumePending) {\n        this._promises.volume.cancel();\n      }\n\n      volume = core_MathUtils.clamp(volume);\n      this._promises.volume = animpack_AnimationUtils.interpolateProperty(this, \'volume\', volume, {\n        seconds: seconds,\n        easingFn: easingFn\n      });\n      return this._promises.volume;\n    }\n    /**\r\n     * Pause interpolation happening on the speaker\'s volume property.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "pauseVolume",\n    value: function pauseVolume() {\n      this._volumePaused = true;\n      return this.volumePending;\n    }\n    /**\r\n     * Resume any interpolation happening on the speaker\'s volume property.\r\n     *\r\n     * @returns {boolean}\r\n     */\n\n  }, {\n    key: "resumeVolume",\n    value: function resumeVolume() {\n      this._volumePaused = false;\n      return this.volumePending;\n    }\n    /**\r\n     * Update the currently playing speech.\r\n     *\r\n     * @param {number} deltaTime - Time since the last update.\r\n     */\n\n  }, {\n    key: "update",\n    value: function update(deltaTime) {\n      if (!this._volumePaused) {\n        this._promises.volume.execute(deltaTime);\n      }\n\n      if (this._currentSpeech && this._currentSpeech.playing) {\n        this._currentSpeech.volume = this._volume;\n\n        this._currentSpeech.update(this._host.now);\n\n        AbstractTextToSpeechFeature_get(AbstractTextToSpeechFeature_getPrototypeOf(AbstractTextToSpeechFeature.prototype), "update", this).call(this, deltaTime);\n      }\n    }\n    /**\r\n     * Set the current speech to a new asset and update the speech\'s speechmark\r\n     * offset value to match that of the feature.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {AbstractSpeech} speech - Speech to set as current.\r\n     */\n\n  }, {\n    key: "_setCurrentSpeech",\n    value: function _setCurrentSpeech(speech) {\n      speech.speechmarkOffset = this._speechmarkOffset;\n      this._currentSpeech = speech;\n    }\n    /**\r\n     * Create a promise that will play/resume a speech with the given text after\r\n     * the audio context attempts to resume and speech audio is retrieved from Polly.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {string} text - The text of the new speech to play.\r\n     * @param {Object=} config - Optional parameters for the speech.\r\n     * @param {string} [playMethod = \'play\'] - Method to execute on the resulting\r\n     * Speech object. Valid options are \'play\' and \'resume\'.\r\n     */\n\n  }, {\n    key: "_startSpeech",\n    value: function _startSpeech(text, config) {\n      var _this8 = this;\n\n      var playMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \'play\';\n\n      // If no text is provided, try to use the current speech\n      if (text === undefined && playMethod === \'resume\' && this._currentSpeech) {\n        text = this._currentSpeech.text;\n      }\n\n      var currentPromise = this._currentPromise || {\n        play: new core_Deferred(undefined, function () {\n          currentPromise.speech.cancel();\n        }, function () {\n          currentPromise.speech.cancel();\n        }, function () {\n          currentPromise.speech.cancel();\n        }),\n        speech: new core_Deferred()\n      };\n      this._currentPromise = currentPromise;\n\n      this._getSpeech(text, config).then(function (speech) {\n        // Exit if the promise is no longer pending because of user interaction\n        if (!currentPromise.play.pending) {\n          return;\n        } else if (_this8._currentPromise !== currentPromise) {\n          // Cancel if another call to play has already been made\n          currentPromise.play.cancel();\n          return;\n        } // Reset current speech when the speech ends\n\n\n        var onFinish = function onFinish() {\n          _this8._currentSpeech = null;\n          _this8._currentPromise = null;\n        }; // Cancel the currently playing speech\n\n\n        if (_this8._currentSpeech && _this8._currentSpeech.playing) {\n          if (playMethod === \'play\') {\n            _this8._currentSpeech.cancel();\n          } else if (playMethod === \'resume\' && _this8._currentSpeech.audio !== speech.audio) {\n            _this8._currentSpeech.cancel();\n          }\n        }\n\n        _this8._setCurrentSpeech(speech); // Play the speech\n\n\n        currentPromise.speech = speech[playMethod](_this8._host.now, onFinish, onFinish, onFinish);\n        currentPromise.speech.then(function () {\n          if (currentPromise.speech.resolved) {\n            currentPromise.play.resolve();\n          } else {\n            currentPromise.play.cancel();\n          }\n        })["catch"](function (error) {\n          currentPromise.play.reject(error);\n        });\n      })["catch"](function (e) {\n        e = "Cannot ".concat(playMethod, " speech ").concat(text, " on host ").concat(_this8.host.id, ". ").concat(e);\n        currentPromise.play.reject(e);\n      });\n\n      return currentPromise.play;\n    }\n    /**\r\n     * Stop any speeches currently playing and play a new speech from the beginning.\r\n     *\r\n     * @param {string} text - The text of the new speech to play.\r\n     * @param {Object=} config - Optional parameters for the speech.\r\n     *\r\n     * @returns {Deferred}\r\n     */\n\n  }, {\n    key: "play",\n    value: function play(text, config) {\n      return this._startSpeech(text, config, \'play\');\n    }\n    /**\r\n     * If a speech is currently playing, pause it at the current time.\r\n     */\n\n  }, {\n    key: "pause",\n    value: function pause() {\n      if (this._currentSpeech && this._currentSpeech.playing) {\n        this._currentSpeech.pause(this._host.now);\n      } else {\n        console.warn("Cannot pause speech on host ".concat(this.host.id, ". No speech is currently playing"));\n      }\n    }\n    /**\r\n     * Stop any speeches currently playing and resume a new speech from the current\r\n     * time.\r\n     *\r\n     * @param {string=} text - The text of the new speech to play. If undefined and\r\n     * there is a current speech that is paused, the current speech will be resumed.\r\n     * @param {Object=} config - Optional parameters for the speech.\r\n     *\r\n     * @returns {Deferred}\r\n     */\n\n  }, {\n    key: "resume",\n    value: function resume(text, config) {\n      return this._startSpeech(text, config, \'resume\');\n    }\n    /**\r\n     * If a speech is currently playing, stop playback and reset time.\r\n     */\n\n  }, {\n    key: "stop",\n    value: function stop() {\n      if (this._currentSpeech && this._currentSpeech.playing) {\n        this._currentSpeech.stop();\n\n        this._currentSpeech = null;\n      } else {\n        console.warn("Cannot stop speech on host ".concat(this.host.id, ". No speech is currently playing."));\n      }\n    }\n  }, {\n    key: "discard",\n    value: function discard() {\n      if (this._currentSpeech && this._currentSpeech.playing) {\n        this._currentSpeech.stop();\n      }\n\n      delete this._speechCache;\n\n      AbstractTextToSpeechFeature_get(AbstractTextToSpeechFeature_getPrototypeOf(AbstractTextToSpeechFeature.prototype), "discard", this).call(this);\n    }\n  }], [{\n    key: "initializeService",\n    value: function initializeService(polly, presigner, version) {\n      var _this9 = this;\n\n      // Make sure all were defined\n      if (polly === undefined || presigner === undefined || version === undefined) {\n        throw new Error(\'Cannot initialize TextToSpeech feature. All arguments must be defined.\');\n      } // Add sumerian hosts user-agent\n\n\n      if (polly.config) {\n        polly.config.customUserAgent = this._withCustomUserAgent(polly.config.customUserAgent);\n      }\n\n      if (presigner.service && presigner.service.config) {\n        presigner.service.config.customUserAgent = this._withCustomUserAgent(presigner.service.config.customUserAgent);\n      }\n\n      this._isReady = false; // Store parameters\n\n      this.SERVICES.polly = polly;\n      this.SERVICES.presigner = presigner;\n      awsVersion = version; // Clear the current polly objects\n\n      var availableVoices = this.POLLY_VOICES;\n      availableVoices.length = 0;\n      var availableLanguages = this.POLLY_LANGUAGES;\n      Object.keys(availableLanguages).forEach(function (name) {\n        delete availableLanguages[name];\n      });\n      var availableLanguageCodes = this.POLLY_LANGUAGE_CODES;\n      Object.keys(availableLanguageCodes).forEach(function (name) {\n        delete availableLanguageCodes[name];\n      }); // Re-populate according to version\n\n      var minNeuralSdk = this.POLLY_MIN_NEURAL_VERSION;\n      return this.SERVICES.polly.describeVoices().promise().then(function (response) {\n        var allCodes = {};\n        response.Voices.forEach(function (voice) {\n          if (voice.SupportedEngines.includes(\'standard\') || version >= minNeuralSdk) {\n            availableVoices.push(voice);\n          }\n\n          availableVoices.forEach(function (voice) {\n            availableLanguages[voice.LanguageName] = voice.LanguageCode;\n            allCodes[voice.LanguageCode] = voice.LanguageName;\n          });\n        });\n        Object.entries(availableLanguages).forEach(function (_ref3) {\n          var _ref4 = AbstractTextToSpeechFeature_slicedToArray(_ref3, 2),\n              name = _ref4[0],\n              code = _ref4[1];\n\n          availableLanguageCodes[code] = name;\n        }); // Notify that we\'re ready to generate speeches\n\n        _this9._isReady = true;\n\n        _this9.emit(_this9.EVENTS.ready);\n      });\n    }\n    /**\r\n     * Indicates whether or not the class is capable of generating speech audio. Polly,\r\n     * Presigner and AWS SDK version number must have been defined using\r\n     * [initializeService]{@link AbstractTextToSpeechFeature.initializeService}.\r\n     *\r\n     * @readonly\r\n     * @type {boolean}\r\n     */\n\n  }, {\n    key: "isReady",\n    get: function get() {\n      return this._isReady;\n    }\n  }, {\n    key: "_withCustomUserAgent",\n    value: function _withCustomUserAgent(currentUserAgent) {\n      var sumerianHostsUserAgent = \'request-source/SumerianHosts\';\n\n      if (currentUserAgent == null) {\n        return sumerianHostsUserAgent;\n      }\n\n      if (currentUserAgent.indexOf(sumerianHostsUserAgent) !== -1) {\n        return currentUserAgent;\n      }\n\n      return currentUserAgent.concat(\' \', sumerianHostsUserAgent);\n    }\n  }]);\n\n  return AbstractTextToSpeechFeature;\n}(core_AbstractHostFeature);\n\nObject.defineProperties(AbstractTextToSpeechFeature, {\n  AWS_VERSION: {\n    get: function get() {\n      return awsVersion;\n    }\n  },\n  POLLY_MIN_NEURAL_VERSION: {\n    value: \'2.503\',\n    writable: false\n  },\n  POLLY_DEFAULTS: {\n    value: {\n      Engine: \'standard\',\n      LexiconNames: [],\n      OutputFormat: \'mp3\',\n      SampleRate: \'22050\',\n      Text: \'\',\n      TextType: \'ssml\',\n      VoiceId: \'Amy\',\n      LanguageCode: \'en-GB\',\n      LanguageName: \'British English\'\n    },\n    writable: false\n  },\n  POLLY_VOICES: {\n    value: [],\n    writable: false\n  },\n  POLLY_LANGUAGES: {\n    value: {},\n    writable: false\n  },\n  POLLY_LANGUAGE_CODES: {\n    value: {},\n    writable: false\n  },\n  _isReady: {\n    value: false,\n    writable: true\n  },\n  EVENTS: {\n    value: AbstractTextToSpeechFeature_objectSpread(AbstractTextToSpeechFeature_objectSpread({}, Object.getPrototypeOf(AbstractTextToSpeechFeature).EVENTS), {}, {\n      ready: \'onReadyEvent\',\n      play: \'onPlayEvent\',\n      pause: \'onPauseEvent\',\n      resume: \'onResumeEvent\',\n      interrupt: \'onInterruptEvent\',\n      stop: \'onStopEvent\',\n      sentence: \'onSentenceEvent\',\n      word: \'onWordEvent\',\n      viseme: \'onVisemeEvent\',\n      ssml: \'onSsmlEvent\'\n    })\n  },\n  SERVICES: {\n    value: AbstractTextToSpeechFeature_objectSpread(AbstractTextToSpeechFeature_objectSpread({}, Object.getPrototypeOf(AbstractTextToSpeechFeature).SERVICES), {}, {\n      polly: undefined,\n      presigner: undefined\n    })\n  }\n});\n/* harmony default export */ const awspack_AbstractTextToSpeechFeature = (AbstractTextToSpeechFeature);\n;// CONCATENATED MODULE: ./src/core/awspack/TextToSpeechFeature.js\nfunction TextToSpeechFeature_typeof(obj) { "@babel/helpers - typeof"; return TextToSpeechFeature_typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (obj) { return typeof obj; } : function (obj) { return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }, TextToSpeechFeature_typeof(obj); }\n\nfunction TextToSpeechFeature_classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }\n\nfunction TextToSpeechFeature_defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction TextToSpeechFeature_createClass(Constructor, protoProps, staticProps) { if (protoProps) TextToSpeechFeature_defineProperties(Constructor.prototype, protoProps); if (staticProps) TextToSpeechFeature_defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }\n\nfunction TextToSpeechFeature_get() { if (typeof Reflect !== "undefined" && Reflect.get) { TextToSpeechFeature_get = Reflect.get; } else { TextToSpeechFeature_get = function _get(target, property, receiver) { var base = TextToSpeechFeature_superPropBase(target, property); if (!base) return; var desc = Object.getOwnPropertyDescriptor(base, property); if (desc.get) { return desc.get.call(arguments.length < 3 ? target : receiver); } return desc.value; }; } return TextToSpeechFeature_get.apply(this, arguments); }\n\nfunction TextToSpeechFeature_superPropBase(object, property) { while (!Object.prototype.hasOwnProperty.call(object, property)) { object = TextToSpeechFeature_getPrototypeOf(object); if (object === null) break; } return object; }\n\nfunction TextToSpeechFeature_inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); Object.defineProperty(subClass, "prototype", { writable: false }); if (superClass) TextToSpeechFeature_setPrototypeOf(subClass, superClass); }\n\nfunction TextToSpeechFeature_setPrototypeOf(o, p) { TextToSpeechFeature_setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return TextToSpeechFeature_setPrototypeOf(o, p); }\n\nfunction TextToSpeechFeature_createSuper(Derived) { var hasNativeReflectConstruct = TextToSpeechFeature_isNativeReflectConstruct(); return function _createSuperInternal() { var Super = TextToSpeechFeature_getPrototypeOf(Derived), result; if (hasNativeReflectConstruct) { var NewTarget = TextToSpeechFeature_getPrototypeOf(this).constructor; result = Reflect.construct(Super, arguments, NewTarget); } else { result = Super.apply(this, arguments); } return TextToSpeechFeature_possibleConstructorReturn(this, result); }; }\n\nfunction TextToSpeechFeature_possibleConstructorReturn(self, call) { if (call && (TextToSpeechFeature_typeof(call) === "object" || typeof call === "function")) { return call; } else if (call !== void 0) { throw new TypeError("Derived constructors may only return object or undefined"); } return TextToSpeechFeature_assertThisInitialized(self); }\n\nfunction TextToSpeechFeature_assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn\'t been initialised - super() hasn\'t been called"); } return self; }\n\nfunction TextToSpeechFeature_isNativeReflectConstruct() { if (typeof Reflect === "undefined" || !Reflect.construct) return false; if (Reflect.construct.sham) return false; if (typeof Proxy === "function") return true; try { Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function () {})); return true; } catch (e) { return false; } }\n\nfunction TextToSpeechFeature_getPrototypeOf(o) { TextToSpeechFeature_getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return TextToSpeechFeature_getPrototypeOf(o); }\n\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n/**\r\n * @extends AbstractTextToSpeechFeature\r\n * @alias core/TextToSpeechFeature\r\n */\n\nvar TextToSpeechFeature = /*#__PURE__*/function (_AbstractTextToSpeech) {\n  TextToSpeechFeature_inherits(TextToSpeechFeature, _AbstractTextToSpeech);\n\n  var _super = TextToSpeechFeature_createSuper(TextToSpeechFeature);\n\n  function TextToSpeechFeature() {\n    var _this;\n\n    TextToSpeechFeature_classCallCheck(this, TextToSpeechFeature);\n\n    for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {\n      args[_key] = arguments[_key];\n    }\n\n    _this = _super.call.apply(_super, [this].concat(args));\n    _this._enabled = false;\n\n    _this._setAudioContext();\n\n    _this._observeAudioContext();\n\n    return _this;\n  }\n  /**\r\n   * Store the audio context that will be used to ensure audio can be played.\r\n   *\r\n   * @private\r\n   */\n\n\n  TextToSpeechFeature_createClass(TextToSpeechFeature, [{\n    key: "_setAudioContext",\n    value: function _setAudioContext() {\n      this._audioContext = new AudioContext();\n    }\n    /**\r\n     * Listen for state changes on the audio context to determine whether the feature\r\n     * is enabled.\r\n     *\r\n     * @private\r\n     */\n\n  }, {\n    key: "_observeAudioContext",\n    value: function _observeAudioContext() {\n      var _this2 = this;\n\n      if (this._audioContext) {\n        this._audioContext.onstatechange = function () {\n          if (_this2._audioContext.state === \'running\') {\n            _this2._enabled = true;\n          } else {\n            _this2._enabled = false;\n            console.warn(\'The audio context is not running. Speech will not be able to be played until it is resumed. Use the "TextToSpeechFeature.resumeAudio" method to try to resume it after a user gesture.\');\n          }\n        };\n\n        this._audioContext.onstatechange();\n      }\n    }\n    /**\r\n     * Create an Audio object of speech audio for the given speech text.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {Object} params - Parameters object compatible with Polly.synthesizeSpeech.\r\n     *\r\n     * @returns {Promise} Resolves with an object containing the audio URL and Audio\r\n     * object.\r\n     */\n\n  }, {\n    key: "_synthesizeAudio",\n    value: function _synthesizeAudio(params) {\n      var _this3 = this;\n\n      return TextToSpeechFeature_get(TextToSpeechFeature_getPrototypeOf(TextToSpeechFeature.prototype), "_synthesizeAudio", this).call(this, params).then(function (result) {\n        var url = result.url; // Create an Audio object that points to the presigned url\n\n        var audio = new Audio(url);\n        audio.loop = _this3.loop;\n        audio.crossOrigin = \'anonymous\';\n        audio.preload = \'auto\';\n        result.audio = audio;\n        return new Promise(function (resolve) {\n          // Resolve once the minimum amount is loaded\n          audio.addEventListener(\'canplaythrough\', function () {\n            resolve(result);\n          }); // Start loading the audio\n\n          document.body.appendChild(audio);\n          audio.load();\n        });\n      });\n    }\n    /**\r\n     * Create a new Speech object for the speaker.\r\n     *\r\n     * @private\r\n     *\r\n     * @param {TextToSpeech} speaker - The TextToSpeech instance that will own the speech.\r\n     * @param {string} text - Text of the speech.\r\n     * @param {Object} speechmarks - Speechmarks for the speech.\r\n     * @param {Object} audioConfig - Audio for the speech.\r\n     *\r\n     * @returns {AbstractSpeech}\r\n     */\n\n  }, {\n    key: "_createSpeech",\n    value: function _createSpeech(text, speechmarks, audioConfig) {\n      return new awspack_Speech(this, text, speechmarks, audioConfig);\n    }\n    /**\r\n     * Gets whether or not the audio context is running and speech can be played.\r\n     *\r\n     * @readonly\r\n     * @type {boolean}\r\n     */\n\n  }, {\n    key: "enabled",\n    get: function get() {\n      return this._enabled;\n    }\n    /**\r\n     * Try to resume the audio context. This will be automatically executed each time\r\n     * speech is played or resumed. If using manually, it should be called after a\r\n     * user interaction occurs.\r\n     *\r\n     * @returns {Deferred} - Resolves once the audio context has resumed.\r\n     */\n\n  }, {\n    key: "resumeAudio",\n    value: function resumeAudio() {\n      var _this4 = this;\n\n      var promise = new core_Deferred(function (resolve, reject) {\n        _this4._audioContext.resume().then(function () {\n          _this4._enabled = true;\n          resolve();\n        })["catch"](function (e) {\n          _this4._enabled = false;\n          reject(e);\n        });\n      });\n      return promise;\n    }\n  }, {\n    key: "_startSpeech",\n    value: function _startSpeech(text, config) {\n      var _this5 = this;\n\n      var playMethod = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : \'play\';\n      var currentPromise = {\n        play: new core_Deferred(undefined, function () {\n          currentPromise.speech.cancel();\n        }, function () {\n          currentPromise.speech.cancel();\n        }, function () {\n          currentPromise.speech.cancel();\n        }),\n        speech: new core_Deferred()\n      };\n      this._currentPromise = currentPromise; // Try to start the audio context\n\n      this.resumeAudio().then(function () {\n        // Exit if the promise is no longer pending because of user interaction\n        if (!currentPromise.play.pending) {\n          return;\n        } // Cancel if another call to play has already been made\n        else if (_this5._currentPromise !== currentPromise) {\n          currentPromise.play.cancel();\n          return;\n        } // The audio context is running so the speech can be played\n\n\n        if (_this5._enabled) {\n          TextToSpeechFeature_get(TextToSpeechFeature_getPrototypeOf(TextToSpeechFeature.prototype), "_startSpeech", _this5).call(_this5, text, config, playMethod);\n        } // Reject if the audio context is not running\n        else {\n          currentPromise.reject(new Error("Cannot ".concat(playMethod, " speech on host ").concat(_this5._host.id, ". The audio context is not running. Use the \\"TextToSpeechFeature.resumeAudio\\" method to try to resume it after a user gesture.")));\n        }\n      });\n      return currentPromise.play;\n    }\n  }, {\n    key: "play",\n    value: function play(text, config) {\n      return this._startSpeech(text, config, \'play\');\n    }\n  }, {\n    key: "resume",\n    value: function resume(text, config) {\n      return this._startSpeech(text, config, \'resume\');\n    }\n  }, {\n    key: "installApi",\n    value: function installApi() {\n      var _this6 = this;\n\n      var api = TextToSpeechFeature_get(TextToSpeechFeature_getPrototypeOf(TextToSpeechFeature.prototype), "installApi", this).call(this);\n\n      Object.defineProperties(api, {\n        /**\r\n         * @memberof TextToSpeechFeature\r\n         * @instance\r\n         * @see core/TextToSpeechFeature#enabled\r\n         */\n        enabled: {\n          get: function get() {\n            return _this6._enabled;\n          }\n        }\n      });\n      return api;\n    }\n  }]);\n\n  return TextToSpeechFeature;\n}(awspack_AbstractTextToSpeechFeature);\n\n/* harmony default export */ const awspack_TextToSpeechFeature = ((/* unused pure expression or super */ null && (TextToSpeechFeature)));\n;// CONCATENATED MODULE: ./src/core/awspack/index.js\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n\n\n/**\r\n * @module core/awspack\r\n */\n\n\n;// CONCATENATED MODULE: ./src/core/index.js\n// Copyright Amazon.com, Inc. or its affiliates. All Rights Reserved.\n// SPDX-License-Identifier: MIT-0\n\n/**\r\n * @module core/HOST\r\n */\n\n\n\n\n\n\n\n\n\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QTtBQUNBO0FBRUE7QUFlQSIsInNvdXJjZXMiOlsid2VicGFjazovL0hPU1RfQ09SRS8uL3NyYy9jb3JlL0RlZmVycmVkLmpzPzY4OGUiLCJ3ZWJwYWNrOi8vSE9TVF9DT1JFLy4vc3JjL2NvcmUvVXRpbHMuanM/YmYyNCIsIndlYnBhY2s6Ly9IT1NUX0NPUkUvLi9zcmMvY29yZS9NYXRoVXRpbHMuanM/ODFlNyIsIndlYnBhY2s6Ly9IT1NUX0NPUkUvLi9zcmMvY29yZS9NZXNzZW5nZXIuanM/ZDAwNiIsIndlYnBhY2s6Ly9IT1NUX0NPUkUvLi9zcmMvY29yZS9BYnN0cmFjdEhvc3RGZWF0dXJlLmpzPzIzNmUiLCJ3ZWJwYWNrOi8vSE9TVF9DT1JFLy4vc3JjL2NvcmUvSG9zdE9iamVjdC5qcz83NWU3Iiwid2VicGFjazovL0hPU1RfQ09SRS8uL3NyYy9jb3JlL2FuaW1wYWNrL0Vhc2luZy5qcz81ODZjIiwid2VicGFjazovL0hPU1RfQ09SRS8uL3NyYy9jb3JlL0ZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2UuanM/MDZiYiIsIndlYnBhY2s6Ly9IT1NUX0NPUkUvLi9zcmMvY29yZS9hbmltcGFjay9BbmltYXRpb25GZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlLmpzPzZlNjMiLCJ3ZWJwYWNrOi8vSE9TVF9DT1JFLy4vc3JjL2NvcmUvYW5pbXBhY2svTWFuYWdlZEFuaW1hdGlvbkxheWVySW50ZXJmYWNlLmpzPzQ3ZDUiLCJ3ZWJwYWNrOi8vSE9TVF9DT1JFLy4vc3JjL2NvcmUvYXdzcGFjay9UZXh0VG9TcGVlY2hGZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlLmpzP2JjYWQiLCJ3ZWJwYWNrOi8vSE9TVF9DT1JFLy4vc3JjL2NvcmUvTGlwc3luY0ZlYXR1cmUuanM/OGQzYSIsIndlYnBhY2s6Ly9IT1NUX0NPUkUvLi9zcmMvY29yZS9hd3NwYWNrL1NTTUxTcGVlY2htYXJrSW50ZXJmYWNlLmpzP2NhNzQiLCJ3ZWJwYWNrOi8vSE9TVF9DT1JFLy4vc3JjL2NvcmUvR2VzdHVyZUZlYXR1cmUuanM/ZGIzOSIsIndlYnBhY2s6Ly9IT1NUX0NPUkUvLi9zcmMvY29yZS9hbmltcGFjay9BbmltYXRpb25VdGlscy5qcz8xMTQ4Iiwid2VicGFjazovL0hPU1RfQ09SRS8uL3NyYy9jb3JlL2FuaW1wYWNrL3N0YXRlL0Fic3RyYWN0U3RhdGUuanM/MmY4NyIsIndlYnBhY2s6Ly9IT1NUX0NPUkUvLi9zcmMvY29yZS9hbmltcGFjay9zdGF0ZS9UcmFuc2l0aW9uU3RhdGUuanM/OWU3NyIsIndlYnBhY2s6Ly9IT1NUX0NPUkUvLi9zcmMvY29yZS9hbmltcGFjay9BbmltYXRpb25QbGF5ZXJJbnRlcmZhY2UuanM/NzMzZSIsIndlYnBhY2s6Ly9IT1NUX0NPUkUvLi9zcmMvY29yZS9hbmltcGFjay9zdGF0ZS9TdGF0ZUNvbnRhaW5lckludGVyZmFjZS5qcz8yNjU5Iiwid2VicGFjazovL0hPU1RfQ09SRS8uL3NyYy9jb3JlL2FuaW1wYWNrL3N0YXRlL1F1ZXVlU3RhdGUuanM/MGM0YSIsIndlYnBhY2s6Ly9IT1NUX0NPUkUvLi9zcmMvY29yZS9hbmltcGFjay9zdGF0ZS9BYnN0cmFjdEJsZW5kU3RhdGUuanM/NjY5NyIsIndlYnBhY2s6Ly9IT1NUX0NPUkUvLi9zcmMvY29yZS9hbmltcGFjay9zdGF0ZS9GcmVlQmxlbmRTdGF0ZS5qcz9kNjc1Iiwid2VicGFjazovL0hPU1RfQ09SRS8uL3NyYy9jb3JlL2FuaW1wYWNrL3N0YXRlL0JsZW5kMWRTdGF0ZS5qcz9hNzQyIiwid2VicGFjazovL0hPU1RfQ09SRS8uL3NyYy9jb3JlL2FuaW1wYWNrL3N0YXRlL0JsZW5kMmRTdGF0ZS5qcz84MTYzIiwid2VicGFjazovL0hPU1RfQ09SRS8uL3NyYy9jb3JlL2FuaW1wYWNrL0FuaW1hdGlvbkxheWVyLmpzP2JlZWMiLCJ3ZWJwYWNrOi8vSE9TVF9DT1JFLy4vc3JjL2NvcmUvYW5pbXBhY2svc3RhdGUvU2luZ2xlU3RhdGUuanM/NGYxNCIsIndlYnBhY2s6Ly9IT1NUX0NPUkUvLi9zcmMvY29yZS9hbmltcGFjay9zdGF0ZS9SYW5kb21BbmltYXRpb25TdGF0ZS5qcz80NDkzIiwid2VicGFjazovL0hPU1RfQ09SRS8uL3NyYy9jb3JlL2FuaW1wYWNrL0FuaW1hdGlvbkZlYXR1cmUuanM/ZWJkZSIsIndlYnBhY2s6Ly9IT1NUX0NPUkUvLi9zcmMvY29yZS9Qb2ludE9mSW50ZXJlc3RGZWF0dXJlLmpzP2RlZTUiLCJ3ZWJwYWNrOi8vSE9TVF9DT1JFLy4vc3JjL2NvcmUvYW5pbXBhY2svaW5kZXguanM/OWExMiIsIndlYnBhY2s6Ly9IT1NUX0NPUkUvLi9zcmMvY29yZS9hd3NwYWNrL0Fic3RyYWN0U3BlZWNoLmpzPzdmMWMiLCJ3ZWJwYWNrOi8vSE9TVF9DT1JFLy4vc3JjL2NvcmUvYXdzcGFjay9TcGVlY2guanM/MmE0MSIsIndlYnBhY2s6Ly9IT1NUX0NPUkUvLi9zcmMvY29yZS9hd3NwYWNrL1RleHRUb1NwZWVjaFV0aWxzLmpzPzc1NWQiLCJ3ZWJwYWNrOi8vSE9TVF9DT1JFLy4vc3JjL2NvcmUvYXdzcGFjay9BYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUuanM/MzQxZiIsIndlYnBhY2s6Ly9IT1NUX0NPUkUvLi9zcmMvY29yZS9hd3NwYWNrL1RleHRUb1NwZWVjaEZlYXR1cmUuanM/NWE4NSIsIndlYnBhY2s6Ly9IT1NUX0NPUkUvLi9zcmMvY29yZS9hd3NwYWNrL2luZGV4LmpzPzNhZTAiLCJ3ZWJwYWNrOi8vSE9TVF9DT1JFLy4vc3JjL2NvcmUvaW5kZXguanM/YzdiMiJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXHJcblxyXG4vKipcclxuICogVGhlIGJ1aWx0LWluIGNsYXNzIGZvciBhc3luY2hyb25vdXMgUHJvbWlzZXMuXHJcbiAqIEBleHRlcm5hbCBQcm9taXNlXHJcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvUHJvbWlzZVxyXG4gKi9cclxuXHJcbi8qKlxyXG4gKiBBIFByb21pc2Ugb2JqZWN0IHRoYXQgY2FuIGJlIHJlc29sdmVkLCByZWplY3RlZCBvciBjYW5jZWxlZCBhdCBhbnkgdGltZSBieSB0aGVcclxuICogdXNlci5cclxuICpcclxuICogQGV4dGVuZHMgZXh0ZXJuYWw6UHJvbWlzZVxyXG4gKi9cclxuY2xhc3MgRGVmZXJyZWQgZXh0ZW5kcyBQcm9taXNlIHtcclxuICAvKipcclxuICAgKiBAY29uc3RydWN0b3JcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtleGVjdXRhYmxlPSgpID0+IHt9XSAtIFRoZSBmdW5jdGlvbiB0byBiZSBleGVjdXRlZCBieSB0aGVcclxuICAgKiBjb25zdHJ1Y3RvciwgZHVyaW5nIHRoZSBwcm9jZXNzIG9mIGNvbnN0cnVjdGluZyB0aGUgcHJvbWlzZS4gVGhlIHNpZ25hdHVyZVxyXG4gICAqIG9mIHRoaXMgaXMgZXhwZWN0ZWQgdG8gYmU6IGV4ZWN1dGFibGUoICByZXNvbHV0aW9uRnVuYywgcmVqZWN0aW9uRnVuYywgY2FuY2VsbGF0aW9uRnVuYyApLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvblJlc29sdmUgLSBPcHRpb25hbCBmdW5jdGlvbiB0byBleGVjdXRlIG9uY2UgdGhlIHByb21pc2VcclxuICAgKiBpcyByZXNvbHZlZC5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25SZWplY3QgLSBPcHRpb25hbCBmdW5jdGlvbiB0byBleGVjdXRlIG9uY2UgdGhlIHByb21pc2VcclxuICAgKiBpcyByZWplY3RlZC5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25DYW5jZWwgLSBPcHRpb25hbCBmdW5jdGlvbiB0byBleGVjdXRlIGlmIHRoZSB1c2VyIGNhbmNlbHNcclxuICAgKiB0aGUgcHJvbWlzZS4gQ2FuY2VsaW5nIHJlc3VsdHMgaW4gdGhlIHByb21pc2UgaGF2aW5nIGEgc3RhdHVzIG9mICdyZXNvbHZlZCcuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoZXhlY3V0YWJsZSA9ICgpID0+IHt9LCBvblJlc29sdmUsIG9uUmVqZWN0LCBvbkNhbmNlbCkge1xyXG4gICAgaWYgKHR5cGVvZiBleGVjdXRhYmxlICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBgQ2Fubm90IGNyZWF0ZSBuZXcgRGVmZXJyZWQuIEV4ZWN1dGFibGUgbXVzdCBiZSBhIGZ1bmN0aW9uLmBcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIG9uUmVzb2x2ZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIG9uUmVzb2x2ZSAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgYENhbm5vdCBjcmVhdGUgbmV3IERlZmVycmVkLiBPblJlc29sdmUgbXVzdCBiZSBhIGZ1bmN0aW9uLmBcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIG9uUmVqZWN0ICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygb25SZWplY3QgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGBDYW5ub3QgY3JlYXRlIG5ldyBEZWZlcnJlZC4gT25SZWplY3QgbXVzdCBiZSBhIGZ1bmN0aW9uLmBcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAodHlwZW9mIG9uQ2FuY2VsICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygb25DYW5jZWwgIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGBDYW5ub3QgY3JlYXRlIG5ldyBEZWZlcnJlZC4gT25DYW5jZWwgbXVzdCBiZSBhIGZ1bmN0aW9uLmBcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgcmVzO1xyXG4gICAgbGV0IHJlajtcclxuICAgIGxldCBjYW5jZWw7XHJcbiAgICBjb25zdCBzdGF0dXMgPSB7XHJcbiAgICAgIHJlc29sdmVkOiBmYWxzZSxcclxuICAgICAgcmVqZWN0ZWQ6IGZhbHNlLFxyXG4gICAgICBjYW5jZWxlZDogZmFsc2UsXHJcbiAgICAgIHBlbmRpbmc6IHRydWUsXHJcbiAgICB9O1xyXG5cclxuICAgIHN1cGVyKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgLy8gU3RvcmUgdGhlIHJlc29sdmVyXHJcbiAgICAgIHJlcyA9IHZhbHVlID0+IHtcclxuICAgICAgICBpZiAoc3RhdHVzLnBlbmRpbmcpIHtcclxuICAgICAgICAgIHN0YXR1cy5yZXNvbHZlZCA9IHRydWU7XHJcbiAgICAgICAgICBzdGF0dXMucGVuZGluZyA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgIGlmICh0eXBlb2Ygb25SZXNvbHZlID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgIHZhbHVlID0gb25SZXNvbHZlKHZhbHVlKTtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZSh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gU3RvcmUgdGhlIHJlamVjdGVyXHJcbiAgICAgIHJlaiA9IHZhbHVlID0+IHtcclxuICAgICAgICBpZiAoc3RhdHVzLnBlbmRpbmcpIHtcclxuICAgICAgICAgIHN0YXR1cy5yZWplY3RlZCA9IHRydWU7XHJcbiAgICAgICAgICBzdGF0dXMucGVuZGluZyA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgIGlmICh0eXBlb2Ygb25SZWplY3QgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSBvblJlamVjdCh2YWx1ZSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuIHJlamVjdCh2YWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgLy8gU3RvcmUgdGhlIGNhbmNlbGVyXHJcbiAgICAgIGNhbmNlbCA9IHZhbHVlID0+IHtcclxuICAgICAgICBpZiAoc3RhdHVzLnBlbmRpbmcpIHtcclxuICAgICAgICAgIHN0YXR1cy5jYW5jZWxlZCA9IHRydWU7XHJcbiAgICAgICAgICBzdGF0dXMucGVuZGluZyA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgIGlmICh0eXBlb2Ygb25DYW5jZWwgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgICAgdmFsdWUgPSBvbkNhbmNlbCh2YWx1ZSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUodmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfTtcclxuXHJcbiAgICAgIC8vIFJ1biB0aGUgZXhlY3V0YWJsZSB3aXRoIGN1c3RvbSByZXNvbHZlciBhbmQgcmVqZWN0ZXJcclxuICAgICAgZXhlY3V0YWJsZShyZXMsIHJlaiwgY2FuY2VsKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuX3N0YXR1cyA9IHN0YXR1cztcclxuICAgIHRoaXMuX3Jlc29sdmUgPSByZXM7XHJcbiAgICB0aGlzLl9yZWplY3QgPSByZWo7XHJcbiAgICB0aGlzLl9jYW5jZWwgPSBjYW5jZWw7XHJcbiAgICB0aGlzLl9leGVjdXRhYmxlID0gZXhlY3V0YWJsZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIHJlc29sdmVkIHN0YXRlIG9mIHRoZSBwcm9taXNlLlxyXG4gICAqXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IHJlc29sdmVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3N0YXR1cy5yZXNvbHZlZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIHJlamVjdGVkIHN0YXRlIG9mIHRoZSBwcm9taXNlLlxyXG4gICAqXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IHJlamVjdGVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3N0YXR1cy5yZWplY3RlZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIGNhbmNlbGVkIHN0YXRlIG9mIHRoZSBwcm9taXNlLlxyXG4gICAqXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICovXHJcbiAgZ2V0IGNhbmNlbGVkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3N0YXR1cy5jYW5jZWxlZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIHBlbmRpbmcgc3RhdGUgb2YgdGhlIHByb21pc2UuXHJcbiAgICpcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgcGVuZGluZygpIHtcclxuICAgIHJldHVybiB0aGlzLl9zdGF0dXMucGVuZGluZztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZvcmNlIHRoZSBwcm9taXNlIHRvIHJlc29sdmUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2FueT19IHZhbHVlIC0gVmFsdWUgdG8gcGFzcyB0byB0aGUgcmVzb2x2ZXIuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7YW55fSAtIFRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIHJlc29sdmVyIGZ1bmN0aW9uLlxyXG4gICAqL1xyXG4gIHJlc29sdmUodmFsdWUpIHtcclxuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKHZhbHVlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZvcmNlIHRoZSBwcm9taXNlIHRvIHJlamVjdC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7YW55PX0gdmFsdWUgLSBWYWx1ZSB0byBwYXNzIHRvIHRoZSByZWplY3Rlci5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHthbnl9IC0gVGhlIHJldHVybiB2YWx1ZSBvZiB0aGUgcmVqZWN0ZXIgZnVuY3Rpb24uXHJcbiAgICovXHJcbiAgcmVqZWN0KHZhbHVlKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcmVqZWN0KHZhbHVlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZvcmNlIHRoZSBwcm9taXNlIHRvIHJlc29sdmUgYW5kIHNldCB0aGUgY2FuY2VsZWQgc3RhdGUgdG8gdHJ1ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7YW55PX0gdmFsdWUgLSBWYWx1ZSB0byBwYXNzIHRvIHRoZSBjYW5jZWxsZXIuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7YW55fSAtIFRoZSByZXR1cm4gdmFsdWUgb2YgdGhlIGNhbmNlbGxlciBmdW5jdGlvbi5cclxuICAgKi9cclxuICBjYW5jZWwodmFsdWUpIHtcclxuICAgIHJldHVybiB0aGlzLl9jYW5jZWwodmFsdWUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUnVuIHRoZSBwcm9taXNlIGZ1bmN0aW9uIHRvIHRyeSB0byByZXNvbHZlIHRoZSBwcm9taXNlLiBQcm9taXNlIG11c3QgYmVcclxuICAgKiBwZW5kaW5nLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsuLi5hbnl9IGFyZ3MgLSBPcHRpb25hbCBhcmd1bWVudHMgdG8gcGFzcyBhZnRlciByZXNvbHZlIGFuZCByZWplY3QuXHJcbiAgICovXHJcbiAgZXhlY3V0ZSguLi5hcmdzKSB7XHJcbiAgICBpZiAodGhpcy5wZW5kaW5nKSB7XHJcbiAgICAgIHRoaXMuX2V4ZWN1dGFibGUodGhpcy5fcmVzb2x2ZSwgdGhpcy5fcmVqZWN0LCB0aGlzLl9jYW5jZWwsIC4uLmFyZ3MpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIGEgY2FuY2VsZWQgZGVmZXJyZWQgcHJvbWlzZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7YW55PX0gdmFsdWUgLSBWYWx1ZSB0byBjYW5jZWwgdGhlIHByb21pc2Ugd2l0aC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH1cclxuICAgKi9cclxuICBzdGF0aWMgY2FuY2VsKHZhbHVlKSB7XHJcbiAgICByZXR1cm4gbmV3IERlZmVycmVkKChfcmVzb2x2ZSwgX3JlamVjdCwgY2FuY2VsKSA9PiB7XHJcbiAgICAgIGNhbmNlbCh2YWx1ZSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiBhIG5ldyBEZWZlcnJlZCBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIG9yIHJlamVjdCBvbmNlIGFsbCBwcm9taXNlc1xyXG4gICAqIGluIHRoZSBpbnB1dCBhcnJheSBoYXZlIGJlZW4gcmVzb2x2ZWQgb3Igb25lIHByb21pc2UgaXMgY2FuY2VsZWQgb3IgcmVqZWN0ZWQuXHJcbiAgICogUHJvbWlzZXMgaW4gdGhlIGFycmF5IHRoYXQgYXJlIERlZmVycmVkIHByb21pc2VzIHdpbGwgYmUgbWFudWFsbHkgcmVzb2x2ZWQsXHJcbiAgICogcmVqZWN0ZWQgb3IgY2FuY2VsZWQgd2hlbiBjYWxsaW5nIHJlc29sdmUsIHJlamVjdCBvciBjYW5jZWwgb24gdGhlIHJldHVybiBwcm9taXNlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBcnJheS48YW55Pn0gaXRlcmFibGUgLSBBbiBpdGVyYWJsZSBzdWNoIGFzIGFuIGFycmF5LlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvblJlc29sdmUgLSBPcHRpb25hbCBmdW5jdGlvbiB0byBleGVjdXRlIG9uY2UgdGhlIHByb21pc2VcclxuICAgKiBpcyByZXNvbHZlZC5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25SZWplY3QgLSBPcHRpb25hbCBmdW5jdGlvbiB0byBleGVjdXRlIG9uY2UgdGhlIHByb21pc2VcclxuICAgKiBpcyByZWplY3RlZC5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25DYW5jZWwgLSBPcHRpb25hbCBmdW5jdGlvbiB0byBleGVjdXRlIGlmIHRoZSB1c2VyIGNhbmNlbHNcclxuICAgKiB0aGUgcHJvbWlzZS4gQ2FuY2VsaW5nIHJlc3VsdHMgaW4gdGhlIHByb21pc2UgaGF2aW5nIGEgc3RhdHVzIG9mICdjYW5jZWxlZCcuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyBEZWZlcnJlZFxyXG4gICAqL1xyXG4gIHN0YXRpYyBhbGwoaXRlcmFibGUsIG9uUmVzb2x2ZSwgb25SZWplY3QsIG9uQ2FuY2VsKSB7XHJcbiAgICBpZiAoaXRlcmFibGUgPT0gbnVsbCB8fCB0eXBlb2YgaXRlcmFibGVbU3ltYm9sLml0ZXJhdG9yXSAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBsZXQgZSA9IGBDYW5ub3QgZXhlY3V0ZSBEZWZlcnJlZC5hbGwuIEZpcnN0IGFyZ3VtZW50IG11c3QgYmUgaXRlcmFibGUuYDtcclxuXHJcbiAgICAgIGlmICh0eXBlb2Ygb25SZWplY3QgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBlID0gb25SZWplY3QoZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBEZWZlcnJlZC5yZWplY3QoZSk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgYXJyYXkgPSBbLi4uaXRlcmFibGVdO1xyXG4gICAgY29uc3QgZGVmZXJyZWQgPSBhcnJheS5maWx0ZXIoaXRlbSA9PiBpdGVtIGluc3RhbmNlb2YgRGVmZXJyZWQpO1xyXG5cclxuICAgIGNvbnN0IHJlc3VsdCA9IG5ldyBEZWZlcnJlZChcclxuICAgICAgdW5kZWZpbmVkLFxyXG4gICAgICByZXNvbHZlVmFsdWUgPT4ge1xyXG4gICAgICAgIGRlZmVycmVkLmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgICAgICBpdGVtLnJlc29sdmUocmVzb2x2ZVZhbHVlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgICBkZWZlcnJlZC5sZW5ndGggPSAwO1xyXG5cclxuICAgICAgICBpZiAodHlwZW9mIG9uUmVzb2x2ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgcmV0dXJuIG9uUmVzb2x2ZShyZXNvbHZlVmFsdWUpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm4gcmVzb2x2ZVZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgZXJyb3IgPT4ge1xyXG4gICAgICAgIGRlZmVycmVkLmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgICAgICBpdGVtLnJlamVjdChlcnJvcik7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZGVmZXJyZWQubGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBvblJlamVjdCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgcmV0dXJuIG9uUmVqZWN0KGVycm9yKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIGVycm9yO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgY2FuY2VsVmFsdWUgPT4ge1xyXG4gICAgICAgIGRlZmVycmVkLmZvckVhY2goaXRlbSA9PiB7XHJcbiAgICAgICAgICBpdGVtLmNhbmNlbChjYW5jZWxWYWx1ZSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgZGVmZXJyZWQubGVuZ3RoID0gMDtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBvbkNhbmNlbCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgcmV0dXJuIG9uQ2FuY2VsKGNhbmNlbFZhbHVlKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmV0dXJuIGNhbmNlbFZhbHVlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBudW1JdGVtcyA9IGFycmF5Lmxlbmd0aDtcclxuICAgIGNvbnN0IGl0ZW1UcmFja2VyID0ge1xyXG4gICAgICBmYWlsZWQ6IGZhbHNlLFxyXG4gICAgICBudW1SZXNvbHZlZDogMCxcclxuICAgICAgcmVzb2x1dGlvbnM6IFtdXHJcbiAgICB9XHJcblxyXG4gICAgYXJyYXkuZm9yRWFjaCgoaXRlbSwgaW5kZXgpID0+IHtcclxuICAgICAgaWYgKGl0ZW1UcmFja2VyLmZhaWxlZCkge1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfSBlbHNlIGlmICghKGl0ZW0gaW5zdGFuY2VvZiBQcm9taXNlKSkge1xyXG4gICAgICAgIGl0ZW1UcmFja2VyLnJlc29sdXRpb25zW2luZGV4XSA9IGl0ZW07XHJcbiAgICAgICAgaXRlbVRyYWNrZXIubnVtUmVzb2x2ZWQgKz0gMTtcclxuXHJcbiAgICAgICAgaWYgKGl0ZW1UcmFja2VyLm51bVJlc29sdmVkID09PSBudW1JdGVtcykge1xyXG4gICAgICAgICAgcmVzdWx0LnJlc29sdmUoaXRlbVRyYWNrZXIucmVzb2x1dGlvbnMpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGl0ZW0udGhlbihcclxuICAgICAgICB2YWx1ZSA9PiB7XHJcbiAgICAgICAgICBpZiAoIWl0ZW1UcmFja2VyLmZhaWxlZCAmJiAhaXRlbS5jYW5jZWxlZCkge1xyXG4gICAgICAgICAgICBpdGVtVHJhY2tlci5yZXNvbHV0aW9uc1tpbmRleF0gPSB2YWx1ZTtcclxuICAgICAgICAgICAgaXRlbVRyYWNrZXIubnVtUmVzb2x2ZWQgKz0gMTtcclxuXHJcbiAgICAgICAgICAgIGlmIChpdGVtVHJhY2tlci5udW1SZXNvbHZlZCA9PT0gbnVtSXRlbXMpIHtcclxuICAgICAgICAgICAgICByZXN1bHQucmVzb2x2ZShpdGVtVHJhY2tlci5yZXNvbHV0aW9ucyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0gZWxzZSBpZiAoIWl0ZW1UcmFja2VyLmZhaWxlZCkge1xyXG4gICAgICAgICAgICBpdGVtVHJhY2tlci5mYWlsZWQgPSB0cnVlO1xyXG4gICAgICAgICAgICByZXN1bHQuY2FuY2VsKHZhbHVlKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGVycm9yID0+IHtcclxuICAgICAgICAgIGlmICghaXRlbVRyYWNrZXIuZmFpbGVkKSB7XHJcbiAgICAgICAgICAgIGl0ZW1UcmFja2VyLmZhaWxlZCA9IHRydWU7XHJcbiAgICAgICAgICAgIHJlc3VsdC5yZWplY3QoZXJyb3IpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiByZXN1bHQ7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBEZWZlcnJlZDtcclxuIiwiLy8gQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxyXG5pbXBvcnQgRGVmZXJyZWQgZnJvbSAnY29yZS9EZWZlcnJlZCc7XHJcblxyXG4vKipcclxuICogQSBjb2xsZWN0aW9uIG9mIHVzZWZ1bCBnZW5lcmljIGZ1bmN0aW9ucy5cclxuICpcclxuICogQGhpZGVjb25zdHJ1Y3RvclxyXG4gKi9cclxuY2xhc3MgVXRpbHMge1xyXG4gIC8qKlxyXG4gICAqIEBzdGF0aWNcclxuICAgKlxyXG4gICAqIEdlbmVyYXRlIGEgdW5pcXVlIGlkXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7U3RyaW5nfVxyXG4gICAqL1xyXG4gIHN0YXRpYyBjcmVhdGVJZCgpIHtcclxuICAgIHJldHVybiAneHh4eHh4eHh4eHh4NHh4eHl4eHh4eHh4eHh4eHh4eHgnLnJlcGxhY2UoL1t4eV0vZywgYyA9PiB7XHJcbiAgICAgIGNvbnN0IHJhbmRvbU51bWJlciA9IE1hdGguZmxvb3IoKERhdGUubm93KCkgKyBNYXRoLnJhbmRvbSgpICogMTYpICUgMTYpO1xyXG4gICAgICBpZiAoYyA9PT0gJ3gnKSB7XHJcbiAgICAgICAgcmV0dXJuIHJhbmRvbU51bWJlci50b1N0cmluZygxNik7XHJcbiAgICAgIH1cclxuICAgICAgLy8gU2V0IGJpdCA2IGFuZCA3IHRvIDAgYW5kIDFcclxuICAgICAgcmV0dXJuICgocmFuZG9tTnVtYmVyICYgMHgzKSB8IDB4OCkudG9TdHJpbmcoMTYpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBAc3RhdGljXHJcbiAgICpcclxuICAgKiBDaGVjayBhIG5hbWUgc3RyaW5nIGFnYWluc3QgYW4gYXJyYXkgb2Ygc3RyaW5ncyB0byBkZXRlcm1pbmUgaWYgaXQgaXMgdW5pcXVlLlxyXG4gICAqIElmIGl0IGlzbid0LCBhcHBlbmQgaW5jcmVtZW50ZWQgdHJhaWxpbmcgaW50ZWdlcnMgdG8gdGhlIGVuZCBvZiB0aGUgbmFtZVxyXG4gICAqIHVudGlsIGl0IGlzIHVuaXF1ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gU3RyaW5nIG5hbWUgdG8gbWFrZSB1bmlxdWUuXHJcbiAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPj19IG5hbWVBcnJheSAtIEFycmF5IG9mIHN0cmluZyBuYW1lcyB0byBjaGVjayBhZ2FpbnMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAqL1xyXG4gIHN0YXRpYyBnZXRVbmlxdWVOYW1lKG5hbWUsIG5hbWVBcnJheSA9IFtdKSB7XHJcbiAgICAvLyBJZiB0aGUgbmFtZSBpc24ndCBpbiB0aGUgYXJyYXkgcmV0dXJuIGl0IHJpZ2h0IGF3YXlcclxuICAgIGlmICghbmFtZUFycmF5LmluY2x1ZGVzKG5hbWUpKSB7XHJcbiAgICAgIHJldHVybiBuYW1lO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG5hbWVTZXQgPSBuZXcgU2V0KG5hbWVBcnJheSk7XHJcblxyXG4gICAgLy8gU2VwYXJhdGUgdGhlIG5hbWUgaW50byBzdHJpbmcgYW5kIHRyYWlsaW5nIG51bWJlcnNcclxuICAgIGNvbnN0IG1hdGNoR3JvdXAgPSBuYW1lLm1hdGNoKC9cXGQqJC8pO1xyXG4gICAgY29uc3Qge2luZGV4fSA9IG1hdGNoR3JvdXA7XHJcbiAgICBjb25zdCBiYXNlTmFtZSA9IG5hbWUuc2xpY2UoMCwgaW5kZXgpO1xyXG4gICAgbGV0IGluY3JlbWVudCA9IE51bWJlcihtYXRjaEdyb3VwWzBdKTtcclxuXHJcbiAgICAvLyBGaW5kIHRoZSBoaWdoZXN0IHRyYWlsaW5nIG51bWJlciB2YWx1ZSBmb3IgdGhlIGJhc2Ugb2YgdGhlIG5hbWVcclxuICAgIG5hbWVTZXQuZm9yRWFjaChzZXROYW1lID0+IHtcclxuICAgICAgY29uc3Qgc2V0TWF0Y2hHcm91cCA9IHNldE5hbWUubWF0Y2goL1xcZCokLyk7XHJcblxyXG4gICAgICBpZiAoc2V0TmFtZS5zbGljZSgwLCBzZXRNYXRjaEdyb3VwLmluZGV4KSA9PT0gYmFzZU5hbWUpIHtcclxuICAgICAgICBjb25zdCBzZXRJbmNyZW1lbnQgPSBOdW1iZXIoc2V0TWF0Y2hHcm91cFswXSk7XHJcblxyXG4gICAgICAgIGlmIChzZXRJbmNyZW1lbnQgPiBpbmNyZW1lbnQpIHtcclxuICAgICAgICAgIGluY3JlbWVudCA9IHNldEluY3JlbWVudDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIC8vIEluY3JlbWVudCB0aGUgaGlnaGVzdCB0cmFpbGluZyBudW1iZXIgYW5kIGFwcGVuZCB0byB0aGUgbmFtZVxyXG4gICAgcmV0dXJuIGAke2Jhc2VOYW1lfSR7aW5jcmVtZW50ICsgMX1gO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIGEgZGVmZXJyZWQgcHJvbWlzZSB0aGF0IHdpbGwgd2FpdCBhIGdpdmVuIG51bWJlciBvZiBzZWNvbmRzIGJlZm9yZVxyXG4gICAqIHJlc29sdmluZy4gUGFzcyBkZWx0YSB0aW1lIGluIG1pbGxpc2Vjb25kcyB0byB0aGUgZGVmZXJyZWQgcHJvbWlzZSdzIGV4ZWN1dGVcclxuICAgKiBtZXRob2QgaW4gYW4gdXBkYXRlIGxvb3AgdG8gcHJvZ3Jlc3MgdGltZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc2Vjb25kcz0wXSAtIE51bWJlciBvZiBzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIHJlc29sdmluZy5cclxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgLSBPcHRpb25hbCBvcHRpb25zIG9iamVjdFxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uRmluaXNoXSAtIENhbGxiYWNrIHRvIGV4ZWN1dGUgb25jZSB0aGUgd2FpdCB0aW1lXHJcbiAgICogaXMgbWV0LlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvcHRpb25zLm9uUHJvZ3Jlc3MgLSBDYWxsYmFjayB0byBleGVjdXRlIGVhY2ggdGltZSB0aGUgd2FpdFxyXG4gICAqIHRpbWUgcHJvZ3Jlc3NlcyB0b3dhcmRzIHRoZSB0YXJnZXQgbnVtYmVyIG9mIHNlY29uZHMuIFRoZSBhbW91bnQgb2YgcHJvZ3Jlc3NcclxuICAgKiBhcyBhIDAtMSBwZXJjZW50YWdlIGlzIHBhc3NlZCBhcyBhbiBhcmd1bWVudC5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb3B0aW9ucy5vbkNhbmNlbCAtIENhbGxiYWNrIHRvIGV4ZWN1dGUgaWYgdGhlIHVzZXIgY2FuY2Vsc1xyXG4gICAqIHRoZSB3YWl0IGJlZm9yZSBjb21wbGV0aW9uLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvcHRpb25zLm9uRXJyb3IgLSBDYWxsYmFjayB0byBleGVjdXRlIGlmIHRoZSB3YWl0IHN0b3BzXHJcbiAgICogYmVjYXVzZSBhbiBlcnJvciBpcyBlbmNvdW50ZXJlZC4gVGhlIGVycm9yIG1lc3NhZ2UgaXMgcGFzc2VkIGFzIGEgcGFyYW1ldGVyLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0RlZmVycmVkfVxyXG4gICAqL1xyXG4gIHN0YXRpYyB3YWl0KHNlY29uZHMgPSAwLCB7b25GaW5pc2gsIG9uUHJvZ3Jlc3MsIG9uQ2FuY2VsLCBvbkVycm9yfSA9IHt9KSB7XHJcbiAgICAvLyBNYWtlIHN1cmUgc2Vjb25kcyBpcyBudW1lcmljXHJcbiAgICBpZiAodHlwZW9mIHNlY29uZHMgIT09ICdudW1iZXInKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICBgSW52YWxpZCBzZWNvbmRzIHZhbHVlICR7c2Vjb25kc30gZm9yIHdhaXQuIERlZmF1bHRpbmcgdG8gMC5gXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBzZWNvbmRzID0gMDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZXNvbHZlIGltbWVkaWF0ZWx5IGlmIHRoZSB3YWl0IHRpbWUgaXMgbm90IGdyZWF0ZXIgdGhhbiAwXHJcbiAgICBpZiAoc2Vjb25kcyA8PSAwKSB7XHJcbiAgICAgIGlmICh0eXBlb2Ygb25GaW5pc2ggPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBvbkZpbmlzaCgpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gRGVmZXJyZWQucmVzb2x2ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIGxldCBjdXJyZW50VGltZSA9IDA7XHJcbiAgICBjb25zdCB0b3RhbFRpbWUgPSBzZWNvbmRzICogMTAwMDsgLy8gY29udmVydCB0byBtaWxsaXNlY29uZHNcclxuXHJcbiAgICAvLyBFeGVjdXRhYmxlIHRvIHBhc3MgdG8gRGVmZXJyZWQsIG1lYW50IHRvIGJlIHJ1biBpbiBhbiB1cGRhdGUgbG9vcFxyXG4gICAgY29uc3Qgb25VcGRhdGUgPSAocmVzb2x2ZSwgcmVqZWN0LCBfY2FuY2VsLCBkZWx0YVRpbWUgPSAwKSA9PiB7XHJcbiAgICAgIGlmICh0eXBlb2YgZGVsdGFUaW1lICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgIGNvbnN0IGUgPSBuZXcgRXJyb3IoXHJcbiAgICAgICAgICBgSW52YWxpZCBwcm9wZXJ0eSB3YWl0IGRlbHRhVGltZS4gRGVsdGFUaW1lIG11c3QgYmUgYSBudW1iZXIuYFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgcmVqZWN0KGUpO1xyXG4gICAgICAgIHJldHVybjtcclxuICAgICAgfVxyXG5cclxuICAgICAgLy8gTWFrZSBzdXJlIHRpbWUgaGFzIHBhc3NlZFxyXG4gICAgICBpZiAoZGVsdGFUaW1lID09PSAwKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBTaWduYWwgcHJvZ3Jlc3NcclxuICAgICAgY3VycmVudFRpbWUgKz0gZGVsdGFUaW1lO1xyXG4gICAgICBpZiAoY3VycmVudFRpbWUgPCAwKSB7XHJcbiAgICAgICAgY3VycmVudFRpbWUgPSAwO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpZiAodHlwZW9mIG9uUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICBvblByb2dyZXNzKE1hdGgubWluKGN1cnJlbnRUaW1lIC8gdG90YWxUaW1lLCAxKSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFNpZ25hbCBjb21wbGV0aW9uIG9uY2UgdGltZSBpcyB1cFxyXG4gICAgICBpZiAoY3VycmVudFRpbWUgPj0gdG90YWxUaW1lKSB7XHJcbiAgICAgICAgcmVzb2x2ZSgpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIHJldHVybiBuZXcgRGVmZXJyZWQob25VcGRhdGUsIG9uRmluaXNoLCBvbkVycm9yLCBvbkNhbmNlbCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgICogR2V0IGEgcmFuZG9tIGZsb2F0IG51bWJlciBiZXR3ZWVuIGEgbWluIChpbmNsdXNpdmUpIGFuZCBtYXggKGV4Y2x1c2l2ZSkgdmFsdWVcclxuICAgICogQHBhcmFtIHtudW1iZXJ9IG1pbiBtaW5pbXVtIHZhbHVlXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBtYXggbWF4aW11bSB2YWx1ZVxyXG4gICAgKiBAcmV0dXJucyB7ZmxvYXR9XHJcbiAgICAqL1xyXG4gIHN0YXRpYyBnZXRSYW5kb21GbG9hdChtaW4sIG1heCkge1xyXG4gICAgcmV0dXJuIE1hdGgucmFuZG9tKCkgKiAobWF4IC0gbWluKSArIG1pbjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAgKiBHZXQgYSByYW5kb20gaW50ZWdlciBudW1iZXIgYmV0d2VlbiBhIG1pbiAoaW5jbHVzaXZlKSBhbmQgbWF4IChleGNsdXNpdmUpIHZhbHVlXHJcbiAgICAqIEBwYXJhbSB7bnVtYmVyfSBtaW4gbWluaW11bSB2YWx1ZVxyXG4gICAgKiBAcGFyYW0ge251bWJlcn0gbWF4IG1heGltdW0gdmFsdWVcclxuICAgICogQHJldHVybnMge2ludGVnZXJ9XHJcbiAgICAqL1xyXG4gIHN0YXRpYyBnZXRSYW5kb21JbnQobWluLCBtYXgpIHtcclxuICAgIG1pbiA9IE1hdGguY2VpbChtaW4pO1xyXG4gICAgbWF4ID0gTWF0aC5mbG9vcihtYXgpO1xyXG4gICAgcmV0dXJuIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIChtYXggLSBtaW4pKSArIG1pbjtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFV0aWxzO1xyXG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXHJcbmNvbnN0IFJhZGlhblRvRGVncmVlID0gMTgwIC8gTWF0aC5QSTtcclxuY29uc3QgRGVncmVlVG9SYWRpYW4gPSBNYXRoLlBJIC8gMTgwO1xyXG5cclxuLyoqXHJcbiAqIEEgY29sbGVjdGlvbiBvZiB1c2VmdWwgbWF0aCBmdW5jdGlvbnMuXHJcbiAqXHJcbiAqIEBoaWRlY29uc3RydWN0b3JcclxuICovXHJcbmNsYXNzIE1hdGhVdGlscyB7XHJcbiAgLyoqXHJcbiAgICogQ29udmVydCB0aGUgZ2l2ZW4gYW5nbGUgZnJvbSByYWRpYW5zIHRvIGRlZ3JlZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gcmFkaWFucyAtIEFuZ2xlIGluIHJhZGlhbnMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIEFuZ2xlIGluIGRlZ3JlZXMuXHJcbiAgICovXHJcbiAgc3RhdGljIHRvRGVncmVlcyhyYWRpYW5zKSB7XHJcbiAgICByZXR1cm4gcmFkaWFucyAqIFJhZGlhblRvRGVncmVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ29udmVydCB0aGUgZ2l2ZW4gYW5nbGUgZnJvbSBkZWdyZWVzIHRvIHJhZGlhbnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVncmVlcyAtIEFuZ2xlIGluIGRlZ3JlZXMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSAtIEFuZ2xlIGluIHJhZGlhbnMuXHJcbiAgICovXHJcbiAgc3RhdGljIHRvUmFkaWFucyhkZWdyZWVzKSB7XHJcbiAgICByZXR1cm4gZGVncmVlcyAqIERlZ3JlZVRvUmFkaWFuO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTGluZWFybHkgaW50ZXJwb2xhdGUgYmV0d2VlbiB0d28gdmFsdWVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGZyb20gLSBTdGFydCB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gdG8gLSBUYXJnZXQgdmFsdWUuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGZhY3RvciAtIDAtMSBhbW91bnQgdG8gaW50ZXJwb2xhdGUgYmV0d2VlbiBmcm9tIGFuZCB0by5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgc3RhdGljIGxlcnAoZnJvbSwgdG8sIGZhY3Rvcikge1xyXG4gICAgcmV0dXJuIGZyb20gKyAodG8gLSBmcm9tKSAqIGZhY3RvcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENsYW1wIGEgbnVtYmVyIGJldHdlZW4gMiB2YWx1ZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdmFsdWUgLSBWYWx1ZSB0byBjbGFtcC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW21pbj0wXSAtIE1pbnVtdW0gdmFsdWUuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttYXg9MV0gLSBNYXhpbXVtIHZhbHVlLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cclxuICBzdGF0aWMgY2xhbXAodmFsdWUsIG1pbiA9IDAsIG1heCA9IDEpIHtcclxuICAgIHJldHVybiBNYXRoLm1heChtaW4sIE1hdGgubWluKHZhbHVlLCBtYXgpKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGN1bGF0ZXMgdGhlIGNsb3Nlc3QgcG9pbnQgb24gYSBnaXZlbiAyRCBsaW5lIHNlZ2VtZW50XHJcbiAgICogZnJvbSBhIGdpdmVuIDJEIHBvaW50LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYSAtIEZpcnN0IHBvaW50IG9uIGxpbmUgc2VnbWVudC5cclxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBiIC0gU2Vjb25kIHBvaW50IG9uIGxpbmUgc2VnbWVudC5cclxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBwIC0gMkQgcG9pbnQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59XHJcbiAgICovXHJcbiAgc3RhdGljIGNsb3Nlc3RQb2ludE9uTGluZShhLCBiLCBwKSB7XHJcbiAgICBjb25zdCBkaXN0U3FyID0gTWF0aFV0aWxzLmRpc3RhbmNlU3F1YXJlZChhLCBiKTtcclxuXHJcbiAgICAvLyBMaW5lIHNlZ21lbnQgaXMgYSBzaW5nbGUgcG9pbnRcclxuICAgIGlmIChkaXN0U3FyID09PSAwKSB7XHJcbiAgICAgIHJldHVybiBhO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHQgPVxyXG4gICAgICAoKHBbMF0gLSBhWzBdKSAqIChiWzBdIC0gYVswXSkgKyAocFsxXSAtIGFbMV0pICogKGJbMV0gLSBhWzFdKSkgLyBkaXN0U3FyO1xyXG5cclxuICAgIGxldCBwb2ludCA9IFsuLi5hXTtcclxuICAgIGlmICh0ID4gMSkge1xyXG4gICAgICBwb2ludCA9IFsuLi5iXTtcclxuICAgIH0gZWxzZSBpZiAodCA+IDApIHtcclxuICAgICAgcG9pbnQgPSBbYVswXSArIHQgKiAoYlswXSAtIGFbMF0pLCBhWzFdICsgdCAqIChiWzFdIC0gYVsxXSldO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBwb2ludDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIGRpc3RhbmNlIHNxdWFyZWQgZm9yIHR3byAyRCBwb2ludHMuXHJcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYSAtIDJEIHBvaW50LlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGIgLSAyRCBwb2ludC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgc3RhdGljIGRpc3RhbmNlU3F1YXJlZChhLCBiKSB7XHJcbiAgICByZXR1cm4gKGFbMF0gLSBiWzBdKSAqIChhWzBdIC0gYlswXSkgKyAoYVsxXSAtIGJbMV0pICogKGFbMV0gLSBiWzFdKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRyaWFuZ3VsYXRlcyBhIHNldCBvZiAyRCBwb2ludHMgdXNpbmcgYW4gaW1wbGVtZW50YXRpb25cclxuICAgKiBvZiB0aGUgQm93eWVyLVdhdHNvbiBpbmNyZW1lbnRhbCBEZWxhdW5heSB0cmlhbmd1bGF0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSB2ZXJ0aWNlcyAtIEFycmF5IG9mIDJEIHBvaW50cy5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtBcnJheS48QXJyYXk8bnVtYmVyPj59IC0gQXJyYXkgb2YgdHJpYW5nbGUgaW5kaWNlcy5cclxuICAgKi9cclxuICBzdGF0aWMgZ2V0RGVsYXVuYXlUcmlhbmd1bGF0aW9uKHZlcnRpY2VzKSB7XHJcbiAgICBpZiAoIXZlcnRpY2VzIHx8IHZlcnRpY2VzLmxlbmd0aCA8IDMpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGBDYW5ub3QgZ2V0IGRlbGF1bmF5IHRyaWFuZ3VsYXRpb24gZm9yIHBvaW50cyAke3ZlcnRpY2VzfS4gSW5wdXQgbXVzdCBjb250YWluIGF0IGxlYXN0IHRocmVlIHBvaW50cy5gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IG1pblggPSBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XHJcbiAgICBsZXQgbWluWSA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuICAgIGxldCBtYXhYID0gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xyXG4gICAgbGV0IG1heFkgPSBOdW1iZXIuTkVHQVRJVkVfSU5GSU5JVFk7XHJcblxyXG4gICAgdmVydGljZXMuZm9yRWFjaCh2ID0+IHtcclxuICAgICAgbWluWCA9IHZbMF0gPCBtaW5YID8gdlswXSA6IG1pblg7XHJcbiAgICAgIG1pblkgPSB2WzFdIDwgbWluWSA/IHZbMV0gOiBtaW5ZO1xyXG4gICAgICBtYXhYID0gdlswXSA+IG1heFggPyB2WzBdIDogbWF4WDtcclxuICAgICAgbWF4WSA9IHZbMV0gPiBtYXhZID8gdlsxXSA6IG1heFk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBkWCA9IG1heFggLSBtaW5YO1xyXG4gICAgY29uc3QgZFkgPSBtYXhZIC0gbWluWTtcclxuICAgIGNvbnN0IG1pZFggPSAobWluWCArIG1heFgpIC8gMjtcclxuICAgIGNvbnN0IG1pZFkgPSAobWluWSArIG1heFkpIC8gMjtcclxuICAgIGNvbnN0IGRNYXggPSBkWCA+IGRZID8gZFggOiBkWTtcclxuXHJcbiAgICBjb25zdCBzdXBlckluZGljZXMgPSBbXHJcbiAgICAgIHZlcnRpY2VzLmxlbmd0aCxcclxuICAgICAgdmVydGljZXMubGVuZ3RoICsgMSxcclxuICAgICAgdmVydGljZXMubGVuZ3RoICsgMixcclxuICAgIF07XHJcblxyXG4gICAgY29uc3QgdmVydHNXaXRoU3VwZXIgPSBbXHJcbiAgICAgIC4uLnZlcnRpY2VzLFxyXG4gICAgICBbbWlkWCAtIDIwICogZE1heCwgbWlkWSAtIGRNYXhdLFxyXG4gICAgICBbbWlkWCwgbWlkWSArIDIwICogZE1heF0sXHJcbiAgICAgIFttaWRYICsgMjAgKiBkTWF4LCBtaWRZIC0gZE1heF0sXHJcbiAgICBdO1xyXG5cclxuICAgIGNvbnN0IHN1cGVyU29ydGVkSW5kaWNlcyA9IE1hdGhVdGlscy5zb3J0UG9pbnRzQ0NXKFxyXG4gICAgICBzdXBlckluZGljZXMsXHJcbiAgICAgIHZlcnRzV2l0aFN1cGVyXHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IHN1cGVyVHJpYW5nbGUgPSB7XHJcbiAgICAgIGluZGljZXM6IHN1cGVyU29ydGVkSW5kaWNlcyxcclxuICAgICAgZWRnZXM6IFtcclxuICAgICAgICBbc3VwZXJTb3J0ZWRJbmRpY2VzWzBdLCBzdXBlclNvcnRlZEluZGljZXNbMV1dLFxyXG4gICAgICAgIFtzdXBlclNvcnRlZEluZGljZXNbMV0sIHN1cGVyU29ydGVkSW5kaWNlc1syXV0sXHJcbiAgICAgICAgW3N1cGVyU29ydGVkSW5kaWNlc1syXSwgc3VwZXJTb3J0ZWRJbmRpY2VzWzBdXSxcclxuICAgICAgXSxcclxuICAgIH07XHJcblxyXG4gICAgY29uc3QgdHJpYW5nbGVzID0gW3N1cGVyVHJpYW5nbGVdO1xyXG5cclxuICAgIHZlcnRzV2l0aFN1cGVyLmZvckVhY2goKG5ld1ZlcnQsIG5ld0luZGV4KSA9PiB7XHJcbiAgICAgIGNvbnN0IGludmFsaWRUcmlhbmdsZXMgPSBbXTtcclxuICAgICAgdHJpYW5nbGVzLmZvckVhY2godHJpYW5nbGUgPT4ge1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgIE1hdGhVdGlscy5pc1BvaW50SW5DaXJjdW1DaXJjbGUoXHJcbiAgICAgICAgICAgIHZlcnRzV2l0aFN1cGVyW3RyaWFuZ2xlLmluZGljZXNbMF1dLFxyXG4gICAgICAgICAgICB2ZXJ0c1dpdGhTdXBlclt0cmlhbmdsZS5pbmRpY2VzWzFdXSxcclxuICAgICAgICAgICAgdmVydHNXaXRoU3VwZXJbdHJpYW5nbGUuaW5kaWNlc1syXV0sXHJcbiAgICAgICAgICAgIG5ld1ZlcnRcclxuICAgICAgICAgIClcclxuICAgICAgICApIHtcclxuICAgICAgICAgIGludmFsaWRUcmlhbmdsZXMucHVzaCh0cmlhbmdsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIGNvbnN0IGJvdW5kaW5nUG9seSA9IFtdO1xyXG4gICAgICBpbnZhbGlkVHJpYW5nbGVzLmZvckVhY2godHJpYW5nbGUgPT4ge1xyXG4gICAgICAgIHRyaWFuZ2xlLmVkZ2VzLmZvckVhY2goZWRnZSA9PiB7XHJcbiAgICAgICAgICBsZXQgY291bnQgPSAwO1xyXG4gICAgICAgICAgaW52YWxpZFRyaWFuZ2xlcy5mb3JFYWNoKG90aGVyVHJpYW5nbGUgPT4ge1xyXG4gICAgICAgICAgICBpZiAodHJpYW5nbGUgIT09IG90aGVyVHJpYW5nbGUpIHtcclxuICAgICAgICAgICAgICBvdGhlclRyaWFuZ2xlLmVkZ2VzLmZvckVhY2gob3RoZXJFZGdlID0+IHtcclxuICAgICAgICAgICAgICAgIGlmIChcclxuICAgICAgICAgICAgICAgICAgKGVkZ2VbMF0gPT09IG90aGVyRWRnZVswXSAmJiBlZGdlWzFdID09PSBvdGhlckVkZ2VbMV0pIHx8XHJcbiAgICAgICAgICAgICAgICAgIChlZGdlWzFdID09PSBvdGhlckVkZ2VbMF0gJiYgZWRnZVswXSA9PT0gb3RoZXJFZGdlWzFdKVxyXG4gICAgICAgICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgICAgICAgIGNvdW50ICs9IDE7XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgaWYgKGNvdW50ID09PSAwKSBib3VuZGluZ1BvbHkucHVzaChlZGdlKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBpbnZhbGlkVHJpYW5nbGVzLmZvckVhY2godHJpYW5nbGUgPT4ge1xyXG4gICAgICAgIHRyaWFuZ2xlcy5zcGxpY2UodHJpYW5nbGVzLmluZGV4T2YodHJpYW5nbGUpLCAxKTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgICBib3VuZGluZ1BvbHkuZm9yRWFjaChlZGdlID0+IHtcclxuICAgICAgICBjb25zdCBzb3J0ZWRJbmRpY2VzID0gTWF0aFV0aWxzLnNvcnRQb2ludHNDQ1coXHJcbiAgICAgICAgICBbZWRnZVswXSwgZWRnZVsxXSwgbmV3SW5kZXhdLFxyXG4gICAgICAgICAgdmVydHNXaXRoU3VwZXJcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICB0cmlhbmdsZXMucHVzaCh7XHJcbiAgICAgICAgICBpbmRpY2VzOiBzb3J0ZWRJbmRpY2VzLFxyXG4gICAgICAgICAgZWRnZXM6IFtcclxuICAgICAgICAgICAgW3NvcnRlZEluZGljZXNbMF0sIHNvcnRlZEluZGljZXNbMV1dLFxyXG4gICAgICAgICAgICBbc29ydGVkSW5kaWNlc1sxXSwgc29ydGVkSW5kaWNlc1syXV0sXHJcbiAgICAgICAgICAgIFtzb3J0ZWRJbmRpY2VzWzJdLCBzb3J0ZWRJbmRpY2VzWzBdXSxcclxuICAgICAgICAgIF0sXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgdHJpYW5nbGVzVG9SZW1vdmUgPSBbXTtcclxuICAgIHRyaWFuZ2xlcy5mb3JFYWNoKHRyaWFuZ2xlID0+IHtcclxuICAgICAgdHJpYW5nbGUuaW5kaWNlcy5mb3JFYWNoKGluZGV4ID0+IHtcclxuICAgICAgICBpZiAoc3VwZXJJbmRpY2VzLmluY2x1ZGVzKGluZGV4KSkge1xyXG4gICAgICAgICAgdHJpYW5nbGVzVG9SZW1vdmUucHVzaCh0cmlhbmdsZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIHRyaWFuZ2xlc1RvUmVtb3ZlLmZvckVhY2godHJpYW5nbGUgPT4ge1xyXG4gICAgICBjb25zdCBpbmRleCA9IHRyaWFuZ2xlcy5pbmRleE9mKHRyaWFuZ2xlKTtcclxuICAgICAgaWYgKGluZGV4ICE9PSAtMSkge1xyXG4gICAgICAgIHRyaWFuZ2xlcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gdHJpYW5nbGVzLm1hcCh0cmlhbmdsZSA9PiB0cmlhbmdsZS5pbmRpY2VzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGVybWluZXMgaWYgYSBnaXZlbiAyRCBwb2ludCBpcyB3aXRoaW4gdGhlIGNpY3J1bWNpcmNsZVxyXG4gICAqIGRlZmluZWQgYnkgdGhyZWUgMkQgcG9pbnRzLiBUaGUgdHJpYW5nbGUgcG9pbnRzIG11c3QgYmUgaW5cclxuICAgKiBjb3VudGVyLWNsb2Nrd2lzZSBvcmRlciBhIC0+IGIgLT4gYy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGEgLSBGaXJzdCB0cmlhbmdsZSBwb2ludC5cclxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBiIC0gU2Vjb25kIHRyaWFuZ2xlIHBvaW50LlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGMgLSBUaGlyZCB0cmlhbmdsZSBwb2ludC5cclxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBwIC0gMkQgcG9pbnQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBzdGF0aWMgaXNQb2ludEluQ2lyY3VtQ2lyY2xlKGEsIGIsIGMsIHApIHtcclxuICAgIGNvbnN0IGF4ID0gYVswXSAtIHBbMF07XHJcbiAgICBjb25zdCBheSA9IGFbMV0gLSBwWzFdO1xyXG4gICAgY29uc3QgYnggPSBiWzBdIC0gcFswXTtcclxuICAgIGNvbnN0IGJ5ID0gYlsxXSAtIHBbMV07XHJcbiAgICBjb25zdCBjeCA9IGNbMF0gLSBwWzBdO1xyXG4gICAgY29uc3QgY3kgPSBjWzFdIC0gcFsxXTtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICAoYXggKiBheCArIGF5ICogYXkpICogKGJ4ICogY3kgLSBjeCAqIGJ5KSAtXHJcbiAgICAgICAgKGJ4ICogYnggKyBieSAqIGJ5KSAqIChheCAqIGN5IC0gY3ggKiBheSkgK1xyXG4gICAgICAgIChjeCAqIGN4ICsgY3kgKiBjeSkgKiAoYXggKiBieSAtIGJ4ICogYXkpID5cclxuICAgICAgMFxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERldGVybWluZXMgaWYgYSBnaXZlbiAyRCBwb2ludCBpcyB3aXRoaW4gYSBnaXZlbiB0cmlhbmdsZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGEgLSBGaXJzdCB0cmlhbmdsZSBwb2ludC5cclxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBiIC0gU2Vjb25kIHRyaWFuZ2xlIHBvaW50LlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGMgLSBUaGlyZCB0cmlhbmdsZSBwb2ludC5cclxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBwIC0gMkQgcG9pbnQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBzdGF0aWMgaXNQb2ludEluVHJpYW5nbGUoYSwgYiwgYywgcCkge1xyXG4gICAgY29uc3QgZGVub20gPSAoYlsxXSAtIGNbMV0pICogKGFbMF0gLSBjWzBdKSArIChjWzBdIC0gYlswXSkgKiAoYVsxXSAtIGNbMV0pO1xyXG4gICAgY29uc3QgYVZhbCA9XHJcbiAgICAgICgoYlsxXSAtIGNbMV0pICogKHBbMF0gLSBjWzBdKSArIChjWzBdIC0gYlswXSkgKiAocFsxXSAtIGNbMV0pKSAvIGRlbm9tO1xyXG4gICAgY29uc3QgYlZhbCA9XHJcbiAgICAgICgoY1sxXSAtIGFbMV0pICogKHBbMF0gLSBjWzBdKSArIChhWzBdIC0gY1swXSkgKiAocFsxXSAtIGNbMV0pKSAvIGRlbm9tO1xyXG4gICAgY29uc3QgY1ZhbCA9IDEgLSBhVmFsIC0gYlZhbDtcclxuXHJcbiAgICByZXR1cm4gKFxyXG4gICAgICBhVmFsID49IDAgJiYgYVZhbCA8PSAxICYmIGJWYWwgPj0gMCAmJiBiVmFsIDw9IDEgJiYgY1ZhbCA+PSAwICYmIGNWYWwgPD0gMVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIHNvcnRlZCBpbmRpY2VzIG9mIGEgZ2l2ZW4gc2V0IG9mIDJEIHBvaW50cyBpblxyXG4gICAqIGNvdW50ZXItY2xvY2t3aXNlIG9yZGVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gaW5kaWNlcyAtIExpc3Qgb2YgaW5kaWNlcy5cclxuICAgKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyPj59IHZlcnRpY2VzIC0gTGlzdCBvZiAyRCBwb2ludHMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7QXJyYXkuPEFycmF5LjxudW1iZXI+Pn0gLSBMaXN0IG9mIHNvcnRlZCBpbmRpY2VzLlxyXG4gICAqL1xyXG4gIHN0YXRpYyBzb3J0UG9pbnRzQ0NXKGluZGljZXMsIHZlcnRpY2VzKSB7XHJcbiAgICBjb25zdCBjZW50cm9pZCA9IFswLCAwXTtcclxuICAgIGluZGljZXMuZm9yRWFjaChpbmRleCA9PiB7XHJcbiAgICAgIGNlbnRyb2lkWzBdICs9IHZlcnRpY2VzW2luZGV4XVswXTtcclxuICAgICAgY2VudHJvaWRbMV0gKz0gdmVydGljZXNbaW5kZXhdWzFdO1xyXG4gICAgfSk7XHJcbiAgICBjZW50cm9pZFswXSAvPSBpbmRpY2VzLmxlbmd0aDtcclxuICAgIGNlbnRyb2lkWzFdIC89IGluZGljZXMubGVuZ3RoO1xyXG5cclxuICAgIGluZGljZXMuc29ydCgoYSwgYikgPT4ge1xyXG4gICAgICBjb25zdCBiVmFsID0gTWF0aC5hdGFuMihcclxuICAgICAgICB2ZXJ0aWNlc1tiXVsxXSAtIGNlbnRyb2lkWzFdLFxyXG4gICAgICAgIHZlcnRpY2VzW2JdWzBdIC0gY2VudHJvaWRbMF1cclxuICAgICAgKTtcclxuICAgICAgY29uc3QgYVZhbCA9IE1hdGguYXRhbjIoXHJcbiAgICAgICAgdmVydGljZXNbYV1bMV0gLSBjZW50cm9pZFsxXSxcclxuICAgICAgICB2ZXJ0aWNlc1thXVswXSAtIGNlbnRyb2lkWzBdXHJcbiAgICAgICk7XHJcblxyXG4gICAgICByZXR1cm4gYVZhbCAtIGJWYWw7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gaW5kaWNlcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhY2x1YXRlcyB0aGUgYXJlYSBvZiBhIHRyaWFuZ2xlXHJcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYSAtIEZpcnN0IHRyaWFuZ2xlIHBvaW50LlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IGIgLSBTZWNvbmQgdHJpYW5nbGUgcG9pbnQuXHJcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gYyAtIFRoaXJkIHRyaWFuZ2xlIHBvaW50LlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cclxuICBzdGF0aWMgdHJpYW5nbGVBcmVhKGEsIGIsIGMpIHtcclxuICAgIHJldHVybiBNYXRoLmFicyhcclxuICAgICAgKGFbMF0gKiAoYlsxXSAtIGNbMV0pICsgYlswXSAqIChjWzFdIC0gYVsxXSkgKyBjWzBdICogKGFbMV0gLSBiWzFdKSkgKiAwLjVcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gdGhlIG1hZ25pdHVkZSBvZiBhIGdpdmVuIHZlY3RvciBhcnJheS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHZlY3RvciAtIEFycmF5IGNvbnNpc3Rpbmcgb2YgbnVtYmVycy5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgc3RhdGljIGdldFZlY3Rvck1hZ25pdHVkZSh2ZWN0b3IpIHtcclxuICAgIGlmICghKHZlY3RvciBpbnN0YW5jZW9mIEFycmF5KSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgYENhbm5vdCBnZXQgbWFnbml0dWRlIGZvciB2ZWN0b3IgJHt2ZWN0b3J9LiBJbnB1dCBtdXN0IGJlIGFuIEFycmF5IG51bWJlcnMuYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHJlZHVjZXIgPSAoYWNjdW11bGF0b3IsIGN1cnJlbnRWYWx1ZSkgPT4ge1xyXG4gICAgICBpZiAodHlwZW9mIGN1cnJlbnRWYWx1ZSAhPT0gJ251bWJlcicpIHtcclxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgICBgQ2Fubm90IGdldCBtYWduaXR1ZGUgZm9yIHZlY3RvciAke3ZlY3Rvcn0uIEFsbCBpdGVtcyBpbiB0aGUgaW5wdXQgQXJyYXkgbXVzdCBiZSBudW1iZXJzLmBcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICByZXR1cm4gYWNjdW11bGF0b3IgKyAoY3VycmVudFZhbHVlICoqIDIpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBNYXRoLnNxcnQodmVjdG9yLnJlZHVjZShyZWR1Y2VyLCAwKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gdGhlIGRvdCBwcm9kdWN0IGJldHdlZW4gdHdvIHZlY3RvcnMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2ZWN0b3JBIC0gQXJyYXkgY29uc2lzdGluZyBvZiBudW1iZXJzLlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHZlY3RvckIgLSBBcnJheSBjb25zaXN0aW5nIG9mIG51bWJlcnMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIHN0YXRpYyBnZXREb3RQcm9kdWN0KHZlY3RvckEsIHZlY3RvckIpIHtcclxuICAgIGlmICghKHZlY3RvckEgaW5zdGFuY2VvZiBBcnJheSkgfHwgISh2ZWN0b3JCIGluc3RhbmNlb2YgQXJyYXkpIHx8IHZlY3RvckEubGVuZ3RoICE9PSB2ZWN0b3JCLmxlbmd0aCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYENhbm5vdCBnZXQgZG90IHByb2R1Y3QgYmV0d2VlbiAke3ZlY3RvckF9IGFuZCAke3ZlY3RvckJ9LiBJbnB1dHMgbXVzdCBiZSB2ZWN0b3JzIG9mIHRoZSBzYW1lIGxlbmd0aC5gKTtcclxuICAgIH1cclxuXHJcbiAgICBsZXQgcmVzdWx0ID0gMDtcclxuICAgIHZlY3RvckEuZm9yRWFjaCgodmFsdWVBLCBpbmRleCkgPT4ge1xyXG4gICAgICBjb25zdCB2YWx1ZUIgPSB2ZWN0b3JCW2luZGV4XTtcclxuXHJcbiAgICAgIGlmICh0eXBlb2YgdmFsdWVBICE9PSAnbnVtYmVyJyB8fCB0eXBlb2YgdmFsdWVCICE9PSAnbnVtYmVyJykge1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IGdldCBkb3QgcHJvZHVjdCBiZXR3ZWVuICR7dmVjdG9yQX0gYW5kICR7dmVjdG9yQn0uIFZlY3RvcnMgbXVzdCBvbmx5IGNvbnNpc3Qgb2YgbnVtZXJpYyB2YWx1ZXMuYCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJlc3VsdCArPSB2YWx1ZUEgKiB2YWx1ZUI7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gcmVzdWx0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIHRoZSBhbmdsZSBpbiByYWRpYW5zIGJldHdlZW4gdmVjdG9yQSBhbmQgdmVjdG9yQi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHZlY3RvckEgLSBBcnJheSBjb25zaXN0aW5nIG9mIG51bWJlcnMuXHJcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gdmVjdG9yQiAtIEFycmF5IGNvbnNpc3Rpbmcgb2YgbnVtYmVycy5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgc3RhdGljIGdldEFuZ2xlQmV0d2Vlbih2ZWN0b3JBLCB2ZWN0b3JCKSB7XHJcbiAgICBjb25zdCBub3JtYWxBID0gdGhpcy5ub3JtYWxpemVWZWN0b3IoWy4uLnZlY3RvckFdKTtcclxuICAgIGNvbnN0IG5vcm1hbEIgPSB0aGlzLm5vcm1hbGl6ZVZlY3RvcihbLi4udmVjdG9yQl0pO1xyXG4gICAgY29uc3QgZG90ID0gdGhpcy5nZXREb3RQcm9kdWN0KG5vcm1hbEEsIG5vcm1hbEIpO1xyXG5cclxuICAgIHJldHVybiBNYXRoLmFjb3ModGhpcy5jbGFtcChkb3QsIC0xLCAxKSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNdWx0aXBseSBhIDN4MyByb3RhdGlvbiBtYXRyaXggd2l0aCBhIHZlY3RvcjMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2ZWN0b3IzIC0gQXJyYXkgY29uc2lzdGluZyBvZiAzIG51bWJlcnMgcmVwcmVzZW50aW5nXHJcbiAgICogYSBkaXJlY3Rpb24gdmVjdG9yLlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IG1hdHJpeDMgLSBBbiBhcnJheSBvZiA5IG51bWJlcnMgcmVwcmVzZW50aW5nIGEgcm93XHJcbiAgICogbWFqb3Igcm90YXRpb24gbWF0cml4LlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0FycmF5LjxudW1iZXI+fSAtIEFuIGFycmF5IG9mIDMgbnVtYmVycyByZXByZXNlbnRpbmcgdGhlIG5ldyBkaXJlY3Rpb25cclxuICAgKiBvZiB0aGUgdmVjdG9yLlxyXG4gICAqL1xyXG4gIHN0YXRpYyByb3RhdGVWZWN0b3IodmVjdG9yMywgbWF0cml4Mykge1xyXG4gICAgaWYgKCEodmVjdG9yMyBpbnN0YW5jZW9mIEFycmF5KVxyXG4gICAgICB8fCB2ZWN0b3IzLmxlbmd0aCAhPT0gM1xyXG4gICAgICB8fCAhdmVjdG9yMy5ldmVyeSh2ID0+IHR5cGVvZiB2ID09PSAnbnVtYmVyJykpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGBDYW5ub3Qgcm90YXRlIHZlY3RvciAke3ZlY3RvcjN9IGJ5IHJvdGF0aW9uIG1hdHJpeCAke21hdHJpeDN9LiBJbnB1dCB2ZWN0b3IgbXVzdCBiZSBhbiBhcnJheSBvZiAzIG51bWJlcnMuYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghKG1hdHJpeDMgaW5zdGFuY2VvZiBBcnJheSlcclxuICAgICAgfHwgbWF0cml4My5sZW5ndGggIT09IDlcclxuICAgICAgfHwgIW1hdHJpeDMuZXZlcnkodiA9PiB0eXBlb2YgdiA9PT0gJ251bWJlcicpKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBgQ2Fubm90IHJvdGF0ZSB2ZWN0b3IgJHt2ZWN0b3IzfSBieSByb3RhdGlvbiBtYXRyaXggJHttYXRyaXgzfS4gSW5wdXQgbWF0cml4MyBtdXN0IGJlIGFuIGFycmF5IG9mIDkgbnVtYmVycy5gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgeCA9IG1hdHJpeDNbMF0gKiB2ZWN0b3IzWzBdXHJcbiAgICAgICsgbWF0cml4M1szXSAqIHZlY3RvcjNbMV1cclxuICAgICAgKyBtYXRyaXgzWzZdICogdmVjdG9yM1syXTtcclxuICAgIGNvbnN0IHkgPSBtYXRyaXgzWzFdICogdmVjdG9yM1swXVxyXG4gICAgICArIG1hdHJpeDNbNF0gKiB2ZWN0b3IzWzFdXHJcbiAgICAgICsgbWF0cml4M1s3XSAqIHZlY3RvcjNbMl07XHJcbiAgICBjb25zdCB6ID0gbWF0cml4M1syXSAqIHZlY3RvcjNbMF1cclxuICAgICAgKyBtYXRyaXgzWzVdICogdmVjdG9yM1sxXVxyXG4gICAgICArIG1hdHJpeDNbOF0gKiB2ZWN0b3IzWzJdO1xyXG5cclxuICAgIHJldHVybiBbeCwgeSwgel07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBOb3JtYWxpemUgYSBnaXZlbiB2ZWN0b3IgYXJyYXkuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSB2ZWN0b3IgLSBBcnJheSBjb25zaXN0aW5nIG9mIG51bWJlcnMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59IFRoZSBvcmlnaW5hbCB2ZWN0b3Igd2l0aCBub3JtYWxpemVkIHZhbHVlcywgZm9yIGNoYWluaW5nLlxyXG4gICAqL1xyXG4gIHN0YXRpYyBub3JtYWxpemVWZWN0b3IodmVjdG9yKSB7XHJcbiAgICBjb25zdCBtYWduaXR1ZGUgPSB0aGlzLmdldFZlY3Rvck1hZ25pdHVkZSh2ZWN0b3IpO1xyXG5cclxuICAgIGlmIChtYWduaXR1ZGUgPT09IDApIHtcclxuICAgICAgdmVjdG9yLmZpbGwoMClcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHZlY3Rvci5mb3JFYWNoKCh2YWx1ZSwgaW5kZXgpID0+IHtcclxuICAgICAgICB2ZWN0b3JbaW5kZXhdID0gdmFsdWUgLyBtYWduaXR1ZGU7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB2ZWN0b3I7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBFeHRyYWN0IHRoZSAzeDMgcm90YXRpb24gbWF0cml4IGZyb20gYSBnaXZlbiA0eDQgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gbWF0cml4NCAtIEFuIGFycmF5IG9mIDE2IG51bWJlcnMgcmVwcmVzZW50aW5nIGEgcm93XHJcbiAgICogbWFqb3IgdHJhbnNmb3JtYXRpb24gbWF0cml4LlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0FycmF5LjxudW1iZXI+fSAtIEFuIGFycmF5IG9mIDkgbnVtYmVycyByZXByZXNlbnRpbmcgYSByb3cgbWFqb3JcclxuICAgKiByb3RhdGlvbiBtYXRyaXguXHJcbiAgICovXHJcbiAgc3RhdGljIGdldFJvdGF0aW9uTWF0cml4KG1hdHJpeDQpIHtcclxuICAgIGlmICghKG1hdHJpeDQgaW5zdGFuY2VvZiBBcnJheSlcclxuICAgICAgfHwgbWF0cml4NC5sZW5ndGggIT09IDE2XHJcbiAgICAgIHx8ICFtYXRyaXg0LmV2ZXJ5KHYgPT4gdHlwZW9mIHYgPT09ICdudW1iZXInKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgYENhbm5vdCBjb252ZXJ0IG1hdHJpeCAke21hdHJpeDR9IHRvIGEgcm90YXRpb24gbWF0cml4LiBJbnB1dCBtYXRyaXggbXVzdCBiZSBhbiBhcnJheSBvZiAxNiBudW1iZXJzLmBcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBFeHRyYWN0IHNjYWxlXHJcbiAgICBjb25zdCBzY2FsZVggPSAxIC8gKHRoaXMuZ2V0VmVjdG9yTWFnbml0dWRlKG1hdHJpeDQuc2xpY2UoMCwgNCkpIHx8IDEpO1xyXG4gICAgY29uc3Qgc2NhbGVZID0gMSAvICh0aGlzLmdldFZlY3Rvck1hZ25pdHVkZShtYXRyaXg0LnNsaWNlKDQsIDgpKSB8fCAxKTtcclxuICAgIGNvbnN0IHNjYWxlWiA9IDEgLyAodGhpcy5nZXRWZWN0b3JNYWduaXR1ZGUobWF0cml4NC5zbGljZSg4LCAxMikpIHx8IDEpO1xyXG5cclxuICAgIHJldHVybiBbXHJcbiAgICAgIG1hdHJpeDRbMF0gKiBzY2FsZVgsIG1hdHJpeDRbMV0gKiBzY2FsZVgsIG1hdHJpeDRbMl0gKiBzY2FsZVgsXHJcbiAgICAgIG1hdHJpeDRbNF0gKiBzY2FsZVksIG1hdHJpeDRbNV0gKiBzY2FsZVksIG1hdHJpeDRbNl0gKiBzY2FsZVksXHJcbiAgICAgIG1hdHJpeDRbOF0gKiBzY2FsZVosIG1hdHJpeDRbOV0gKiBzY2FsZVosIG1hdHJpeDRbMTBdICogc2NhbGVaXHJcbiAgICBdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIGFuIGFycmF5IGNvbnRhaW5pbmcgdGhlIHNwaGVyaWNhbCBjb29yZGluYXRlcyBvZiB0aGUgZ2l2ZW4gY2FydGVzaWFuXHJcbiAgICogeHl6IGNvb3JkaW5hdGVzLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB4IC0gUG9zaXRpb24gYWxvbmcgdGhlIHggYXhpcy5cclxuICAgKiBAcGFyYW0ge251bWJlcn0geSAtIFBvc2l0aW9uIGFsb25nIHRoZSB5IGF4aXMuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHogLSBQb3NpdGlvbiBhbG9uZyB0aGUgeiBheGlzLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0FycmF5LjxudW1iZXI+fSAtIEFuIGFycmF5IGNvbnNpc3Rpbmcgb2YgdGhyZWUgbnVtYmVyZXMgd2hlcmUgaW5kZXhcclxuICAgKiAwIHJlcHJlc2VudHMgdGhlIHJhZGl1cywgaW5kZXggMSByZXByZXNlbnRzIHRoZSB2ZXJ0aWNhbC9wb2xhciBhbmdsZSBpbiByYWRpYW5zXHJcbiAgICogYW5kIGluZGV4IDIgcmVwcmVzZW50cyB0aGUgaG9yaXpvbnRhbC9hemltdXRoYWwgYW5nbGUgaW4gcmFkaWFucy5cclxuICAgKi9cclxuICBzdGF0aWMgY2FydGVzaWFuVG9TcGhlcmljYWwoeCwgeSwgeikge1xyXG4gICAgY29uc3QgciA9IHRoaXMuZ2V0VmVjdG9yTWFnbml0dWRlKFt4LCB5LCB6XSk7XHJcblxyXG4gICAgLy8gUmV0dXJuIGlkZW50aXR5IGlmIHRoZSB2ZWN0b3IgaGFzIG5vIGxlbmd0aFxyXG4gICAgaWYgKHIgPT09IDApIHtcclxuICAgICAgcmV0dXJuIFswLCAwLCAwXTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gW1xyXG4gICAgICByLFxyXG4gICAgICBNYXRoLmFjb3ModGhpcy5jbGFtcCh5IC8gciwgLSAxLCAxKSksXHJcbiAgICAgIE1hdGguYXRhbjIoeCwgeiksXHJcbiAgICBdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR3JhZHVhbGx5IGNoYW5nZSBhIHZhbHVlIG9mIGEgbnVtZXJpYyBwcm9wZXJ0eSB0b3dhcmRzIGEgZ29hbCBvdmVyIHRpbWUgdXNpbmdcclxuICAgKiBhIGNyaXRpY2FsbHkgZGFtcGVkIHNwcmluZyBmdW5jdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyZW50VmFsdWUgLSBUaGUgc3RhcnRpbmcgdmFsdWUuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRhcmdldFZhbHVlLSBUaGUgZ29hbCB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBbdmFsdWVTdG9yZSA9IFswLCAwXV0gLSBBbiBBcnJheSBjb25zaXN0aW5nIG9mIHR3b1xyXG4gICAqIG51bWJlcnMgd2hlcmUgdGhlIGZpcnN0IG51bWJlciBob2xkcyB0aGUgcmVzdWx0IHZhbHVlIGFuZCB0aGUgc2Vjb25kIGhvbGRzXHJcbiAgICogdGhlIHZlbG9jaXR5IHRoYXQgcmVzdWx0ZWQgaW4gdGhhdCB2YWx1ZS4gVGhlIHNhbWUgYXJyYXkgc2hvdWxkIGJlIHByb3ZpZGVkXHJcbiAgICogd2l0aCBlYWNoIGNhbGwgdG8gdGhpcyBmdW5jdGlvbi5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW2RlbHRhVGltZSA9IDFlLTddIC0gVGhlIHRpbWUgc2luY2UgdGhlIGxhc3QgY2FsbCB0byB0aGlzIGZ1bmN0aW9uXHJcbiAgICogaW4gc2Vjb25kcy5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW3Ntb290aFRpbWUgPSAwLjNdIC0gVGhlIGFwcHJveGltYXRlIGFtb3VudCBvZiB0aW1lIGluIHNlY29uZHNcclxuICAgKiBpdCBzaG91bGQgdGFrZSB0byByZWFjaCB0aGUgdGFyZ2V0IHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4U3BlZWQgPSAxZTddIC0gQSBjbGFtcGluZyB2YWx1ZSBmb3IgdGhlIG1heGltdW0gc3BlZWQgdGhlXHJcbiAgICogdmFsdWUgY2FuIGNoYW5nZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtBcnJheS48bnVtYmVyPn0gLSBUaGUgdmFsdWVTdG9yZSBhcnJheS5cclxuICAgKi9cclxuICBzdGF0aWMgZGFtcFZhbHVlKFxyXG4gICAgY3VycmVudFZhbHVlLFxyXG4gICAgdGFyZ2V0VmFsdWUsXHJcbiAgICB2YWx1ZVN0b3JlID0gWzAsIDBdLFxyXG4gICAgZGVsdGFUaW1lID0gMWUtNyxcclxuICAgIHNtb290aFRpbWUgPSAwLjMsXHJcbiAgICBtYXhTcGVlZCA9IDFlN1xyXG4gICkge1xyXG4gICAgc21vb3RoVGltZSA9IE1hdGgubWF4KDAuMDAwMSwgc21vb3RoVGltZSk7XHJcbiAgICBkZWx0YVRpbWUgPSBNYXRoLm1heCgxZS03LCBkZWx0YVRpbWUpO1xyXG5cclxuICAgIC8vIEZpbmQgdGhlIGRlbHRhIGJldHdlZW4gdmFsdWVzIGFuZCB1c2UgaXQgdG8gZXN0aW1hdGUgdGhlIHByZXZpb3VzIHZhbHVlXHJcbiAgICBjb25zdCBjbGFtcFRpbWUgPSBtYXhTcGVlZCAqIHNtb290aFRpbWU7XHJcbiAgICBjb25zdCBkZWx0YVZhbHVlID0gY3VycmVudFZhbHVlIC0gdGFyZ2V0VmFsdWU7XHJcbiAgICBjb25zdCBjbGFtcERlbHRhVmFsdWUgPSB0aGlzLmNsYW1wKGRlbHRhVmFsdWUsIC1jbGFtcFRpbWUsIGNsYW1wVGltZSk7XHJcbiAgICBjb25zdCBsYXN0VmFsdWUgPSBjdXJyZW50VmFsdWUgLSBjbGFtcERlbHRhVmFsdWU7XHJcblxyXG4gICAgLy8gQ2FsY3VsYXRlIGRhbXBpbmcgZmFjdG9yc1xyXG4gICAgY29uc3QgZDEgPSAyIC8gc21vb3RoVGltZTtcclxuICAgIGNvbnN0IGQyID0gZDEgKiBkZWx0YVRpbWU7XHJcbiAgICBjb25zdCBkMyA9IDEgLyAoMSArIGQyICsgMC41ICogZDIgKiogMiArIDAuMjUgKiBkMiAqKiAzKTtcclxuICAgIGNvbnN0IGQ0ID0gKHZhbHVlU3RvcmVbMV0gKyBkMSAqIGNsYW1wRGVsdGFWYWx1ZSkgKiBkZWx0YVRpbWU7XHJcblxyXG4gICAgLy8gRGFtcCB0aGUgdGFyZ2V0IHZhbHVlIGFuZCB1cGRhdGUgdGhlIHZlbG9jaXR5XHJcbiAgICB2YWx1ZVN0b3JlWzBdID0gbGFzdFZhbHVlICsgKGNsYW1wRGVsdGFWYWx1ZSArIGQ0KSAqIGQzO1xyXG4gICAgdmFsdWVTdG9yZVsxXSA9ICh2YWx1ZVN0b3JlWzFdIC0gZDEgKiBkNCkgKiBkMztcclxuXHJcbiAgICAvLyBQcmV2ZW50IG92ZXJzaG9vdGluZ1xyXG4gICAgaWYgKHRhcmdldFZhbHVlIC0gY3VycmVudFZhbHVlID4gMCA9PT0gdmFsdWVTdG9yZVswXSA+IHRhcmdldFZhbHVlKSB7XHJcbiAgICAgIHZhbHVlU3RvcmVbMF0gPSB0YXJnZXRWYWx1ZTtcclxuICAgICAgdmFsdWVTdG9yZVsxXSA9ICh2YWx1ZVN0b3JlWzBdIC0gdGFyZ2V0VmFsdWUpIC8gZGVsdGFUaW1lO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB2YWx1ZVN0b3JlO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgTWF0aFV0aWxzO1xyXG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXHJcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVyc2NvcmUtZGFuZ2xlICovXHJcbmltcG9ydCBVdGlscyBmcm9tICcuL1V0aWxzJztcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyB0aGF0IGNhbiBleGVjdXRlIGZ1bmN0aW9ucyB3aGVuIGxvY2FsIG1lc3NhZ2VzIGFyZSByZWNlaXZlZC4gTG9jYWwgbWVzc2FnZXNcclxuICogYXJlIHByZWZpeGVkIHdpdGggdGhlIGluc3RhbmNlJ3MgaWQuXHJcbiAqXHJcbiAqIEBhbGlhcyBjb3JlL01lc3NlbmdlclxyXG4gKlxyXG4gKiBAcHJvcGVydHkge2NvcmUvTWVzc2VuZ2VyfSBHbG9iYWxNZXNzZW5nZXIgLSBBIG1lc3NlbmdlciB0aGF0IGNhbiBiZSB1c2VkIGZvclxyXG4gKiBnbG9iYWwgbWVzc2FnaW5nLiBXaGVuIHVzaW5nIHN0YXRpYyBsaXN0ZW4gYW5kIGVtaXQgbWV0aG9kcyB0aGV5IGFyZSBleGVjdXRlZFxyXG4gKiBvbiB0aGlzIG1lc3Nlbmdlci5cclxuICogQHByb3BlcnR5IHtPYmplY3R9IEVWRU5UUyAtIEJ1aWx0LWluIGV2ZW50cyB0aGF0IHRoZSBNZXNzZW5nZXIgZW1pdHMuXHJcbiAqL1xyXG5jbGFzcyBNZXNzZW5nZXIge1xyXG4gIC8qKlxyXG4gICAqIEBjb25zdHJ1Y3RvclxyXG4gICAqXHJcbiAgICogQHBhcmFtIHthbnk9fSBpZCAtIElkIGZvciB0aGUgb2JqZWN0LiBJZiBub25lIGlzIHByb3ZpZGVkIGEgbmV3IGlkIHdpbGxcclxuICAgKiBiZSBjcmVhdGVkLiBJZCBzaG91bGQgYmUgYWJsZSB0byBiZSByZXByZXNlbnRlZCBhcyBhIHN0cmluZy5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihpZCkge1xyXG4gICAgdGhpcy5faWQgPSBpZCAhPT0gdW5kZWZpbmVkID8gaWQgOiBVdGlscy5jcmVhdGVJZCgpO1xyXG4gICAgdGhpcy5fZGlzcGF0Y2hlciA9IHdpbmRvdztcclxuICAgIHRoaXMuX2NhbGxiYWNrcyA9IHt9O1xyXG4gICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnMgPSB7fTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIHN0cmluZyBpZCBvZiB0aGUgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHR5cGUge3N0cmluZ31cclxuICAgKi9cclxuICBnZXQgaWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQcmVmaXggYSBtZXNzYWdlIHdpdGggdGhlIGluc3RhbmNlIGlkLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAqL1xyXG4gIF9jcmVhdGVMb2NhbE1lc3NhZ2UobWVzc2FnZSkge1xyXG4gICAgcmV0dXJuIGAke3RoaXMuaWR9LiR7bWVzc2FnZX1gO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIGEgZnVuY3Rpb24gdGhhdCB3aWxsIGNhbGwgYSBjYWxsYmFjayBmdW5jdGlvbiBhbmQgc3VwcGx5IHRoZSBldmVudCdzXHJcbiAgICogZGV0YWlsIHByb3BlcnR5IGFzIGFuIGFyZ3VtZW50LlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7RnVuY3Rpb259XHJcbiAgICovXHJcbiAgX2NyZWF0ZUxpc3RlbmVyKGNhbGxiYWNrKSB7XHJcbiAgICByZXR1cm4gZSA9PiB7XHJcbiAgICAgIGxldCB2YWx1ZTtcclxuXHJcbiAgICAgIGlmIChlLmRldGFpbCAhPT0gbnVsbCkge1xyXG4gICAgICAgIHZhbHVlID0gZS5kZXRhaWw7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNhbGxiYWNrKHZhbHVlKTtcclxuICAgIH07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgYW4gZXZlbnQgb2JqZWN0IGFuZCBzZW5kIGl0IHRvIGxpc3RlbmVycy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIEV2ZW50IHR5cGUgbmFtZS5cclxuICAgKiBAcGFyYW0ge2FueT19IHZhbHVlIC0gVmFsdWUgdG8gc2VuZCB0byBsaXN0ZW5lcnMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7Q3VzdG9tRXZlbnR9XHJcbiAgICovXHJcbiAgX2NyZWF0ZUV2ZW50KG1lc3NhZ2UsIHZhbHVlKSB7XHJcbiAgICByZXR1cm4gbmV3IEN1c3RvbUV2ZW50KG1lc3NhZ2UsIHtkZXRhaWw6IHZhbHVlfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZWdpc3RlciBhbiBldmVudC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIEV2ZW50IHR5cGUgbmFtZS5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBsaXN0ZW5lciAtIEEgbGlzdGVuZXIgZnVuY3Rpb24gZ2VuZXJhdGVkIHVzaW5nIF9jcmVhdGVMaXN0ZW5lci5cclxuICAgKi9cclxuICBfYWRkTGlzdGVuZXIobWVzc2FnZSwgbGlzdGVuZXIpIHtcclxuICAgIHRoaXMuX2Rpc3BhdGNoZXIuYWRkRXZlbnRMaXN0ZW5lcihcclxuICAgICAgdGhpcy5fY3JlYXRlTG9jYWxNZXNzYWdlKG1lc3NhZ2UpLFxyXG4gICAgICBsaXN0ZW5lclxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVucmVnaXN0ZXIgYW4gZXZlbnQuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBFdmVudCB0eXBlIG5hbWUuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gbGlzdGVuZXIgLSBBIGxpc3RlbmVyIGZ1bmN0aW9uIGdlbmVyYXRlZCB1c2luZyBfY3JlYXRlTGlzdGVuZXIuXHJcbiAgICovXHJcbiAgX3JlbW92ZUxpc3RlbmVyKG1lc3NhZ2UsIGxpc3RlbmVyKSB7XHJcbiAgICB0aGlzLl9kaXNwYXRjaGVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoXHJcbiAgICAgIHRoaXMuX2NyZWF0ZUxvY2FsTWVzc2FnZShtZXNzYWdlKSxcclxuICAgICAgbGlzdGVuZXJcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBFeGVjdXRlIGEgZnVuY3Rpb24gd2hlbiBhIG1lc3NhZ2UgaXMgcmVjZWl2ZWQgZm9yIHRoaXMgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBUaGUgbWVzc2FnZSB0byBsaXN0ZW4gZm9yLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSBvbmNlIHRoZSBtZXNzYWdlIGlzIHJlY2VpdmVkLlxyXG4gICAqL1xyXG4gIGxpc3RlblRvKG1lc3NhZ2UsIGNhbGxiYWNrKSB7XHJcbiAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBgQ2Fubm90IGFkZCBsaXN0ZW5lciBmb3IgJHttZXNzYWdlfSBvbiAke3RoaXMuaWR9LiBDYWxsYmFjayBtdXN0IGJlIGEgZnVuY3Rpb24uYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9jYWxsYmFja3NbbWVzc2FnZV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aGlzLl9jYWxsYmFja3NbbWVzc2FnZV0gPSBbXTtcclxuICAgICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnNbbWVzc2FnZV0gPSBbXTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBsaXN0ZW5lciA9IHRoaXMuX2NyZWF0ZUxpc3RlbmVyKGNhbGxiYWNrKTtcclxuICAgIHRoaXMuX2NhbGxiYWNrc1ttZXNzYWdlXS5wdXNoKGNhbGxiYWNrKTtcclxuICAgIHRoaXMuX2V2ZW50TGlzdGVuZXJzW21lc3NhZ2VdLnB1c2gobGlzdGVuZXIpO1xyXG5cclxuICAgIHRoaXMuX2FkZExpc3RlbmVyKG1lc3NhZ2UsIGxpc3RlbmVyKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFByZXZlbnQgYSBmdW5jdGlvbiBmcm9tIGJlaW5nIGV4ZWN1dGVkIHdoZW4gYSBtZXNzYWdlIGlzIHJlY2VpdmVkIGZvciB0aGlzXHJcbiAgICogb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBUaGUgbWVzc2FnZSB0byBzdG9wIGxpc3RlbmluZyBmb3IuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IGNhbGxiYWNrIC0gT3B0aW9uYWwgY2FsbGJhY2sgdG8gcmVtb3ZlLiBJZiBub25lIGlzIGRlZmluZWQsXHJcbiAgICogcmVtb3ZlIGFsbCBjYWxsYmFja3MgZm9yIHRoZSBtZXNzYWdlLlxyXG4gICAqL1xyXG4gIHN0b3BMaXN0ZW5pbmcobWVzc2FnZSwgY2FsbGJhY2spIHtcclxuICAgIGlmICh0aGlzLl9jYWxsYmFja3NbbWVzc2FnZV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9IGVsc2UgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgLy8gSWYgbm8gY2FsbGJhY2sgd2FzIGRlZmluZWQsIGNhbGwgc3RvcExpc3RlbmluZyBvbiBhbGwgY2FsbGJhY2tzIGZvciB0aGUgbWVzc2FnZVxyXG4gICAgICBmb3IgKGxldCBpID0gdGhpcy5fY2FsbGJhY2tzW21lc3NhZ2VdLmxlbmd0aCAtIDE7IGkgPiAtMTsgaS0tKSB7XHJcbiAgICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nKG1lc3NhZ2UsIHRoaXMuX2NhbGxiYWNrc1ttZXNzYWdlXVtpXSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBJZiBhIGNhbGxiYWNrIHdhcyBkZWZpbmVkLCBtYWtlIHN1cmUgaXQncyBhIGxpc3RlbmVyXHJcbiAgICBjb25zdCBpbmRleCA9IHRoaXMuX2NhbGxiYWNrc1ttZXNzYWdlXS5pbmRleE9mKGNhbGxiYWNrKTtcclxuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGxpc3RlbmVyID0gdGhpcy5fZXZlbnRMaXN0ZW5lcnNbbWVzc2FnZV1baW5kZXhdO1xyXG4gICAgdGhpcy5fcmVtb3ZlTGlzdGVuZXIobWVzc2FnZSwgbGlzdGVuZXIpO1xyXG5cclxuICAgIHRoaXMuX2NhbGxiYWNrc1ttZXNzYWdlXS5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgdGhpcy5fZXZlbnRMaXN0ZW5lcnNbbWVzc2FnZV0uc3BsaWNlKGluZGV4LCAxKTtcclxuXHJcbiAgICBpZiAodGhpcy5fY2FsbGJhY2tzW21lc3NhZ2VdLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgICBkZWxldGUgdGhpcy5fY2FsbGJhY2tzW21lc3NhZ2VdO1xyXG4gICAgICBkZWxldGUgdGhpcy5fZXZlbnRMaXN0ZW5lcnNbbWVzc2FnZV07XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBEZS1yZWdpc3RlciBjYWxsYmFjayhzKSBmcm9tIGJlaW5nIGV4ZWN1dGVkIHdoZW4gbWVzc2FnZXMgbWF0Y2hpbmcgdGhlIGdpdmVuXHJcbiAgICogcmVndWxhciBleHByZXNzaW9uIGFyZSByZWNlaXZlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UmVnZXhwfSByZWdleHAgLSByZWdleHAgLSBUaGUgcmVndWxhciBleHByZXNzaW9uIHRvIGZpbHRlciBtZXNzYWdlcyB3aXRoLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBjYWxsYmFjayAtIE9wdGlvbmFsIGNhbGxiYWNrIHRvIHJlbW92ZS4gSWYgbm9uZSBpcyBkZWZpbmVkLFxyXG4gICAqIHJlbW92ZSBhbGwgY2FsbGJhY2tzIGZvciBtZXNzYWdlcyBtYXRjaGluZyB0aGUgcmVndWxhciBleHByZXNzaW9uLlxyXG4gICAqL1xyXG4gIHN0b3BMaXN0ZW5pbmdCeVJlZ2V4cChyZWdleHAsIGNhbGxiYWNrKSB7XHJcbiAgICBjb25zdCBtZXNzYWdlcyA9IE9iamVjdC5rZXlzKHRoaXMuX2NhbGxiYWNrcykuZmlsdGVyKG1lc3NhZ2UgPT4gcmVnZXhwLnRlc3QobWVzc2FnZSkpO1xyXG5cclxuICAgIG1lc3NhZ2VzLmZvckVhY2gobWVzc2FnZSA9PiB7XHJcbiAgICAgIHRoaXMuc3RvcExpc3RlbmluZyhtZXNzYWdlLCBjYWxsYmFjayk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFByZXZlbnQgYW55IGZ1bmN0aW9ucyBmcm9tIGJlaW5nIGV4ZWN1dGVkIHdoZW4gYW55IG1lc3NhZ2UgaXMgcmVjZWl2ZWQgZm9yXHJcbiAgICogdGhpcyBvYmplY3QuXHJcbiAgICovXHJcbiAgc3RvcExpc3RlbmluZ1RvQWxsKCkge1xyXG4gICAgY29uc3QgbWVzc2FnZXMgPSBPYmplY3Qua2V5cyh0aGlzLl9jYWxsYmFja3MpO1xyXG5cclxuICAgIGZvciAobGV0IGkgPSBtZXNzYWdlcy5sZW5ndGggLSAxOyBpID4gLTE7IGktLSkge1xyXG4gICAgICB0aGlzLnN0b3BMaXN0ZW5pbmcobWVzc2FnZXNbaV0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2VuZCBhIG1lc3NhZ2UsIGNhdXNpbmcgbGlzdGVuZXIgZnVuY3Rpb25zIGZvciB0aGUgbWVzc2FnZSBvbiB0aGlzIG9iamVjdFxyXG4gICAqIHRvIGJlIGV4ZWN1dGVkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBUaGUgbWVzc2FnZSB0byBlbWl0LlxyXG4gICAqIEBwYXJhbSB7YW55PX0gdmFsdWUgLSBPcHRpb25hbCBhcmd1bWVudCB0byBwYXNzIHRvIGxpc3RlbmVyIGNhbGxiYWNrcy5cclxuICAgKi9cclxuICBlbWl0KG1lc3NhZ2UsIHZhbHVlKSB7XHJcbiAgICBpZiAodGhpcy5fY2FsbGJhY2tzW21lc3NhZ2VdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIG1lc3NhZ2UgPSB0aGlzLl9jcmVhdGVMb2NhbE1lc3NhZ2UobWVzc2FnZSk7XHJcbiAgICBjb25zdCBldmVudCA9IHRoaXMuX2NyZWF0ZUV2ZW50KG1lc3NhZ2UsIHZhbHVlKTtcclxuICAgIHRoaXMuX2Rpc3BhdGNoZXIuZGlzcGF0Y2hFdmVudChldmVudCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBFeGVjdXRlIGEgZnVuY3Rpb24gd2hlbiBhIG1lc3NhZ2UgaXMgcmVjZWl2ZWQgZm9yIHRoZSBnbG9iYWwgTWVzc2VuZ2VyIGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHN0YXRpY1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBUaGUgbWVzc2FnZSB0byBsaXN0ZW4gZm9yLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSBvbmNlIHRoZSBtZXNzYWdlIGlzIHJlY2VpdmVkLlxyXG4gICAqL1xyXG4gIHN0YXRpYyBsaXN0ZW5UbyhtZXNzYWdlLCBjYWxsYmFjaywgbWVzc2VuZ2VyKSB7XHJcbiAgICB0aGlzLkdsb2JhbE1lc3Nlbmdlci5saXN0ZW5UbyhtZXNzYWdlLCBjYWxsYmFjaywgbWVzc2VuZ2VyKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFByZXZlbnQgYSBmdW5jdGlvbiBmcm9tIGJlaW5nIGV4ZWN1dGVkIHdoZW4gYSBtZXNzYWdlIGlzIHJlY2VpdmVkIGZvciB0aGVcclxuICAgKiBnbG9iYWwgTWVzc2VuZ2VyIGluc3RhbmNlLlxyXG4gICAqXHJcbiAgICogQHN0YXRpY1xyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBUaGUgbWVzc2FnZSB0byBzdG9wIGxpc3RlbmluZyBmb3IuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IGNhbGxiYWNrIC0gT3B0aW9uYWwgY2FsbGJhY2sgdG8gcmVtb3ZlLiBJZiBub25lIGlzIGRlZmluZWQsXHJcbiAgICogcmVtb3ZlIGFsbCBjYWxsYmFja3MgZm9yIHRoZSBtZXNzYWdlLlxyXG4gICAqL1xyXG4gIHN0YXRpYyBzdG9wTGlzdGVuaW5nKG1lc3NhZ2UsIGNhbGxiYWNrKSB7XHJcbiAgICB0aGlzLkdsb2JhbE1lc3Nlbmdlci5zdG9wTGlzdGVuaW5nKG1lc3NhZ2UsIGNhbGxiYWNrKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIERlLXJlZ2lzdGVyIGNhbGxiYWNrKHMpIGZyb20gYmVpbmcgZXhlY3V0ZWQgb24gdGhlIGdsb2JhbCBtZXNzZW5nZXJyIGluc3RhbmNlXHJcbiAgICogd2hlbiBtZXNzYWdlcyBtYXRjaGluZyB0aGUgZ2l2ZW4gcmVndWxhciBleHByZXNzaW9uIGFyZSByZWNlaXZlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UmVnZXhwfSByZWdleHAgLSByZWdleHAgLSBUaGUgcmVndWxhciBleHByZXNzaW9uIHRvIGZpbHRlciBtZXNzYWdlcyB3aXRoLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBjYWxsYmFjayAtIE9wdGlvbmFsIGNhbGxiYWNrIHRvIHJlbW92ZS4gSWYgbm9uZSBpcyBkZWZpbmVkLFxyXG4gICAqIHJlbW92ZSBhbGwgY2FsbGJhY2tzIGZvciBtZXNzYWdlcyBtYXRjaGluZyB0aGUgcmVndWxhciBleHByZXNzaW9uLlxyXG4gICAqL1xyXG4gIHN0YXRpYyBzdG9wTGlzdGVuaW5nQnlSZWdleHAocmVnZXhwLCBjYWxsYmFjaykge1xyXG4gICAgY29uc3QgbWVzc2FnZXMgPSBPYmplY3Qua2V5cyh0aGlzLkdsb2JhbE1lc3Nlbmdlci5fY2FsbGJhY2tzKS5maWx0ZXIoXHJcbiAgICAgIG1lc3NhZ2UgPT4gcmVnZXhwLnRlc3QobWVzc2FnZSlcclxuICAgICk7XHJcblxyXG4gICAgbWVzc2FnZXMuZm9yRWFjaChtZXNzYWdlID0+IHtcclxuICAgICAgdGhpcy5zdG9wTGlzdGVuaW5nKG1lc3NhZ2UsIGNhbGxiYWNrKTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUHJldmVudCBhbnkgZnVuY3Rpb25zIGZyb20gYmVpbmcgZXhlY3V0ZWQgd2hlbiBhbnkgbWVzc2FnZSBpcyByZWNlaXZlZCBmb3JcclxuICAgKiB0aGUgZ2xvYmFsIE1lc3NlbmdlciBpbnN0YW5jZS5cclxuICAgKlxyXG4gICAqIEBzdGF0aWNcclxuICAgKi9cclxuICBzdGF0aWMgc3RvcExpc3RlbmluZ1RvQWxsKCkge1xyXG4gICAgdGhpcy5HbG9iYWxNZXNzZW5nZXIuc3RvcExpc3RlbmluZ1RvQWxsKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZW5kIGEgbWVzc2FnZSwgY2F1c2luZyBsaXN0ZW5lciBmdW5jdGlvbnMgZm9yIHRoZSBtZXNzYWdlIG9uIHRoZSBnbG9iYWwgTWVzc2VuZ2VyXHJcbiAgICogaW5zdGFuY2UgdG8gYmUgZXhlY3V0ZWQuXHJcbiAgICpcclxuICAgKiBAc3RhdGljXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIFRoZSBtZXNzYWdlIHRvIGVtaXQuXHJcbiAgICogQHBhcmFtIHthbnk9fSB2YWx1ZSAtIE9wdGlvbmFsIGFyZ3VtZW50IHRvIHBhc3MgdG8gbGlzdGVuZXIgY2FsbGJhY2tzLlxyXG4gICAqL1xyXG4gIHN0YXRpYyBlbWl0KG1lc3NhZ2UsIHZhbHVlKSB7XHJcbiAgICB0aGlzLkdsb2JhbE1lc3Nlbmdlci5lbWl0KG1lc3NhZ2UsIHZhbHVlKTtcclxuICB9XHJcbn1cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE1lc3Nlbmdlciwge1xyXG4gIEdsb2JhbE1lc3Nlbmdlcjoge1xyXG4gICAgdmFsdWU6IG5ldyBNZXNzZW5nZXIoKSxcclxuICAgIHdyaXRhYmxlOiBmYWxzZSxcclxuICB9LFxyXG4gIEVWRU5UUzoge1xyXG4gICAgdmFsdWU6IHt9LFxyXG4gICAgd3JpdGFibGU6IGZhbHNlLFxyXG4gIH0sXHJcbn0pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgTWVzc2VuZ2VyO1xyXG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXHJcbmltcG9ydCBNZXNzZW5nZXIgZnJvbSAnYXBwL01lc3Nlbmdlcic7XHJcblxyXG4vKipcclxuICogQmFzZSBjbGFzcyBmb3IgYWxsIGhvc3QgZmVhdHVyZXMuIEtlZXBzIGEgcmVmZXJlbmNlIHRvIHRoZSBob3N0IG9iamVjdCBtYW5hZ2luZ1xyXG4gKiB0aGUgZmVhdHVyZS5cclxuICpcclxuICogQGFic3RyYWN0XHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBFVkVOVFMgLSBCdWlsdC1pbiBtZXNzYWdlcyB0aGF0IHRoZSBmZWF0dXJlIGVtaXRzLiBXaGVuIHRoZVxyXG4gKiBmZWF0dXJlIGlzIGFkZGVkIHRvIGEge0BsaW5rIGNvcmUvSG9zdE9iamVjdH0sIGV2ZW50IG5hbWVzIHdpbGwgYmUgcHJlZml4ZWQgYnkgdGhlXHJcbiAqIG5hbWUgb2YgdGhlIGZlYXR1cmUgY2xhc3MgKyAnLicuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRTLnVwZGF0ZT1vblVwZGF0ZV0gLSBNZXNzYWdlIHRoYXQgaXMgZW1pdHRlZCBhZnRlclxyXG4gKiBlYWNoIGNhbGwgdG8gW3VwZGF0ZV17QGxpbmsgQWJzdHJhY3RIb3N0RmVhdHVyZSN1cGRhdGV9LlxyXG4gKiBAcHJvcGVydHkge09iamVjdH0gU0VSVklDRVMgLSBBbnkgQVdTIHNlcnZpY2VzIHRoYXQgYXJlIG5lY2Vzc2FyeSBmb3IgdGhlXHJcbiAqIGZlYXR1cmUgdG8gZnVuY3Rpb24uXHJcbiAqL1xyXG5jbGFzcyBBYnN0cmFjdEhvc3RGZWF0dXJlIHtcclxuICAvKipcclxuICAgKiBAY29uc3RydWN0b3JcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Y29yZS9Ib3N0T2JqZWN0fSBob3N0IC0gVGhlIEhvc3RPYmplY3QgbWFuYWdpbmcgdGhlIGZlYXR1cmUuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoaG9zdCkge1xyXG4gICAgdGhpcy5faG9zdCA9IGhvc3Q7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBBZGRzIGEgbmFtZXNwYWNlIHRvIHRoZSBob3N0IHdpdGggdGhlIG5hbWUgb2YgdGhlIGZlYXR1cmUgdG8gY29udGFpbiBwcm9wZXJ0aWVzXHJcbiAgICogYW5kIG1ldGhvZHMgZnJvbSB0aGUgZmVhdHVyZSB0aGF0IHVzZXJzIG9mIHRoZSBob3N0IG5lZWQgYWNjZXNzIHRvLlxyXG4gICAqL1xyXG4gIGluc3RhbGxBcGkoKSB7XHJcbiAgICBjb25zdCBldmVudHMgPSB7fTtcclxuICAgIGNvbnN0IGFwaSA9IHtFVkVOVFM6IGV2ZW50c307XHJcblxyXG4gICAgLy8gQWRkIHRoZSBjbGFzcyBuYW1lIHRvIGV2ZW50IG5hbWVzXHJcbiAgICBPYmplY3QuZW50cmllcyh0aGlzLmNvbnN0cnVjdG9yLkVWRU5UUykuZm9yRWFjaCgoW25hbWUsIHZhbHVlXSkgPT4ge1xyXG4gICAgICBldmVudHNbbmFtZV0gPSBgJHt0aGlzLmNvbnN0cnVjdG9yLm5hbWV9LiR7dmFsdWV9YDtcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuX2hvc3RbdGhpcy5jb25zdHJ1Y3Rvci5uYW1lXSA9IGFwaTtcclxuXHJcbiAgICByZXR1cm4gYXBpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgaG9zdCB0aGF0IG1hbmFnZXMgdGhlIGZlYXR1cmUuXHJcbiAgICpcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKi9cclxuICBnZXQgaG9zdCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9ob3N0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgZW5naW5lIG93bmVyIG9iamVjdCBvZiB0aGUgaG9zdC5cclxuICAgKlxyXG4gICAqIEByZWFkb25seVxyXG4gICAqL1xyXG4gIGdldCBvd25lcigpIHtcclxuICAgIHJldHVybiB0aGlzLl9ob3N0Lm93bmVyO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTGlzdGVuIHRvIGEgZmVhdHVyZSBtZXNzYWdlIGZyb20gdGhlIGhvc3Qgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBNZXNzYWdlIHRvIGxpc3RlbiBmb3IuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHRoZSBtZXNzYWdlIGlzIHJlY2VpdmVkLlxyXG4gICAqL1xyXG4gIGxpc3RlblRvKG1lc3NhZ2UsIGNhbGxiYWNrKSB7XHJcbiAgICB0aGlzLl9ob3N0Lmxpc3RlblRvKG1lc3NhZ2UsIGNhbGxiYWNrKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIExpc3RlbiB0byBhIGZlYXR1cmUgbWVzc2FnZSBmcm9tIHRoZSBnbG9iYWwgbWVzc2VuZ2VyLiBGZWF0dXJlIG1lc3NhZ2VzIHdpbGxcclxuICAgKiBiZSBwcmVmaXhlZCB3aXRoIHRoZSBjbGFzcyBuYW1lIG9mIHRoZSBmZWF0dXJlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBNZXNzYWdlIHRvIGxpc3RlbiBmb3IuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2sgLSBUaGUgY2FsbGJhY2sgdG8gZXhlY3V0ZSB3aGVuIHRoZSBtZXNzYWdlIGlzIHJlY2VpdmVkLlxyXG4gICAqL1xyXG4gIHN0YXRpYyBsaXN0ZW5UbyhtZXNzYWdlLCBjYWxsYmFjaykge1xyXG4gICAgbWVzc2FnZSA9IGAke3RoaXMubmFtZX0uJHttZXNzYWdlfWA7XHJcbiAgICBNZXNzZW5nZXIubGlzdGVuVG8obWVzc2FnZSwgY2FsbGJhY2spO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RvcCBsaXN0ZW5pbmcgdG8gYSBtZXNzYWdlIGZyb20gdGhlIGhvc3Qgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBNZXNzYWdlIHRvIHN0b3AgbGlzdGVuaW5nIGZvci5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gY2FsbGJhY2sgLSBPcHRpb25hbCBjYWxsYmFjayB0byByZW1vdmUuIElmIG5vbmUgaXMgZGVmaW5lZCxcclxuICAgKiByZW1vdmUgYWxsIGNhbGxiYWNrcyBmb3IgdGhlIG1lc3NhZ2UuXHJcbiAgICovXHJcbiAgc3RvcExpc3RlbmluZyhtZXNzYWdlLCBjYWxsYmFjaykge1xyXG4gICAgdGhpcy5faG9zdC5zdG9wTGlzdGVuaW5nKG1lc3NhZ2UsIGNhbGxiYWNrKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0b3AgbGlzdGVuaW5nIHRvIGEgbWVzc2FnZSBmcm9tIHRoZSBnbG9iYWwgbWVzc2VuZ2VyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgLSBNZXNzYWdlIHRvIHN0b3AgbGlzdGVuaW5nIGZvci5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gY2FsbGJhY2sgLSBPcHRpb25hbCBjYWxsYmFjayB0byByZW1vdmUuIElmIG5vbmUgaXMgZGVmaW5lZCxcclxuICAgKiByZW1vdmUgYWxsIGNhbGxiYWNrcyBmb3IgdGhlIG1lc3NhZ2UuXHJcbiAgICovXHJcbiAgc3RhdGljIHN0b3BMaXN0ZW5pbmcobWVzc2FnZSwgY2FsbGJhY2spIHtcclxuICAgIG1lc3NhZ2UgPSBgJHt0aGlzLm5hbWV9LiR7bWVzc2FnZX1gO1xyXG4gICAgTWVzc2VuZ2VyLnN0b3BMaXN0ZW5pbmcobWVzc2FnZSwgY2FsbGJhY2spO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RvcCBsaXN0ZW5pbmcgdG8gYSBtZXNzYWdlIG1hdGNoaW5nIHRoZSBnaXZlbiByZWd1bGFyIGV4cHJlc3Npb24gZnJvbSB0aGVcclxuICAgKiBob3N0IG9iamVjdC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7UmVnZXhwfSByZWdleHAgLSBUaGUgcmVndWxhciBleHByZXNzaW9uIHRvIHN0b3AgbGlzdGVuaW5nIGZvci5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gY2FsbGJhY2sgLSBPcHRpb25hbCBjYWxsYmFjayB0byByZW1vdmUuIElmIG5vbmUgaXMgZGVmaW5lZCxcclxuICAgKiByZW1vdmUgYWxsIGNhbGxiYWNrcyBmb3IgdGhlIG1lc3NhZ2UuXHJcbiAgICovXHJcbiAgc3RvcExpc3RlbmluZ0J5UmVnZXhwKHJlZ2V4cCwgY2FsbGJhY2spIHtcclxuICAgIHRoaXMuX2hvc3Quc3RvcExpc3RlbmluZ0J5UmVnZXhwKHJlZ2V4cCwgY2FsbGJhY2spO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RvcCBsaXN0ZW5pbmcgdG8gYSBtZXNzYWdlIG1hdGNoaW5nIHRoZSBnaXZlbiByZWd1bGFyIGV4cHJlc3Npb24gZnJvbSB0aGVcclxuICAgKiBnbG9iYWwgbWVzc2VuZ2VyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtSZWdleHB9IHJlZ2V4cCAtIFRoZSByZWd1bGFyIGV4cHJlc3Npb24gdG8gc3RvcCBsaXN0ZW5pbmcgZm9yLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBjYWxsYmFjayAtIE9wdGlvbmFsIGNhbGxiYWNrIHRvIHJlbW92ZS4gSWYgbm9uZSBpcyBkZWZpbmVkLFxyXG4gICAqIHJlbW92ZSBhbGwgY2FsbGJhY2tzIGZvciB0aGUgbWVzc2FnZS5cclxuICAgKi9cclxuICBzdGF0aWMgc3RvcExpc3RlbmluZ0J5UmVnZXhwKHJlZ2V4cCwgY2FsbGJhY2spIHtcclxuICAgIHJlZ2V4cCA9IG5ldyBSZWdFeHAoYF4ke3RoaXMubmFtZX0uJHtyZWdleHAuc291cmNlLnJlcGxhY2UoL1xcXi8sICcnKX1gKTtcclxuICAgIE1lc3Nlbmdlci5zdG9wTGlzdGVuaW5nQnlSZWdleHAocmVnZXhwLCBjYWxsYmFjayk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdG9wIGxpc3RlbmluZyB0byBhbGwgbWVzc2FnZXMuXHJcbiAgICovXHJcbiAgc3RvcExpc3RlbmluZ1RvQWxsKCkge1xyXG4gICAgdGhpcy5faG9zdC5zdG9wTGlzdGVuaW5nVG9BbGwoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0b3AgbGlzdGVuaW5nIHRvIGFsbCBmZWF0dXJlIG1lc3NhZ2VzLlxyXG4gICAqL1xyXG4gIHN0YXRpYyBzdG9wTGlzdGVuaW5nVG9BbGwoKSB7XHJcbiAgICBNZXNzZW5nZXIuc3RvcExpc3RlbmluZ0J5UmVnZXhwKG5ldyBSZWdFeHAoYF4ke3RoaXMubmFtZX0uYCkpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRW1pdCBmZWF0dXJlIG1lc3NhZ2VzIGZyb20gdGhlIGhvc3QuIEZlYXR1cmUgbWVzc2FnZXMgd2lsbCBiZSBwcmVmaXhlZCB3aXRoXHJcbiAgICogdGhlIGNsYXNzIG5hbWUgb2YgdGhlIGZlYXR1cmUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSAtIFRoZSBtZXNzYWdlIHRvIGVtaXQuXHJcbiAgICogQHBhcmFtIHthbnk9fSB2YWx1ZSAtIE9wdGlvbmFsIHBhcmFtZXRlciB0byBwYXNzIHRvIGxpc3RlbmVyIGNhbGxiYWNrcy5cclxuICAgKi9cclxuICBlbWl0KG1lc3NhZ2UsIHZhbHVlKSB7XHJcbiAgICBtZXNzYWdlID0gYCR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfS4ke21lc3NhZ2V9YDtcclxuICAgIHRoaXMuX2hvc3QuZW1pdChtZXNzYWdlLCB2YWx1ZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBFbWl0IGZlYXR1cmUgbWVzc2FnZXMgZnJvbSB0aGUgZ2xvYmFsIG1lc3Nlbmdlci4gRmVhdHVyZSBtZXNzYWdlcyB3aWxsIGJlIHByZWZpeGVkXHJcbiAgICogd2l0aCB0aGUgY2xhc3MgbmFtZSBvZiB0aGUgZmVhdHVyZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBtZXNzYWdlIC0gVGhlIG1lc3NhZ2UgdG8gZW1pdC5cclxuICAgKiBAcGFyYW0ge2FueT19IHZhbHVlIC0gT3B0aW9uYWwgcGFyYW1ldGVyIHRvIHBhc3MgdG8gbGlzdGVuZXIgY2FsbGJhY2tzLlxyXG4gICAqL1xyXG4gIHN0YXRpYyBlbWl0KG1lc3NhZ2UsIHZhbHVlKSB7XHJcbiAgICBtZXNzYWdlID0gYCR7dGhpcy5uYW1lfS4ke21lc3NhZ2V9YDtcclxuICAgIE1lc3Nlbmdlci5lbWl0KG1lc3NhZ2UsIHZhbHVlKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEV4ZWN1dGVzIGVhY2ggdGltZSB0aGUgaG9zdCBpcyB1cGRhdGVkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhVGltZSAtIEFtb3VudCBvZiB0aW1lIHNpbmNlIHRoZSBsYXN0IGhvc3QgdXBkYXRlIHdhc1xyXG4gICAqIGNhbGxlZC5cclxuICAgKi9cclxuICB1cGRhdGUoZGVsdGFUaW1lKSB7XHJcbiAgICB0aGlzLmVtaXQodGhpcy5jb25zdHJ1Y3Rvci5FVkVOVFMudXBkYXRlLCBkZWx0YVRpbWUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2xlYW4gdXAgb25jZSB0aGUgZmVhdHVyZSBpcyBubyBsb25nZXIgaW4gdXNlLiBSZW1vdmUgdGhlIGZlYXR1cmUgbmFtZXNwYWNlXHJcbiAgICogZnJvbSB0aGUgaG9zdCBhbmQgcmVtb3ZlIHJlZmVyZW5jZSB0byB0aGUgaG9zdC5cclxuICAgKi9cclxuICBkaXNjYXJkKCkge1xyXG4gICAgT2JqZWN0LmtleXModGhpcy5faG9zdFt0aGlzLmNvbnN0cnVjdG9yLm5hbWVdKS5mb3JFYWNoKG5hbWUgPT4ge1xyXG4gICAgICBkZWxldGUgdGhpcy5faG9zdFt0aGlzLmNvbnN0cnVjdG9yLm5hbWVdW25hbWVdO1xyXG4gICAgfSk7XHJcblxyXG4gICAgZGVsZXRlIHRoaXMuX2hvc3RbdGhpcy5jb25zdHJ1Y3Rvci5uYW1lXTtcclxuICAgIGRlbGV0ZSB0aGlzLl9ob3N0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQXBwbGllcyBhIHNlcXVlbmNlIG9mIG1peGluIGNsYXNzIGZhY3RvcnkgZnVuY3Rpb25zIHRvIHRoaXMgY2xhc3MgYW5kXHJcbiAgICogcmV0dXJucyB0aGUgcmVzdWx0LiBFYWNoIGZ1bmN0aW9uIGlzIGV4cGVjdGVkIHRvIHJldHVybiBhIGNsYXNzIHRoYXRcclxuICAgKiBleHRlbmRzIHRoZSBjbGFzcyBpdCB3YXMgZ2l2ZW4uIFRoZSBmdW5jdGlvbnMgYXJlIGFwcGxpZWQgaW4gdGhlIG9yZGVyXHJcbiAgICogdGhhdCBwYXJhbWV0ZXJzIGFyZSBnaXZlbiwgbWVhbmluZyB0aGF0IHRoZSBmaXJzdCBmYWN0b3J5IHdpbGxcclxuICAgKiBleHRlbmQgdGhpcyBiYXNlIGNsYXNzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsuLi5GdW5jdGlvbn0gbWl4aW5DbGFzc0ZhY3RvcmllcyBDbGFzcyBmYWN0b3J5IGZ1bmN0aW9ucyB0aGF0IHdpbGxcclxuICAgKiBiZSBhcHBsaWVkLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0NsYXNzfSBBIGNsYXNzIHRoYXQgaXMgdGhlIHJlc3VsdCBvZiBhcHBseWluZyB0aGUgZmFjdG9yeSBmdW5jdGlvbnMuXHJcbiAgICogVGhlIHJlc3VsdGluZyBjbGFzcyB3aWxsIGFsd2F5cyBpbmhlcml0IGZyb20gQWJzdHJhY3RIb3N0RmVhdHVyZS5cclxuICAgKi9cclxuICBzdGF0aWMgbWl4KC4uLm1peGluQ2xhc3NGYWN0b3JpZXMpIHtcclxuICAgIGxldCBSZXN1bHRDbGFzcyA9IHRoaXM7XHJcblxyXG4gICAgbWl4aW5DbGFzc0ZhY3Rvcmllcy5mb3JFYWNoKG1peGluQ2xhc3NGYWN0b3J5ID0+IHtcclxuICAgICAgUmVzdWx0Q2xhc3MgPSBtaXhpbkNsYXNzRmFjdG9yeShSZXN1bHRDbGFzcyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gUmVzdWx0Q2xhc3M7XHJcbiAgfVxyXG59XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhBYnN0cmFjdEhvc3RGZWF0dXJlLCB7XHJcbiAgRVZFTlRTOiB7XHJcbiAgICB2YWx1ZToge1xyXG4gICAgICB1cGRhdGU6ICdvblVwZGF0ZScsXHJcbiAgICB9LFxyXG4gICAgd3JpdGFibGU6IGZhbHNlLFxyXG4gIH0sXHJcbiAgU0VSVklDRVM6IHtcclxuICAgIHZhbHVlOiB7fSxcclxuICAgIHdyaXRhYmxlOiBmYWxzZSxcclxuICB9LFxyXG59KTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEFic3RyYWN0SG9zdEZlYXR1cmU7XHJcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcclxuaW1wb3J0IE1lc3NlbmdlciBmcm9tICdhcHAvTWVzc2VuZ2VyJztcclxuaW1wb3J0IEFic3RyYWN0SG9zdEZlYXR1cmUgZnJvbSAnLi9BYnN0cmFjdEhvc3RGZWF0dXJlJztcclxuaW1wb3J0IFV0aWxzIGZyb20gJy4vVXRpbHMnO1xyXG5cclxuLyoqXHJcbiAqIE9iamVjdCB0aGF0IG1hbmFnZXMgYWNjZXNzIHRvIGFsbCBIb3N0IGZlYXR1cmVzLiBDb250YWlucyBhIHJlZmVyZW5jZSB0b1xyXG4gKiBlbmdpbmUtc3BlY2lmaWMgdmlzdWFscyBpZiBhcHBsaWNhYmxlLlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBjb3JlL01lc3NlbmdlclxyXG4gKiBAYWxpYXMgY29yZS9Ib3N0T2JqZWN0XHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBFVkVOVFMgLSBCdWlsdC1pbiBtZXNzYWdlcyB0aGF0IHRoZSBNZXNzZW5nZXIgZW1pdHMuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRTLnVwZGF0ZT0nb25VcGRhdGUnXSAtIE1lc3NhZ2UgdGhhdCBpcyBlbWl0dGVkIGFmdGVyXHJcbiAqIGVhY2ggY2FsbCB0byBbdXBkYXRlXXtAbGluayBjb3JlL0hvc3RPYmplY3QjdXBkYXRlfS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVFMuYWRkRmVhdHVyZT0nb25BZGRGZWF0dXJlJ10gLSBNZXNzYWdlIHRoYXQgaXMgZW1pdHRlZFxyXG4gKiBhZnRlciBlYWNoIGNhbGwgdG8gW2FkZEZlYXR1cmVde0BsaW5rIGNvcmUvSG9zdE9iamVjdCNhZGRGZWF0dXJlfS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVFMucmVtb3ZlRmVhdHVyZT0nb25SZW1vdmVGZWF0dXJlJ10gLSBNZXNzYWdlIHRoYXQgaXMgZW1pdHRlZFxyXG4gKiBhZnRlciBlYWNoIGNhbGwgdG8gW3JlbW92ZUZlYXR1cmVde0BsaW5rIGNvcmUvSG9zdE9iamVjdCNyZW1vdmVGZWF0dXJlfS5cclxuICovXHJcbmNsYXNzIEhvc3RPYmplY3QgZXh0ZW5kcyBNZXNzZW5nZXIge1xyXG4gIC8qKlxyXG4gICAqIEBjb25zdHJ1Y3RvclxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIGhvc3QuXHJcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zLm93bmVyIC0gT3B0aW9uYWwgZW5naW5lLXNwZWNpZmljIG93bmVyIG9mIHRoZSBob3N0LlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKHtvd25lciA9IHt9fSA9IHt9KSB7XHJcbiAgICAvLyBJZiBhbiBvd25lciBpcyBzcGVjaWZpZWQsIHVzZSBpdHMgaWQgZm9yIG1lc3NhZ2luZ1xyXG4gICAgc3VwZXIob3duZXIuaWQpO1xyXG5cclxuICAgIHRoaXMuX293bmVyID0gb3duZXI7XHJcbiAgICB0aGlzLl9mZWF0dXJlcyA9IHt9O1xyXG4gICAgdGhpcy5fd2FpdHMgPSBbXTtcclxuICAgIHRoaXMuX2xhc3RVcGRhdGUgPSB0aGlzLm5vdztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIGVuZ2luZSBvd25lciBvYmplY3Qgb2YgdGhlIGhvc3QuXHJcbiAgICpcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAdHlwZSB7T2JqZWN0fVxyXG4gICAqL1xyXG4gIGdldCBvd25lcigpIHtcclxuICAgIHJldHVybiB0aGlzLl9vd25lcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIGN1cnJlbnQgdGltZSBpbiBtaWxsaXNlY29uZHMuXHJcbiAgICpcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCBub3coKSB7XHJcbiAgICByZXR1cm4gRGF0ZS5ub3coKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIGFtb3VudCBvZiB0aW1lIGluIG1pbGxpc2Vjb25kcyBzaW5jZSB1cGRhdGUgd2FzIGxhc3QgY2FsbGVkLlxyXG4gICAqXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgZGVsdGFUaW1lKCkge1xyXG4gICAgcmV0dXJuIHRoaXMubm93IC0gdGhpcy5fbGFzdFVwZGF0ZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFRoaXMgZnVuY3Rpb24gc2hvdWxkIGJlIGNhbGxlZCBpbiB0aGUgZW5naW5lJ3MgcmVuZGVyIGxvb3AuIEV4ZWN1dGVzIHVwZGF0ZVxyXG4gICAqIGxvb3BzIGZvciBhbGwgZmVhdHVyZXMuXHJcbiAgICovXHJcbiAgdXBkYXRlKCkge1xyXG4gICAgY29uc3QgY3VycmVudFRpbWUgPSB0aGlzLm5vdztcclxuICAgIGNvbnN0IGR0ID0gdGhpcy5kZWx0YVRpbWU7XHJcblxyXG4gICAgLy8gUHJvZ3Jlc3Mgc3RvcmVkIHdhaXRzXHJcbiAgICB0aGlzLl93YWl0cy5mb3JFYWNoKHdhaXQgPT4ge1xyXG4gICAgICB3YWl0LmV4ZWN1dGUoZHQpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gVXBkYXRlIGFsbCBmZWF0dXJlc1xyXG4gICAgT2JqZWN0LnZhbHVlcyh0aGlzLl9mZWF0dXJlcykuZm9yRWFjaChmZWF0dXJlID0+IHtcclxuICAgICAgZmVhdHVyZS51cGRhdGUoZHQpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gTm90aWZ5IGxpc3RlbmVycyBhbiB1cGRhdGUgb2NjdXJlZFxyXG4gICAgdGhpcy5lbWl0KHRoaXMuY29uc3RydWN0b3IuRVZFTlRTLnVwZGF0ZSwgZHQpO1xyXG5cclxuICAgIHRoaXMuX2xhc3RVcGRhdGUgPSBjdXJyZW50VGltZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiBhIGRlZmVycmVkIHByb21pc2UgdGhhdCB3aWxsIHdhaXQgYSBnaXZlbiBudW1iZXIgb2Ygc2Vjb25kcyBiZWZvcmVcclxuICAgKiByZXNvbHZpbmcuIFRoZSBob3N0IHdpbGwgY29udGludW91c2x5IHVwZGF0ZSB0aGUgd2FpdCBwcm9taXNlIGR1cmluZyB0aGVcclxuICAgKiB1cGRhdGUgbG9vcCB1bnRpbCBpdCByZXNvbHZlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc2Vjb25kcz0wXSAtIE51bWJlciBvZiBzZWNvbmRzIHRvIHdhaXQgYmVmb3JlIHJlc29sdmluZy5cclxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgLSBPcHRpb25hbCBvcHRpb25zIG9iamVjdFxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uRmluaXNoXSAtIENhbGxiYWNrIHRvIGV4ZWN1dGUgb25jZSB0aGUgd2FpdCB0aW1lXHJcbiAgICogaXMgbWV0LlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvcHRpb25zLm9uUHJvZ3Jlc3MgLSBDYWxsYmFjayB0byBleGVjdXRlIGVhY2ggdGltZSB0aGUgd2FpdFxyXG4gICAqIHRpbWUgcHJvZ3Jlc3NlcyB0b3dhcmRzIHRoZSB0YXJnZXQgbnVtYmVyIG9mIHNlY29uZHMuIFRoZSBhbW91bnQgb2YgcHJvZ3Jlc3NcclxuICAgKiBhcyBhIDAtMSBwZXJjZW50YWdlIGlzIHBhc3NlZCBhcyBhbiBhcmd1bWVudC5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb3B0aW9ucy5vbkNhbmNlbCAtIENhbGxiYWNrIHRvIGV4ZWN1dGUgaWYgdGhlIHVzZXIgY2FuY2Vsc1xyXG4gICAqIHRoZSB3YWl0IGJlZm9yZSBjb21wbGV0aW9uLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvcHRpb25zLm9uRXJyb3IgLSBDYWxsYmFjayB0byBleGVjdXRlIGlmIHRoZSB3YWl0IHN0b3BzXHJcbiAgICogYmVjYXVzZSBhbiBlcnJvciBpcyBlbmNvdW50ZXJlZC4gVGhlIGVycm9yIG1lc3NhZ2UgaXMgcGFzc2VkIGFzIGEgcGFyYW1ldGVyLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0RlZmVycmVkfVxyXG4gICAqL1xyXG4gIHdhaXQoc2Vjb25kcywge29uRmluaXNoLCBvblByb2dyZXNzLCBvbkNhbmNlbCwgb25FcnJvcn0gPSB7fSkge1xyXG4gICAgY29uc3Qgd2FpdCA9IFV0aWxzLndhaXQoc2Vjb25kcywge29uRmluaXNoLCBvblByb2dyZXNzLCBvbkNhbmNlbCwgb25FcnJvcn0pO1xyXG4gICAgdGhpcy5fd2FpdHMucHVzaCh3YWl0KTtcclxuXHJcbiAgICAvLyBPbmNlIHRoZSB3YWl0IHByb21pc2UgaXMgbm8gbG9uZ2VyIHBlbmRpbmcgcmVtb3ZlIGl0IGZyb20gdGhlIHdhaXRzIGFycmF5XHJcbiAgICBjb25zdCBvbkNvbXBsZXRlID0gKCkgPT4ge1xyXG4gICAgICB0aGlzLl93YWl0cy5zcGxpY2UodGhpcy5fd2FpdHMuaW5kZXhPZih3YWl0KSwgMSk7XHJcbiAgICB9O1xyXG4gICAgd2FpdC50aGVuKG9uQ29tcGxldGUsIG9uQ29tcGxldGUpO1xyXG5cclxuICAgIHJldHVybiB3YWl0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSW5zdGFudGlhdGUgYSBuZXcgSG9zdCBmZWF0dXJlIGFuZCBzdG9yZSBpdC4gRmVhdHVyZXMgbXVzdCBpbmhlcml0IGZyb21cclxuICAgKiBBYnN0cmFjdEhvc3RGZWF0dXJlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtDbGFzc30gRmVhdHVyZUNsYXNzIC0gQ2xhc3MgdGhhdCB3aWxsIGluc3RhbnRpYXRlIHRoZSBmZWF0dXJlLiBNdXN0XHJcbiAgICogZXh0ZW5kIHtAbGluayBBYnN0cmFjdEhvc3RGZWF0dXJlfS5cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtmb3JjZT1mYWxzZV0gLSBXaGV0aGVyIG9yIG5vdCB0byBvdmVyd3JpdGUgYW4gZXhpc3RpbmdcclxuICAgKiBmZWF0dXJlIGlmIG9uZSBvZiB0aGlzIHR5cGUgYWxyZWFkeSBleGlzdHMgb24gdGhlIG9iamVjdC5cclxuICAgKiBAcGFyYW0gIHsuLi5hbnl9IGFyZ3MgLSBBZGRpdGlvbmFsIGFyZ3VtZW50cyB0byBwYXNzIHRvIHRoZSBGZWF0dXJlQ2xhc3NcclxuICAgKiBjb25zdHJ1Y3Rvci4gVGhlIEhvc3RPYmplY3Qgd2lsbCBhbHdheXMgYmUgcGFzc2VkIGFzIHRoZSBmaXJzdCBhcmd1bWVudC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufSAtIFdoZXRoZXIgb3Igbm90IGEgZmVhdHVyZSB3YXMgc3VjY2Vzc2Z1bGx5IGFkZGVkLlxyXG4gICAqL1xyXG4gIGFkZEZlYXR1cmUoRmVhdHVyZUNsYXNzLCBmb3JjZSA9IGZhbHNlLCAuLi5hcmdzKSB7XHJcbiAgICBjb25zdCBpbnB1dFR5cGUgPSB0eXBlb2YgRmVhdHVyZUNsYXNzO1xyXG5cclxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgRmVhdHVyZUNsYXNzIGNhbiBiZSBleGVjdXRlZFxyXG4gICAgaWYgKGlucHV0VHlwZSAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgYENhbm5vdCBhZGQgZmVhdHVyZSB0byBob3N0ICR7dGhpcy5pZH0uIEZlYXR1cmVDbGFzcyBtdXN0IGJlIGEgY2xhc3MuYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBmZWF0dXJlIGlzIGEgaG9zdCBmZWF0dXJlXHJcbiAgICBlbHNlIGlmICghKEZlYXR1cmVDbGFzcy5wcm90b3R5cGUgaW5zdGFuY2VvZiBBYnN0cmFjdEhvc3RGZWF0dXJlKSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgYENhbm5vdCBhZGQgZmVhdHVyZSAke0ZlYXR1cmVDbGFzcy5uYW1lfSB0byBob3N0ICR7dGhpcy5pZH0uIEZlYXR1cmVDbGFzcyBtdXN0IGV4dGVuZCBBYnN0cmFjdEhvc3RGZWF0dXJlLmBcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBDaGVjayBpZiB0aGUgRmVhdHVyZUNsYXNzIGFscmVhZHkgZXhpc3RzIG9uIHRoaXMgb2JqZWN0XHJcbiAgICBpZiAodGhpcy5fZmVhdHVyZXNbRmVhdHVyZUNsYXNzLm5hbWVdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgaWYgKGZvcmNlKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKFxyXG4gICAgICAgICAgYEZlYXR1cmUgJHtGZWF0dXJlQ2xhc3MubmFtZX0gYWxyZWFkeSBleGlzdHMgb24gaG9zdCAke3RoaXMuaWR9LiBFeGlzdGluZyBmZWF0dXJlIHdpbGwgYmUgb3ZlcndyaXR0ZW4uYFxyXG4gICAgICAgICk7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgYEZlYXR1cmUgJHtGZWF0dXJlQ2xhc3MubmFtZX0gYWxyZWFkeSBleGlzdHMgb24gaG9zdCAke3RoaXMuaWR9LiBVc2UgJ2ZvcmNlJyBhcmd1bWVudCB0byBvdmVyd3JpdGUgdGhlIGZlYXR1cmUuYFxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBJbml0aWFsaXplIHRoZSBmZWF0dXJlXHJcbiAgICBjb25zdCBmZWF0dXJlID0gbmV3IEZlYXR1cmVDbGFzcyh0aGlzLCAuLi5hcmdzKTtcclxuICAgIGZlYXR1cmUuaW5zdGFsbEFwaSgpO1xyXG5cclxuICAgIHRoaXMuX2ZlYXR1cmVzW0ZlYXR1cmVDbGFzcy5uYW1lXSA9IGZlYXR1cmU7XHJcbiAgICB0aGlzLmVtaXQodGhpcy5jb25zdHJ1Y3Rvci5FVkVOVFMuYWRkRmVhdHVyZSwgRmVhdHVyZUNsYXNzLm5hbWUpO1xyXG5cclxuICAgIHJldHVybiB0cnVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVtb3ZlIGEgZmVhdHVyZSBmcm9tIHRoZSBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdHlwZU5hbWUgLSBOYW1lIG9mIHRoZSB0eXBlIG9mIGZlYXR1cmUgdG8gcmVtb3ZlLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59IC0gV2hldGhlciBvciBub3QgYSBmZWF0dXJlIHdhcyBzdWNjZXNzZnVsbHkgcmVtb3ZlZC5cclxuICAgKi9cclxuICByZW1vdmVGZWF0dXJlKHR5cGVOYW1lKSB7XHJcbiAgICBpZiAodGhpcy5fZmVhdHVyZXNbdHlwZU5hbWVdID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgY29uc29sZS53YXJuKFxyXG4gICAgICAgIGBGZWF0dXJlIG9mIHR5cGUgJHt0eXBlTmFtZX0gZG9lcyBub3QgZXhpc3Qgb24gaG9zdCAke3RoaXMuaWR9LiBObyBmZWF0dXJlIHdpbGwgYmUgcmVtb3ZlZC5gXHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIC8vIFJlbW92ZSB0aGUgZmVhdHVyZVxyXG4gICAgICB0aGlzLmVtaXQodGhpcy5jb25zdHJ1Y3Rvci5FVkVOVFMucmVtb3ZlRmVhdHVyZSwgdHlwZU5hbWUpO1xyXG4gICAgICB0aGlzLl9mZWF0dXJlc1t0eXBlTmFtZV0uZGlzY2FyZCgpO1xyXG4gICAgICBkZWxldGUgdGhpcy5fZmVhdHVyZXNbdHlwZU5hbWVdO1xyXG5cclxuICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbmRpY2F0ZSB3aGV0aGVyIGEgc3BlY2lmaWVkIGZlYXR1cmUgaXMgaW5zdGFsbGVkIG9uIHRoZSBob3N0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVOYW1lIC0gTmFtZSBvZiB0aGUgdHlwZSBvZiBmZWF0dXJlIHRvIGxvb2sgZm9yLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgaGFzRmVhdHVyZSh0eXBlTmFtZSkge1xyXG4gICAgcmV0dXJuICEhdGhpcy5fZmVhdHVyZXNbdHlwZU5hbWVdO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTGlzdCB0aGUgbmFtZXMgb2YgdGhlIGZlYXR1cmVzIGluc3RhbGxlZCBvbiB0aGUgaG9zdC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtBcnJheS48c3RyaW5nPn1cclxuICAgKi9cclxuICBsaXN0RmVhdHVyZXMoKSB7XHJcbiAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5fZmVhdHVyZXMpO1xyXG4gIH1cclxufVxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEhvc3RPYmplY3QsICdFVkVOVFMnLCB7XHJcbiAgdmFsdWU6IHtcclxuICAgIC4uLk9iamVjdC5nZXRQcm90b3R5cGVPZihIb3N0T2JqZWN0KS5FVkVOVFMsXHJcbiAgICB1cGRhdGU6ICdvblVwZGF0ZScsXHJcbiAgICBhZGRGZWF0dXJlOiAnb25BZGRGZWF0dXJlJyxcclxuICAgIHJlbW92ZUZlYXR1cmU6ICdvblJlbW92ZUZlYXR1cmUnLFxyXG4gIH0sXHJcbiAgd3JpdGFibGU6IGZhbHNlLFxyXG59KTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEhvc3RPYmplY3Q7XHJcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcclxuLyoqXHJcbiAqIEB0eXBlZGVmIHtPYmplY3R9IEVhc2luZ09iamVjdCBPYmplY3QgY29udGFpbmluZyBlYXNpbmcgZnVuY3Rpb25zXHJcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IEluIC0gRWFzaW5nICdJbicgZnVuY3Rpb24uIFNob3VsZCB1c2UgdGhlIHNpZ25hdHVyZSAoazpudW1iZXIpOm51bWJlci5cclxuICogQHByb3BlcnR5IHtGdW5jdGlvbn0gT3V0IC0gRWFzaW5nICdPdXQnIGZ1bmN0aW9uLiBTaG91bGQgdXNlIHRoZSBzaWduYXR1cmUgKGs6bnVtYmVyKTpudW1iZXIuXHJcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IEluT3V0IC0gRWFzaW5nICdJbk91dCcgZnVuY3Rpb24uIFNob3VsZCB1c2UgdGhlIHNpZ25hdHVyZSAoazpudW1iZXIpOm51bWJlci5cclxuICovXHJcblxyXG4vKipcclxuICogTGluZWFyIEVhc2luZ1xyXG4gKiBAdHlwZSB7RWFzaW5nT2JqZWN0fVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IExpbmVhciA9IHtcclxuICBOb25lKGspIHtcclxuICAgIHJldHVybiBrO1xyXG4gIH0sXHJcbiAgSW4oaykge1xyXG4gICAgcmV0dXJuIGs7XHJcbiAgfSxcclxuICBPdXQoaykge1xyXG4gICAgcmV0dXJuIGs7XHJcbiAgfSxcclxuICBJbk91dChrKSB7XHJcbiAgICByZXR1cm4gaztcclxuICB9LFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFF1YWRyYXRpYyBFYXNpbmdcclxuICogQHR5cGUge0Vhc2luZ09iamVjdH1cclxuICovXHJcbmV4cG9ydCBjb25zdCBRdWFkcmF0aWMgPSB7XHJcbiAgSW4oaykge1xyXG4gICAgcmV0dXJuIGsgKiBrO1xyXG4gIH0sXHJcbiAgT3V0KGspIHtcclxuICAgIHJldHVybiBrICogKDIgLSBrKTtcclxuICB9LFxyXG4gIEluT3V0KGspIHtcclxuICAgIGsgKj0gMjtcclxuICAgIGlmIChrIDwgMSkge1xyXG4gICAgICByZXR1cm4gMC41ICogayAqIGs7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gLTAuNSAqICgtLWsgKiAoayAtIDIpIC0gMSk7XHJcbiAgfSxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBDdWJpYyBFYXNpbmdcclxuICogQHR5cGUge0Vhc2luZ09iamVjdH1cclxuICovXHJcbmV4cG9ydCBjb25zdCBDdWJpYyA9IHtcclxuICBJbihrKSB7XHJcbiAgICByZXR1cm4gayAqIGsgKiBrO1xyXG4gIH0sXHJcbiAgT3V0KGspIHtcclxuICAgIHJldHVybiAtLWsgKiBrICogayArIDE7XHJcbiAgfSxcclxuICBJbk91dChrKSB7XHJcbiAgICBrICo9IDI7XHJcbiAgICBpZiAoayA8IDEpIHtcclxuICAgICAgcmV0dXJuIDAuNSAqIGsgKiBrICogaztcclxuICAgIH1cclxuXHJcbiAgICBrIC09IDI7XHJcbiAgICByZXR1cm4gMC41ICogKGsgKiBrICogayArIDIpO1xyXG4gIH0sXHJcbn07XHJcblxyXG4vKipcclxuICogUXVhcnRpYyBFYXNpbmdcclxuICogQHR5cGUge0Vhc2luZ09iamVjdH1cclxuICovXHJcbmV4cG9ydCBjb25zdCBRdWFydGljID0ge1xyXG4gIEluKGspIHtcclxuICAgIHJldHVybiBrICogayAqIGsgKiBrO1xyXG4gIH0sXHJcbiAgT3V0KGspIHtcclxuICAgIHJldHVybiAxIC0gLS1rICogayAqIGsgKiBrO1xyXG4gIH0sXHJcbiAgSW5PdXQoaykge1xyXG4gICAgayAqPSAyO1xyXG4gICAgaWYgKGsgPCAxKSB7XHJcbiAgICAgIHJldHVybiAwLjUgKiBrICogayAqIGsgKiBrO1xyXG4gICAgfVxyXG5cclxuICAgIGsgLT0gMjtcclxuICAgIHJldHVybiAtMC41ICogKGsgKiBrICogayAqIGsgLSAyKTtcclxuICB9LFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIFF1aW50aWMgRWFzaW5nXHJcbiAqIEB0eXBlIHtFYXNpbmdPYmplY3R9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgUXVpbnRpYyA9IHtcclxuICBJbihrKSB7XHJcbiAgICByZXR1cm4gayAqIGsgKiBrICogayAqIGs7XHJcbiAgfSxcclxuICBPdXQoaykge1xyXG4gICAgcmV0dXJuIC0tayAqIGsgKiBrICogayAqIGsgKyAxO1xyXG4gIH0sXHJcbiAgSW5PdXQoaykge1xyXG4gICAgayAqPSAyO1xyXG4gICAgaWYgKGsgPCAxKSB7XHJcbiAgICAgIHJldHVybiAwLjUgKiBrICogayAqIGsgKiBrICogaztcclxuICAgIH1cclxuXHJcbiAgICBrIC09IDI7XHJcbiAgICByZXR1cm4gMC41ICogKGsgKiBrICogayAqIGsgKiBrICsgMik7XHJcbiAgfSxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBTaW51c29pZGFsIEVhc2luZ1xyXG4gKiBAdHlwZSB7RWFzaW5nT2JqZWN0fVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IFNpbnVzb2lkYWwgPSB7XHJcbiAgSW4oaykge1xyXG4gICAgcmV0dXJuIDEgLSBNYXRoLmNvcygoayAqIE1hdGguUEkpIC8gMik7XHJcbiAgfSxcclxuICBPdXQoaykge1xyXG4gICAgcmV0dXJuIE1hdGguc2luKChrICogTWF0aC5QSSkgLyAyKTtcclxuICB9LFxyXG4gIEluT3V0KGspIHtcclxuICAgIHJldHVybiAwLjUgKiAoMSAtIE1hdGguY29zKE1hdGguUEkgKiBrKSk7XHJcbiAgfSxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFeHBvbmVudGlhbCBFYXNpbmdcclxuICogQHR5cGUge0Vhc2luZ09iamVjdH1cclxuICovXHJcbmV4cG9ydCBjb25zdCBFeHBvbmVudGlhbCA9IHtcclxuICBJbihrKSB7XHJcbiAgICByZXR1cm4gayA9PT0gMCA/IDAgOiAxMDI0ICoqIChrIC0gMSk7XHJcbiAgfSxcclxuICBPdXQoaykge1xyXG4gICAgcmV0dXJuIGsgPT09IDEgPyAxIDogMSAtIDIgKiogKC0xMCAqIGspO1xyXG4gIH0sXHJcbiAgSW5PdXQoaykge1xyXG4gICAgaWYgKGsgPT09IDApIHtcclxuICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcbiAgICBpZiAoayA9PT0gMSkge1xyXG4gICAgICByZXR1cm4gMTtcclxuICAgIH1cclxuXHJcbiAgICBrICo9IDI7XHJcbiAgICBpZiAoayA8IDEpIHtcclxuICAgICAgcmV0dXJuIDAuNSAqIDEwMjQgKiogKGsgLSAxKTtcclxuICAgIH1cclxuICAgIHJldHVybiAwLjUgKiAoLSgyICoqICgtMTAgKiAoayAtIDEpKSkgKyAyKTtcclxuICB9LFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIENpcmN1bGFyIEVhc2luZ1xyXG4gKiBAdHlwZSB7RWFzaW5nT2JqZWN0fVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IENpcmN1bGFyID0ge1xyXG4gIEluKGspIHtcclxuICAgIHJldHVybiAxIC0gTWF0aC5zcXJ0KDEgLSBrICogayk7XHJcbiAgfSxcclxuICBPdXQoaykge1xyXG4gICAgcmV0dXJuIE1hdGguc3FydCgxIC0gLS1rICogayk7XHJcbiAgfSxcclxuICBJbk91dChrKSB7XHJcbiAgICBrICo9IDI7XHJcbiAgICBpZiAoayA8IDEpIHtcclxuICAgICAgcmV0dXJuIC0wLjUgKiAoTWF0aC5zcXJ0KDEgLSBrICogaykgLSAxKTtcclxuICAgIH1cclxuXHJcbiAgICBrIC09IDI7XHJcbiAgICByZXR1cm4gMC41ICogKE1hdGguc3FydCgxIC0gayAqIGspICsgMSk7XHJcbiAgfSxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBFbGFzdGljIEVhc2luZ1xyXG4gKiBAdHlwZSB7RWFzaW5nT2JqZWN0fVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IEVsYXN0aWMgPSB7XHJcbiAgSW4oaykge1xyXG4gICAgbGV0IHM7XHJcbiAgICBsZXQgYSA9IDAuMTtcclxuICAgIGNvbnN0IHAgPSAwLjQ7XHJcblxyXG4gICAgaWYgKGsgPT09IDApIHtcclxuICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGsgPT09IDEpIHtcclxuICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFhIHx8IGEgPCAxKSB7XHJcbiAgICAgIGEgPSAxO1xyXG4gICAgICBzID0gcCAvIDQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzID0gKHAgKiBNYXRoLmFzaW4oMSAvIGEpKSAvICgyICogTWF0aC5QSSk7XHJcbiAgICB9XHJcblxyXG4gICAgayAtPSAxO1xyXG4gICAgcmV0dXJuIC0oYSAqIDIgKiogKDEwICogaykgKiBNYXRoLnNpbigoKGsgLSBzKSAqICgyICogTWF0aC5QSSkpIC8gcCkpO1xyXG4gIH0sXHJcbiAgT3V0KGspIHtcclxuICAgIGxldCBzO1xyXG4gICAgbGV0IGEgPSAwLjE7XHJcbiAgICBjb25zdCBwID0gMC40O1xyXG5cclxuICAgIGlmIChrID09PSAwKSB7XHJcbiAgICAgIHJldHVybiAwO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChrID09PSAxKSB7XHJcbiAgICAgIHJldHVybiAxO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghYSB8fCBhIDwgMSkge1xyXG4gICAgICBhID0gMTtcclxuICAgICAgcyA9IHAgLyA0O1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgcyA9IChwICogTWF0aC5hc2luKDEgLyBhKSkgLyAoMiAqIE1hdGguUEkpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBhICogMiAqKiAoLTEwICogaykgKiBNYXRoLnNpbigoKGsgLSBzKSAqICgyICogTWF0aC5QSSkpIC8gcCkgKyAxO1xyXG4gIH0sXHJcbiAgSW5PdXQoaykge1xyXG4gICAgbGV0IHM7XHJcbiAgICBsZXQgYSA9IDAuMTtcclxuICAgIGNvbnN0IHAgPSAwLjQ7XHJcblxyXG4gICAgaWYgKGsgPT09IDApIHtcclxuICAgICAgcmV0dXJuIDA7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGsgPT09IDEpIHtcclxuICAgICAgcmV0dXJuIDE7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKCFhIHx8IGEgPCAxKSB7XHJcbiAgICAgIGEgPSAxO1xyXG4gICAgICBzID0gcCAvIDQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBzID0gKHAgKiBNYXRoLmFzaW4oMSAvIGEpKSAvICgyICogTWF0aC5QSSk7XHJcbiAgICB9XHJcblxyXG4gICAgayAqPSAyO1xyXG4gICAgaWYgKGsgPCAxKSB7XHJcbiAgICAgIGsgLT0gMTtcclxuICAgICAgcmV0dXJuIChcclxuICAgICAgICAtMC41ICogKGEgKiAyICoqICgxMCAqIGspICogTWF0aC5zaW4oKChrIC0gcykgKiAoMiAqIE1hdGguUEkpKSAvIHApKVxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGsgLT0gMTtcclxuICAgIHJldHVybiAoXHJcbiAgICAgIGEgKiAyICoqICgtMTAgKiBrKSAqIE1hdGguc2luKCgoayAtIHMpICogKDIgKiBNYXRoLlBJKSkgLyBwKSAqIDAuNSArIDFcclxuICAgICk7XHJcbiAgfSxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBCYWNrIEVhc2luZ1xyXG4gKiBAdHlwZSB7RWFzaW5nT2JqZWN0fVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IEJhY2sgPSB7XHJcbiAgSW4oaykge1xyXG4gICAgY29uc3QgcyA9IDEuNzAxNTg7XHJcbiAgICByZXR1cm4gayAqIGsgKiAoKHMgKyAxKSAqIGsgLSBzKTtcclxuICB9LFxyXG4gIE91dChrKSB7XHJcbiAgICBjb25zdCBzID0gMS43MDE1ODtcclxuICAgIHJldHVybiAtLWsgKiBrICogKChzICsgMSkgKiBrICsgcykgKyAxO1xyXG4gIH0sXHJcbiAgSW5PdXQoaykge1xyXG4gICAgY29uc3QgcyA9IDEuNzAxNTggKiAxLjUyNTtcclxuICAgIGsgKj0gMjtcclxuICAgIGlmIChrIDwgMSkge1xyXG4gICAgICByZXR1cm4gMC41ICogKGsgKiBrICogKChzICsgMSkgKiBrIC0gcykpO1xyXG4gICAgfVxyXG5cclxuICAgIGsgLT0gMjtcclxuICAgIHJldHVybiAwLjUgKiAoayAqIGsgKiAoKHMgKyAxKSAqIGsgKyBzKSArIDIpO1xyXG4gIH0sXHJcbn07XHJcblxyXG4vKipcclxuICogQm91bmNlIEVhc2luZ1xyXG4gKiBAdHlwZSB7RWFzaW5nT2JqZWN0fVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IEJvdW5jZSA9IHtcclxuICBJbihrKSB7XHJcbiAgICByZXR1cm4gMSAtIEJvdW5jZS5PdXQoMSAtIGspO1xyXG4gIH0sXHJcbiAgT3V0KGspIHtcclxuICAgIGlmIChrIDwgMSAvIDIuNzUpIHtcclxuICAgICAgcmV0dXJuIDcuNTYyNSAqIGsgKiBrO1xyXG4gICAgfSBlbHNlIGlmIChrIDwgMiAvIDIuNzUpIHtcclxuICAgICAgayAtPSAxLjU7XHJcbiAgICAgIHJldHVybiA3LjU2MjUgKiAoayAvIDIuNzUpICogayArIDAuNzU7XHJcbiAgICB9IGVsc2UgaWYgKGsgPCAyLjUgLyAyLjc1KSB7XHJcbiAgICAgIGsgLT0gMi4yNTtcclxuICAgICAgcmV0dXJuIDcuNTYyNSAqIChrIC8gMi43NSkgKiBrICsgMC45Mzc1O1xyXG4gICAgfVxyXG4gICAgayAtPSAyLjYyNTtcclxuICAgIHJldHVybiA3LjU2MjUgKiAoayAvIDIuNzUpICogayArIDAuOTg0Mzc1O1xyXG4gIH0sXHJcbiAgSW5PdXQoaykge1xyXG4gICAgaWYgKGsgPCAwLjUpIHtcclxuICAgICAgcmV0dXJuIEJvdW5jZS5JbihrICogMikgKiAwLjU7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gQm91bmNlLk91dChrICogMiAtIDEpICogMC41ICsgMC41O1xyXG4gIH0sXHJcbn07XHJcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcclxuXHJcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXHJcbi8qIGVzbGludC1kaXNhYmxlIG1heC1jbGFzc2VzLXBlci1maWxlICovXHJcbmltcG9ydCBIb3N0T2JqZWN0IGZyb20gJ2FwcC9Ib3N0T2JqZWN0JztcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyBmYWN0b3J5IGludGVyZmFjZSBmb3IgZmVhdHVyZXMgdGhhdCBhcmUgZGVwZW5kZW50IG9uIG90aGVyIGZlYXR1cmVzIGJlaW5nXHJcbiAqIHByZXNlbnQgb24gdGhlIGhvc3QuIEV2ZW50IGRlcGVuZGVuY2llcyB3aWxsIGJlIGxpc3RlbmVkIGZvciB3aGVuIGEgZmVhdHVyZSBvZlxyXG4gKiBtYXRjaGluZyB0eXBlIGlzIGFkZGVkIHRvIHRoZSBob3N0IGFuZCB3aWxsIHN0b3AgYmVpbmcgbGlzdGVuZWQgZm9yIHdoZW4gb25lXHJcbiAqIGlzIHJlbW92ZWQuIElmIHRoZSBmZWF0dXJlIGlzIGFscmVhZHkgcHJlc2VudCB3aGVuIGNvbnN0cnVjdGVkLCBldmVudHMgd2lsbFxyXG4gKiBiZSBsaXN0ZW5lZCBmb3IgcmlnaHQgYXdheS5cclxuICpcclxuICogQGludGVyZmFjZVxyXG4gKlxyXG4gKiBAcHJvcGVydHkge09iamVjdH0gRVZFTlRfREVQRU5ERU5DSUVTIC0gRXZlbnRzIHRoYXQgdGhlIGZlYXR1cmUgc2hvdWxkIHN0YXJ0L3N0b3BcclxuICogbGlzdGVuaW5nIGZvciB3aGVuIGEgZmVhdHVyZSBvZiB0eXBlIEZlYXR1cmVOYW1lIGlzIGFkZGVkL3JlbW92ZWQgZnJvbSB0aGUgaG9zdC5cclxuICogRXZlbnQgZGVwZW5kZW5jaWVzIHNob3VsZCBmb2xsb3cgdGhlIHNpZ25hdHVyZTpcclxuICogIHsgRmVhdHVyZU5hbWU6IHsgZXZlbnROYW1lOiBjYWxsYmFja05hbWUsIC4uLiB9LCAuLi4gfVxyXG4gKi9cclxuY2xhc3MgRmVhdHVyZURlcGVuZGVudEludGVyZmFjZSB7XHJcbiAgLyoqXHJcbiAgICogU3RhcnQgbGlzdGVuaW5nIGZvciBldmVudCBkZXBlbmRlbmNpZXMgdGhhdCBtYXRjaCB0aGUgZ2l2ZW4gZmVhdHVyZSB0eXBlLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0eXBlTmFtZSAtIHR5cGUgb2YgZmVhdHVyZSB0byBsaXN0ZW4gZm9yLlxyXG4gICAqL1xyXG4gIF9vbkZlYXR1cmVBZGRlZCh0eXBlTmFtZSkge31cclxuXHJcbiAgLyoqXHJcbiAgICogU3RvcCBsaXN0ZW5pbmcgZm9yIGV2ZW50IGRlcGVuZGVuY2llcyB0aGF0IG1hdGNoIHRoZSBnaXZlbiBmZWF0dXJlIHR5cGUuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVOYW1lIC0gdHlwZSBvZiBmZWF0dXJlIHRvIHN0b3AgbGlzdGVuaW5nIGZvci5cclxuICAgKi9cclxuICBfb25GZWF0dXJlUmVtb3ZlZCh0eXBlTmFtZSkge31cclxuXHJcbiAgLyoqXHJcbiAgICogQGF1Z21lbnRzIHtAbGluayBBYnN0cmFjdEhvc3RGZWF0dXJlI2Rpc2NhcmR9XHJcbiAgICovXHJcbiAgZGlzY2FyZCgpIHt9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBjbGFzcyB0aGF0IGltcGxlbWVudHMge0BsaW5rIEZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2V9IGFuZCBleHRlbmRzXHJcbiAgICogYSBzcGVjaWZpZWQgYmFzZSBjbGFzcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Q2xhc3N9IEJhc2VDbGFzcyAtIFRoZSBjbGFzcyB0byBleHRlbmQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtDbGFzc30gQSBjbGFzcyB0aGF0IGV4dGVuZHMgYEJhc2VDbGFzc2AgYW5kIGltcGxlbWVudHMge0BsaW5rIEZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2V9LlxyXG4gICAqL1xyXG4gIHN0YXRpYyBNaXhpbihCYXNlQ2xhc3MpIHtcclxuICAgIGNvbnN0IEZlYXR1cmVEZXBlbmRlbnRNaXhpbiA9IGNsYXNzIGV4dGVuZHMgQmFzZUNsYXNzIHtcclxuICAgICAgY29uc3RydWN0b3IoaG9zdCkge1xyXG4gICAgICAgIHN1cGVyKGhvc3QpO1xyXG4gICAgICAgIHRoaXMuX2hvc3QgPSBob3N0O1xyXG5cclxuICAgICAgICAvLyBObyBuZWVkIHRvIGxpc3RlbiBmb3IgZXZlbnRzIGlmIHRoZSBtaXhpbiBpcyBpbiB0aGUgcHJvdG90eXBlIGNoYWluIG11bHRpcGxlIHRpbWVzXHJcbiAgICAgICAgaWYgKCF0aGlzLl9pbml0aWFsaXplZCkge1xyXG4gICAgICAgICAgdGhpcy5faW5pdGlhbGl6ZWQgPSB0cnVlO1xyXG5cclxuICAgICAgICAgIC8vIFN0YXJ0IGxpc3RlbmluZyBmb3IgZmVhdHVyZSBldmVudHNcclxuICAgICAgICAgIHRoaXMuX29uRmVhdHVyZUFkZGVkID0gdGhpcy5fb25GZWF0dXJlQWRkZWQuYmluZCh0aGlzKTtcclxuICAgICAgICAgIHRoaXMuX29uRmVhdHVyZVJlbW92ZWQgPSB0aGlzLl9vbkZlYXR1cmVSZW1vdmVkLmJpbmQodGhpcyk7XHJcblxyXG4gICAgICAgICAgdGhpcy5faG9zdC5saXN0ZW5UbyhcclxuICAgICAgICAgICAgSG9zdE9iamVjdC5FVkVOVFMuYWRkRmVhdHVyZSxcclxuICAgICAgICAgICAgdGhpcy5fb25GZWF0dXJlQWRkZWRcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICB0aGlzLl9ob3N0Lmxpc3RlblRvKFxyXG4gICAgICAgICAgICBIb3N0T2JqZWN0LkVWRU5UUy5yZW1vdmVGZWF0dXJlLFxyXG4gICAgICAgICAgICB0aGlzLl9vbkZlYXR1cmVSZW1vdmVkXHJcbiAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgIC8vIFJlZ2lzdGVyIGZlYXR1cmVzIHRoYXQgYWxyZWFkeSBleGlzdFxyXG4gICAgICAgICAgT2JqZWN0LmtleXModGhpcy5jb25zdHJ1Y3Rvci5FVkVOVF9ERVBFTkRFTkNJRVMpLmZvckVhY2godHlwZU5hbWUgPT4ge1xyXG4gICAgICAgICAgICBpZiAodGhpcy5faG9zdFt0eXBlTmFtZV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgIHRoaXMuX29uRmVhdHVyZUFkZGVkKHR5cGVOYW1lKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBfb25GZWF0dXJlQWRkZWQodHlwZU5hbWUpIHtcclxuICAgICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5FVkVOVF9ERVBFTkRFTkNJRVNbdHlwZU5hbWVdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIGNvbnN0IGV2ZW50cyA9IHRoaXMuY29uc3RydWN0b3IuRVZFTlRfREVQRU5ERU5DSUVTW3R5cGVOYW1lXTtcclxuXHJcbiAgICAgICAgICBPYmplY3QuZW50cmllcyhldmVudHMpLmZvckVhY2goKFtldmVudE5hbWUsIGNhbGxiYWNrXSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzW2NhbGxiYWNrXSA9IHRoaXNbY2FsbGJhY2tdLmJpbmQodGhpcyk7XHJcbiAgICAgICAgICAgIHRoaXMuX2hvc3QubGlzdGVuVG8oXHJcbiAgICAgICAgICAgICAgdGhpcy5faG9zdFt0eXBlTmFtZV0uRVZFTlRTW2V2ZW50TmFtZV0sXHJcbiAgICAgICAgICAgICAgdGhpc1tjYWxsYmFja11cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgX29uRmVhdHVyZVJlbW92ZWQodHlwZU5hbWUpIHtcclxuICAgICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5FVkVOVF9ERVBFTkRFTkNJRVNbdHlwZU5hbWVdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIGNvbnN0IGV2ZW50cyA9IHRoaXMuY29uc3RydWN0b3IuRVZFTlRfREVQRU5ERU5DSUVTW3R5cGVOYW1lXTtcclxuXHJcbiAgICAgICAgICBPYmplY3QuZW50cmllcyhldmVudHMpLmZvckVhY2goKFtldmVudE5hbWUsIGNhbGxiYWNrXSkgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9ob3N0LnN0b3BMaXN0ZW5pbmcoXHJcbiAgICAgICAgICAgICAgdGhpcy5faG9zdFt0eXBlTmFtZV0uRVZFTlRTW2V2ZW50TmFtZV0sXHJcbiAgICAgICAgICAgICAgdGhpc1tjYWxsYmFja11cclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgZGlzY2FyZCgpIHtcclxuICAgICAgICAvLyBTdG9wIGxpc3RlbmluZyBmb3IgZmVhdHVyZSBldmVudHNcclxuICAgICAgICB0aGlzLl9ob3N0LnN0b3BMaXN0ZW5pbmcoXHJcbiAgICAgICAgICBIb3N0T2JqZWN0LkVWRU5UUy5hZGRGZWF0dXJlLFxyXG4gICAgICAgICAgdGhpcy5fb25GZWF0dXJlQWRkZWRcclxuICAgICAgICApO1xyXG4gICAgICAgIHRoaXMuX2hvc3Quc3RvcExpc3RlbmluZyhcclxuICAgICAgICAgIEhvc3RPYmplY3QuRVZFTlRTLnJlbW92ZUZlYXR1cmUsXHJcbiAgICAgICAgICB0aGlzLl9vbkZlYXR1cmVSZW1vdmVkXHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gU3RvcCBsaXN0ZW5pbmcgdG8gZmVhdHVyZS1zcGVjaWZpYyBldmVudHNcclxuICAgICAgICBPYmplY3Qua2V5cyh0aGlzLmNvbnN0cnVjdG9yLkVWRU5UX0RFUEVOREVOQ0lFUykuZm9yRWFjaCh0eXBlTmFtZSA9PiB7XHJcbiAgICAgICAgICBpZiAodGhpcy5faG9zdFt0eXBlTmFtZV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICB0aGlzLl9vbkZlYXR1cmVSZW1vdmVkKHR5cGVOYW1lKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgc3VwZXIuZGlzY2FyZCgpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIGNvbnN0IEVWRU5UX0RFUEVOREVOQ0lFUyA9IEJhc2VDbGFzcy5FVkVOVF9ERVBFTkRFTkNJRVMgfHwge307XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoRmVhdHVyZURlcGVuZGVudE1peGluLCB7XHJcbiAgICAgIEVWRU5UX0RFUEVOREVOQ0lFUzoge1xyXG4gICAgICAgIHZhbHVlOiB7XHJcbiAgICAgICAgICAuLi5FVkVOVF9ERVBFTkRFTkNJRVMsXHJcbiAgICAgICAgfSxcclxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gRmVhdHVyZURlcGVuZGVudE1peGluO1xyXG4gIH1cclxufVxyXG5cclxuLyoqXHJcbiAqIEV2ZW50IGRlcGVuZGVuY2llcyBzaG91bGQgZm9sbG93IHRoZSBzaWduYXR1cmU6XHJcbiAqIHtcclxuICogIEZlYXR1cmVOYW1lOiB7XHJcbiAqICAgIC8vIEV2ZW50cyB0aGF0IHRoZSBmZWF0dXJlIHNob3VsZCBzdGFydC9zdG9wIGxpc3RlbmluZyBmb3Igd2hlbiBhIGZlYXR1cmVcclxuICogICAgLy8gb2YgdHlwZSBGZWF0dXJlTmFtZSBpcyBhZGRlZC9yZW1vdmVkIGZyb20gdGhlIGhvc3RcclxuICogICAge1xyXG4gKiAgICAgIGV2ZW50TmFtZTogY2FsbGJhY2tOYW1lLFxyXG4gKiAgICAgIC4uLlxyXG4gKiAgICB9LFxyXG4gKiAgfVxyXG4gKiB9XHJcbiAqL1xyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhGZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlLCB7XHJcbiAgRVZFTlRfREVQRU5ERU5DSUVTOiB7XHJcbiAgICB2YWx1ZToge30sXHJcbiAgICB3cml0YWJsZTogZmFsc2UsXHJcbiAgfSxcclxufSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBGZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlO1xyXG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXHJcblxyXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xyXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtY2xhc3Nlcy1wZXItZmlsZSAqL1xyXG5pbXBvcnQgRmVhdHVyZURlcGVuZGVudEludGVyZmFjZSBmcm9tICdjb3JlL0ZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2UnO1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIGZhY3RvcnkgaW50ZXJmYWNlIGZvciBmZWF0dXJlcyB0aGF0IGFyZSBkZXBlbmRlbnQgb24gdGhlIEFuaW1hdGlvbkZlYXR1cmVcclxuICogYmVpbmcgcHJlc2VudCBvbiB0aGUgaG9zdC4gTGF5ZXIgYW5kIGFuaW1hdGlvbiBldmVudHMgd2lsbCBhdXRvbWF0aWNhbGx5IGJlXHJcbiAqIGxpc3RlbmVkIGZvciBvbmNlIGEgQW5pbWF0aW9uRmVhdHVyZSBpcyBhZGRlZCB0byB0aGUgaG9zdCBhbmQgc3RvcHBlZCBvbmNlIGl0XHJcbiAqIGlzIHJlbW92ZWQuXHJcbiAqXHJcbiAqIEBpbnRlcmZhY2VcclxuICogQGV4dGVuZHMgRmVhdHVyZURlcGVuZGVudEludGVyZmFjZVxyXG4gKlxyXG4gKiBAcHJvcGVydHkge09iamVjdH0gRVZFTlRfREVQRU5ERU5DSUVTIC0gRXZlbnRzIHRoYXQgdGhlIGZlYXR1cmUgc2hvdWxkIHN0YXJ0L3N0b3BcclxuICogbGlzdGVuaW5nIGZvciB3aGVuIGEgZmVhdHVyZSBvZiB0eXBlIEZlYXR1cmVOYW1lIGlzIGFkZGVkL3JlbW92ZWQgZnJvbSB0aGUgaG9zdC5cclxuICogQHByb3BlcnR5IHtPYmplY3R9IEVWRU5UX0RFUEVOREVOQ0lFUy5BbmltYXRpb25GZWF0dXJlIC0gRXZlbnRzIHRoYXQgYXJlXHJcbiAqIHNwZWNpZmljIHRvIHRoZSBBbmltYXRpb25GZWF0dXJlLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UX0RFUEVOREVOQ0lFUy5BbmltYXRpb25GZWF0dXJlLmFkZExheWVyPSdfb25MYXllckFkZGVkJ10gLVxyXG4gKiBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIEFuaW1hdGlvbkZlYXR1cmUgYWRkTGF5ZXJcclxuICogZXZlbnRzIGFyZSBlbWl0dGVkLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UX0RFUEVOREVOQ0lFUy5BbmltYXRpb25GZWF0dXJlLnJlbW92ZUxheWVyPSdfb25MYXllclJlbW92ZWQnXSAtXHJcbiAqIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gQW5pbWF0aW9uRmVhdHVyZSByZW1vdmVMYXllclxyXG4gKiBldmVudHMgYXJlIGVtaXR0ZWQuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRfREVQRU5ERU5DSUVTLkFuaW1hdGlvbkZlYXR1cmUucmVuYW1lTGF5ZXI9J19vbkxheWVyUmVuYW1lZCddIC1cclxuICogVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiBBbmltYXRpb25GZWF0dXJlIHJlbmFtZUxheWVyXHJcbiAqIGV2ZW50cyBhcmUgZW1pdHRlZC5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVF9ERVBFTkRFTkNJRVMuQW5pbWF0aW9uRmVhdHVyZS5hZGRBbmltYXRpb249J19vbkFuaW1hdGlvbkFkZGVkJ10gLVxyXG4gKiBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIEFuaW1hdGlvbkZlYXR1cmUgYWRkQW5pbWF0aW9uXHJcbiAqIGV2ZW50cyBhcmUgZW1pdHRlZC5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVF9ERVBFTkRFTkNJRVMuQW5pbWF0aW9uRmVhdHVyZS5yZW1vdmVBbmltYXRpb249J19vbkFuaW1hdGlvblJlbW92ZWQnXSAtXHJcbiAqIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gQW5pbWF0aW9uRmVhdHVyZSByZW1vdmVBbmltYXRpb25cclxuICogZXZlbnRzIGFyZSBlbWl0dGVkLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UX0RFUEVOREVOQ0lFUy5BbmltYXRpb25GZWF0dXJlLnJlbmFtZUFuaW1hdGlvbj0nX29uQW5pbWF0aW9uUmVuYW1lZCddIC1cclxuICogVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiBBbmltYXRpb25GZWF0dXJlIHJlbmFtZUFuaW1hdGlvblxyXG4gKiBldmVudHMgYXJlIGVtaXR0ZWQuXHJcbiAqL1xyXG5jbGFzcyBBbmltYXRpb25GZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlIGV4dGVuZHMgRmVhdHVyZURlcGVuZGVudEludGVyZmFjZSB7XHJcbiAgLyoqXHJcbiAgICogRXhlY3V0ZWQgd2hlbiBhbmltYXRpb24gbGF5ZXIgYWRkZWQgZXZlbnRzIGFyZSBjYXVnaHQuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0aGF0IHdhcyBhZGRlZC5cclxuICAgKi9cclxuICBfb25MYXllckFkZGVkKHtuYW1lfSkge31cclxuXHJcbiAgLyoqXHJcbiAgICogRXhlY3V0ZWQgd2hlbiBhbmltYXRpb24gbGF5ZXIgcmVtb3ZlZCBldmVudHMgYXJlIGNhdWdodC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRoYXQgd2FzIHJlbW92ZWQuXHJcbiAgICovXHJcbiAgX29uTGF5ZXJSZW1vdmVkKHtuYW1lfSkge31cclxuXHJcbiAgLyoqXHJcbiAgICogRXhlY3V0ZWQgd2hlbiBhbmltYXRpb24gbGF5ZXIgcmVuYW1lZCBldmVudHMgYXJlIGNhdWdodC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gb2xkTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRoYXQgd2FzIHJlbmFtZWQuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5ld05hbWUgLSBOZXcgbmFtZSBvZiB0aGUgbGF5ZXIuXHJcbiAgICovXHJcbiAgX29uTGF5ZXJSZW5hbWVkKHtvbGROYW1lLCBuZXdOYW1lfSkge31cclxuXHJcbiAgLyoqXHJcbiAgICogRXhlY3V0ZWQgd2hlbiBhbmltYXRpb24gYWRkZWQgZXZlbnRzIGFyZSBjYXVnaHQuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRoYXQgYW4gYW5pbWF0aW9uIHdhcyBhZGRlZCB0by5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gYW5pbWF0aW9uTmFtZSAtIE5hbWUgb2YgdGhlIGFuaW1hdGlvbiB0aGF0IHdhcyBhZGRlZC5cclxuICAgKi9cclxuICBfb25BbmltYXRpb25BZGRlZCh7bGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lfSkge31cclxuXHJcbiAgLyoqXHJcbiAgICogRXhlY3V0ZWQgd2hlbiBhbmltYXRpb24gcmVtb3ZlZCBldmVudHMgYXJlIGNhdWdodC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdGhhdCBhbiBhbmltYXRpb24gd2FzIHJlbW92ZWQgZnJvbS5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gYW5pbWF0aW9uTmFtZSAtIE5hbWUgb2YgdGhlIGFuaW1hdGlvbiB0aGF0IHdhcyByZW1vdmVkLlxyXG4gICAqL1xyXG4gIF9vbkFuaW1hdGlvblJlbW92ZWQoe2xheWVyTmFtZSwgYW5pbWF0aW9uTmFtZX0pIHt9XHJcblxyXG4gIC8qKlxyXG4gICAqIEV4ZWN1dGVkIHdoZW4gYW5pbWF0aW9uIHJlbmFtZWQgZXZlbnRzIGFyZSBjYXVnaHQuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRoYXQgYW4gYW5pbWF0aW9uIGJlbG9uZ3MgdG8uXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG9sZE5hbWUgLSBOYW1lIG9mIHRoZSBhbmltYXRpb24gdGhhdCB3YXMgcmVuYW1lZC5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmV3TmFtZSAtIE5ldyBuYW1lIG9mIHRoZSBhbmltYXRpb24uXHJcbiAgICovXHJcbiAgX29uQW5pbWF0aW9uUmVuYW1lZCh7bGF5ZXJOYW1lLCBvbGROYW1lLCBuZXdOYW1lfSkge31cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIGNsYXNzIHRoYXQgaW1wbGVtZW50cyB7QGxpbmsgQW5pbWF0aW9uRmVhdHVyZURlcGVuZGVudEludGVyZmFjZX1cclxuICAgKiBhbmQgZXh0ZW5kcyBhIHNwZWNpZmllZCBiYXNlIGNsYXNzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtDbGFzc30gQmFzZUNsYXNzIC0gVGhlIGNsYXNzIHRvIGV4dGVuZC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0NsYXNzfSBBIGNsYXNzIHRoYXQgZXh0ZW5kcyBgQmFzZUNsYXNzYCBhbmQgaW1wbGVtZW50cyB7QGxpbmsgQW5pbWF0aW9uRmVhdHVyZURlcGVuZGVudEludGVyZmFjZX0uXHJcbiAgICovXHJcbiAgc3RhdGljIE1peGluKEJhc2VDbGFzcykge1xyXG4gICAgY29uc3QgUGFyZW50Q2xhc3MgPSBGZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlLk1peGluKEJhc2VDbGFzcyk7XHJcbiAgICBjb25zdCBBbmltYXRpb25GZWF0dXJlRGVwZW5kZW50TWl4aW4gPSBjbGFzcyBleHRlbmRzIFBhcmVudENsYXNzIHtcclxuICAgICAgX29uTGF5ZXJBZGRlZCh7bmFtZX0pIHt9XHJcblxyXG4gICAgICBfb25MYXllclJlbW92ZWQoe25hbWV9KSB7fVxyXG5cclxuICAgICAgX29uTGF5ZXJSZW5hbWVkKHtvbGROYW1lLCBuZXdOYW1lfSkge31cclxuXHJcbiAgICAgIF9vbkFuaW1hdGlvbkFkZGVkKHtsYXllck5hbWUsIGFuaW1hdGlvbk5hbWV9KSB7fVxyXG5cclxuICAgICAgX29uQW5pbWF0aW9uUmVtb3ZlZCh7bGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lfSkge31cclxuXHJcbiAgICAgIF9vbkFuaW1hdGlvblJlbmFtZWQoe2xheWVyTmFtZSwgb2xkTmFtZSwgbmV3TmFtZX0pIHt9XHJcbiAgICB9O1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEFuaW1hdGlvbkZlYXR1cmVEZXBlbmRlbnRNaXhpbiwge1xyXG4gICAgICBFVkVOVF9ERVBFTkRFTkNJRVM6IHtcclxuICAgICAgICB2YWx1ZToge1xyXG4gICAgICAgICAgLi4uUGFyZW50Q2xhc3MuRVZFTlRfREVQRU5ERU5DSUVTLFxyXG4gICAgICAgICAgLi4uQW5pbWF0aW9uRmVhdHVyZURlcGVuZGVudEludGVyZmFjZS5FVkVOVF9ERVBFTkRFTkNJRVMsXHJcbiAgICAgICAgfSxcclxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gQW5pbWF0aW9uRmVhdHVyZURlcGVuZGVudE1peGluO1xyXG4gIH1cclxufVxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoQW5pbWF0aW9uRmVhdHVyZURlcGVuZGVudEludGVyZmFjZSwge1xyXG4gIEVWRU5UX0RFUEVOREVOQ0lFUzoge1xyXG4gICAgdmFsdWU6IHtcclxuICAgICAgQW5pbWF0aW9uRmVhdHVyZToge1xyXG4gICAgICAgIGFkZExheWVyOiAnX29uTGF5ZXJBZGRlZCcsXHJcbiAgICAgICAgcmVtb3ZlTGF5ZXI6ICdfb25MYXllclJlbW92ZWQnLFxyXG4gICAgICAgIHJlbmFtZUxheWVyOiAnX29uTGF5ZXJSZW5hbWVkJyxcclxuICAgICAgICBhZGRBbmltYXRpb246ICdfb25BbmltYXRpb25BZGRlZCcsXHJcbiAgICAgICAgcmVtb3ZlQW5pbWF0aW9uOiAnX29uQW5pbWF0aW9uUmVtb3ZlZCcsXHJcbiAgICAgICAgcmVuYW1lQW5pbWF0aW9uOiAnX29uQW5pbWF0aW9uUmVuYW1lZCcsXHJcbiAgICAgIH0sXHJcbiAgICB9LFxyXG4gICAgd3JpdGFibGU6IGZhbHNlLFxyXG4gIH0sXHJcbn0pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgQW5pbWF0aW9uRmVhdHVyZURlcGVuZGVudEludGVyZmFjZTtcclxuIiwiLy8gQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxyXG5cclxuLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cclxuLyogZXNsaW50LWRpc2FibGUgbWF4LWNsYXNzZXMtcGVyLWZpbGUgKi9cclxuaW1wb3J0IEFuaW1hdGlvbkZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2UgZnJvbSAnY29yZS9hbmltcGFjay9BbmltYXRpb25GZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlJztcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyBmYWN0b3J5IGludGVyZmFjZSBmb3IgdGhhdCBrZWVwcyB0cmFjayBvZiBsYXllcnMgYW5kIGFuaW1hdGlvbnMgb24gYSBob3N0LlxyXG4gKiBUcmFja2VkIGFzc2V0cyBhcmUgbWFya2VkIGFzIGluYWN0aXZlIHVudGlsIGxheWVycyBhbmQgYW5pbWF0aW9ucyB3aXRoIG1hdGNoaW5nXHJcbiAqIG5hbWVzIGFyZSBkZXRlY3RlZCBhcyBwcmVzZW50IG9uIHRoZSBob3N0LlxyXG4gKlxyXG4gKiBAaW50ZXJmYWNlXHJcbiAqIEBleHRlbmRzIEFuaW1hdGlvbkZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2VcclxuICpcclxuICogQHByb3BlcnR5IHtPYmplY3R9IERFRkFVTFRfTEFZRVJfT1BUSU9OUyAtIERlZmF1bHQgb3B0aW9ucyB0byB1c2Ugd2hlbiBleGVjdXRpbmdcclxuICoge0BsaW5rIEFuaW1hdGlvbkxheWVyfSBtZXRob2RzLlxyXG4gKiBAcHJvcGVydHkge251bWJlcn0gW0RFRkFVTFRfTEFZRVJfT1BUSU9OUy5ibGVuZFRpbWU9MC41XSAtIERlZmF1bHQgdGltZSBpbiBzZWNvbmRzXHJcbiAqIHRvIHVzZSB3aGVuIGV4ZWN1dGluZyB7QGxpbmsgQW5pbWF0aW9uTGF5ZXIuc2V0QmxlbmRXZWlnaHR9LlxyXG4gKiBAcHJvcGVydHkge09iamVjdH0gW0RFRkFVTFRfTEFZRVJfT1BUSU9OUy5hbmltYXRpb25zPXt9XSAtIE1hcHMgYW5pbWF0aW9uIG5hbWVzXHJcbiAqIHRvIGRlZmF1bHQgb3B0aW9ucyBvYmplY3RzIHRvIHVzZSBmb3IgbWFuYWdlZCBhbmltYXRpb25zLlxyXG4gKi9cclxuY2xhc3MgTWFuYWdlZEFuaW1hdGlvbkxheWVySW50ZXJmYWNlIGV4dGVuZHMgQW5pbWF0aW9uRmVhdHVyZURlcGVuZGVudEludGVyZmFjZSB7XHJcbiAgLyoqXHJcbiAgICogU3RhcnQgdHJhY2tpbmcga2VlcGluZyB0cmFjayBvZiB3aGV0aGVyIGEgbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpcyBwcmVzZW50XHJcbiAgICogb24gdGhlIGhvc3QuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRvIGtlZXAgdHJhY2sgb2YuXHJcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIGxheWVyLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gb3B0aW9ucy5ibGVuZFRpbWUgLSBEZWZhdWx0IGFtb3VudCBvZiB0aW1lIHRvIHVzZSB3aGVuXHJcbiAgICogbWFuaXB1bGF0aW5nIGxheWVyIHdlaWdodHMgb24gdGhpcyBsYXllci5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb3B0aW9ucy5lYXNpbmdGbiAtIERlZmF1bHQgZWFzaW5nIGZ1bmN0aW9uIHRvIHVzZSB3aGVuXHJcbiAgICogbWFuaXB1bGF0aW5nIGxheWVyIHdlaWdodHMgb24gdGhpcyBsYXllci5cclxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMuYW5pbWF0aW9ucyAtIEFuaW1hdGlvbnMgdG8ga2VlcCB0cmFjayBvZiBvbiB0aGUgbGF5ZXIuXHJcbiAgICogQW5pbWF0aW9ucyBhcmUgcmVwcmVzZW50ZWQgYXMga2V5L3ZhbHVlIHBhaXJzIG9mIGFuaW1hdGlvbiBuYW1lcyBhbmQgdGhlaXJcclxuICAgKiBvcHRpb25zLlxyXG4gICAqL1xyXG4gIHJlZ2lzdGVyTGF5ZXIobmFtZSwgb3B0aW9ucyA9IHt9KSB7fVxyXG5cclxuICAvKipcclxuICAgKiBTdGFydCB0cmFja2luZyBrZWVwaW5nIHRyYWNrIG9mIHdoZXRoZXIgYW4gYW5pbWF0aW9uIHdpdGggdGhlIGdpdmVuIG5hbWUgaXNcclxuICAgKiBwcmVzZW50IG9uIHRoZSBob3N0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRoYXQgd2lsbCBvd24gdGhlIGFuaW1hdGlvbi5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gYW5pbWF0aW9uTmFtZSAtIE5hbWUgb2YgdGhlIGFuaW1hdGlvbiB0byBrZWVwIHRyYWNrIG9mLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBhbmltYXRpb24uXHJcbiAgICovXHJcbiAgcmVnaXN0ZXJBbmltYXRpb24obGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lLCBvcHRpb25zID0ge30pIHt9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCBsYXllciB3ZWlnaHRzIG9uIHRyYWNrZWQgbGF5ZXJzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG5hbWVGaWx0ZXIgLSBQcmVkaWNhdGUgZnVuY3Rpb24gdG8gdGVzdCBlYWNoIHRyYWNrZWQgbGF5ZXJcclxuICAgKiB3aXRoLiBCeSBkZWZhdWx0IGFsbCBsYXllcnMgd2lsbCBwYXNzLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3ZWlnaHQgLSBXZWlnaHQgdmFsdWUgdG8gc2V0IG9uIGxheWVycy5cclxuICAgKiBAcGFyYW0ge251bWJlcj19IHNlY29uZHMgLSBOdW1iZXIgb2Ygc2Vjb25kcyBpdCB3aWxsIHRha2UgdG8gcmVhY2ggdGhlIHdlaWdodFxyXG4gICAqIG9uIGVhY2ggbGF5ZXIuIElmIHVuZGVmaW5lZCwgZWFjaCBsYXllcnMnIGJsZW5kVGltZSBvcHRpb24gaXMgdXNlZC5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gZWFzaW5nRm4gLSBFYXNpbmcgZnVuY3Rpb24gdG8gdXNlIHdoZW4gc2V0dGluZyB3ZWlnaHRcclxuICAgKiBvbiBlYWNoIGxheWVyLiBJZiB1bmRlZmluZWQsIGVhY2ggbGF5ZXJzJyBlYXNpbmdGbiBvcHRpb24gaXMgdXNlZC5cclxuICAgKi9cclxuICBzZXRMYXllcldlaWdodHMobmFtZUZpbHRlciA9ICgpID0+IHRydWUsIHdlaWdodCwgc2Vjb25kcywgZWFzaW5nRm4pIHt9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCBhbGwgdHJhY2tlZCBsYXllcnMnIHdlaWdodHMgdG8gMS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gc2Vjb25kcyAtIE51bWJlciBvZiBzZWNvbmRzIGl0IHdpbGwgdGFrZSB0byByZWFjaCB0aGUgd2VpZ2h0XHJcbiAgICogb24gZWFjaCBsYXllci4gSWYgdW5kZWZpbmVkLCBlYWNoIGxheWVycycgYmxlbmRUaW1lIG9wdGlvbiBpcyB1c2VkLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBlYXNpbmdGbiAtIEVhc2luZyBmdW5jdGlvbiB0byB1c2Ugd2hlbiBzZXR0aW5nIHdlaWdodFxyXG4gICAqIG9uIGVhY2ggbGF5ZXIuIElmIHVuZGVmaW5lZCwgZWFjaCBsYXllcnMnIGVhc2luZ0ZuIG9wdGlvbiBpcyB1c2VkLlxyXG4gICAqL1xyXG4gIGVuYWJsZShzZWNvbmRzLCBlYXNpbmdGbikge31cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IGFsbCB0cmFja2VkIGxheWVycycgd2VpZ2h0cyB0byAwLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXI9fSBzZWNvbmRzIC0gTnVtYmVyIG9mIHNlY29uZHMgaXQgd2lsbCB0YWtlIHRvIHJlYWNoIHRoZSB3ZWlnaHRcclxuICAgKiBvbiBlYWNoIGxheWVyLiBJZiB1bmRlZmluZWQsIGVhY2ggbGF5ZXJzJyBibGVuZFRpbWUgb3B0aW9uIGlzIHVzZWQuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IGVhc2luZ0ZuIC0gRWFzaW5nIGZ1bmN0aW9uIHRvIHVzZSB3aGVuIHNldHRpbmcgd2VpZ2h0XHJcbiAgICogb24gZWFjaCBsYXllci4gSWYgdW5kZWZpbmVkLCBlYWNoIGxheWVycycgZWFzaW5nRm4gb3B0aW9uIGlzIHVzZWQuXHJcbiAgICovXHJcbiAgZGlzYWJsZShzZWNvbmRzLCBlYXNpbmdGbikge31cclxuXHJcbiAgLyoqXHJcbiAgICogQ3JlYXRlcyBhIGNsYXNzIHRoYXQgaW1wbGVtZW50cyB7QGxpbmsgTWFuYWdlZEFuaW1hdGlvbkxheWVySW50ZXJmYWNlfVxyXG4gICAqIGFuZCBleHRlbmRzIGEgc3BlY2lmaWVkIGJhc2UgY2xhc3MuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0NsYXNzfSBCYXNlQ2xhc3MgLSBUaGUgY2xhc3MgdG8gZXh0ZW5kLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Q2xhc3N9IEEgY2xhc3MgdGhhdCBleHRlbmRzIGBCYXNlQ2xhc3NgIGFuZCBpbXBsZW1lbnRzIHtAbGluayBNYW5hZ2VkQW5pbWF0aW9uTGF5ZXJJbnRlcmZhY2V9LlxyXG4gICAqL1xyXG4gIHN0YXRpYyBNaXhpbihCYXNlQ2xhc3MpIHtcclxuICAgIGNvbnN0IFBhcmVudENsYXNzID0gQW5pbWF0aW9uRmVhdHVyZURlcGVuZGVudEludGVyZmFjZS5NaXhpbihCYXNlQ2xhc3MpO1xyXG4gICAgY29uc3QgTWFuYWdlZEFuaW1hdGlvbkxheWVyTWl4aW4gPSBjbGFzcyBleHRlbmRzIFBhcmVudENsYXNzIHtcclxuICAgICAgY29uc3RydWN0b3IoLi4uYXJncykge1xyXG4gICAgICAgIHN1cGVyKC4uLmFyZ3MpO1xyXG5cclxuICAgICAgICB0aGlzLl9tYW5hZ2VkTGF5ZXJzID0ge307XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIF9vbkZlYXR1cmVBZGRlZCh0eXBlTmFtZSkge1xyXG4gICAgICAgIHN1cGVyLl9vbkZlYXR1cmVBZGRlZCh0eXBlTmFtZSk7XHJcblxyXG4gICAgICAgIGlmICh0eXBlTmFtZSAhPT0gJ0FuaW1hdGlvbkZlYXR1cmUnKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9tYW5hZ2VkTGF5ZXJzID0gdGhpcy5fbWFuYWdlZExheWVycyB8fCB7fTtcclxuXHJcbiAgICAgICAgLy8gRGV0ZWN0IG5ldyBsYXllcnNcclxuICAgICAgICB0aGlzLl9ob3N0LkFuaW1hdGlvbkZlYXR1cmUubGF5ZXJzLmZvckVhY2gobmFtZSA9PiB7XHJcbiAgICAgICAgICB0aGlzLl9vbkxheWVyQWRkZWQoe25hbWV9KTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgX29uRmVhdHVyZVJlbW92ZWQodHlwZU5hbWUpIHtcclxuICAgICAgICBzdXBlci5fb25GZWF0dXJlUmVtb3ZlZCh0eXBlTmFtZSk7XHJcblxyXG4gICAgICAgIGlmICh0eXBlTmFtZSAhPT0gJ0FuaW1hdGlvbkZlYXR1cmUnKSB7XHJcbiAgICAgICAgICByZXR1cm47XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9tYW5hZ2VkTGF5ZXJzID0gdGhpcy5fbWFuYWdlZExheWVycyB8fCB7fTtcclxuXHJcbiAgICAgICAgLy8gRGVhY3RpdmF0ZSB0aGUgbGF5ZXJzXHJcbiAgICAgICAgT2JqZWN0LmtleXModGhpcy5fbWFuYWdlZExheWVycykuZm9yRWFjaChuYW1lID0+IHtcclxuICAgICAgICAgIHRoaXMuX29uTGF5ZXJSZW1vdmVkKHtuYW1lfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIF9vbkxheWVyQWRkZWQoe25hbWV9KSB7XHJcbiAgICAgICAgLy8gTWFyayB0aGUgbGF5ZXIgYXMgYWN0aXZlIGlmIGl0IGlzIG1hbmFnZWRcclxuICAgICAgICBpZiAodGhpcy5fbWFuYWdlZExheWVyc1tuYW1lXSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTGF5ZXJzW25hbWVdLmlzQWN0aXZlID0gdHJ1ZTtcclxuXHJcbiAgICAgICAgICAvLyBEZXRlY3QgbmV3IGFuaW1hdGlvbnNcclxuICAgICAgICAgIHRoaXMuX2hvc3QuQW5pbWF0aW9uRmVhdHVyZS5nZXRBbmltYXRpb25zKG5hbWUpLmZvckVhY2goYW5pbU5hbWUgPT4ge1xyXG4gICAgICAgICAgICB0aGlzLl9vbkFuaW1hdGlvbkFkZGVkKHtsYXllck5hbWU6IG5hbWUsIGFuaW1hdGlvbk5hbWU6IGFuaW1OYW1lfSk7XHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIF9vbkxheWVyUmVtb3ZlZCh7bmFtZX0pIHtcclxuICAgICAgICAvLyBEZWFjdGl2YXRlIHRoZSBsYXllciBpZiBpdCBpcyBtYW5hZ2VkXHJcbiAgICAgICAgaWYgKHRoaXMuX21hbmFnZWRMYXllcnNbbmFtZV0gIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgdGhpcy5fbWFuYWdlZExheWVyc1tuYW1lXS5pc0FjdGl2ZSA9IGZhbHNlO1xyXG5cclxuICAgICAgICAgIC8vIERlYWN0aXZhdGUgdGhlIGFuaW1hdGlvbnNcclxuICAgICAgICAgIE9iamVjdC5rZXlzKHRoaXMuX21hbmFnZWRMYXllcnNbbmFtZV0uYW5pbWF0aW9ucykuZm9yRWFjaChcclxuICAgICAgICAgICAgYW5pbU5hbWUgPT4ge1xyXG4gICAgICAgICAgICAgIHRoaXMuX29uQW5pbWF0aW9uUmVtb3ZlZCh7XHJcbiAgICAgICAgICAgICAgICBsYXllck5hbWU6IG5hbWUsXHJcbiAgICAgICAgICAgICAgICBhbmltYXRpb25OYW1lOiBhbmltTmFtZSxcclxuICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIF9vbkxheWVyUmVuYW1lZCh7b2xkTmFtZSwgbmV3TmFtZX0pIHtcclxuICAgICAgICBjb25zdCBsYXllck9wdGlvbnMgPSB0aGlzLl9tYW5hZ2VkTGF5ZXJzW29sZE5hbWVdO1xyXG5cclxuICAgICAgICAvLyBSZXBsYWNlIHRoZSBsYXllciBrZXkgd2l0aCB0aGUgbmV3IG5hbWVcclxuICAgICAgICBpZiAobGF5ZXJPcHRpb25zICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICAgIGRlbGV0ZSB0aGlzLl9tYW5hZ2VkTGF5ZXJzW29sZE5hbWVdO1xyXG4gICAgICAgICAgdGhpcy5fbWFuYWdlZExheWVyc1tuZXdOYW1lXSA9IGxheWVyT3B0aW9ucztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIF9vbkFuaW1hdGlvbkFkZGVkKHtsYXllck5hbWUsIGFuaW1hdGlvbk5hbWV9KSB7XHJcbiAgICAgICAgLy8gTWFyayB0aGUgYW5pbWF0aW9uIGFzIGFjdGl2ZSBpZiBpdCBpcyBtYW5hZ2VkXHJcbiAgICAgICAgaWYgKFxyXG4gICAgICAgICAgdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgICAgIHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXS5hbmltYXRpb25zW2FuaW1hdGlvbk5hbWVdICE9PSB1bmRlZmluZWRcclxuICAgICAgICApIHtcclxuICAgICAgICAgIHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXS5hbmltYXRpb25zW1xyXG4gICAgICAgICAgICBhbmltYXRpb25OYW1lXHJcbiAgICAgICAgICBdLmlzQWN0aXZlID0gdHJ1ZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIF9vbkFuaW1hdGlvblJlbW92ZWQoe2xheWVyTmFtZSwgYW5pbWF0aW9uTmFtZX0pIHtcclxuICAgICAgICAvLyBEZWFjdGl2YXRlIHRoZSBhbmltYXRpb24gaWYgaXQgaXMgbWFuYWdlZFxyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgIHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXSAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV0uYW5pbWF0aW9uc1thbmltYXRpb25OYW1lXSAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV0uYW5pbWF0aW9uc1tcclxuICAgICAgICAgICAgYW5pbWF0aW9uTmFtZVxyXG4gICAgICAgICAgXS5pc0FjdGl2ZSA9IGZhbHNlO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG5cclxuICAgICAgX29uQW5pbWF0aW9uUmVuYW1lZCh7bGF5ZXJOYW1lLCBvbGROYW1lLCBuZXdOYW1lfSkge1xyXG4gICAgICAgIGlmIChcclxuICAgICAgICAgIHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXSAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV0uYW5pbWF0aW9uc1tvbGROYW1lXSAhPT0gdW5kZWZpbmVkXHJcbiAgICAgICAgKSB7XHJcbiAgICAgICAgICAvLyBSZXBsYWNlIHRoZSBhbmltYXRpb24ga2V5IHdpdGggdGhlIG5ldyBuYW1lXHJcbiAgICAgICAgICBjb25zdCBhbmltT3B0aW9ucyA9IHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXS5hbmltYXRpb25zW1xyXG4gICAgICAgICAgICBvbGROYW1lXHJcbiAgICAgICAgICBdO1xyXG4gICAgICAgICAgZGVsZXRlIHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXS5hbmltYXRpb25zW29sZE5hbWVdO1xyXG4gICAgICAgICAgdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdLmFuaW1hdGlvbnNbbmV3TmFtZV0gPSBhbmltT3B0aW9ucztcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJlZ2lzdGVyTGF5ZXIobmFtZSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICAgICAgLy8gU3RhcnQgd2l0aCBkZWZhdWx0IG9wdGlvbnMgZm9yIGVhY2ggbmV3IGxheWVyXHJcbiAgICAgICAgaWYgKHRoaXMuX21hbmFnZWRMYXllcnNbbmFtZV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgdGhpcy5fbWFuYWdlZExheWVyc1tuYW1lXSA9IHtcclxuICAgICAgICAgICAgLi4udGhpcy5jb25zdHJ1Y3Rvci5ERUZBVUxUX0xBWUVSX09QVElPTlMsXHJcbiAgICAgICAgICAgIGFuaW1hdGlvbnM6IHt9LFxyXG4gICAgICAgICAgfTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSBhbGwgb3B0aW9ucyBleGNlcHQgYW5pbWF0aW9uc1xyXG4gICAgICAgIGNvbnN0IGxheWVyT3B0aW9ucyA9IHRoaXMuX21hbmFnZWRMYXllcnNbbmFtZV07XHJcbiAgICAgICAgb3B0aW9ucyA9IHsuLi5vcHRpb25zfTtcclxuICAgICAgICBjb25zdCBhbmltYXRpb25PcHRpb25zID0gb3B0aW9ucy5hbmltYXRpb25zIHx8IHt9O1xyXG4gICAgICAgIGRlbGV0ZSBvcHRpb25zLmFuaW1hdGlvbnM7XHJcbiAgICAgICAgT2JqZWN0LmFzc2lnbihsYXllck9wdGlvbnMsIG9wdGlvbnMpO1xyXG5cclxuICAgICAgICAvLyBDaGVjayB3aGV0aGVyIHRoZSBsYXllciBjYW4gYmUgbWFuaXB1bGF0ZWQgbm93XHJcbiAgICAgICAgbGF5ZXJPcHRpb25zLmlzQWN0aXZlID1cclxuICAgICAgICAgIHRoaXMuX2hvc3QuQW5pbWF0aW9uRmVhdHVyZSAhPT0gdW5kZWZpbmVkICYmXHJcbiAgICAgICAgICB0aGlzLl9ob3N0LkFuaW1hdGlvbkZlYXR1cmUubGF5ZXJzLmluY2x1ZGVzKG5hbWUpO1xyXG5cclxuICAgICAgICAvLyBSZWdpc3RlciB0aGUgYW5pbWF0aW9uc1xyXG4gICAgICAgIE9iamVjdC5lbnRyaWVzKGFuaW1hdGlvbk9wdGlvbnMpLmZvckVhY2goKFthbmltTmFtZSwgYW5pbU9wdGlvbnNdKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLnJlZ2lzdGVyQW5pbWF0aW9uKG5hbWUsIGFuaW1OYW1lLCBhbmltT3B0aW9ucyk7XHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJlZ2lzdGVyQW5pbWF0aW9uKGxheWVyTmFtZSwgYW5pbWF0aW9uTmFtZSwgb3B0aW9ucyA9IHt9KSB7XHJcbiAgICAgICAgLy8gUmVnaXN0ZXIgdGhlIGxheWVyIGlmIGl0IGhhc24ndCBiZWVuIHJlZ2lzdGVyZWQgeWV0XHJcbiAgICAgICAgaWYgKHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICB0aGlzLnJlZ2lzdGVyTGF5ZXIobGF5ZXJOYW1lKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFVwZGF0ZSBhbmltYXRpb24gb3B0aW9uc1xyXG4gICAgICAgIGNvbnN0IGFuaW1PcHRpb25zID1cclxuICAgICAgICAgIHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXS5hbmltYXRpb25zW2FuaW1hdGlvbk5hbWVdIHx8IHt9O1xyXG4gICAgICAgIE9iamVjdC5hc3NpZ24oYW5pbU9wdGlvbnMsIG9wdGlvbnMpO1xyXG4gICAgICAgIHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXS5hbmltYXRpb25zW2FuaW1hdGlvbk5hbWVdID0gYW5pbU9wdGlvbnM7XHJcblxyXG4gICAgICAgIC8vIENoZWNrIHdoZXRoZXIgdGhlIGFuaW1hdGlvbiBjYW4gYmUgbWFuaXB1bGF0ZWQgbm93XHJcbiAgICAgICAgdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdLmFuaW1hdGlvbnNbYW5pbWF0aW9uTmFtZV0uaXNBY3RpdmUgPVxyXG4gICAgICAgICAgdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdLmlzQWN0aXZlICYmXHJcbiAgICAgICAgICB0aGlzLl9ob3N0LkFuaW1hdGlvbkZlYXR1cmUuZ2V0QW5pbWF0aW9ucyhsYXllck5hbWUpLmluY2x1ZGVzKFxyXG4gICAgICAgICAgICBhbmltYXRpb25OYW1lXHJcbiAgICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzZXRMYXllcldlaWdodHMobmFtZUZpbHRlciA9ICgpID0+IHRydWUsIHdlaWdodCwgc2Vjb25kcywgZWFzaW5nRm4pIHtcclxuICAgICAgICBjb25zdCBsYXllck5hbWVzID0gT2JqZWN0LmtleXModGhpcy5fbWFuYWdlZExheWVycykuZmlsdGVyKG5hbWVGaWx0ZXIpO1xyXG5cclxuICAgICAgICBsYXllck5hbWVzLmZvckVhY2gobmFtZSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBsYXllck9wdGlvbnMgPSB0aGlzLl9tYW5hZ2VkTGF5ZXJzW25hbWVdO1xyXG5cclxuICAgICAgICAgIGlmIChsYXllck9wdGlvbnMuaXNBY3RpdmUpIHtcclxuICAgICAgICAgICAgdGhpcy5faG9zdC5BbmltYXRpb25GZWF0dXJlLnNldExheWVyV2VpZ2h0KFxyXG4gICAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICAgICAgd2VpZ2h0LFxyXG4gICAgICAgICAgICAgIHNlY29uZHMgIT09IHVuZGVmaW5lZCA/IHNlY29uZHMgOiBsYXllck9wdGlvbnMuYmxlbmRUaW1lLFxyXG4gICAgICAgICAgICAgIGVhc2luZ0ZuIHx8IGxheWVyT3B0aW9ucy5lYXNpbmdGblxyXG4gICAgICAgICAgICApO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBlbmFibGUoc2Vjb25kcywgZWFzaW5nRm4pIHtcclxuICAgICAgICB0aGlzLnNldExheWVyV2VpZ2h0cyh1bmRlZmluZWQsIDEsIHNlY29uZHMsIGVhc2luZ0ZuKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZGlzYWJsZShzZWNvbmRzLCBlYXNpbmdGbikge1xyXG4gICAgICAgIHRoaXMuc2V0TGF5ZXJXZWlnaHRzKHVuZGVmaW5lZCwgMCwgc2Vjb25kcywgZWFzaW5nRm4pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBpbnN0YWxsQXBpKCkge1xyXG4gICAgICAgIGNvbnN0IGFwaSA9IHN1cGVyLmluc3RhbGxBcGkoKTtcclxuXHJcbiAgICAgICAgT2JqZWN0LmFzc2lnbihhcGksIHtcclxuICAgICAgICAgIHJlZ2lzdGVyTGF5ZXI6IHRoaXMucmVnaXN0ZXJMYXllci5iaW5kKHRoaXMpLFxyXG4gICAgICAgICAgcmVnaXN0ZXJBbmltYXRpb246IHRoaXMucmVnaXN0ZXJBbmltYXRpb24uYmluZCh0aGlzKSxcclxuICAgICAgICAgIHNldExheWVyV2VpZ2h0czogdGhpcy5zZXRMYXllcldlaWdodHMuYmluZCh0aGlzKSxcclxuICAgICAgICAgIGVuYWJsZTogdGhpcy5lbmFibGUuYmluZCh0aGlzKSxcclxuICAgICAgICAgIGRpc2FibGU6IHRoaXMuZGlzYWJsZS5iaW5kKHRoaXMpLFxyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICByZXR1cm4gYXBpO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE1hbmFnZWRBbmltYXRpb25MYXllck1peGluLCB7XHJcbiAgICAgIERFRkFVTFRfTEFZRVJfT1BUSU9OUzoge1xyXG4gICAgICAgIHZhbHVlOiBNYW5hZ2VkQW5pbWF0aW9uTGF5ZXJJbnRlcmZhY2UuREVGQVVMVF9MQVlFUl9PUFRJT05TLFxyXG4gICAgICAgIHdyaXRhYmxlOiBmYWxzZSxcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBNYW5hZ2VkQW5pbWF0aW9uTGF5ZXJNaXhpbjtcclxuICB9XHJcbn1cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKE1hbmFnZWRBbmltYXRpb25MYXllckludGVyZmFjZSwge1xyXG4gIERFRkFVTFRfTEFZRVJfT1BUSU9OUzoge1xyXG4gICAgdmFsdWU6IHtibGVuZFRpbWU6IDAuNSwgYW5pbWF0aW9uczoge319LFxyXG4gICAgd3JpdGFibGU6IGZhbHNlLFxyXG4gIH0sXHJcbn0pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgTWFuYWdlZEFuaW1hdGlvbkxheWVySW50ZXJmYWNlO1xyXG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXHJcblxyXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtY2xhc3Nlcy1wZXItZmlsZSAqL1xyXG5pbXBvcnQgRmVhdHVyZURlcGVuZGVudEludGVyZmFjZSBmcm9tICdjb3JlL0ZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2UnO1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIGZhY3RvcnkgaW50ZXJmYWNlIGZvciBmZWF0dXJlcyB0aGF0IGFyZSBkZXBlbmRlbnQgb24gdGhlIFRleHRUb1NwZWVjaEZlYXR1cmVcclxuICogYmVpbmcgcHJlc2VudCBvbiB0aGUgaG9zdC4gU3BlZWNoIGV2ZW50cyB3aWxsIGF1dG9tYXRpY2FsbHkgYmUgbGlzdGVuZWQgZm9yIG9uY2UgYVxyXG4gKiBUZXh0VG9TcGVlY2hGZWF0dXJlIGlzIGFkZGVkIHRvIHRoZSBob3N0IGFuZCBzdG9wcGVkIG9uY2UgaXQgaXMgcmVtb3ZlZC5cclxuICpcclxuICogQGludGVyZmFjZVxyXG4gKiBAZXh0ZW5kcyBGZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBFVkVOVF9ERVBFTkRFTkNJRVMgLSBFdmVudHMgdGhhdCB0aGUgZmVhdHVyZSBzaG91bGQgc3RhcnQvc3RvcFxyXG4gKiBsaXN0ZW5pbmcgZm9yIHdoZW4gYSBmZWF0dXJlIG9mIHR5cGUgRmVhdHVyZU5hbWUgaXMgYWRkZWQvcmVtb3ZlZCBmcm9tIHRoZSBob3N0LlxyXG4gKiBAcHJvcGVydHkge09iamVjdH0gRVZFTlRfREVQRU5ERU5DSUVTLlRleHRUb1NwZWVjaEZlYXR1cmUgLSBFdmVudHMgdGhhdCBhcmVcclxuICogc3BlY2lmaWMgdG8gdGhlIFRleHRUb1NwZWVjaEZlYXR1cmUuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRfREVQRU5ERU5DSUVTLlRleHRUb1NwZWVjaEZlYXR1cmUucGxheT0nX29uUGxheSddIC1cclxuICogVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiBUZXh0VG9TcGVlY2hGZWF0dXJlIHBsYXlcclxuICogZXZlbnRzIGFyZSBlbWl0dGVkLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UX0RFUEVOREVOQ0lFUy5UZXh0VG9TcGVlY2hGZWF0dXJlLnBhdXNlPSdfb25QYXVzZSddIC1cclxuICogVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiBUZXh0VG9TcGVlY2hGZWF0dXJlIHBhdXNlXHJcbiAqIGV2ZW50cyBhcmUgZW1pdHRlZC5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVF9ERVBFTkRFTkNJRVMuVGV4dFRvU3BlZWNoRmVhdHVyZS5yZXN1bWU9J19vblJlc3VtZSddIC1cclxuICogVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiBUZXh0VG9TcGVlY2hGZWF0dXJlIHJlc3VtZVxyXG4gKiBldmVudHMgYXJlIGVtaXR0ZWQuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRfREVQRU5ERU5DSUVTLlRleHRUb1NwZWVjaEZlYXR1cmUuc3RvcD0nX29uU3RvcCddIC1cclxuICogVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiBUZXh0VG9TcGVlY2hGZWF0dXJlIHN0b3BcclxuICogZXZlbnRzIGFyZSBlbWl0dGVkLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UX0RFUEVOREVOQ0lFUy5UZXh0VG9TcGVlY2hGZWF0dXJlLnNlbnRlbmNlPSdfb25TZW50ZW5jZSddIC1cclxuICogVGhlIG5hbWUgb2YgdGhlIG1ldGhvZCB0aGF0IHdpbGwgYmUgZXhlY3V0ZWQgd2hlbiBUZXh0VG9TcGVlY2hGZWF0dXJlIHNlbnRlbmNlXHJcbiAqIGV2ZW50cyBhcmUgZW1pdHRlZC5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVF9ERVBFTkRFTkNJRVMuVGV4dFRvU3BlZWNoRmVhdHVyZS53b3JkPSdfb25Xb3JkJ10gLVxyXG4gKiBUaGUgbmFtZSBvZiB0aGUgbWV0aG9kIHRoYXQgd2lsbCBiZSBleGVjdXRlZCB3aGVuIFRleHRUb1NwZWVjaEZlYXR1cmUgd29yZFxyXG4gKiBldmVudHMgYXJlIGVtaXR0ZWQuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRfREVQRU5ERU5DSUVTLlRleHRUb1NwZWVjaEZlYXR1cmUudmlzZW1lPSdfb25WaXNlbWUnXSAtXHJcbiAqIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gVGV4dFRvU3BlZWNoRmVhdHVyZSB2aXNlbWVcclxuICogZXZlbnRzIGFyZSBlbWl0dGVkLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UX0RFUEVOREVOQ0lFUy5UZXh0VG9TcGVlY2hGZWF0dXJlLnNzbWw9J19vblNzbWwnXSAtXHJcbiAqIFRoZSBuYW1lIG9mIHRoZSBtZXRob2QgdGhhdCB3aWxsIGJlIGV4ZWN1dGVkIHdoZW4gVGV4dFRvU3BlZWNoRmVhdHVyZSBzc21sXHJcbiAqIGV2ZW50cyBhcmUgZW1pdHRlZC5cclxuICovXHJcbmNsYXNzIFRleHRUb1NwZWVjaEZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2UgZXh0ZW5kcyBGZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlIHtcclxuICAvKipcclxuICAgKiBFeGVjdXRlZCB3aGVuIHNwZWVjaCBwbGF5IGV2ZW50cyBhcmUgY2F1Z2h0LlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfb25QbGF5KCkge31cclxuXHJcbiAgLyoqXHJcbiAgICogRXhlY3V0ZWQgd2hlbiBzcGVlY2ggcGF1c2UgZXZlbnRzIGFyZSBjYXVnaHQuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9vblBhdXNlKCkge31cclxuXHJcbiAgLyoqXHJcbiAgICogRXhlY3V0ZWQgd2hlbiBzcGVlY2ggcmVzdW1lIGV2ZW50cyBhcmUgY2F1Z2h0LlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfb25SZXN1bWUoKSB7fVxyXG5cclxuICAvKipcclxuICAgKiBFeGVjdXRlZCB3aGVuIHNwZWVjaCBzdG9wIGV2ZW50cyBhcmUgY2F1Z2h0LlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfb25TdG9wKCkge31cclxuXHJcbiAgLyoqXHJcbiAgICogRXhlY3V0ZWQgd2hlbiBzcGVlY2ggc2VudGVuY2UgZXZlbnRzIGFyZSBjYXVnaHQuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9vblNlbnRlbmNlKCkge31cclxuXHJcbiAgLyoqXHJcbiAgICogRXhlY3V0ZWQgd2hlbiBzcGVlY2ggd29yZCBldmVudHMgYXJlIGNhdWdodC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX29uV29yZCgpIHt9XHJcblxyXG4gIC8qKlxyXG4gICAqIEV4ZWN1dGVkIHdoZW4gc3BlZWNoIHZpc2VtZSBldmVudHMgYXJlIGNhdWdodC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX29uVmlzZW1lKCkge31cclxuXHJcbiAgLyoqXHJcbiAgICogRXhlY3V0ZWQgd2hlbiBzcGVlY2ggc3NtbCBldmVudHMgYXJlIGNhdWdodC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX29uU3NtbCgpIHt9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBjbGFzcyB0aGF0IGltcGxlbWVudHMge0BsaW5rIFRleHRUb1NwZWVjaEZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2V9XHJcbiAgICogYW5kIGV4dGVuZHMgYSBzcGVjaWZpZWQgYmFzZSBjbGFzcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Q2xhc3N9IEJhc2VDbGFzcyAtIFRoZSBjbGFzcyB0byBleHRlbmQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJuIHtDbGFzc30gQSBjbGFzcyB0aGF0IGV4dGVuZHMgYEJhc2VDbGFzc2AgYW5kIGltcGxlbWVudHMge0BsaW5rIFRleHRUb1NwZWVjaEZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2V9LlxyXG4gICAqL1xyXG4gIHN0YXRpYyBNaXhpbihCYXNlQ2xhc3MpIHtcclxuICAgIGNvbnN0IFBhcmVudENsYXNzID0gRmVhdHVyZURlcGVuZGVudEludGVyZmFjZS5NaXhpbihCYXNlQ2xhc3MpO1xyXG4gICAgY29uc3QgVGV4dFRvU3BlZWNoRmVhdHVyZURlcGVuZGVudE1peGluID0gY2xhc3MgZXh0ZW5kcyBQYXJlbnRDbGFzcyB7XHJcbiAgICAgIF9vblBsYXkoKSB7fVxyXG5cclxuICAgICAgX29uUGF1c2UoKSB7fVxyXG5cclxuICAgICAgX29uUmVzdW1lKCkge31cclxuXHJcbiAgICAgIF9vblN0b3AoKSB7fVxyXG5cclxuICAgICAgX29uU2VudGVuY2UoKSB7fVxyXG5cclxuICAgICAgX29uV29yZCgpIHt9XHJcblxyXG4gICAgICBfb25WaXNlbWUoKSB7fVxyXG5cclxuICAgICAgX29uU3NtbCgpIHt9XHJcbiAgICB9O1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKFRleHRUb1NwZWVjaEZlYXR1cmVEZXBlbmRlbnRNaXhpbiwge1xyXG4gICAgICBFVkVOVF9ERVBFTkRFTkNJRVM6IHtcclxuICAgICAgICB2YWx1ZToge1xyXG4gICAgICAgICAgLi4uUGFyZW50Q2xhc3MuRVZFTlRfREVQRU5ERU5DSUVTLFxyXG4gICAgICAgICAgLi4uVGV4dFRvU3BlZWNoRmVhdHVyZURlcGVuZGVudEludGVyZmFjZS5FVkVOVF9ERVBFTkRFTkNJRVMsXHJcbiAgICAgICAgfSxcclxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXHJcbiAgICAgIH0sXHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gVGV4dFRvU3BlZWNoRmVhdHVyZURlcGVuZGVudE1peGluO1xyXG4gIH1cclxufVxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoVGV4dFRvU3BlZWNoRmVhdHVyZURlcGVuZGVudEludGVyZmFjZSwge1xyXG4gIEVWRU5UX0RFUEVOREVOQ0lFUzoge1xyXG4gICAgdmFsdWU6IHtcclxuICAgICAgVGV4dFRvU3BlZWNoRmVhdHVyZToge1xyXG4gICAgICAgIHBsYXk6ICdfb25QbGF5JyxcclxuICAgICAgICBwYXVzZTogJ19vblBhdXNlJyxcclxuICAgICAgICByZXN1bWU6ICdfb25SZXN1bWUnLFxyXG4gICAgICAgIHN0b3A6ICdfb25TdG9wJyxcclxuICAgICAgICBzZW50ZW5jZTogJ19vblNlbnRlbmNlJyxcclxuICAgICAgICB3b3JkOiAnX29uV29yZCcsXHJcbiAgICAgICAgdmlzZW1lOiAnX29uVmlzZW1lJyxcclxuICAgICAgICBzc21sOiAnX29uU3NtbCcsXHJcbiAgICAgIH0sXHJcbiAgICB9LFxyXG4gICAgd3JpdGFibGU6IGZhbHNlLFxyXG4gIH0sXHJcbn0pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgVGV4dFRvU3BlZWNoRmVhdHVyZURlcGVuZGVudEludGVyZmFjZTtcclxuIiwiLy8gQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxyXG5pbXBvcnQgTWF0aFV0aWxzIGZyb20gJy4vTWF0aFV0aWxzJztcclxuaW1wb3J0IHtRdWFkcmF0aWN9IGZyb20gJy4vYW5pbXBhY2svRWFzaW5nJztcclxuaW1wb3J0IE1hbmFnZWRBbmltYXRpb25MYXllckludGVyZmFjZSBmcm9tICcuL2FuaW1wYWNrL01hbmFnZWRBbmltYXRpb25MYXllckludGVyZmFjZSc7XHJcbmltcG9ydCBUZXh0VG9TcGVlY2hGZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlIGZyb20gJy4vYXdzcGFjay9UZXh0VG9TcGVlY2hGZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlJztcclxuaW1wb3J0IEFic3RyYWN0SG9zdEZlYXR1cmUgZnJvbSAnLi9BYnN0cmFjdEhvc3RGZWF0dXJlJztcclxuXHJcbi8qKlxyXG4gKiBEZWZhdWx0IG1hcHBpbmcgb2YgUG9sbHkgdmlzZW1lIG5hbWVzIHRvIGFuaW1hdGlvbiBvcHRpb25zIG9iamVjdHMuXHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbc2lsPXtuYW1lOiAnc2lsJ31dXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbcD17bmFtZTogJ3AnLCBvdmVycmlkZVdlaWdodDogMC45fV1cclxuICogQHByb3BlcnR5IHtPYmplY3R9IFt0PXtuYW1lOiAndCcsIGJsZW5kVGltZTogMC4yfV1cclxuICogQHByb3BlcnR5IHtPYmplY3R9IFtTPXtuYW1lOiAnUyd9XVxyXG4gKiBAcHJvcGVydHkge09iamVjdH0gW1Q9e25hbWU6ICdUJ31dXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbZj17bmFtZTogJ2YnLCBvdmVycmlkZVdlaWdodDogMC43NX1dXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbaz17bmFtZTogJ2snfV1cclxuICogQHByb3BlcnR5IHtPYmplY3R9IFtpPXtuYW1lOiAnaSd9XVxyXG4gKiBAcHJvcGVydHkge09iamVjdH0gW3I9e25hbWU6ICdyJ31dXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbcz17bmFtZTogJ3MnLCBibGVuZFRpbWU6IDAuMjV9XVxyXG4gKiBAcHJvcGVydHkge09iamVjdH0gW3U9e25hbWU6ICd1J31dXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbQD17bmFtZTogJ0AnfV1cclxuICogQHByb3BlcnR5IHtPYmplY3R9IFthPXtuYW1lOiAnYSd9XVxyXG4gKiBAcHJvcGVydHkge09iamVjdH0gW2U9e25hbWU6ICdlJywgYmxlbmRUaW1lOiAwLjJ9XVxyXG4gKiBAcHJvcGVydHkge09iamVjdH0gW0U9e25hbWU6ICdFJ31dXHJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBbbz17bmFtZTogJ28nfV1cclxuICogQHByb3BlcnR5IHtPYmplY3R9IFtPPXtuYW1lOiAnTyd9XVxyXG4gKi9cclxuY29uc3QgRGVmYXVsdFZpc2VtZU1hcCA9IHtcclxuICBzaWw6IHtuYW1lOiAnc2lsJ30sXHJcbiAgcDoge25hbWU6ICdwJywgb3ZlcnJpZGVXZWlnaHQ6IDAuOX0sXHJcbiAgdDoge25hbWU6ICd0JywgYmxlbmRUaW1lOiAwLjJ9LFxyXG4gIFM6IHtuYW1lOiAnUyd9LFxyXG4gIFQ6IHtuYW1lOiAnVCd9LFxyXG4gIGY6IHtuYW1lOiAnZicsIG92ZXJyaWRlV2VpZ2h0OiAwLjc1fSxcclxuICBrOiB7bmFtZTogJ2snfSxcclxuICBpOiB7bmFtZTogJ2knfSxcclxuICByOiB7bmFtZTogJ3InfSxcclxuICBzOiB7bmFtZTogJ3MnLCBibGVuZFRpbWU6IDAuMjV9LFxyXG4gIHU6IHtuYW1lOiAndSd9LFxyXG4gICdAJzoge25hbWU6ICdAJ30sXHJcbiAgYToge25hbWU6ICdhJ30sXHJcbiAgZToge25hbWU6ICdlJywgYmxlbmRUaW1lOiAwLjJ9LFxyXG4gIEU6IHtuYW1lOiAnRSd9LFxyXG4gIG86IHtuYW1lOiAnbyd9LFxyXG4gIE86IHtuYW1lOiAnTyd9LFxyXG59O1xyXG5cclxuLyoqXHJcbiAqIExpcHN5bmMgY29udHJvbHMgdHdvIHR5cGVzIG9mIG1vdmVtZW50OiBpZGxlIGFuaW1hdGlvbiB0aGF0IHNob3VsZCBwbGF5IHdoaWxlXHJcbiAqIHNwZWVjaCBpcyBwbGF5aW5nIGFuZCB2aXNlbWUgYW5pbWF0aW9ucyBjb3JyZXNwb25kaW5nIHRvIFBvbGx5IHZpc2VtZXMgd2hvc2VcclxuICogd2VpZ2h0cyBzaG91bGQgYmUgdHVybmVkIG9uIGFuZCBvZmYgYXMgdGhleSBhcmUgZW5jb3VudGVyZWQgaW4gdGhlIFBvbGx5IFNTTUxcclxuICogdHJhbnNjcmlwdC4gTGF5ZXJzIG93bmVkIGJ5IHRoaXMgZmVhdHVyZSB3aWxsIGJlIGVuYWJsZWQgd2hpbGUgc3BlZWNoIGlzIHBsYXlpbmdcclxuICogYW5kIGRpc2FibGVkIG9uY2UgaXQgc3RvcHMuXHJcbiAqXHJcbiAqIEBleHRlbmRzIEFic3RyYWN0SG9zdEZlYXR1cmVcclxuICogQGFsaWFzIGNvcmUvTGlwc3luY0ZlYXR1cmVcclxuICogQGltcGxlbWVudHMgVGV4dFRvU3BlZWNoRmVhdHVyZURlcGVuZGVudEludGVyZmFjZVxyXG4gKiBAaW1wbGVtZW50cyBNYW5hZ2VkQW5pbWF0aW9uTGF5ZXJJbnRlcmZhY2VcclxuICovXHJcbmNsYXNzIExpcHN5bmNGZWF0dXJlIGV4dGVuZHMgQWJzdHJhY3RIb3N0RmVhdHVyZS5taXgoXHJcbiAgVGV4dFRvU3BlZWNoRmVhdHVyZURlcGVuZGVudEludGVyZmFjZS5NaXhpbixcclxuICBNYW5hZ2VkQW5pbWF0aW9uTGF5ZXJJbnRlcmZhY2UuTWl4aW5cclxuKSB7XHJcbiAgLyoqXHJcbiAgICogQGNvbnN0cnVjdG9yXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2NvcmUvSG9zdE9iamVjdH0gaG9zdCAtIEhvc3QgdGhhdCBvd25zIHRoZSBmZWF0dXJlLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gdmlzZW1lT3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSB2aXNlbWUgbGF5ZXJzLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbdmlzZW1lT3B0aW9ucy5ibGVuZFRpbWU9MC4xNV0gLSBEZWZhdWx0IGFtb3VudCBvZiB0aW1lIGl0XHJcbiAgICogd2lsbCB0YWtlIHRvIG1hbmlwdWxhdGUgZWFjaCBmcmVlQmxlbmQgd2VpZ2h0IG9uIHRoZSB2aXNlbWUgc3RhdGVzLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbdmlzZW1lT3B0aW9ucy5kZWNheVJhdGU9e2Ftb3VudDogLjUsIHNlY29uZHM6IC41fV0gLSBBbiBvYmplY3RcclxuICAgKiBkZXNjcmliaW5nIHRoZSAwLTEgZmFjdG9yIHZpc2VtZSB3ZWlnaHQgd2lsbCBkZWNheSBpZiB0aGUgdmlzZW1lIGR1cmF0aW9uIGlzXHJcbiAgICogbG9uZ2VyIHRoYW4gdGhlIGJsZW5kVGltZSBhbmQgdGhlIG51bWJlciBvZiBzZWNvbmRzIGl0IHdvdWxkIHRha2UgdG8gZGVjYXlcclxuICAgKiBieSB0aGF0IGZhY3Rvci5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW3Zpc2VtZU9wdGlvbnMuZWFzaW5nRm49UXVhZHJhdGljLkluT3V0XSAtIERlZmF1bHQgZWFzaW5nIGZ1bmN0aW9uXHJcbiAgICogdG8gdXNlIHdoZW4gbWFuaXB1bGF0aW5nIHZpc2VtZSBmcmVlQmxlbmQgd2VpZ2h0cy5cclxuICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBbdmlzZW1lT3B0aW9ucy4ubGF5ZXJzPVtdXSAtIEFuIGFycmF5IG9mIGxheWVyIG9wdGlvbnNcclxuICAgKiBvYmplY3RzIHRvIHJlZ2lzdGVyIGFzIHZpc2VtZSBsYXllcnMuXHJcbiAgICogQHBhcmFtIHtPYmplY3Q9fSB0YWxraW5nT3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSB0YWxraW5nIGxheWVycy5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW3RhbGtpbmdPcHRpb25zLmJsZW5kVGltZT0wLjc1XSAtIERlZmF1bHQgYW1vdW50IG9mIHRpbWUgdG9cclxuICAgKiBlbmFibGUgYW5kIGRpc2FibGUgdGhlIHRhbGtpbmcgaWRsZSBsYXllcnNcclxuICAgKiBAcGFyYW0ge251bWJlcn0gW3RhbGtpbmdPcHRpb25zLmVhc2luZ0ZuPVF1YWRyYXRpYy5Jbk91dF0gLSBEZWZhdWx0IGVhc2luZ1xyXG4gICAqIGZ1bmN0aW9uIHRvIHVzZSB3aGVuIG1hbmlwdWxhdGluZyB3ZWlnaHRzIG9uIHRoZSB0YWxraW5nIGlkbGUgbGF5ZXJzLlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IFt0YWxraW5nT3B0aW9ucy5sYXllcnM9W11dIC0gQW4gYXJyYXkgb2YgbGF5ZXIgb3B0aW9uc1xyXG4gICAqIG9iamVjdHMgdG8gcmVnaXN0ZXIgYXMgdGFsa2luZyBsYXllcnMuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFt2aXNlbWVMZWFkVGltZT0uMDY3XSAtIFRoZSBhbW91bnQgb2YgdGltZSB0byBpbnN0cnVjdCB0aGVcclxuICAgKiBUZXh0VG9TcGVlY2hGZWF0dXJlIHRvIGVtaXQgc3BlZWNobWFya3MgYmVmb3JlIGVhY2ggb25lJ3MgYWN0dWFsIHRpbWVzdGFtcFxyXG4gICAqIGlzIHJlYWNoZWQuIFRoaXMgd2lsbCBzZXQgdGhlICdzcGVlY2hNYXJrT2Zmc2V0JyB2YXJpYWJsZSBvbiB0aGUgVGV4dFRvU3BlZWNoRmVhdHVyZS5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIGhvc3QsXHJcbiAgICB7XHJcbiAgICAgIGJsZW5kVGltZTogdmlzZW1lQmxlbmRUaW1lID0gMC4xNSxcclxuICAgICAgZGVjYXlSYXRlOiB7YW1vdW50ID0gMC41LCBzZWNvbmRzID0gMC41fSA9IHt9LFxyXG4gICAgICBlYXNpbmdGbjogdmlzZW1lRWFzaW5nRm4gPSBRdWFkcmF0aWMuSW5PdXQsXHJcbiAgICAgIGxheWVyczogdmlzZW1lTGF5ZXJzID0gW10sXHJcbiAgICB9ID0ge30sXHJcbiAgICB7XHJcbiAgICAgIGJsZW5kVGltZTogdGFsa2luZ0JsZW5kVGltZSA9IDAuNzUsXHJcbiAgICAgIGVhc2luZ0ZuOiB0YWxraW5nRWFzaW5nRm4gPSBRdWFkcmF0aWMuSW5PdXQsXHJcbiAgICAgIGxheWVyczogdGFsa2luZ0xheWVycyA9IFtdLFxyXG4gICAgfSA9IHt9LFxyXG4gICAgdmlzZW1lTGVhZFRpbWUgPSAwLjA2N1xyXG4gICkge1xyXG4gICAgc3VwZXIoaG9zdCk7XHJcblxyXG4gICAgdGhpcy5fdmlzZW1lTGF5ZXJzID0ge307XHJcbiAgICB0aGlzLl90YWxraW5nTGF5ZXJzID0ge307XHJcbiAgICB0aGlzLnZpc2VtZUxlYWRUaW1lID0gdmlzZW1lTGVhZFRpbWU7XHJcblxyXG4gICAgLy8gUmVnaXN0ZXIgdGhlIHZpc2VtZSBsYXllcnNcclxuICAgIHZpc2VtZUxheWVycy5mb3JFYWNoKCh7bmFtZSwgYW5pbWF0aW9uLCB2aXNlbWVNYXAgPSBEZWZhdWx0VmlzZW1lTWFwfSkgPT4ge1xyXG4gICAgICB0aGlzLnJlZ2lzdGVyVmlzZW1lTGF5ZXIobmFtZSwge1xyXG4gICAgICAgIGFuaW1hdGlvbixcclxuICAgICAgICB2aXNlbWVNYXAsXHJcbiAgICAgICAgZGVjYXlSYXRlOiB7YW1vdW50LCBzZWNvbmRzfSxcclxuICAgICAgICBibGVuZFRpbWU6IHZpc2VtZUJsZW5kVGltZSxcclxuICAgICAgICBlYXNpbmdGbjogdmlzZW1lRWFzaW5nRm4sXHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gUmVnaXN0ZXIgdGhlIHRhbGtpbmcgbGF5ZXJzXHJcbiAgICB0YWxraW5nTGF5ZXJzLmZvckVhY2goKHtuYW1lLCBhbmltYXRpb259KSA9PiB7XHJcbiAgICAgIHRoaXMucmVnaXN0ZXJUYWxraW5nTGF5ZXIobmFtZSwge1xyXG4gICAgICAgIGFuaW1hdGlvbixcclxuICAgICAgICBibGVuZFRpbWU6IHRhbGtpbmdCbGVuZFRpbWUsXHJcbiAgICAgICAgZWFzaW5nRm46IHRhbGtpbmdFYXNpbmdGbixcclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEVuc3VyZSB0aGF0IHJlZ2lzdGVyZWQgdmlzZW1lIGFuaW1hdGlvbnMgYXJlIEZyZWVCbGVuZFN0YXRlcy5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdGhhdCBjb250YWlucyB0aGUgdmlzZW1lIGFuaW1hdGlvbi5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gYW5pbWF0aW9uTmFtZSAtIE5hbWUgb2YgdGhlIGFuaW1hdGlvbi5cclxuICAgKi9cclxuICBfcmVnaXN0ZXJWaXNlbWVBbmltYXRpb24obGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lKSB7XHJcbiAgICBpZiAodGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdLmFuaW1hdGlvbnNbYW5pbWF0aW9uTmFtZV0uaXNBY3RpdmUpIHtcclxuICAgICAgaWYgKFxyXG4gICAgICAgIHRoaXMuX2hvc3QuQW5pbWF0aW9uRmVhdHVyZS5nZXRBbmltYXRpb25UeXBlKFxyXG4gICAgICAgICAgbGF5ZXJOYW1lLFxyXG4gICAgICAgICAgYW5pbWF0aW9uTmFtZVxyXG4gICAgICAgICkgIT09ICdmcmVlQmxlbmQnXHJcbiAgICAgICkge1xyXG4gICAgICAgIC8vIFdhcm4gYW5kIGRlYWN0aXZhdGUgaWYgdGhlIHJlZ2lzdGVyZWQgc3RhdGUgaXMgbm90IGZyZWVCbGVuZFxyXG4gICAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICAgIGBDYW5ub3QgcmVnaXN0ZXIgTGlwc3luYyB2aXNlbWUgYW5pbWF0aW9uICR7YW5pbWF0aW9uTmFtZX0gb24gbGF5ZXIgJHtsYXllck5hbWV9IGZvciBob3N0ICR7dGhpcy5faG9zdC5pZH0uIFZpc2VtZSBhbmltYXRpb25zIG11c3QgYmUgb2YgdHlwZSAnZnJlZUJsZW5kJy5gXHJcbiAgICAgICAgKTtcclxuICAgICAgICB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV0uYW5pbWF0aW9uc1tcclxuICAgICAgICAgIGFuaW1hdGlvbk5hbWVcclxuICAgICAgICBdLmlzQWN0aXZlID0gZmFsc2U7XHJcbiAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgLy8gQ2hlY2sgaWYgdGhlIGJsZW5kV2VpZ2h0cyBjYW4gYmUgbWFuaXB1bGF0ZWQgbm93XHJcbiAgICAgICAgY29uc3Qgd2VpZ2h0TmFtZXMgPSB0aGlzLl9ob3N0LkFuaW1hdGlvbkZlYXR1cmUuZ2V0QW5pbWF0aW9uQmxlbmROYW1lcyhcclxuICAgICAgICAgIGxheWVyTmFtZSxcclxuICAgICAgICAgIGFuaW1hdGlvbk5hbWVcclxuICAgICAgICApO1xyXG4gICAgICAgIGNvbnN0IHt2aXNlbWVNYXB9ID0gdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdLmFuaW1hdGlvbnNbXHJcbiAgICAgICAgICBhbmltYXRpb25OYW1lXHJcbiAgICAgICAgXTtcclxuXHJcbiAgICAgICAgT2JqZWN0LnZhbHVlcyh2aXNlbWVNYXApLmZvckVhY2godmlzZW1lT3B0aW9ucyA9PiB7XHJcbiAgICAgICAgICB2aXNlbWVPcHRpb25zLmlzQWN0aXZlID0gd2VpZ2h0TmFtZXMuaW5jbHVkZXModmlzZW1lT3B0aW9ucy5uYW1lKTtcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSWYgdGhlIGFkZGVkIGZlYXR1cmUgaXMgVGV4dFRvU3BlZWNoLCB1cGRhdGUgaXRzIHNwZWVjaE1hcmtPZmZzZXQgdmFyaWFibGUuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHR5cGVOYW1lIC0gTmFtZSBvZiB0aGUgdHlwZSBvZiBmZWF0dXJlIHRoYXQgd2FzIGFkZGVkLlxyXG4gICAqL1xyXG4gIF9vbkZlYXR1cmVBZGRlZCh0eXBlTmFtZSkge1xyXG4gICAgdGhpcy5fdmlzZW1lTGF5ZXJzID0gdGhpcy5fdmlzZW1lTGF5ZXJzIHx8IHt9O1xyXG4gICAgdGhpcy5fdGFsa2luZ0xheWVycyA9IHRoaXMuX3RhbGtpbmdMYXllcnMgfHwge307XHJcblxyXG4gICAgc3VwZXIuX29uRmVhdHVyZUFkZGVkKHR5cGVOYW1lKTtcclxuXHJcbiAgICBpZiAodHlwZU5hbWUgPT09ICdUZXh0VG9TcGVlY2hGZWF0dXJlJykge1xyXG4gICAgICB0aGlzLl9ob3N0LlRleHRUb1NwZWVjaEZlYXR1cmUuc3BlZWNobWFya09mZnNldCA9XHJcbiAgICAgICAgLXRoaXMuX3Zpc2VtZUxlYWRUaW1lIHx8IDA7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICBfb25MYXllckFkZGVkKHtuYW1lfSkge1xyXG4gICAgc3VwZXIuX29uTGF5ZXJBZGRlZCh7bmFtZX0pO1xyXG5cclxuICAgIC8vIFZhbGlkYXRlIHRoZSB2aXNlbWUgYW5pbWF0aW9uXHJcbiAgICBpZiAodGhpcy5fdmlzZW1lTGF5ZXJzW25hbWVdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhpcy5fcmVnaXN0ZXJWaXNlbWVBbmltYXRpb24obmFtZSwgdGhpcy5fdmlzZW1lTGF5ZXJzW25hbWVdKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9vbkFuaW1hdGlvbkFkZGVkKHtsYXllck5hbWUsIGFuaW1hdGlvbk5hbWV9KSB7XHJcbiAgICBzdXBlci5fb25BbmltYXRpb25BZGRlZCh7bGF5ZXJOYW1lfSk7XHJcblxyXG4gICAgLy8gVmFsaWRhdGUgdGhlIHZpc2VtZSBhbmltYXRpb25cclxuICAgIGlmICh0aGlzLl92aXNlbWVMYXllcnNbbGF5ZXJOYW1lXSA9PT0gYW5pbWF0aW9uTmFtZSkge1xyXG4gICAgICB0aGlzLl9yZWdpc3RlclZpc2VtZUFuaW1hdGlvbihsYXllck5hbWUsIHRoaXMuX3Zpc2VtZUxheWVyc1tsYXllck5hbWVdKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIF9vblBsYXkoKSB7XHJcbiAgICAvLyBUdXJuIG9uIHRoZSBsYXllciB3ZWlnaHRzXHJcbiAgICB0aGlzLmVuYWJsZSgpO1xyXG5cclxuICAgIC8vIFNldCB0aGUgY3VycmVudCBhbmltYXRpb25zXHJcbiAgICBbdGhpcy5fdmlzZW1lTGF5ZXJzLCB0aGlzLl90YWxraW5nTGF5ZXJzXS5mb3JFYWNoKGxheWVycyA9PiB7XHJcbiAgICAgIE9iamVjdC5lbnRyaWVzKGxheWVycykuZm9yRWFjaCgoW2xheWVyTmFtZSwgYW5pbWF0aW9uTmFtZV0pID0+IHtcclxuICAgICAgICBpZiAodGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdLmFuaW1hdGlvbnNbYW5pbWF0aW9uTmFtZV0uaXNBY3RpdmUpIHtcclxuICAgICAgICAgIHRoaXMuX2hvc3QuQW5pbWF0aW9uRmVhdHVyZS5yZXN1bWVBbmltYXRpb24obGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBfb25QYXVzZSgpIHtcclxuICAgIHRoaXMuX29uU3RvcCgpO1xyXG4gIH1cclxuXHJcbiAgX29uUmVzdW1lKCkge1xyXG4gICAgdGhpcy5fb25QbGF5KCk7XHJcbiAgfVxyXG5cclxuICBfb25TdG9wKCkge1xyXG4gICAgLy8gVHVybiBvZmYgdGhlIGxheWVyIHdlaWdodHNcclxuICAgIHRoaXMuZGlzYWJsZSgpO1xyXG5cclxuICAgIC8vIFBhdXNlIHRoZSBjdXJyZW50IGFuaW1hdGlvbnNcclxuICAgIFt0aGlzLl92aXNlbWVMYXllcnMsIHRoaXMuX3RhbGtpbmdMYXllcnNdLmZvckVhY2gobGF5ZXJzID0+IHtcclxuICAgICAgT2JqZWN0LmVudHJpZXMobGF5ZXJzKS5mb3JFYWNoKChbbGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lXSkgPT4ge1xyXG4gICAgICAgIGlmICh0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV0uYW5pbWF0aW9uc1thbmltYXRpb25OYW1lXS5pc0FjdGl2ZSkge1xyXG4gICAgICAgICAgdGhpcy5faG9zdC5BbmltYXRpb25GZWF0dXJlLnBhdXNlQW5pbWF0aW9uKGxheWVyTmFtZSwgYW5pbWF0aW9uTmFtZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogV2hlbiB2aXNlbWUgZXZlbnRzIGFyZSBjYXVnaHQsIHR1cm4gb24gd2VpZ2h0IG9mIHRoZSBuZXcgdmlzZW1lIGZvciB0aGUgZHVyYXRpb25cclxuICAgKiBvZiB0aGUgc3BlZWNoIG1hcmssIHRoZW4gdHVybiB3ZWlnaHQgYmFjayBvZmYuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gRXZlbnQgZGF0YSBwYXNzZWQgZnJvbSB0aGUgc3BlZWNoLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudC5tYXJrIC0gU3BlZWNobWFyayBvYmplY3QuXHJcbiAgICovXHJcbiAgYXN5bmMgX29uVmlzZW1lKHttYXJrfSkge1xyXG4gICAgT2JqZWN0LmVudHJpZXModGhpcy5fdmlzZW1lTGF5ZXJzKS5mb3JFYWNoKChbbGF5ZXJOYW1lLCBhbmltTmFtZV0pID0+IHtcclxuICAgICAgLy8gTWFrZSBzdXJlIHRoZSBsYXllciBjYW4gYmUgbWFuaXB1bGF0ZWRcclxuICAgICAgY29uc3Qge2lzQWN0aXZlLCB2aXNlbWVNYXB9ID0gdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdLmFuaW1hdGlvbnNbXHJcbiAgICAgICAgYW5pbU5hbWVcclxuICAgICAgXTtcclxuXHJcbiAgICAgIGlmICghaXNBY3RpdmUpIHtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFRha2UgdmFyaWFibGVzIGZyb20gdGhlIHZpc2VtZSBpZiB0aGV5IGV4aXN0IGFuZCBkZWZhdWx0IHRvIHRoZSBsYXllclxyXG4gICAgICBjb25zdCB7XHJcbiAgICAgICAgbmFtZTogdmlzZW1lLFxyXG4gICAgICAgIGlzQWN0aXZlOiBpc1Zpc2VtZUFjdGl2ZSxcclxuICAgICAgICBkZWNheVJhdGUsXHJcbiAgICAgICAgYmxlbmRUaW1lLFxyXG4gICAgICAgIGVhc2luZ0ZuLFxyXG4gICAgICAgIG92ZXJyaWRlV2VpZ2h0LFxyXG4gICAgICB9ID0ge1xyXG4gICAgICAgIC4uLnRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXSxcclxuICAgICAgICAuLi52aXNlbWVNYXBbbWFyay52YWx1ZV0sXHJcbiAgICAgIH07XHJcblxyXG4gICAgICBjb25zdCB2aXNlbWVOYW1lcyA9IHRoaXMuX2hvc3QuQW5pbWF0aW9uRmVhdHVyZS5nZXRBbmltYXRpb25CbGVuZE5hbWVzKFxyXG4gICAgICAgIGxheWVyTmFtZSxcclxuICAgICAgICBhbmltTmFtZVxyXG4gICAgICApO1xyXG5cclxuICAgICAgLy8gTWFrZSBzdXJlIHRoZSBuZXcgdmlzZW1lIGhhcyBhbiBhY3RpdmUgZnJlZUJsZW5kIHdlaWdodFxyXG4gICAgICBpZiAoIWlzVmlzZW1lQWN0aXZlIHx8ICF2aXNlbWVOYW1lcy5pbmNsdWRlcyh2aXNlbWUpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBGaW5kIHRoZSBwZWFrIHdlaWdodCBmb3IgdGhlIHZpc2VtZSBhbmQgdGhlIGFtb3VudCBvZiB0aW1lIGl0IHNob3VsZFxyXG4gICAgICAvLyB0YWtlIHRvIHJlYWNoIGl0XHJcbiAgICAgIGxldCB3ZWlnaHQgPSAxO1xyXG4gICAgICBjb25zdCBkdXJhdGlvbiA9IG1hcmsuZHVyYXRpb24gLyAxMDAwO1xyXG4gICAgICBpZiAoZHVyYXRpb24gPCBibGVuZFRpbWUpIHtcclxuICAgICAgICBjb25zdCBsZXJwRmFjdG9yID0gYmxlbmRUaW1lID4gMCA/IGR1cmF0aW9uIC8gYmxlbmRUaW1lIDogMTtcclxuICAgICAgICB3ZWlnaHQgPVxyXG4gICAgICAgICAgb3ZlcnJpZGVXZWlnaHQgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICA/IG92ZXJyaWRlV2VpZ2h0XHJcbiAgICAgICAgICAgIDogTWF0aFV0aWxzLmxlcnAoMCwgMSwgbGVycEZhY3Rvcik7XHJcbiAgICAgIH1cclxuICAgICAgY29uc3QgYmxlbmRJblRpbWUgPSBNYXRoLm1pbihkdXJhdGlvbiwgYmxlbmRUaW1lKTtcclxuXHJcbiAgICAgIC8vIEZpbmQgdGhlIGFtb3VudCBhbmQgdGltZSB2aXNlbWUgd2lsbCBiZSBoZWxkIGZvclxyXG4gICAgICBjb25zdCBob2xkVGltZSA9IGR1cmF0aW9uIC0gYmxlbmRUaW1lO1xyXG5cclxuICAgICAgaWYgKGhvbGRUaW1lIDwgMCkge1xyXG4gICAgICAgIC8vIFBlcmZvcm0gaW4gLT4gb3V0IGFuaW1hdGlvblxyXG4gICAgICAgIHRoaXMuX2FuaW1hdGVTaW1wbGVWaXNlbWUoXHJcbiAgICAgICAgICBsYXllck5hbWUsXHJcbiAgICAgICAgICBhbmltTmFtZSxcclxuICAgICAgICAgIHZpc2VtZSxcclxuICAgICAgICAgIHdlaWdodCxcclxuICAgICAgICAgIGJsZW5kSW5UaW1lLFxyXG4gICAgICAgICAgYmxlbmRUaW1lLFxyXG4gICAgICAgICAgZWFzaW5nRm5cclxuICAgICAgICApO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNvbnN0IGxlcnBGYWN0b3IgPVxyXG4gICAgICAgICAgZGVjYXlSYXRlLnNlY29uZHMgPiAwID8gaG9sZFRpbWUgLyBkZWNheVJhdGUuc2Vjb25kcyA6IDE7XHJcbiAgICAgICAgLy8gUGVyZm9ybSBpbiAtPiBob2xkIC0+IG91dCBhbmltYXRpb25cclxuICAgICAgICBjb25zdCBkZWNheVdlaWdodCA9IE1hdGhVdGlscy5sZXJwKFxyXG4gICAgICAgICAgd2VpZ2h0LFxyXG4gICAgICAgICAgd2VpZ2h0ICogZGVjYXlSYXRlLmFtb3VudCxcclxuICAgICAgICAgIE1hdGgubWluKDEsIGxlcnBGYWN0b3IpXHJcbiAgICAgICAgKTtcclxuICAgICAgICB0aGlzLl9hbmltYXRlSGVsZFZpc2VtZShcclxuICAgICAgICAgIGxheWVyTmFtZSxcclxuICAgICAgICAgIGFuaW1OYW1lLFxyXG4gICAgICAgICAgdmlzZW1lLFxyXG4gICAgICAgICAgd2VpZ2h0LFxyXG4gICAgICAgICAgZGVjYXlXZWlnaHQsXHJcbiAgICAgICAgICBibGVuZEluVGltZSxcclxuICAgICAgICAgIGhvbGRUaW1lLFxyXG4gICAgICAgICAgYmxlbmRUaW1lLFxyXG4gICAgICAgICAgZWFzaW5nRm5cclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFuaW1hdGUgYSB2aXNlbWUgYmxlbmQgd2VpZ2h0IHRvd2FyZHMgYSB2YWx1ZSBhbmQgdGhlbiBiYWNrIHRvIHplcm8uXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRoYXQgY29udGFpbnMgdGhlIHZpc2VtZS5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gYW5pbU5hbWUgLSBOYW1lIG9mIHRoZSBmcmVlYmxlbmQgYW5pbWF0aW9uIHRoYXQgY29udGFpbnNcclxuICAgKiB0aGUgdmlzZW1lLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB2aXNlbWVOYW1lIC0gTmFtZSBvZiB0aGUgYmxlbmQgd2VpZ2h0IHRvIG1hbmlwdWxhdGUuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHdlaWdodCAtIFBlYWsgd2VpZ2h0IHRvIGFuaW1hdGUgdG93YXJkcy5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gYmxlbmRJblRpbWUgLSBBbW91bnQgb2YgdGltZSBpdCBzaG91bGQgdGFrZSB0byByZWFjaCB0aGVcclxuICAgKiBwZWFrIHdlaWdodC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gYmxlbmRPdXRUaW1lIC0gQW1vdW50IG9mIHRpbWUgaXQgc2hvdWxkIHRha2UgdG8gYW5pbWF0ZSBiYWNrXHJcbiAgICogdG8gemVybyBhZnRlciByZWFjaGluZyB0aGUgcGVhayB3ZWlnaHQuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbn0gZWFzaW5nRm4gLSBFYXNpbmcgZnVuY3Rpb24gdG8gdXNlIGR1cmluZyBhbmltYXRpb24uXHJcbiAgICovXHJcbiAgX2FuaW1hdGVTaW1wbGVWaXNlbWUoXHJcbiAgICBsYXllck5hbWUsXHJcbiAgICBhbmltTmFtZSxcclxuICAgIHZpc2VtZU5hbWUsXHJcbiAgICBwZWFrV2VpZ2h0LFxyXG4gICAgYmxlbmRJblRpbWUsXHJcbiAgICBibGVuZE91dFRpbWUsXHJcbiAgICBlYXNpbmdGblxyXG4gICkge1xyXG4gICAgLy8gQW5pbWF0ZSB0b3dhcmRzIHRoZSBwZWFrIHZhbHVlXHJcbiAgICBjb25zdCB3ZWlnaHRQcm9taXNlID0gdGhpcy5faG9zdC5BbmltYXRpb25GZWF0dXJlLnNldEFuaW1hdGlvbkJsZW5kV2VpZ2h0KFxyXG4gICAgICBsYXllck5hbWUsXHJcbiAgICAgIGFuaW1OYW1lLFxyXG4gICAgICB2aXNlbWVOYW1lLFxyXG4gICAgICBwZWFrV2VpZ2h0LFxyXG4gICAgICBibGVuZEluVGltZSxcclxuICAgICAgZWFzaW5nRm5cclxuICAgICk7XHJcblxyXG4gICAgLy8gQW5pbWF0ZSBiYWNrIHRvIHplcm8gaWYgdGhlcmUgd2FzIG5vIHdlaWdodCBpbnRlcnJ1cHRpb25cclxuICAgIHdlaWdodFByb21pc2UudGhlbigoKSA9PiB7XHJcbiAgICAgIGlmICghd2VpZ2h0UHJvbWlzZS5jYW5jZWxlZCkge1xyXG4gICAgICAgIHRoaXMuX2hvc3QuQW5pbWF0aW9uRmVhdHVyZS5zZXRBbmltYXRpb25CbGVuZFdlaWdodChcclxuICAgICAgICAgIGxheWVyTmFtZSxcclxuICAgICAgICAgIGFuaW1OYW1lLFxyXG4gICAgICAgICAgdmlzZW1lTmFtZSxcclxuICAgICAgICAgIDAsXHJcbiAgICAgICAgICBibGVuZE91dFRpbWUsXHJcbiAgICAgICAgICBlYXNpbmdGblxyXG4gICAgICAgICk7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQW5pbWF0ZSBhIHZpc2VtZSBibGVuZCB3ZWlnaHQgdG93YXJkcyBhIHZhbHVlIGFuZCB0aGVuIGJhY2sgdG8gemVyby5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdGhhdCBjb250YWlucyB0aGUgdmlzZW1lLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhbmltTmFtZSAtIE5hbWUgb2YgdGhlIGZyZWVibGVuZCBhbmltYXRpb24gdGhhdCBjb250YWluc1xyXG4gICAqIHRoZSB2aXNlbWUuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZpc2VtZU5hbWUgLSBOYW1lIG9mIHRoZSBibGVuZCB3ZWlnaHQgdG8gbWFuaXB1bGF0ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gcGVha1dlaWdodCAtIFBlYWsgd2VpZ2h0IHRvIGFuaW1hdGUgdG93YXJkcy5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVjYXlXZWlnaHQgLSBXZWlnaHQgdG8gYW5pbWF0ZSB0b3dhcmRzIGFmdGVyIHJlYWNoaW5nIHRoZVxyXG4gICAqIHBlYWsgd2VpZ2h0LlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBibGVuZEluVGltZSAtIEFtb3VudCBvZiB0aW1lIGl0IHNob3VsZCB0YWtlIHRvIHJlYWNoIHRoZVxyXG4gICAqIHBlYWsgd2VpZ2h0LlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBob2xkVGltZSAtIEFtb3VudCBvZiB0aW1lIGl0IHNob3VsZCB0YWtlIHRvIHJlYWNoIHRoZSBkZWNheVxyXG4gICAqIHdlaWdodCBhZnRlciB0aGUgcGVhayB3ZWlnaHQgaGFzIGJlZW4gcmVhY2hlZC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gYmxlbmRPdXRUaW1lIC0gQW1vdW50IG9mIHRpbWUgaXQgc2hvdWxkIHRha2UgdG8gYW5pbWF0ZSBiYWNrXHJcbiAgICogdG8gemVybyBhZnRlciByZWFjaGluZyB0aGUgZGVjYXkgd2VpZ2h0LlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IGVhc2luZ0ZuIC0gRWFzaW5nIGZ1bmN0aW9uIHRvIHVzZSBkdXJpbmcgYW5pbWF0aW9uLlxyXG4gICAqL1xyXG4gIGFzeW5jIF9hbmltYXRlSGVsZFZpc2VtZShcclxuICAgIGxheWVyTmFtZSxcclxuICAgIGFuaW1OYW1lLFxyXG4gICAgdmlzZW1lTmFtZSxcclxuICAgIHBlYWtXZWlnaHQsXHJcbiAgICBkZWNheVdlaWdodCxcclxuICAgIGJsZW5kSW5UaW1lLFxyXG4gICAgaG9sZFRpbWUsXHJcbiAgICBibGVuZE91dFRpbWUsXHJcbiAgICBlYXNpbmdGblxyXG4gICkge1xyXG4gICAgLy8gQW5pbWF0ZSB0b3dhcmRzIHRoZSBwZWFrIHZhbHVlXHJcbiAgICBjb25zdCBzdGFydFByb21pc2UgPSB0aGlzLl9ob3N0LkFuaW1hdGlvbkZlYXR1cmUuc2V0QW5pbWF0aW9uQmxlbmRXZWlnaHQoXHJcbiAgICAgIGxheWVyTmFtZSxcclxuICAgICAgYW5pbU5hbWUsXHJcbiAgICAgIHZpc2VtZU5hbWUsXHJcbiAgICAgIHBlYWtXZWlnaHQsXHJcbiAgICAgIGJsZW5kSW5UaW1lLFxyXG4gICAgICBlYXNpbmdGblxyXG4gICAgKTtcclxuXHJcbiAgICBhd2FpdCBzdGFydFByb21pc2U7XHJcblxyXG4gICAgaWYgKCFzdGFydFByb21pc2UuY2FuY2VsZWQpIHtcclxuICAgICAgLy8gQW5pbWF0ZSB0b3dhcmRzIHRoZSBkZWNheSB2YWx1ZSBpZiB0aGVyZSB3YXMgbm8gd2VpZ2h0IGludGVycnVwdGlvblxyXG4gICAgICBjb25zdCBob2xkUHJvbWlzZSA9IHRoaXMuX2hvc3QuQW5pbWF0aW9uRmVhdHVyZS5zZXRBbmltYXRpb25CbGVuZFdlaWdodChcclxuICAgICAgICBsYXllck5hbWUsXHJcbiAgICAgICAgYW5pbU5hbWUsXHJcbiAgICAgICAgdmlzZW1lTmFtZSxcclxuICAgICAgICBkZWNheVdlaWdodCxcclxuICAgICAgICBob2xkVGltZSxcclxuICAgICAgICBlYXNpbmdGblxyXG4gICAgICApO1xyXG5cclxuICAgICAgYXdhaXQgaG9sZFByb21pc2U7XHJcblxyXG4gICAgICBpZiAoIWhvbGRQcm9taXNlLmNhbmNlbGVkKSB7XHJcbiAgICAgICAgLy8gQW5pbWF0ZSBiYWNrIHRvIHplcm8gaWYgdGhlcmUgd2FzIG5vIHdlaWdodCBpbnRlcnJ1cHRpb25cclxuICAgICAgICB0aGlzLl9ob3N0LkFuaW1hdGlvbkZlYXR1cmUuc2V0QW5pbWF0aW9uQmxlbmRXZWlnaHQoXHJcbiAgICAgICAgICBsYXllck5hbWUsXHJcbiAgICAgICAgICBhbmltTmFtZSxcclxuICAgICAgICAgIHZpc2VtZU5hbWUsXHJcbiAgICAgICAgICAwLFxyXG4gICAgICAgICAgYmxlbmRPdXRUaW1lLFxyXG4gICAgICAgICAgZWFzaW5nRm5cclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIGFuZCBzZXRzIHRoZSBhbW91bnQgb2YgdGltZSBpbiBzZWNvbmRzIHRvIG5lZ2F0aXZlbHkgb2Zmc2V0IHNwZWVjaG1hcmtcclxuICAgKiBlbWlzc2lvbiBieS5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IHZpc2VtZUxlYWRUaW1lKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3Zpc2VtZUxlYWRUaW1lO1xyXG4gIH1cclxuXHJcbiAgc2V0IHZpc2VtZUxlYWRUaW1lKHNlY29uZHMpIHtcclxuICAgIHRoaXMuX3Zpc2VtZUxlYWRUaW1lID0gc2Vjb25kcztcclxuXHJcbiAgICBpZiAodGhpcy5faG9zdC5UZXh0VG9TcGVlY2hGZWF0dXJlKSB7XHJcbiAgICAgIHRoaXMuX2hvc3QuVGV4dFRvU3BlZWNoRmVhdHVyZS5zcGVlY2htYXJrT2Zmc2V0ID0gLXNlY29uZHM7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdGFydCBrZWVwaW5nIHRyYWNrIG9mIGFuIGFuaW1hdGlvbiBsYXllciB0aGF0IG93bnMgYSBmcmVlQmxlbmQgYW5pbWF0aW9uXHJcbiAgICogd2l0aCBibGVuZFdlaWdodHMgY29ycmVzcG9uZGluZyB0byB2aXNlbWVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRvIGtlZXAgdHJhY2sgb2YuXHJcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIGxheWVyLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb249J3Zpc2VtZXMnXSAtIE5hbWUgb2YgdGhlIGFuaW1hdGlvbiBvbiB0aGVcclxuICAgKiBsYXllciB0aGF0IHdpbGwgYmUgcGxheWVkIGR1cmluZyBzcGVlY2guIFRoaXMgYW5pbWF0aW9uIG11c3QgYmUgb2YgdHlwZVxyXG4gICAqIGZyZWVCbGVuZC5cclxuICAgKiBAcGFyYW0ge09iamVjdD19IGRlY2F5UmF0ZVxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVjYXlSYXRlLmFtb3VudD0wLjVdIC0gVGhlIHBlcmNlbnRhZ2UgdG8gZGVjcmVhc2UgdGhlIHZpc2VtZSdzXHJcbiAgICogcGVhayB2YWx1ZSBieSBvdmVyIHRpbWUgb25jZSB0aGUgcGVhayB2YWx1ZSBoYXMgYmVlbiByZWFjaGVkLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbZGVjYXlSYXRlLnNlY29uZHM9MC41XSAtIFRoZSBhbW91bnQgb2YgdGltZSBpbiBzZWNvbmRzIHRvXHJcbiAgICogZGVjcmVhc2UgdGhlIHZpc2VtZSdzIHdlaWdodCBvbmNlIGl0IGhhcyByZWFjaGVkIGl0cyBwZWFrIHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gW29wdGlvbnMuYmxlbmRUaW1lPVtMaXBzeW5jRmVhdHVyZS5ERUZBVUxUX0xBWUVSX09QVElPTlMuYmxlbmRUaW1lXXtAbGluayBMaXBzeW5jRmVhdHVyZSNERUZBVUxUX0xBWUVSX09QVElPTlMjYmxlbmRUaW1lfV0gLVxyXG4gICAqIERlZmF1bHQgYW1vdW50IG9mIHRpbWUgdG8gdXNlIHdoZW4gbWFuaXB1bGF0aW5nIGFuaW1hdGlvbiBibGVuZFdlaWdodHMuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9wdGlvbnMuZWFzaW5nRm4gLSBEZWZhdWx0IGVhc2luZyBmdW5jdGlvbiB0byB1c2Ugd2hlblxyXG4gICAqIG1hbmlwdWxhdGluZyBhbmltYXRpb24gYmxlbmRXZWlnaHRzLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9ucy52aXNlbWVNYXA9RGVmYXVsdFZpc2VtZU1hcF0gLSBPYmplY3QgY29udGFpbmluZyBrZXkvdmFsdWUgcGFpcnMgb2ZcclxuICAgKiBQb2xseSB2aXNlbWUgbmFtZXMgbWFwcGVkIHRvIG9iamVjdHMgY29udGFpbmluZyB0aGUgbmFtZSBvZiB0aGUgY29ycmVzcG9uZGluZ1xyXG4gICAqIGFuaW1hdGlvbiBibGVuZFdlaWdodCBhbmQgYW55IG90aGVyIGFuaW1hdGlvbiBvcHRpb25zIHRvIHVzZSBzdWNoIGFzIHZpc2VtZVxyXG4gICAqIHNwZWNpZmljIGJsZW5kIHRpbWVzIGFuZCBlYXNpbmcgZnVuY3Rpb25zLlxyXG4gICAqL1xyXG4gIHJlZ2lzdGVyVmlzZW1lTGF5ZXIoXHJcbiAgICBsYXllck5hbWUsXHJcbiAgICB7XHJcbiAgICAgIGFuaW1hdGlvbiA9ICd2aXNlbWVzJyxcclxuICAgICAgZGVjYXlSYXRlID0ge2Ftb3VudDogMC41LCBzZWNvbmRzOiAwLjV9LFxyXG4gICAgICBibGVuZFRpbWUgPSBMaXBzeW5jRmVhdHVyZS5ERUZBVUxUX0xBWUVSX09QVElPTlMuYmxlbmRUaW1lLFxyXG4gICAgICBlYXNpbmdGbixcclxuICAgICAgdmlzZW1lTWFwID0gRGVmYXVsdFZpc2VtZU1hcCxcclxuICAgIH0gPSB7fVxyXG4gICkge1xyXG4gICAgLy8gUmVnaXN0ZXIgdGhlIGxheWVyIGFuZCBhbmltYXRpb25cclxuICAgIHRoaXMucmVnaXN0ZXJMYXllcihsYXllck5hbWUsIHtcclxuICAgICAgZGVjYXlSYXRlLFxyXG4gICAgICBibGVuZFRpbWUsXHJcbiAgICAgIGVhc2luZ0ZuLFxyXG4gICAgICBhbmltYXRpb25zOiB7W2FuaW1hdGlvbl06IHt2aXNlbWVNYXB9fSxcclxuICAgIH0pO1xyXG4gICAgdGhpcy5fdmlzZW1lTGF5ZXJzW2xheWVyTmFtZV0gPSBhbmltYXRpb247XHJcblxyXG4gICAgLy8gVmFsaWRhdGUgdGhlIHZpc2VtZSBhbmltYXRpb25cclxuICAgIHRoaXMuX3JlZ2lzdGVyVmlzZW1lQW5pbWF0aW9uKGxheWVyTmFtZSwgYW5pbWF0aW9uKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0YXJ0IGtlZXBpbmcgdHJhY2sgb2YgYW4gYW5pbWF0aW9uIGxheWVyIHRoYXQgY29udGFpbnMgYSBsb29waW5nIGFuaW1hdGlvblxyXG4gICAqIHRvIGJlIHBsYXllZCBkdXJpbmcgc3BlZWNoLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRvIGtlZXAgdHJhY2sgb2YuXHJcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIGxheWVyLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbb3B0aW9ucy5hbmltYXRpb249J3N0YW5kX3RhbGsnXSAtIE5hbWUgb2YgdGhlIGFuaW1hdGlvbiBvbiB0aGVcclxuICAgKiBsYXllciB0aGF0IHdpbGwgYmUgcGxheWVkIGR1cmluZyBzcGVlY2guXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmJsZW5kVGltZT1bTGlwc3luY0ZlYXR1cmUuREVGQVVMVF9MQVlFUl9PUFRJT05TLmJsZW5kVGltZV17QGxpbmsgTGlwc3luY0ZlYXR1cmUjREVGQVVMVF9MQVlFUl9PUFRJT05TI2JsZW5kVGltZX1dIC1cclxuICAgKiBEZWZhdWx0IGFtb3VudCBvZiB0aW1lIHRvIHVzZSB3aGVuIG1hbmlwdWxhdGluZyB0aGUgbGF5ZXIncyB3ZWlnaHRzLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvcHRpb25zLmVhc2luZ0ZuIC0gRGVmYXVsdCBlYXNpbmcgZnVuY3Rpb24gdG8gdXNlIHdoZW5cclxuICAgKiBtYW5pcHVsYXRpbmcgdGhlIGxheWVyJ3Mgd2VpZ2h0cy5cclxuICAgKi9cclxuICByZWdpc3RlclRhbGtpbmdMYXllcihcclxuICAgIGxheWVyTmFtZSxcclxuICAgIHtcclxuICAgICAgYW5pbWF0aW9uID0gJ3N0YW5kX3RhbGsnLFxyXG4gICAgICBibGVuZFRpbWUgPSBMaXBzeW5jRmVhdHVyZS5ERUZBVUxUX0xBWUVSX09QVElPTlMuYmxlbmRUaW1lLFxyXG4gICAgICBlYXNpbmdGbixcclxuICAgIH0gPSB7fVxyXG4gICkge1xyXG4gICAgLy8gUmVnaXN0ZXIgdGhlIGxheWVyIGFuZCBhbmltYXRpb25cclxuICAgIHRoaXMucmVnaXN0ZXJMYXllcihsYXllck5hbWUsIHtcclxuICAgICAgYmxlbmRUaW1lLFxyXG4gICAgICBlYXNpbmdGbixcclxuICAgICAgYW5pbWF0aW9uczoge1thbmltYXRpb25dOiB7fX0sXHJcbiAgICB9KTtcclxuICAgIHRoaXMuX3RhbGtpbmdMYXllcnNbbGF5ZXJOYW1lXSA9IGFuaW1hdGlvbjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgYSBuYW1lc3BhY2UgdG8gdGhlIGhvc3Qgd2l0aCB0aGUgbmFtZSBvZiB0aGUgZmVhdHVyZSB0byBjb250YWluIHByb3BlcnRpZXNcclxuICAgKiBhbmQgbWV0aG9kcyBmcm9tIHRoZSBmZWF0dXJlIHRoYXQgdXNlcnMgb2YgdGhlIGhvc3QgbmVlZCBhY2Nlc3MgdG8uXHJcbiAgICpcclxuICAgKiBAc2VlIExpcHN5bmNGZWF0dXJlXHJcbiAgICovXHJcbiAgaW5zdGFsbEFwaSgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKiBAbmFtZXNwYWNlIExpcHN5bmNGZWF0dXJlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IGFwaSA9IHN1cGVyLmluc3RhbGxBcGkoKTtcclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZW1iZXJvZiBMaXBzeW5jRmVhdHVyZVxyXG4gICAgICogQG5hbWUgcmVnaXN0ZXJMYXllclxyXG4gICAgICogQGluc3RhbmNlXHJcbiAgICAgKiBAbWV0aG9kXHJcbiAgICAgKiBAc2VlIE1hbmFnZWRBbmltYXRpb25MYXllckludGVyZmFjZSNyZWdpc3RlckxheWVyXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZW1iZXJvZiBMaXBzeW5jRmVhdHVyZVxyXG4gICAgICogQG5hbWUgcmVnaXN0ZXJBbmltYXRpb25cclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQHNlZSBNYW5hZ2VkQW5pbWF0aW9uTGF5ZXJJbnRlcmZhY2UjcmVnaXN0ZXJBbmltYXRpb25cclxuICAgICAqL1xyXG5cclxuICAgIC8qKlxyXG4gICAgICogQG1lbWJlcm9mIExpcHN5bmNGZWF0dXJlXHJcbiAgICAgKiBAbmFtZSBzZXRMYXllcldlaWdodHNcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQHNlZSBNYW5hZ2VkQW5pbWF0aW9uTGF5ZXJJbnRlcmZhY2Ujc2V0TGF5ZXJXZWlnaHRzXHJcbiAgICAgKi9cclxuXHJcbiAgICAvKipcclxuICAgICAqIEBtZW1iZXJvZiBMaXBzeW5jRmVhdHVyZVxyXG4gICAgICogQG5hbWUgZW5hYmxlXHJcbiAgICAgKiBAaW5zdGFuY2VcclxuICAgICAqIEBtZXRob2RcclxuICAgICAqIEBzZWUgTWFuYWdlZEFuaW1hdGlvbkxheWVySW50ZXJmYWNlI2VuYWJsZVxyXG4gICAgICovXHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyb2YgTGlwc3luY0ZlYXR1cmVcclxuICAgICAqIEBuYW1lIGRpc2FibGVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQG1ldGhvZFxyXG4gICAgICogQHNlZSBNYW5hZ2VkQW5pbWF0aW9uTGF5ZXJJbnRlcmZhY2UjZGlzYWJsZVxyXG4gICAgICovXHJcblxyXG4gICAgT2JqZWN0LmFzc2lnbihhcGksIHtcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBtZW1iZXJvZiBMaXBzeW5jRmVhdHVyZVxyXG4gICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgKiBAc2VlIGNvcmUvTGlwc3luY0ZlYXR1cmUjcmVnaXN0ZXJWaXNlbWVMYXllclxyXG4gICAgICAgKi9cclxuICAgICAgcmVnaXN0ZXJWaXNlbWVMYXllcjogdGhpcy5yZWdpc3RlclZpc2VtZUxheWVyLmJpbmQodGhpcyksXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbWVtYmVyb2YgTGlwc3luY0ZlYXR1cmVcclxuICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAqIEBtZXRob2RcclxuICAgICAgICogQHNlZSBjb3JlL0xpcHN5bmNGZWF0dXJlI3JlZ2lzdGVyVGFsa2luZ0xheWVyXHJcbiAgICAgICAqL1xyXG4gICAgICByZWdpc3RlclRhbGtpbmdMYXllcjogdGhpcy5yZWdpc3RlclRhbGtpbmdMYXllci5iaW5kKHRoaXMpLFxyXG4gICAgfSk7XHJcblxyXG4gICAgLyoqXHJcbiAgICAgKiBAbWVtYmVyb2YgTGlwc3luY0ZlYXR1cmVcclxuICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICogQG5hbWUgdmlzZW1lTGVhZFRpbWVcclxuICAgICAqIEBzZWUgY29yZS9MaXBzeW5jRmVhdHVyZSN2aXNlbWVMZWFkVGltZVxyXG4gICAgICovXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoYXBpLCAndmlzZW1lTGVhZFRpbWUnLCB7XHJcbiAgICAgIGdldDogKCkgPT4gdGhpcy52aXNlbWVMZWFkVGltZSxcclxuICAgICAgc2V0OiBzZWNvbmRzID0+IHtcclxuICAgICAgICB0aGlzLnZpc2VtZUxlYWRUaW1lID0gc2Vjb25kcztcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBhcGk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBMaXBzeW5jRmVhdHVyZTtcclxuZXhwb3J0IHtEZWZhdWx0VmlzZW1lTWFwfTtcclxuIiwiLyogZXNsaW50LWRpc2FibGUgbm8tdW51c2VkLXZhcnMgKi9cclxuLy8gQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxyXG5cclxuLyogZXNsaW50LWRpc2FibGUgbWF4LWNsYXNzZXMtcGVyLWZpbGUgKi9cclxuLyogZXNsaW50LWRpc2FibGUgbm8tZW1wdHkgKi9cclxuaW1wb3J0IFRleHRUb1NwZWVjaEZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2UgZnJvbSAnY29yZS9hd3NwYWNrL1RleHRUb1NwZWVjaEZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2UnO1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIGZhY3RvcnkgaW50ZXJmYWNlIGZvciB0aGF0IHJlZ2lzdGVycyBjYWxsYmFjayBtZXRob2Qgd2hlbiBhIHNzbWwgc3BlZWNobWFyayBldmVudCBpcyBlbWl0dGVkLlxyXG4gKlxyXG4gKiBAaW50ZXJmYWNlXHJcbiAqIEBleHRlbmRzIFRleHRUb1NwZWVjaEZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2VcclxuICovXHJcbmNsYXNzIFNTTUxTcGVlY2htYXJrSW50ZXJmYWNlIGV4dGVuZHMgVGV4dFRvU3BlZWNoRmVhdHVyZURlcGVuZGVudEludGVyZmFjZSB7XHJcbiAgLyoqXHJcbiAgICogV2hlbiBzc21sIGV2ZW50cyBhcmUgY2F1Z2h0LCB0aGlzIHdpbGwgdHJ5IHRvIHBhcnNlIHRoZSBzcGVlY2ggbWFyayB2YWx1ZSBhbmQgZXhlY3V0ZSBhbnkgZnVuY3Rpb24gd2hpY2ggbWVldHMgY3JpdGVyaWEgZGVmaW5lZCBpbiB0aGUgdmFsdWUuXHJcbiAgICogU3BlZWNoIG1hcmsgdmFsdWUgd2lsbCBiZSB0cmVhdGVkIGFzIHN0cmluZ2lmaWVkIGpzb24gZm9ybWF0IGNvbnRhaW5pbmcgcmVxdWlyZWQgZmVhdHVyZSBuYW1lLCBmdW5jdGlvbiBuYW1lIGFuZCBhcmd1bWVudCBhcnJheSB0byBwYXNzIGluLlxyXG4gICAqIEV4YW1wbGUgc3BlZWNoIG1hcmsgdmFsdWUgbWlnaHQgbG9vayBsaWtlOiAne1wiZmVhdHVyZVwiOlwiR2VzdHVyZUZlYXR1cmVcIiwgXCJtZXRob2RcIjpcInN3aXRjaFRvR2VzdHVyZVwiLCBcImFyZ3NcIjpbXCJnZW5yaWNBXCIsIDAuNV19J1xyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudCAtIEV2ZW50IGRhdGEgcGFzc2VkIGZyb20gdGhlIHNwZWVjaC5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gZXZlbnQubWFyayAtIFNwZWVjaG1hcmsgb2JqZWN0LlxyXG4gICAqL1xyXG4gIF9vblNzbWwoe21hcmt9KSB7fVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGVzIGEgY2xhc3MgdGhhdCBpbXBsZW1lbnRzIHtAbGluayBTU01MU3BlZWNobWFya0ludGVyZmFjZX1cclxuICAgKiBhbmQgZXh0ZW5kcyBhIHNwZWNpZmllZCBiYXNlIGNsYXNzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtDbGFzc30gQmFzZUNsYXNzIC0gVGhlIGNsYXNzIHRvIGV4dGVuZC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0NsYXNzfSBBIGNsYXNzIHRoYXQgZXh0ZW5kcyBgQmFzZUNsYXNzYCBhbmQgaW1wbGVtZW50cyB7QGxpbmsgU1NNTFNwZWVjaG1hcmtJbnRlcmZhY2V9LlxyXG4gICAqL1xyXG4gIHN0YXRpYyBNaXhpbihCYXNlQ2xhc3MpIHtcclxuICAgIGNvbnN0IFBhcmVudENsYXNzID0gVGV4dFRvU3BlZWNoRmVhdHVyZURlcGVuZGVudEludGVyZmFjZS5NaXhpbihCYXNlQ2xhc3MpO1xyXG4gICAgY29uc3QgU1NNTFNwZWVjaE1hcmtNaXhpbiA9IGNsYXNzIGV4dGVuZHMgUGFyZW50Q2xhc3Mge1xyXG4gICAgICBfb25Tc21sKHttYXJrfSkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICBjb25zdCB7ZmVhdHVyZSwgbWV0aG9kLCBhcmdzfSA9IEpTT04ucGFyc2UobWFyay52YWx1ZSk7XHJcbiAgICAgICAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5uYW1lID09PSBmZWF0dXJlKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGNhbGxiYWNrID0gdGhpc1ttZXRob2RdO1xyXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2sgJiYgdHlwZW9mIGNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICAgICAgY2FsbGJhY2suYXBwbHkodGhpcywgYXJncylcclxuICAgICAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEZ1bmN0aW9uICR7bWV0aG9kfSBkb2VzIG5vdCBleGlzdCB3aXRoaW4gZmVhdHVyZSAke2ZlYXR1cmV9YClcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gY2F0Y2goZSkge31cclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICByZXR1cm4gU1NNTFNwZWVjaE1hcmtNaXhpbjtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFNTTUxTcGVlY2htYXJrSW50ZXJmYWNlO1xyXG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXHJcbmltcG9ydCBNYW5hZ2VkQW5pbWF0aW9uTGF5ZXJJbnRlcmZhY2UgZnJvbSAnLi9hbmltcGFjay9NYW5hZ2VkQW5pbWF0aW9uTGF5ZXJJbnRlcmZhY2UnO1xyXG5pbXBvcnQgU1NNTFNwZWVjaG1hcmtJbnRlcmZhY2UgZnJvbSAnLi9hd3NwYWNrL1NTTUxTcGVlY2htYXJrSW50ZXJmYWNlJztcclxuaW1wb3J0IEFic3RyYWN0SG9zdEZlYXR1cmUgZnJvbSAnLi9BYnN0cmFjdEhvc3RGZWF0dXJlJztcclxuaW1wb3J0IERlZmVycmVkIGZyb20gJy4vRGVmZXJyZWQnO1xyXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi9VdGlscyc7XHJcblxyXG5jb25zdCBEZWZhdWx0R2VzdHVyZVdvcmRzID0ge1xyXG4gIGJpZzogW1xyXG4gICAgJ2FkZCcsXHJcbiAgICAnYWJvdmUnLFxyXG4gICAgJ2F1dGhvcml0eScsXHJcbiAgICAnYmlnJyxcclxuICAgICdjb3ZlcicsXHJcbiAgICAnZnVsbCcsXHJcbiAgICAnZmx5JyxcclxuICAgICdncm93JyxcclxuICAgICdncm93dGgnLFxyXG4gICAgJ2hpZ2gnLFxyXG4gICAgJ2h1Z2UnLFxyXG4gICAgJ2luY3JlYXNlJyxcclxuICAgICdtYWpvcicsXHJcbiAgICAnbWFqb3JpdHknLFxyXG4gICAgJ2xhcmdlJyxcclxuICAgICdsZWFkZXInLFxyXG4gICAgJ2xvdCcsXHJcbiAgICAncmFpc2UnLFxyXG4gICAgJ3Jpc2UnLFxyXG4gICAgJ3RhbGwnLFxyXG4gIF0sXHJcbiAgaGVhcnQ6IFtcclxuICAgICdhY2NlcHQnLFxyXG4gICAgJ2FkbWl0JyxcclxuICAgICdiZWxpZXZlJyxcclxuICAgICdjYXJlJyxcclxuICAgICdmZWVsaW5nJyxcclxuICAgICdmZWVsJyxcclxuICAgICdmcmllbmQnLFxyXG4gICAgJ2dyYXRlZnVsJyxcclxuICAgICdoYXBweScsXHJcbiAgICAnaGVhcnQnLFxyXG4gICAgJ2h1bWFuJyxcclxuICAgICdwYWluJyxcclxuICAgICdzYXZlJyxcclxuICAgICdzYWZlJyxcclxuICAgICdraW5kJyxcclxuICAgICdsb3ZlJyxcclxuICBdLFxyXG4gIGluOiBbXHJcbiAgICAnaW5jbHVkZScsXHJcbiAgICAnaW5jbHVkaW5nJyxcclxuICAgICdpbnNpZGUnLFxyXG4gICAgJ2ludG8nLFxyXG4gICAgJ25vdycsXHJcbiAgICAnbmVhcicsXHJcbiAgICAnbmVhcmVzdCcsXHJcbiAgICAnY2xvc2VzdCcsXHJcbiAgICAndGhlcmVpbicsXHJcbiAgICAnd2l0aGluJyxcclxuICBdLFxyXG4gIG1hbnk6IFtcclxuICAgICdhbGwnLFxyXG4gICAgJ2Fsd2F5cycsXHJcbiAgICAnYW55JyxcclxuICAgICdhbnlvbmUnLFxyXG4gICAgJ2Ftb25nJyxcclxuICAgICdhcmVhJyxcclxuICAgICdhcm91bmQnLFxyXG4gICAgJ2JlYXV0aWZ1bCcsXHJcbiAgICAnZW50aXJlJyxcclxuICAgICdlbnZpcm9ubWVudCcsXHJcbiAgICAnZW52aXJvbm1lbnRzJyxcclxuICAgICdlbnZpcm9ubWVudGFsJyxcclxuICAgICdldmVyeWJvZHknLFxyXG4gICAgJ2V2ZXJ5b25lJyxcclxuICAgICdldmVyeXRoaW5nJyxcclxuICAgICdhdWRpZW5jZScsXHJcbiAgICAndG90YWwnLFxyXG4gICAgJ2dyb3VwJyxcclxuICAgICdncm91cHMnLFxyXG4gICAgJ21pbGxpb24nLFxyXG4gICAgJ21pbGxpb25zJyxcclxuICAgICdvdGhlcnMnLFxyXG4gICAgJ2JpbGxpb24nLFxyXG4gICAgJ2JpbGxpb25zJyxcclxuICAgICdodW5kcmVkJyxcclxuICAgICdodW5kcmVkcycsXHJcbiAgICAnbWFueScsXHJcbiAgICAndGhvdXNhbmQnLFxyXG4gICAgJ3Rob3VzYW5kcycsXHJcbiAgICAnd29ybGQnLFxyXG4gICAgJ3dvcmxkcycsXHJcbiAgICAnb3V0c2lkZScsXHJcbiAgICAncmV2ZWFsJyxcclxuICBdLFxyXG4gIG1vdmVtZW50OiBbXHJcbiAgICAnYXdheScsXHJcbiAgICAnYWNyb3NzJyxcclxuICAgICdhaGVhZCcsXHJcbiAgICAnYWxvbmcnLFxyXG4gICAgJ2ZhcicsXHJcbiAgICAnZmFzdCcsXHJcbiAgICAnZm9sbG93JyxcclxuICAgICdnbycsXHJcbiAgICAnbGVhdmUnLFxyXG4gICAgJ21vdmUnLFxyXG4gICAgJ21vdmVtZW50JyxcclxuICAgICd0aHJvdWdoJyxcclxuICAgICd0aHJvdWdob3V0JyxcclxuICAgICd0b3dhcmQnLFxyXG4gICAgJ3RyYXZlbCcsXHJcbiAgICAndHVybmVkJyxcclxuICAgICdwYXNzZWQnLFxyXG4gIF0sXHJcbiAgb25lOiBbXHJcbiAgICAnc2luZ2xlJyxcclxuICAgICdvbmUnLFxyXG4gICAgJ29uY2UnLFxyXG4gICAgJ2ZpcnN0JyxcclxuICAgICdmaXJzdGx5JyxcclxuICAgICdvbmx5JyxcclxuICAgICdzb2xvJyxcclxuICAgICd3YXJuZWQnLFxyXG4gICAgJ3RydWx5JyxcclxuICAgICd1cCcsXHJcbiAgICAnYWxvbmUnLFxyXG4gIF0sXHJcbiAgYWdncmVzc2l2ZTogW1xyXG4gICAgJ3Bvd2VyJyxcclxuICAgICdwb3dlcnMnLFxyXG4gICAgJ3Bvd2VyZnVsJyxcclxuICAgICdhc3NlcnQnLFxyXG4gICAgJ2Fzc2VydGl2ZScsXHJcbiAgICAnc3Ryb25nJyxcclxuICAgICdzdHJvbmdlcicsXHJcbiAgICAnc3Ryb25nZXN0JyxcclxuICAgICdzdHJlbmd0aCcsXHJcbiAgICAnZmxleCcsXHJcbiAgICAnZGFuZycsXHJcbiAgICAnZGFtbicsXHJcbiAgICAnZGFtbml0JyxcclxuICAgICdkYXJuJyxcclxuICAgICdzaHVja3MnLFxyXG4gICAgJ2RvaCcsXHJcbiAgICAnZHJhdCcsXHJcbiAgICAnYW5ncnknLFxyXG4gICAgJ2FuZ3JpZXInLFxyXG4gICAgJ2FuZ3JpZXN0JyxcclxuICAgICdhZ2dyZXNzaXZlJyxcclxuICAgICdhbm5veWVkJyxcclxuICAgICdhbm5veWluZycsXHJcbiAgICAnYXR0YWNrJyxcclxuICAgICdhdHRhY2tpbmcnLFxyXG4gICAgJ29mZmVuc2UnLFxyXG4gICAgJ29mZmVuc2l2ZScsXHJcbiAgICAnYmF0dGxlJyxcclxuICBdLFxyXG4gIHlvdTogWyd5b3UnLCAneWFsbCcsIFwieSdhbGxcIiwgJ3lvdXInLCAneW91cnMnLCAndGhvdScsICd0aHknXSxcclxuICBkZWZlbnNlOiBbXHJcbiAgICAnZGVmZW5zZScsXHJcbiAgICAnZmVhcicsXHJcbiAgICAncmVwdWxzZWQnLFxyXG4gICAgJ3NjYXJlZCcsXHJcbiAgICAnc2NhcnknLFxyXG4gICAgJ3NjYXJpZXInLFxyXG4gICAgJ3NjYXJpZXN0JyxcclxuICAgICdmZWFyZnVsJyxcclxuICAgICdhZnJhaWQnLFxyXG4gICAgJ2Nvd2VyJyxcclxuICAgICdjb3dlcnMnLFxyXG4gICAgJ2Nvd2VyaW5nJyxcclxuICAgICdoaWRlb3VzJyxcclxuICAgICdkb29tZWQnLFxyXG4gICAgJ3RlcnJpZmllZCcsXHJcbiAgICAndGVycmlmeScsXHJcbiAgICAndGVycmlmeWluZycsXHJcbiAgICAndGVycmlmaWVzJyxcclxuICAgICdzcG9va3knLFxyXG4gICAgJ3Nwb29raWVyJyxcclxuICAgICdzcG9va2llc3QnLFxyXG4gIF0sXHJcbiAgd2F2ZTogW1xyXG4gICAgJ2hlbGxvJyxcclxuICAgICdoaScsXHJcbiAgICAnaGl5YScsXHJcbiAgICAnaG93ZHknLFxyXG4gICAgJ3dlbGNvbWUnLFxyXG4gICAgJ2Fsb2hhJyxcclxuICAgICdoZXlhJyxcclxuICAgICdoZXknLFxyXG4gICAgJ2J5ZScsXHJcbiAgICAnZ29vZGJ5ZScsXHJcbiAgICAnaG9sYScsXHJcbiAgICAnYWRpb3MnLFxyXG4gICAgJ2NoYW8nLFxyXG4gIF0sXHJcbiAgc2VsZjogWydteScsICdJJywgJ215c2VsZicsICdzZWxmJywgXCJJJ3ZlXCIsICdJdmUnLCAnbWUnLCAnbWluZScsICdvd24nXSxcclxufTtcclxuXHJcbi8qKlxyXG4gKiBHZXN0dXJlIGFsbG93cyB5b3UgdG8gcGxheSBhbmltYXRpb25zIG9uIGRlbWFuZCBvbiBvbmUgb3IgbW9yZSBsYXllcnMgZnJvbSBzY3JpcHRcclxuICogb3Igc3NtbC4gSWYgZ2VzdHVyZSBpcyBwbGF5ZWQgdGhhdCBpcyBhIFF1ZXVlU3RhdGUsIHRoZSBxdWV1ZSB3aWxsIGF1dG9tYXRpY2FsbHlcclxuICogYmUgcHJvZ3Jlc3NlZCBhZnRlciBhIGdpdmVuIGhvbGQgdGltZSBpZiBhIGxvb3BpbmcgcXVldWVkIHN0YXRlIGlzIHJlYWNoZWQuIEdlc3R1cmVcclxuICogbGF5ZXJzIGNhbiBvcHRpb25hbGx5IGJlIGF1dG9tYXRpY2FsbHkgZGlzYWJsZWQgd2hlbiBubyBnZXN0dXJlIGFuaW1hdGlvbiBpc1xyXG4gKiBpbiBwcm9ncmVzcy5cclxuICpcclxuICogQGV4dGVuZHMgQWJzdHJhY3RIb3N0RmVhdHVyZVxyXG4gKiBAaW1wbGVtZW50cyBTU01MU3BlZWNobWFya0ludGVyZmFjZVxyXG4gKiBAaW1wbGVtZW50cyBNYW5hZ2VkQW5pbWF0aW9uTGF5ZXJJbnRlcmZhY2VcclxuICovXHJcbmNsYXNzIEdlc3R1cmVGZWF0dXJlIGV4dGVuZHMgQWJzdHJhY3RIb3N0RmVhdHVyZS5taXgoXHJcbiAgU1NNTFNwZWVjaG1hcmtJbnRlcmZhY2UuTWl4aW4sXHJcbiAgTWFuYWdlZEFuaW1hdGlvbkxheWVySW50ZXJmYWNlLk1peGluXHJcbikge1xyXG4gIC8qKlxyXG4gICAqIEBjb25zdHJ1Y3RvclxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtjb3JlL0hvc3RPYmplY3R9IGhvc3QgLSBIb3N0IG9iamVjdCB0aGF0IG93bnMgdGhlIGZlYXR1cmUuXHJcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIC0gT3B0aW9uYWwgb3B0aW9ucyBmb3IgdGhlIGZlYXR1cmUuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmhvbGRUaW1lID0gM10gLSBBbW91bnQgb2YgdGltZSBpbiBzZWNvbmRzIHRoYXQgbXVzdFxyXG4gICAqIGVsYXBzZSBiZWZvcmUgYWR2YW5jaW5nIGEgZ2VzdHVyZSB0aGF0J3MgYSB7QGxpbmsgUXVldWVTdGF0ZX0gd2hlbiB0aGUgY3VycmVudFxyXG4gICAqIHN0YXRlIGluIHRoZSBxdWV1ZSBpcyBzZXQgdG8gbG9vcCBpbmZpbml0ZWx5LlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5taW5pbXVtSW50ZXJ2YWwgPSAwLjI1XSAtIFRoZSBtaW5pbXVtIGFtb3VudCBvZiB0aW1lXHJcbiAgICogaW4gc2Vjb25kcyB0aGF0IG11c3QgZWxhcHNlIGJlZm9yZSBhbm90aGVyIGdlc3R1cmUgY2FuIGJlIHBsYXllZC5cclxuICAgKiBAcGFyYW0gIHtPYmplY3R9IGxheWVycyAtIEFuIG9iamVjdCB0aGF0IG1hcHMgbGF5ZXIgbmFtZXMgdG8gbGF5ZXIgb3B0aW9ucy5cclxuICAgKiBUaGVzZSBhcmUgdGhlIGxheWVycyB0aGF0IHdpbGwgYmUgcmVnaXN0ZXJlZCBhcyB0cmFja2VkIGdlc3R1cmUgbGF5ZXJzLiBTZWVcclxuICAgKiB7QGxpbmsgTWFuYWdlZEFuaW1hdGlvbkxheWVySW50ZXJmYWNlI3JlZ2lzdGVyTGF5ZXJ9IGZvciBtb3JlIGluZm9ybWF0aW9uXHJcbiAgICogb24gZXhwZWN0ZWQgZm9ybWF0IGZvciBlYWNoIGxheWVyIG9wdGlvbnMgb2JqZWN0LlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGhvc3QsIHtob2xkVGltZSA9IDMsIG1pbmltdW1JbnRlcnZhbCA9IDEsIGxheWVycyA9IHt9fSA9IHt9KSB7XHJcbiAgICBzdXBlcihob3N0KTtcclxuXHJcbiAgICB0aGlzLmhvbGRUaW1lID0gaG9sZFRpbWU7XHJcbiAgICB0aGlzLm1pbmltdW1JbnRlcnZhbCA9IG1pbmltdW1JbnRlcnZhbDtcclxuXHJcbiAgICAvLyBSZWdpc3RlciB0aGUgZ2VzdHVyZSBsYXllcnNcclxuICAgIE9iamVjdC5lbnRyaWVzKGxheWVycykuZm9yRWFjaCgoW25hbWUsIG9wdGlvbnMgPSB7fV0pID0+IHtcclxuICAgICAgdGhpcy5yZWdpc3RlckxheWVyKG5hbWUsIG9wdGlvbnMpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gYSB2YWxpZCBob2xkIHRpbWUgdmFsdWUuIElmIGhvbGQgdGltZSBpc24ndCBkZWZpbmVkIGZvciB0aGUgYW5pbWF0aW9uLFxyXG4gICAqIHRyeSB0byB1c2UgdGhlIGhvbGQgdGltZSBmb3IgdGhlIGxheWVyLiBJZiB0aGF0J3Mgbm90IGRlZmluZWQsIGZhbGwgYmFjayB0b1xyXG4gICAqIHRoZSBob2xkIHRpbWUgZm9yIHRoZSBmZWF0dXJlLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsYXllciAtIE1hbmFnZWQgbGF5ZXIgb3B0aW9ucyBvYmplY3QuXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGFuaW1hdGlvbiAtIE1hbmFnZWQgYW5pbWF0aW9uIG9wdGlvbnMgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cclxuICBfZ2V0SG9sZFRpbWUobGF5ZXIsIGFuaW1hdGlvbikge1xyXG4gICAgY29uc3QgbGF5ZXJIb2xkVGltZSA9XHJcbiAgICAgIGxheWVyLmhvbGRUaW1lICE9PSB1bmRlZmluZWQgPyBsYXllci5ob2xkVGltZSA6IHRoaXMuaG9sZFRpbWU7XHJcblxyXG4gICAgcmV0dXJuIGFuaW1hdGlvbi5ob2xkVGltZSAhPT0gdW5kZWZpbmVkXHJcbiAgICAgID8gYW5pbWF0aW9uLmhvbGRUaW1lXHJcbiAgICAgIDogbGF5ZXJIb2xkVGltZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiBhIHZhbGlkIG1pbmltdW0gaW50ZXJ2YWwgdmFsdWUuIElmIG1pbmltdW0gaW50ZXJ2YWwgaXNuJ3QgZGVmaW5lZCBmb3JcclxuICAgKiB0aGUgYW5pbWF0aW9uLCB0cnkgdG8gdXNlIHRoZSBtaW5pbXVtIGludGVydmFsIGZvciB0aGUgbGF5ZXIuIElmIHRoYXQncyBub3RcclxuICAgKiBkZWZpbmVkLCBmYWxsIGJhY2sgdG8gdGhlIG1pbmltdW0gaW50ZXJ2YWwgZm9yIHRoZSBmZWF0dXJlLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBsYXllciAtIE1hbmFnZWQgbGF5ZXIgb3B0aW9ucyBvYmplY3QuXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGFuaW1hdGlvbiAtIE1hbmFnZWQgYW5pbWF0aW9uIG9wdGlvbnMgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cclxuICBfZ2V0TWluaW11bUludGVydmFsKGxheWVyLCBhbmltYXRpb24pIHtcclxuICAgIGNvbnN0IGxheWVyTWluaW11bUludGVydmFsID1cclxuICAgICAgbGF5ZXIubWluaW11bUludGVydmFsICE9PSB1bmRlZmluZWRcclxuICAgICAgICA/IGxheWVyLm1pbmltdW1JbnRlcnZhbFxyXG4gICAgICAgIDogdGhpcy5taW5pbXVtSW50ZXJ2YWw7XHJcblxyXG4gICAgcmV0dXJuIGFuaW1hdGlvbi5taW5pbXVtSW50ZXJ2YWwgIT09IHVuZGVmaW5lZFxyXG4gICAgICA/IGFuaW1hdGlvbi5taW5pbXVtSW50ZXJ2YWxcclxuICAgICAgOiBsYXllck1pbmltdW1JbnRlcnZhbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbGxiYWNrIGZvciB7QGxpbmsgY29yZS9BbmltYXRpb25GZWF0dXJlI3BsYXlOZXh0QW5pbWF0aW9ufSBldmVudC4gSWYgdGhlXHJcbiAgICogZXZlbnQgaXMgZW1pdHRlZCBmb3IgYSBtYW5hZ2VkIGFuaW1hdGlvbiBhbmQgdGhlIG5ldyBxdWV1ZWQgc3RhdGUgY2Fubm90XHJcbiAgICogYWR2YW5jZSBvbiBpdHMgb3duLCBzdGFydCBhIG5ldyB0aW1lciBwcm9taXNlIHRoYXQgd2lsbCBhZHZhbmNlIHRoZSBxdWV1ZVxyXG4gICAqIG9uY2UgaXQgcmVzb2x2ZXMuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIG9iamVjdCBwYXNzZWQgZnJvbSBwbGF5TmV4dEFuaW1hdGlvbiBldmVudC5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdGhhdCBvd25zIHRoZSBxdWV1ZSBzdGF0ZS5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gYW5pbWF0aW9uTmFtZSAtIE5hbWUgb2YgdGhlIHF1ZXVlIHN0YXRlIGFuaW1hdGlvbi5cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IGNhbkFkdmFuY2UgLSBXaGV0aGVyIG9yIG5vdCB0aGUgY3VycmVudCBzdGF0ZSBpbiB0aGUgcXVldWVcclxuICAgKiBjYW4gYWR2YW5jZSBvbiBpdHMgb3duLlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gaXNRdWV1ZUVuZCAtIFdoZXRoZXIgdGhlIGN1cnJlbnQgc3RhdGUgaW4gdGhlIHF1ZXVlIGlzIHRoZSBsYXN0XHJcbiAgICogc3RhdGUgaW4gdGhlIHF1ZXVlLlxyXG4gICAqL1xyXG4gIF9vbk5leHQoe2xheWVyTmFtZSwgYW5pbWF0aW9uTmFtZSwgY2FuQWR2YW5jZSwgaXNRdWV1ZUVuZH0pIHtcclxuICAgIC8vIEV4aXQgaWYgdGhpcyBpc24ndCBhIG1hbmFnZWQgbGF5ZXJcclxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdO1xyXG4gICAgaWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEV4aXQgaWYgaXQgaXNuJ3QgYSBtYW5hZ2VkIGFuaW1hdGlvblxyXG4gICAgY29uc3QgYW5pbWF0aW9uID0gbGF5ZXIuYW5pbWF0aW9uc1thbmltYXRpb25OYW1lXTtcclxuICAgIGlmIChhbmltYXRpb24gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU3RhcnQgYSBuZXcgdGltZXIgZm9yIGxvb3Bpbmcgc3RhdGVzIHRoYXQgYXJlbid0IHRoZSBlbmQgb2YgdGhlIHF1ZXVlXHJcbiAgICBpZiAoIWNhbkFkdmFuY2UgJiYgIWlzUXVldWVFbmQgJiYgbGF5ZXIuY3VycmVudEdlc3R1cmUgPT09IGFuaW1hdGlvbk5hbWUpIHtcclxuICAgICAgY29uc3QgaG9sZFRpbWUgPSB0aGlzLl9nZXRIb2xkVGltZShsYXllciwgYW5pbWF0aW9uKTtcclxuICAgICAgbGF5ZXIuaG9sZFRpbWVyLmNhbmNlbCgpO1xyXG5cclxuICAgICAgLy8gU2tpcCB0byB0aGUgbmV4dCBhbmltYXRpb24gcmlnaHQgYXdheSBpZiBob2xkIHRpbWUgaXMgemVyb1xyXG4gICAgICBpZiAoaG9sZFRpbWUgPD0gMCkge1xyXG4gICAgICAgIHRoaXMuX2hvc3QuQW5pbWF0aW9uRmVhdHVyZS5wbGF5TmV4dEFuaW1hdGlvbihsYXllck5hbWUsIGFuaW1hdGlvbk5hbWUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBXYWl0IGZvciB0aGUgZ2l2ZW4gaG9sZCB0aW1lIGJlZm9yZSBwcm9ncmVzc2luZ1xyXG4gICAgICBlbHNlIHtcclxuICAgICAgICBsYXllci5ob2xkVGltZXIgPSBVdGlscy53YWl0KGhvbGRUaW1lLCB7XHJcbiAgICAgICAgICBvbkZpbmlzaDogKCkgPT4ge1xyXG4gICAgICAgICAgICAvLyBBZHZhbmNlIHRoZSBxdWV1ZSB0byB0aGUgbmV4dCBzdGF0ZVxyXG4gICAgICAgICAgICBpZiAobGF5ZXIuY3VycmVudEdlc3R1cmUgPT09IGFuaW1hdGlvbk5hbWUpIHtcclxuICAgICAgICAgICAgICB0aGlzLl9ob3N0LkFuaW1hdGlvbkZlYXR1cmUucGxheU5leHRBbmltYXRpb24oXHJcbiAgICAgICAgICAgICAgICBsYXllck5hbWUsXHJcbiAgICAgICAgICAgICAgICBhbmltYXRpb25OYW1lXHJcbiAgICAgICAgICAgICAgKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSxcclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FsbGJhY2sgZm9yIHtAbGluayBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjc3RvcEFuaW1hdGlvbn0gZXZlbnQuIElmIHRoZVxyXG4gICAqIGV2ZW50IGlzIGVtaXR0ZWQgZm9yIGEgbWFuYWdlZCBhbmltYXRpb24gY2FuY2VsIHRoZSBsYXllcidzIHN0b3JlZCB0aW1lcnMuXHJcbiAgICogSWYgdGhlIGxheWVyIGlzIHNldCB0byBhdXRvLWRpc2FibGUgc2V0IGl0cyB3ZWlnaHQgdG8gMC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgb2JqZWN0IHBhc3NlZCBmcm9tIHBsYXlOZXh0QW5pbWF0aW9uIGV2ZW50LlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllck5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0aGF0IG93bnMgdGhlIHN0b3BwZWQgYW5pbWF0aW9uLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhbmltYXRpb25OYW1lIC0gTmFtZSBvZiB0aGUgYW5pbWF0aW9uIHRoYXQgd2FzIHN0b3BwZWQuXHJcbiAgICovXHJcbiAgX29uU3RvcCh7bGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lfSkge1xyXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBsYXllciBpcyBtYW5hZ2VkXHJcbiAgICBjb25zdCBsYXllciA9IHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXTtcclxuICAgIGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBNYWtlIHN1cmUgdGhlIGFuaW1hdGlvbiBpcyBtYW5hZ2VkXHJcbiAgICBjb25zdCBhbmltYXRpb24gPSBsYXllci5hbmltYXRpb25zW2FuaW1hdGlvbk5hbWVdO1xyXG4gICAgaWYgKGFuaW1hdGlvbiAhPT0gdW5kZWZpbmVkICYmIGFuaW1hdGlvbk5hbWUgPT09IGxheWVyLmN1cnJlbnRHZXN0dXJlKSB7XHJcbiAgICAgIGxheWVyLmN1cnJlbnRHZXN0dXJlID0gbnVsbDtcclxuICAgICAgbGF5ZXIucGxheVRpbWVyID0gbnVsbDtcclxuICAgICAgbGF5ZXIuaG9sZFRpbWVyLmNhbmNlbCgpO1xyXG5cclxuICAgICAgLy8gVHVybiBvZmYgbGF5ZXIgd2VpZ2h0XHJcbiAgICAgIGlmIChsYXllci5hdXRvRGlzYWJsZSkge1xyXG4gICAgICAgIHRoaXMuc2V0TGF5ZXJXZWlnaHRzKG5hbWUgPT4gbmFtZSA9PT0gbGF5ZXJOYW1lLCAwKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX29uQW5pbWF0aW9uQWRkZWQoe2xheWVyTmFtZSwgYW5pbWF0aW9uTmFtZX0pIHtcclxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdO1xyXG5cclxuICAgIGlmIChsYXllciAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGNvbnN0IGFuaW1hdGlvbiA9IGxheWVyLmFuaW1hdGlvbnNbYW5pbWF0aW9uTmFtZV07XHJcblxyXG4gICAgICAvLyBSZWdpc3RlciB0aGUgYW5pbWF0aW9uIGFzIGFjdGl2ZSBpZiBpdCBpcyB1bm1hbmFnZWRcclxuICAgICAgaWYgKGFuaW1hdGlvbiA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgdGhpcy5yZWdpc3RlckFuaW1hdGlvbihsYXllck5hbWUsIGFuaW1hdGlvbk5hbWUpO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIE1hcmsgdGhlIGFuaW1hdGlvbiBhcyBhY3RpdmUgaWYgaXQgaXMgbWFuYWdlZFxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICBhbmltYXRpb24uaXNBY3RpdmUgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZWdpc3RlckxheWVyKG5hbWUsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3VwZXIucmVnaXN0ZXJMYXllcihuYW1lLCB7XHJcbiAgICAgIC4uLm9wdGlvbnMsXHJcbiAgICAgIGhvbGRUaW1lcjogRGVmZXJyZWQucmVzb2x2ZSgpLFxyXG4gICAgICBwbGF5VGltZXI6IG51bGwsXHJcbiAgICAgIGN1cnJlbnRHZXN0dXJlOiBudWxsLFxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKHRoaXMuX21hbmFnZWRMYXllcnNbbmFtZV0uaXNBY3RpdmUpIHtcclxuICAgICAgdGhpcy5faG9zdC5BbmltYXRpb25GZWF0dXJlLmdldEFuaW1hdGlvbnMobmFtZSkuZm9yRWFjaChhbmltID0+IHtcclxuICAgICAgICAvLyBBdXRvbWF0aWNhbGx5IHJlZ2lzdGVyIGFsbCBhbmltYXRpb25zIG9uIHRoZSBsYXllclxyXG4gICAgICAgIGlmICh0aGlzLl9tYW5hZ2VkTGF5ZXJzW25hbWVdLmFuaW1hdGlvbnNbYW5pbV0gPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgdGhpcy5yZWdpc3RlckFuaW1hdGlvbihcclxuICAgICAgICAgICAgbmFtZSxcclxuICAgICAgICAgICAgYW5pbSxcclxuICAgICAgICAgICAgdGhpcy5fbWFuYWdlZExheWVyc1tuYW1lXS5hbmltYXRpb25zW2FuaW1dXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICByZWdpc3RlckFuaW1hdGlvbihsYXllck5hbWUsIGFuaW1hdGlvbk5hbWUsIG9wdGlvbnMgPSB7fSkge1xyXG4gICAgLy8gVHJ5IHRvIGZhbGwgYmFjayB0byBhIGRlZmF1bHQgd29yZCBhcnJheVxyXG4gICAgaWYgKCEob3B0aW9ucy53b3JkcyBpbnN0YW5jZW9mIEFycmF5KSAmJiAhKG9wdGlvbnMud29yZHMgaW5zdGFuY2VvZiBTZXQpKSB7XHJcbiAgICAgIG9wdGlvbnMud29yZHMgPSBEZWZhdWx0R2VzdHVyZVdvcmRzW2FuaW1hdGlvbk5hbWVdIHx8IFtdO1xyXG4gICAgfVxyXG5cclxuICAgIHN1cGVyLnJlZ2lzdGVyQW5pbWF0aW9uKGxheWVyTmFtZSwgYW5pbWF0aW9uTmFtZSwgb3B0aW9ucyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgYW4gb2JqZWN0IHRoYXQgbWFwcyBzc21sIG1hcmsgc3ludGF4IHJlcXVpcmVkIHRvIHBsYXkgZWFjaCBnZXN0dXJlIHRvXHJcbiAgICogdGhlIHdvcmRzIGFycmF5IGFzc29jaWF0ZWQgd2l0aCBlYWNoIGdlc3R1cmUuIFdvcmRzIGFycmF5cyBhcmUgZGVmaW5lZCBhdCB3aGVuXHJcbiAgICogdGhlIGdlc3R1cmUgYW5pbWF0aW9uIGlzIHJlZ2lzdGVyZWQuIEdlc3R1cmVzIHdpdGhvdXQgYXNzb2NpYXRlZCB3b3JkcyB3aWxsXHJcbiAgICogYmUgZXhjbHVkZWQgZnJvbSB0aGUgcmVzdWx0LiBUaGUgcmVzdWx0aW5nIG9iamVjdCBjYW4gYmUgdXNlZCBhcyBhbiBpbnB1dFxyXG4gICAqIGZvciB7QGxpbmsgVGV4dFRvU3BlZWNoVXRpbHMuYXV0b0dlbmVyYXRlU1NNTE1hcmtzfSB0byB1cGRhdGUgYSBzcGVlY2ggc3RyaW5nXHJcbiAgICogd2l0aCB0aGUgbWFya3VwIHJlcXVpcmVkIHRvIHBsYXkgZ2VzdHVyZXMgdGltZWQgd2l0aCB0aGVpciBhc3NvY2lhdGVkIHdvcmRzLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge09iamVjdH1cclxuICAgKi9cclxuICBjcmVhdGVHZXN0dXJlTWFwKCkge1xyXG4gICAgY29uc3QgZ2VzdHVyZU1hcCA9IHt9O1xyXG5cclxuICAgIE9iamVjdC5lbnRyaWVzKHRoaXMuX21hbmFnZWRMYXllcnMpLmZvckVhY2goKFtsYXllck5hbWUsIHthbmltYXRpb25zfV0pID0+IHtcclxuICAgICAgT2JqZWN0LmVudHJpZXMoYW5pbWF0aW9ucykuZm9yRWFjaChcclxuICAgICAgICAoW1xyXG4gICAgICAgICAgYW5pbWF0aW9uTmFtZSxcclxuICAgICAgICAgIHtob2xkVGltZSwgbWluaW11bUludGVydmFsLCB3b3JkcywgdHJhbnNpdGlvblRpbWV9LFxyXG4gICAgICAgIF0pID0+IHtcclxuICAgICAgICAgIC8vIE9ubHkgc3RvcmUgZ2VzdHVyZXMgdGhhdCBoYXZlIGFueSBhc3NvY2lhdGVkIHdvcmRzXHJcbiAgICAgICAgICBpZiAod29yZHMubGVuZ3RoKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IG9wdGlvbnMgPSB7XHJcbiAgICAgICAgICAgICAgLi4uKGhvbGRUaW1lICYmIHsgaG9sZFRpbWUgfSksXHJcbiAgICAgICAgICAgICAgLi4uKG1pbmltdW1JbnRlcnZhbCAmJiB7IG1pbmltdW1JbnRlcnZhbCB9KSxcclxuICAgICAgICAgICAgICAuLi4odHJhbnNpdGlvblRpbWUgJiYgeyB0cmFuc2l0aW9uVGltZSB9KSxcclxuICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgY29uc3Qga2V5ID0ge1xyXG4gICAgICAgICAgICAgIGZlYXR1cmU6IHRoaXMuY29uc3RydWN0b3IubmFtZSxcclxuICAgICAgICAgICAgICBtZXRob2Q6ICdwbGF5R2VzdHVyZScsXHJcbiAgICAgICAgICAgICAgYXJnczogW2xheWVyTmFtZSwgYW5pbWF0aW9uTmFtZSwgb3B0aW9uc10sXHJcbiAgICAgICAgICAgIH07XHJcblxyXG4gICAgICAgICAgICBnZXN0dXJlTWFwW0pTT04uc3RyaW5naWZ5KGtleSldID0gd29yZHM7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGdlc3R1cmVNYXA7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgYW4gYXJyYXkgdGhhdCBjb250YWlucyBzc21sIG1hcmsgc3ludGF4IHJlcXVpcmVkIHRvIHBsYXkgZWFjaCBnZXN0dXJlXHJcbiAgICogdGhhdCBkb2VzIG5vdCBoYXZlIGFueSBhc3NvY2lhdGVkIHdvcmRzLiBUaGUgcmVzdWx0aW5nIGFycmF5IGNhbiBiZSB1c2VkIGFzXHJcbiAgICogYW4gaW5wdXQgZm9yIHtAbGluayBUZXh0VG9TcGVlY2hVdGlscy5hdXRvR2VuZXJhdGVTU01MTWFya3N9IG9yXHJcbiAgICoge0BsaW5rIFRleHRUb1NwZWVjaFV0aWxzLmFkZE1hcmtzVG9Vbm1hcmtlZFNlbnRlbmNlc30gdG8gdXBkYXRlIGEgc3BlZWNoXHJcbiAgICogc3RyaW5nIHdpdGggdGhlIG1hcmt1cCByZXF1aXJlZCB0byBwbGF5IHJhbmRvbSBnZXN0dXJlcyBhdCBlYWNoIHVubWFya2VkXHJcbiAgICogc2VudGVuY2UgaW4gdGhlIHN0cmluZy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz49fSBsYXllcnMgLSBBbiBhcnJheSBvZiBuYW1lcyBvZiBtYW5hZ2VkIGxheWVycyB0byBnZW5lcmF0ZVxyXG4gICAqIG1hcmtzIGZvci4gSWYgdW5kZWZpbmVkLCB1c2UgYWxsIG1hbmFnZWQgbGF5ZXJzLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0FycmF5LjxzdHJpbmc+fVxyXG4gICAqL1xyXG4gIGNyZWF0ZUdlbmVyaWNHZXN0dXJlQXJyYXkobGF5ZXJzKSB7XHJcbiAgICBjb25zdCBnZW5lcmljR2VzdHVyZXMgPSBbXTtcclxuICAgIGxheWVycyA9IGxheWVycyB8fCBPYmplY3Qua2V5cyh0aGlzLl9tYW5hZ2VkTGF5ZXJzKTtcclxuXHJcbiAgICBsYXllcnMuZm9yRWFjaChsYXllck5hbWUgPT4ge1xyXG4gICAgICBjb25zdCBsYXllciA9IHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXTtcclxuXHJcbiAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgbGF5ZXIgaXMgbWFuYWdlZFxyXG4gICAgICBpZiAoIWxheWVyKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBPYmplY3QuZW50cmllcyhsYXllci5hbmltYXRpb25zKS5mb3JFYWNoKFxyXG4gICAgICAgIChbXHJcbiAgICAgICAgICBhbmltYXRpb25OYW1lLFxyXG4gICAgICAgICAgeyBob2xkVGltZSwgbWluaW11bUludGVydmFsLCB3b3JkcywgdHJhbnNpdGlvblRpbWUgfSxcclxuICAgICAgICBdKSA9PiB7XHJcbiAgICAgICAgICAvLyBPbmx5IHN0b3JlIGdlc3R1cmVzIHRoYXQgZG9uJ3QgaGF2ZSBhbnkgYXNzb2NpYXRlZCB3b3Jkc1xyXG4gICAgICAgICAgaWYgKCF3b3Jkcy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcclxuICAgICAgICAgICAgICAuLi4oaG9sZFRpbWUgJiYgeyBob2xkVGltZSB9KSxcclxuICAgICAgICAgICAgICAuLi4obWluaW11bUludGVydmFsICYmIHsgbWluaW11bUludGVydmFsIH0pLFxyXG4gICAgICAgICAgICAgIC4uLih0cmFuc2l0aW9uVGltZSAmJiB7IHRyYW5zaXRpb25UaW1lIH0pLFxyXG4gICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICBjb25zdCBrZXkgPSBKU09OLnN0cmluZ2lmeSh7XHJcbiAgICAgICAgICAgICAgZmVhdHVyZTogdGhpcy5jb25zdHJ1Y3Rvci5uYW1lLFxyXG4gICAgICAgICAgICAgIG1ldGhvZDogJ3BsYXlHZXN0dXJlJyxcclxuICAgICAgICAgICAgICBhcmdzOiBbbGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lLCBvcHRpb25zXSxcclxuICAgICAgICAgICAgfSk7XHJcblxyXG4gICAgICAgICAgICBpZiAoIWdlbmVyaWNHZXN0dXJlcy5pbmNsdWRlcyhrZXkpKSB7XHJcbiAgICAgICAgICAgICAgZ2VuZXJpY0dlc3R1cmVzLnB1c2goa2V5KTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgKTtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBnZW5lcmljR2VzdHVyZXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQbGF5IGEgbWFuYWdlZCBnZXN0dXJlIGFuaW1hdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllck5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgbGF5ZXIgdGhhdCBjb250YWlucyB0aGUgZ2VzdHVyZVxyXG4gICAqIGFuaW1hdGlvbi5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gYW5pbWF0aW9uTmFtZSAtIFRoZSBuYW1lIG9mIHRoZSBnZXN0dXJlIGFuaW1hdGlvbi5cclxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgLSBPcHRpb25hbCBnZXN0dXJlIG9wdGlvbnMuXHJcbiAgICogQHBhcmFtIHtudW1iZXI9fSBvcHRpb25zLmhvbGRUaW1lIC0gVGhpcyBvcHRpb24gb25seSBhcHBsaWVzIHRvIHtAbGluayBRdWV1ZVN0YXRlfVxyXG4gICAqIGdlc3R1cmVzLiBXaGVuIGEgUXVldWVTdGF0ZSBnZXN0dXJlIHByb2dyZXNzZXMgdG8gYSBsb29waW5nIHN0YXRlLCB0aGlzIG9wdGlvblxyXG4gICAqIGRlZmluZXMgaG93IG1hbnkgc2Vjb25kcyBzaG91bGQgZWxhcHNlIGJlZm9yZSBtb3ZpbmcgdGhlIHF1ZXVlIGZvcndhcmQuIElmXHJcbiAgICogdW5kZWZpbmVkLCBpdCB3aWxsIGZhbGwgYmFjayBmaXJzdCB0byB0aGUgaG9sZFRpbWUgZGVmaW5lZCBpbiB0aGUgb3B0aW9ucyB3aGVuXHJcbiAgICogdGhlIGdlc3R1cmUgYW5pbWF0aW9uIHdhcyByZWdpc3RlcmVkIGFuZCB0aGVuIHRvIHRoZSBob2xkVGltZSBkZWZpbmVkIG9uIHRoZVxyXG4gICAqIGZlYXR1cmUuXHJcbiAgICogQHBhcmFtIHtudW1iZXI9fSBvcHRpb25zLm1pbmltdW1JbnRlcnZhbCAtIFRoZSBtaW5pbXVtIGFtb3VudCBvZiB0aW1lIHRoYXRcclxuICAgKiBtdXN0IGhhdmUgZWxhcHNlZCBzaW5jZSB0aGUgbGFzdCB0aW1lIGEgZ2VzdHVyZSB3YXMgcGxheWVkLlxyXG4gICAqL1xyXG4gIHBsYXlHZXN0dXJlKFxyXG4gICAgbGF5ZXJOYW1lLFxyXG4gICAgYW5pbWF0aW9uTmFtZSxcclxuICAgIHtob2xkVGltZSwgbWluaW11bUludGVydmFsLCB0cmFuc2l0aW9uVGltZSwgZm9yY2UgPSBmYWxzZX0gPSB7fVxyXG4gICkge1xyXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBhbmltYXRpb24gaXMgcmVnaXN0ZXJlZFxyXG4gICAgaWYgKFxyXG4gICAgICB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV0gPT09IHVuZGVmaW5lZCB8fFxyXG4gICAgICB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV0uYW5pbWF0aW9uc1thbmltYXRpb25OYW1lXSA9PT0gdW5kZWZpbmVkXHJcbiAgICApIHtcclxuICAgICAgdGhpcy5yZWdpc3RlckFuaW1hdGlvbihsYXllck5hbWUsIGFuaW1hdGlvbk5hbWUsIHtcclxuICAgICAgICBob2xkVGltZSxcclxuICAgICAgICBtaW5pbXVtSW50ZXJ2YWwsXHJcbiAgICAgICAgdHJhbnNpdGlvblRpbWUsXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdO1xyXG4gICAgY29uc3QgYW5pbWF0aW9uID0gbGF5ZXIuYW5pbWF0aW9uc1thbmltYXRpb25OYW1lXTtcclxuXHJcbiAgICAvLyBNYWtlIHN1cmUgdGhlIGFuaW1hdGlvbiBpcyBhY3RpdmVcclxuICAgIGlmICghYW5pbWF0aW9uLmlzQWN0aXZlKSB7XHJcbiAgICAgIC8vIENyZWF0ZSB3YXJuaW5nIG1lc3NhZ2UgYmFzZWQgb24gd2hpY2ggb2JqZWN0IGRvZXNuJ3QgZXhpc3QgeWV0XHJcbiAgICAgIGNvbnN0IHR5cGVOYW1lID0gbGF5ZXIuaXNBY3RpdmUgPyAnYW5pbWF0aW9uJyA6ICdsYXllcic7XHJcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgU2tpcHBpbmcgZ2VzdHVyZSAke2FuaW1hdGlvbk5hbWV9IG9uIGxheWVyICR7bGF5ZXJOYW1lfSBmb3IgaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBObyAke3R5cGVOYW1lfSBleGlzdHMgd2l0aCB0aGlzIG5hbWUgeWV0LmA7XHJcblxyXG4gICAgICBjb25zb2xlLndhcm4obWVzc2FnZSk7XHJcbiAgICAgIHJldHVybiBEZWZlcnJlZC5jYW5jZWwoe3JlYXNvbjogJ2luYWN0aXZlJywgdmFsdWU6IHR5cGVOYW1lfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ2hlY2sgaWYgdGhlIGdlc3R1cmUgaXMgYWxyZWFkeSBwbGF5aW5nXHJcbiAgICBjb25zdCB7Y3VycmVudEdlc3R1cmV9ID0gbGF5ZXI7XHJcbiAgICBpZiAoY3VycmVudEdlc3R1cmUgPT09IGFuaW1hdGlvbk5hbWUgJiYgIWZvcmNlKSB7XHJcbiAgICAgIGNvbnN0IG1lc3NhZ2UgPSBgU2tpcHBpbmcgZ2VzdHVyZSAke2FuaW1hdGlvbk5hbWV9IG9uIGxheWVyICR7bGF5ZXJOYW1lfSBmb3IgaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBUaGUgZ2VzdHVyZSBpcyBhbHJlYWR5IHBsYXlpbmcuIFVzZSBvcHRpb25zLmZvcmNlIHRvIGZvcmNlIHRoZSBnZXN0dXJlIHJlcGxheSwgd2hpY2ggbWF5IHJlc3VsdCBpbiBhIGhhcmQgdHJhbnNpdGlvbi5gO1xyXG5cclxuICAgICAgY29uc29sZS53YXJuKG1lc3NhZ2UpO1xyXG4gICAgICByZXR1cm4gRGVmZXJyZWQuY2FuY2VsKHtyZWFzb246ICdwbGF5aW5nJywgdmFsdWU6IGFuaW1hdGlvbk5hbWV9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBVcGRhdGUgYW5pbWF0aW9uIG9wdGlvbnNcclxuICAgIGlmIChob2xkVGltZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGFuaW1hdGlvbi5ob2xkVGltZSA9IGhvbGRUaW1lO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChtaW5pbXVtSW50ZXJ2YWwgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBhbmltYXRpb24ubWluaW11bUludGVydmFsID0gbWluaW11bUludGVydmFsO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgbWluaW11bUludGVydmFsID0gdGhpcy5fZ2V0TWluaW11bUludGVydmFsKGxheWVyLCBhbmltYXRpb24pO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENoZWNrIHRoZSBpbnRlcnZhbFxyXG4gICAgaWYgKCFmb3JjZSAmJiBsYXllci5wbGF5VGltZXIgIT09IG51bGwgJiYgbGF5ZXIucGxheVRpbWVyIDwgbWluaW11bUludGVydmFsKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICBgU2tpcHBpbmcgZ2VzdHVyZSAke2FuaW1hdGlvbk5hbWV9IG9uIGxheWVyICR7bGF5ZXJOYW1lfSBmb3IgaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBNaW5pbXVtIGludGVydmFsICR7bWluaW11bUludGVydmFsfSBoYXMgbm90IGJlZW4gbWV0LmBcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIERlZmVycmVkLmNhbmNlbCh7XHJcbiAgICAgICAgcmVhc29uOiAnbWluaW11bUludGVydmFsJyxcclxuICAgICAgICB2YWx1ZTogbWluaW11bUludGVydmFsIC0gbGF5ZXIucGxheVRpbWVyLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBQbGF5IHRoZSBhbmltYXRpb25cclxuICAgIGxheWVyLmN1cnJlbnRHZXN0dXJlID0gYW5pbWF0aW9uTmFtZTtcclxuICAgIGxheWVyLnBsYXlUaW1lciA9IDA7XHJcbiAgICBsYXllci5ob2xkVGltZXIuY2FuY2VsKCk7XHJcbiAgICBpZiAobGF5ZXIuYXV0b0Rpc2FibGUpIHtcclxuICAgICAgdGhpcy5zZXRMYXllcldlaWdodHMobmFtZSA9PiBuYW1lID09PSBsYXllck5hbWUsIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aGlzLl9ob3N0LkFuaW1hdGlvbkZlYXR1cmUucGxheUFuaW1hdGlvbihcclxuICAgICAgbGF5ZXJOYW1lLFxyXG4gICAgICBhbmltYXRpb25OYW1lLFxyXG4gICAgICB0cmFuc2l0aW9uVGltZVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIHVwZGF0ZShkZWx0YVRpbWUpIHtcclxuICAgIHN1cGVyLnVwZGF0ZShkZWx0YVRpbWUpO1xyXG5cclxuICAgIC8vIEluY3JlbWVudCB0aGUgdGltZXJzXHJcbiAgICBPYmplY3QuZW50cmllcyh0aGlzLl9tYW5hZ2VkTGF5ZXJzKS5mb3JFYWNoKChbbmFtZSwgb3B0aW9uc10pID0+IHtcclxuICAgICAgaWYgKG9wdGlvbnMuaXNBY3RpdmUgJiYgIXRoaXMuX2hvc3QuQW5pbWF0aW9uRmVhdHVyZS5nZXRQYXVzZWQobmFtZSkpIHtcclxuICAgICAgICBvcHRpb25zLmhvbGRUaW1lci5leGVjdXRlKGRlbHRhVGltZSk7XHJcblxyXG4gICAgICAgIGlmIChvcHRpb25zLnBsYXlUaW1lciAhPT0gbnVsbCkge1xyXG4gICAgICAgICAgb3B0aW9ucy5wbGF5VGltZXIgKz0gZGVsdGFUaW1lIC8gMTAwMDtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuXHJcbiAgaW5zdGFsbEFwaSgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQGlubmVyXHJcbiAgICAgKiBAbmFtZXNwYWNlIEdlc3R1cmVGZWF0dXJlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IGFwaSA9IHN1cGVyLmluc3RhbGxBcGkoKTtcclxuXHJcbiAgICBPYmplY3QuYXNzaWduKGFwaSwge1xyXG4gICAgICAvKipcclxuICAgICAgICogQG1lbWJlcm9mIEdlc3R1cmVGZWF0dXJlXHJcbiAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAqIEBzZWUgR2VzdHVyZUZlYXR1cmUjY3JlYXRlR2VzdHVyZU1hcFxyXG4gICAgICAgKi9cclxuICAgICAgY3JlYXRlR2VzdHVyZU1hcDogdGhpcy5jcmVhdGVHZXN0dXJlTWFwLmJpbmQodGhpcyksXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbWVtYmVyb2YgR2VzdHVyZUZlYXR1cmVcclxuICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAqIEBtZXRob2RcclxuICAgICAgICogQHNlZSBHZXN0dXJlRmVhdHVyZSNjcmVhdGVHZW5lcmljR2VzdHVyZUFycmF5XHJcbiAgICAgICAqL1xyXG4gICAgICBjcmVhdGVHZW5lcmljR2VzdHVyZUFycmF5OiB0aGlzLmNyZWF0ZUdlbmVyaWNHZXN0dXJlQXJyYXkuYmluZCh0aGlzKSxcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBtZW1iZXJvZiBHZXN0dXJlRmVhdHVyZVxyXG4gICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgKiBAc2VlIEdlc3R1cmVGZWF0dXJlI3BsYXlHZXN0dXJlXHJcbiAgICAgICAqL1xyXG4gICAgICBwbGF5R2VzdHVyZTogdGhpcy5wbGF5R2VzdHVyZS5iaW5kKHRoaXMpLFxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG5PYmplY3QuZGVmaW5lUHJvcGVydGllcyhHZXN0dXJlRmVhdHVyZSwge1xyXG4gIERFRkFVTFRfTEFZRVJfT1BUSU9OUzoge1xyXG4gICAgdmFsdWU6IHtcclxuICAgICAgLi4uR2VzdHVyZUZlYXR1cmUuREVGQVVMVF9MQVlFUl9PUFRJT05TLFxyXG4gICAgICBhdXRvRGlzYWJsZTogdHJ1ZSxcclxuICAgIH0sXHJcbiAgICB3cml0YWJsZTogZmFsc2UsXHJcbiAgfSxcclxuICBFVkVOVF9ERVBFTkRFTkNJRVM6IHtcclxuICAgIHZhbHVlOiB7XHJcbiAgICAgIC4uLkdlc3R1cmVGZWF0dXJlLkVWRU5UX0RFUEVOREVOQ0lFUyxcclxuICAgICAgQW5pbWF0aW9uRmVhdHVyZToge1xyXG4gICAgICAgIC4uLkdlc3R1cmVGZWF0dXJlLkVWRU5UX0RFUEVOREVOQ0lFUy5BbmltYXRpb25GZWF0dXJlLFxyXG4gICAgICAgIHBsYXlOZXh0QW5pbWF0aW9uOiAnX29uTmV4dCcsXHJcbiAgICAgICAgc3RvcEFuaW1hdGlvbjogJ19vblN0b3AnLFxyXG4gICAgICAgIGludGVycnVwdEFuaW1hdGlvbjogJ19vblN0b3AnXHJcbiAgICAgIH0sXHJcbiAgICB9LFxyXG4gIH0sXHJcbn0pO1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgR2VzdHVyZUZlYXR1cmU7XHJcbmV4cG9ydCB7RGVmYXVsdEdlc3R1cmVXb3Jkc307XHJcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcclxuaW1wb3J0IERlZmVycmVkIGZyb20gJ2NvcmUvRGVmZXJyZWQnO1xyXG5pbXBvcnQgVXRpbHMgZnJvbSAnY29yZS9VdGlscyc7XHJcbmltcG9ydCBNYXRoVXRpbHMgZnJvbSAnY29yZS9NYXRoVXRpbHMnO1xyXG5pbXBvcnQge0xpbmVhcn0gZnJvbSAnLi9FYXNpbmcnO1xyXG5cclxuLyoqXHJcbiAqIEEgY29sbGVjdGlvbiBvZiB1c2VmdWwgYW5pbWF0aW9uIGZ1bmN0aW9ucy5cclxuICpcclxuICogQGhpZGVjb25zdHJ1Y3RvclxyXG4gKi9cclxuY2xhc3MgQW5pbWF0aW9uVXRpbHMge1xyXG4gIHN0YXRpYyBsZXJwKGZyb20sIHRvLCBmYWN0b3IpIHtcclxuICAgIGNvbnNvbGUud2FybihgQW5pbWF0aW9uVXRpbHMubGVycCBpcyBiZWluZyBkZXByZWNhdGVkLiBVc2UgTWF0aFV0aWxzLmxlcnAgaW5zdGVhZC5gKTtcclxuXHJcbiAgICByZXR1cm4gTWF0aFV0aWxzLmxlcnAoZnJvbSwgdG8sIGZhY3Rvcik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDbGFtcCBhIG51bWJlciBiZXR3ZWVuIDIgdmFsdWVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHZhbHVlIC0gVmFsdWUgdG8gY2xhbXAuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFttaW49MF0gLSBNaW51bXVtIHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbWF4PTFdIC0gTWF4aW11bSB2YWx1ZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgc3RhdGljIGNsYW1wKHZhbHVlLCBtaW4gPSAwLCBtYXggPSAxKSB7XHJcbiAgICBjb25zb2xlLndhcm4oYEFuaW1hdGlvblV0aWxzLmNsYW1wIGlzIGJlaW5nIGRlcHJlY2F0ZWQuIFVzZSBNYXRoVXRpbHMuY2xhbXAgaW5zdGVhZC5gKTtcclxuXHJcbiAgICByZXR1cm4gTWF0aFV0aWxzLmNsYW1wKHZhbHVlLCBtaW4sIG1heCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gYSBkZWZlcnJlZCBwcm9taXNlIHRoYXQgY2FuIGJlIHVzZWQgdG8gdXBkYXRlIHRoZSB2YWx1ZSBvZiBhIG51bWVyaWNcclxuICAgKiBwcm9wZXJ0eSBvZiB0aGlzIG9iamVjdCBvdmVyIHRpbWUuIFBhc3MgZGVsdGEgdGltZSBpbiBtaWxsaXNlY29uZHMgdG8gdGhlXHJcbiAgICogZGVmZXJyZWQgcHJvbWlzZSdzIGV4ZWN1dGUgbWV0aG9kIGluIGFuIHVwZGF0ZSBsb29wIHRvIGFuaW1hdGUgdGhlIHByb3BlcnR5XHJcbiAgICogdG93YXJkcyB0aGUgdGFyZ2V0IHZhbHVlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IHByb3BlcnR5T3duZXIgLSBPYmplY3QgdGhhdCBjb250YWlucyB0aGUgcHJvcGVydHkgdG8gYW5pbWF0aW9uLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBwcm9wZXJ0eU5hbWUgLSBOYW1lIG9mIHRoZSBwcm9wZXJ0eSB0byBhbmltYXRlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB0YXJnZXRWYWx1ZSAtIFRhcmdldCB2YWx1ZSB0byByZWFjaC5cclxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgLSBPcHRpb25hbCBvcHRpb25zIG9iamVjdFxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5zZWNvbmRzPTBdIC0gTnVtYmVyIG9mIHNlY29uZHMgaXQgd2lsbCB0YWtlIHRvIHJlYWNoXHJcbiAgICogdGhlIHRhcmdldCB2YWx1ZS5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBbb3B0aW9ucy5lYXNpbmdGbj1MaW5lYXIuSW5PdXRdIC0gRWFzaW5nIGZ1bmN0aW9uIHRvIHVzZSBmb3IgYW5pbWF0aW9uLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb259IFtvcHRpb25zLm9uRmluaXNoXSAtIENhbGxiYWNrIHRvIGV4ZWN1dGUgb25jZSB0aGUgYW5pbWF0aW9uIGNvbXBsZXRlcy5cclxuICAgKiBUaGUgdGFyZ2V0IHZhbHVlIGlzIHBhc3NlZCBhcyBhIHBhcmFtZXRlci5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb3B0aW9ucy5vblByb2dyZXNzIC0gQ2FsbGJhY2sgdG8gZXhlY3V0ZSBlYWNoIHRpbWUgdGhlIGFuaW1hdGlvblxyXG4gICAqIHByb3BlcnR5IGlzIHVwZGF0ZWQgZHVyaW5nIHRoZSBhbmltYXRpb24uIFRoZSBwcm9wZXJ0eSdzIHZhbHVlIGF0IHRoZSB0aW1lIG9mXHJcbiAgICogdGhlIHVwZGF0ZSBpcyBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9wdGlvbnMub25DYW5jZWwgLSBDYWxsYmFjayB0byBleGVjdXRlIGlmIHRoZSB1c2VyIGNhbmNlbHMgdGhlXHJcbiAgICogYW5pbWF0aW9uIGJlZm9yZSBjb21wbGV0aW9uLiBUaGUgYW5pbWF0aW9uIHByb3BlcnR5J3MgdmFsdWUgYXQgdGhlIHRpbWUgb2ZcclxuICAgKiBjYW5jZWwgaXMgcGFzc2VkIGFzIGEgcGFyYW1ldGVyLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvcHRpb25zLm9uRXJyb3IgLSBDYWxsYmFjayB0byBleGVjdXRlIGlmIHRoZSBhbmltYXRpb24gc3RvcHNcclxuICAgKiBiZWNhdXNlIGFuIGVycm9yIGlzIGVuY291bnRlcmVkLiBUaGUgZXJyb3IgbWVzc2FnZSBpcyBwYXNzZWQgYXMgYSBwYXJhbWV0ZXIuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9IFJlc29sdmVzIHdpdGggdGhlIHByb3BlcnR5J3MgdmFsdWUgb25jZSBpdCByZWFjaGVzIHRoZVxyXG4gICAqIHRhcmdldCB2YWx1ZS5cclxuICAgKi9cclxuICBzdGF0aWMgaW50ZXJwb2xhdGVQcm9wZXJ0eShcclxuICAgIHByb3BlcnR5T3duZXIsXHJcbiAgICBwcm9wZXJ0eU5hbWUsXHJcbiAgICB0YXJnZXRWYWx1ZSxcclxuICAgIHtzZWNvbmRzID0gMCwgZWFzaW5nRm4sIG9uRmluaXNoLCBvblByb2dyZXNzLCBvbkNhbmNlbCwgb25FcnJvcn0gPSB7fVxyXG4gICkge1xyXG4gICAgLy8gTWFrZSBzdXJlIHByb3BlcnR5IGlzIGFuIG9iamVjdFxyXG4gICAgaWYgKCEocHJvcGVydHlPd25lciBpbnN0YW5jZW9mIE9iamVjdCkpIHtcclxuICAgICAgY29uc3QgZSA9IG5ldyBFcnJvcihcclxuICAgICAgICBgQ2Fubm90IGludGVycG9sYXRlIHByb3BlcnR5ICR7cHJvcGVydHlOYW1lfS4gUHJvcGVydHkgb3duZXIgbXVzdCBiZSBhbiBvYmplY3QuYFxyXG4gICAgICApO1xyXG5cclxuICAgICAgaWYgKHR5cGVvZiBvbkVycm9yID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgb25FcnJvcihlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIERlZmVycmVkLnJlamVjdChlKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBNYWtlIHN1cmUgcHJvcGVydHkgaXMgbnVtZXJpY1xyXG4gICAgaWYgKE51bWJlci5pc05hTihOdW1iZXIocHJvcGVydHlPd25lcltwcm9wZXJ0eU5hbWVdKSkpIHtcclxuICAgICAgY29uc3QgZSA9IG5ldyBFcnJvcihcclxuICAgICAgICBgQ2Fubm90IGludGVycG9sYXRlIHByb3BlcnR5ICR7cHJvcGVydHlOYW1lfS4gUHJvcGVydHkgbXVzdCBiZSBudW1lcmljLmBcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGlmICh0eXBlb2Ygb25FcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIG9uRXJyb3IoZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBEZWZlcnJlZC5yZWplY3QoZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTWFrZSBzdXJlIHRoZSB0YXJnZXQgdmFsdWUgaXMgbnVtZXJpY1xyXG4gICAgaWYgKE51bWJlci5pc05hTihOdW1iZXIodGFyZ2V0VmFsdWUpKSkge1xyXG4gICAgICBjb25zdCBlID0gbmV3IEVycm9yKFxyXG4gICAgICAgIGBDYW5ub3QgaW50ZXJwb2xhdGUgcHJvcGVydHkgJHtwcm9wZXJ0eU5hbWV9IHRvIHZhbHVlICR7dGFyZ2V0VmFsdWV9LiBUYXJnZXQgdmFsdWUgbXVzdCBiZSBudW1lcmljLmBcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGlmICh0eXBlb2Ygb25FcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIG9uRXJyb3IoZSk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJldHVybiBEZWZlcnJlZC5yZWplY3QoZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gUmVzb2x2ZSBpbW1lZGlhdGVseSBpZiB0aGUgdGFyZ2V0IGhhcyBhbHJlYWR5IGJlZW4gcmVhY2hlZFxyXG4gICAgY29uc3Qgc3RhcnRWYWx1ZSA9IHByb3BlcnR5T3duZXJbcHJvcGVydHlOYW1lXTtcclxuXHJcbiAgICBpZiAoc3RhcnRWYWx1ZSA9PT0gdGFyZ2V0VmFsdWUpIHtcclxuICAgICAgaWYgKHR5cGVvZiBvbkZpbmlzaCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIG9uRmluaXNoKHRhcmdldFZhbHVlKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcmV0dXJuIERlZmVycmVkLnJlc29sdmUodGFyZ2V0VmFsdWUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIERlZmF1bHQgdG8gbGluZWFyIGludGVycG9sYXRpb25cclxuICAgIGlmICh0eXBlb2YgZWFzaW5nRm4gIT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgaWYgKGVhc2luZ0ZuICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgICBgSW52YWxpZCBwcm9wZXJ0eSBpbnRlcnBvbGF0aW9uIGVhc2luZ0ZuLiBEZWZhdWx0aW5nIHRvIGxpbmVhciBpbnRlcnBvbGF0aW9uLmBcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBlYXNpbmdGbiA9IExpbmVhci5Jbk91dDtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBpbnRlcnBvbGF0b3IgPSBVdGlscy53YWl0KHNlY29uZHMsIHtcclxuICAgICAgb25GaW5pc2g6ICgpID0+IHtcclxuICAgICAgICBwcm9wZXJ0eU93bmVyW3Byb3BlcnR5TmFtZV0gPSB0YXJnZXRWYWx1ZTtcclxuXHJcbiAgICAgICAgaWYgKHR5cGVvZiBvbkZpbmlzaCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgb25GaW5pc2godGFyZ2V0VmFsdWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgb25DYW5jZWw6ICgpID0+IHtcclxuICAgICAgICBpZiAodHlwZW9mIG9uQ2FuY2VsID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgICBvbkNhbmNlbChwcm9wZXJ0eU93bmVyW3Byb3BlcnR5TmFtZV0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSxcclxuICAgICAgb25Qcm9ncmVzczogcHJvZ3Jlc3MgPT4ge1xyXG4gICAgICAgIGlmIChwcm9wZXJ0eU93bmVyW3Byb3BlcnR5TmFtZV0gIT09IHRhcmdldFZhbHVlKSB7XHJcbiAgICAgICAgICAvLyBDYWxjdWxhdGUgdGhlIGxlcnAgZmFjdG9yXHJcbiAgICAgICAgICBjb25zdCBlYXNlRmFjdG9yID0gZWFzaW5nRm4ocHJvZ3Jlc3MpO1xyXG5cclxuICAgICAgICAgIGlmICh0eXBlb2YgZWFzZUZhY3RvciAhPT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgY29uc3QgZSA9IG5ldyBFcnJvcihcclxuICAgICAgICAgICAgICBgSW52YWxpZCBwcm9wZXJ0eSBpbnRlcnBvbGF0aW9uIGVhc2luZ0ZuLiBFYXNpbmdGbiBtdXN0IHJldHVybiBhIG51bWJlci5gXHJcbiAgICAgICAgICAgICk7XHJcbiAgICAgICAgICAgIGludGVycG9sYXRvci5yZWplY3QoZSk7XHJcbiAgICAgICAgICAgIHJldHVybjtcclxuICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAvLyBVcGRhdGUgdGhlIHZhbHVlXHJcbiAgICAgICAgICBwcm9wZXJ0eU93bmVyW3Byb3BlcnR5TmFtZV0gPSBNYXRoVXRpbHMubGVycChcclxuICAgICAgICAgICAgc3RhcnRWYWx1ZSxcclxuICAgICAgICAgICAgdGFyZ2V0VmFsdWUsXHJcbiAgICAgICAgICAgIGVhc2VGYWN0b3JcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBTaWduYWwgcHJvZ3Jlc3NcclxuICAgICAgICBpZiAodHlwZW9mIG9uUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicpIHtcclxuICAgICAgICAgIG9uUHJvZ3Jlc3MocHJvcGVydHlPd25lcltwcm9wZXJ0eU5hbWVdKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFNpZ25hbCBjb21wbGV0aW9uIG9uY2UgdGltZSBpcyB1cFxyXG4gICAgICAgIGlmIChwcm9ncmVzcyA9PT0gMSkge1xyXG4gICAgICAgICAgcHJvcGVydHlPd25lcltwcm9wZXJ0eU5hbWVdID0gdGFyZ2V0VmFsdWU7XHJcbiAgICAgICAgICBpbnRlcnBvbGF0b3IucmVzb2x2ZSh0YXJnZXRWYWx1ZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICBvbkVycm9yLFxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGludGVycG9sYXRvcjtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEFuaW1hdGlvblV0aWxzO1xyXG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXHJcbmltcG9ydCBEZWZlcnJlZCBmcm9tICdjb3JlL0RlZmVycmVkJztcclxuaW1wb3J0IE1hdGhVdGlscyBmcm9tICdjb3JlL01hdGhVdGlscyc7XHJcbmltcG9ydCBBbmltYXRpb25VdGlscyBmcm9tICcuLi9BbmltYXRpb25VdGlscyc7XHJcblxyXG4vKipcclxuICogQmFzZSBjbGFzcyBmb3IgYSBzdGF0ZSBpbiBvdXIgYW5pbWF0aW9uIHN5c3RlbS5cclxuICpcclxuICogQGFic3RyYWN0XHJcbiAqL1xyXG5jbGFzcyBBYnN0cmFjdFN0YXRlIHtcclxuICAvKipcclxuICAgKiBAY29uc3RydWN0b3JcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBhbmltYXRpb24gc3RhdGUuXHJcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRpb25zLm5hbWUgLSBOYW1lIGZvciB0aGUgYW5pbWF0aW9uIHN0YXRlLiBOYW1lcyBtdXN0IGJlXHJcbiAgICogdW5pcXVlIGZvciB0aGUgY29udGFpbmVyIHRoZSBzdGF0ZSBpcyBhcHBsaWVkIHRvIGFuZCBzaG91bGQgYmUgdmFsaWRhdGVkIGF0XHJcbiAgICogdGhlIGNvbnRhaW5lciBsZXZlbC4gSWYgbm8gbmFtZSBpcyBnaXZlbiBpdCB3aWxsIGRlZmF1bHQgdG8gdGhlIGNvbnN0cnVjdG9yXHJcbiAgICogbmFtZS5cclxuICAgKiBAcGFyYW0ge3dlaWdodH0gW29wdGlvbnMud2VpZ2h0PTBdIC0gVGhlIDAtMSBhbW91bnQgb2YgaW5mbHVlbmNlIHRoZSBzdGF0ZSB3aWxsIGhhdmUuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3Iob3B0aW9ucyA9IHt9KSB7XHJcbiAgICB0aGlzLm5hbWUgPVxyXG4gICAgICBvcHRpb25zLm5hbWUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMubmFtZSA6IHRoaXMuY29uc3RydWN0b3IubmFtZTtcclxuICAgIHRoaXMuX3dlaWdodCA9XHJcbiAgICAgIG9wdGlvbnMud2VpZ2h0ICE9PSB1bmRlZmluZWRcclxuICAgICAgICA/IE1hdGhVdGlscy5jbGFtcChvcHRpb25zLndlaWdodCwgMCwgMSlcclxuICAgICAgICA6IDA7XHJcbiAgICB0aGlzLl9pbnRlcm5hbFdlaWdodCA9IHRoaXMuX3dlaWdodDtcclxuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMuX3Byb21pc2VzID0ge1xyXG4gICAgICBmaW5pc2g6IERlZmVycmVkLnJlc29sdmUoKSxcclxuICAgICAgd2VpZ2h0OiBEZWZlcnJlZC5yZXNvbHZlKCksXHJcbiAgICAgIHBsYXk6IERlZmVycmVkLnJlc29sdmUoKSxcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5fcGxheUNhbGxiYWNrcyA9IHtcclxuICAgICAgb25GaW5pc2g6IHVuZGVmaW5lZCxcclxuICAgICAgb25FcnJvcjogdW5kZWZpbmVkLFxyXG4gICAgICBvbkNhbmNlbDogdW5kZWZpbmVkLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgd2hldGhlciBvciBub3QgdGhlIHN0YXRlIGlzIGN1cnJlbnRseSBwYXVzZWQuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCBwYXVzZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcGF1c2VkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyBhbmQgc2V0cyB0aGUgdXNlciBkZWZpbmVkIHdlaWdodC5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IHdlaWdodCgpIHtcclxuICAgIHJldHVybiB0aGlzLl93ZWlnaHQ7XHJcbiAgfVxyXG5cclxuICBzZXQgd2VpZ2h0KHdlaWdodCkge1xyXG4gICAgdGhpcy5fd2VpZ2h0ID0gTWF0aFV0aWxzLmNsYW1wKHdlaWdodCwgMCwgMSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHdoZXRoZXIgb3Igbm90IHRoZSB3ZWlnaHQgaXMgY3VycmVudGx5IGJlaW5nIGFuaW1hdGVkLlxyXG4gICAqXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgZ2V0IHdlaWdodFBlbmRpbmcoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZXMud2VpZ2h0ICYmIHRoaXMuX3Byb21pc2VzLndlaWdodC5wZW5kaW5nO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlcyB0aGUgdXNlciBkZWZpbmVkIHdlaWdodCBvdmVyIHRpbWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gd2VpZ2h0IC0gVGhlIHRhcmdldCB3ZWlnaHQgdmFsdWUuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzZWNvbmRzPTBdIC0gVGhlIGFtb3VudCBvZiB0aW1lIGl0IHdpbGwgdGFrZSB0byByZWFjaCB0aGVcclxuICAgKiB0YXJnZXQgd2VpZ2h0LlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBlYXNpbmdGbiAtIFRoZSBlYXNpbmcgZnVuY3Rpb24gdG8gdXNlIGZvciBpbnRlcnBvbGF0aW9uLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0RlZmVycmVkfVxyXG4gICAqL1xyXG4gIHNldFdlaWdodCh3ZWlnaHQsIHNlY29uZHMgPSAwLCBlYXNpbmdGbikge1xyXG4gICAgdGhpcy5fcHJvbWlzZXMud2VpZ2h0LmNhbmNlbCgpO1xyXG4gICAgd2VpZ2h0ID0gTWF0aFV0aWxzLmNsYW1wKHdlaWdodCk7XHJcblxyXG4gICAgdGhpcy5fcHJvbWlzZXMud2VpZ2h0ID0gQW5pbWF0aW9uVXRpbHMuaW50ZXJwb2xhdGVQcm9wZXJ0eShcclxuICAgICAgdGhpcyxcclxuICAgICAgJ3dlaWdodCcsXHJcbiAgICAgIHdlaWdodCxcclxuICAgICAge3NlY29uZHMsIGVhc2luZ0ZufVxyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZXMud2VpZ2h0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgaW50ZXJuYWwgd2VpZ2h0LlxyXG4gICAqXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgaW50ZXJuYWxXZWlnaHQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5faW50ZXJuYWxXZWlnaHQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNdWx0aXBsaWVzIHRoZSB1c2VyIHdlaWdodCBieSBhIGZhY3RvciB0byBkZXRlcm1pbmUgdGhlIGludGVybmFsIHdlaWdodC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmYWN0b3IgLSAwLTEgbXVsdGlwbGllciB0byBhcHBseSB0byB0aGUgdXNlciB3ZWlnaHQuXHJcbiAgICovXHJcbiAgdXBkYXRlSW50ZXJuYWxXZWlnaHQoZmFjdG9yKSB7XHJcbiAgICB0aGlzLl9pbnRlcm5hbFdlaWdodCA9IHRoaXMuX3dlaWdodCAqIGZhY3RvcjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBhbnkgdmFsdWVzIHRoYXQgbmVlZCB0byBiZSBldmFsdWF0ZWQgZXZlcnkgZnJhbWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGFUaW1lIC0gVGltZSBpbiBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGxhc3QgdXBkYXRlLlxyXG4gICAqL1xyXG4gIHVwZGF0ZShkZWx0YVRpbWUpIHtcclxuICAgIGlmICghdGhpcy5fcGF1c2VkKSB7XHJcbiAgICAgIE9iamVjdC52YWx1ZXModGhpcy5fcHJvbWlzZXMpLmZvckVhY2gocHJvbWlzZSA9PiB7XHJcbiAgICAgICAgcHJvbWlzZS5leGVjdXRlKGRlbHRhVGltZSk7XHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RhcnQgcGxheWJhY2sgb2YgdGhlIHN0YXRlIGZyb20gdGhlIGJlZ2lubmluZy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbkZpbmlzaCAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiB0aGUgc3RhdGUgZmluaXNoZXMuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uRXJyb3IgLSBGdW5jdGlvbiB0byBleGVjdXRlIGlmIHRoZSBzdGF0ZSBlbmNvdW50ZXJzXHJcbiAgICogYW4gZXJyb3IgZHVyaW5nIHBsYXliYWNrLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbkNhbmNlbCAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgaWYgcGxheWJhY2sgaXMgY2FuY2VsZWQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9XHJcbiAgICovXHJcbiAgcGxheShvbkZpbmlzaCwgb25FcnJvciwgb25DYW5jZWwpIHtcclxuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5fcGxheUNhbGxiYWNrcy5vbkZpbmlzaCA9IG9uRmluaXNoO1xyXG4gICAgdGhpcy5fcGxheUNhbGxiYWNrcy5vbkVycm9yID0gb25FcnJvcjtcclxuICAgIHRoaXMuX3BsYXlDYWxsYmFja3Mub25DYW5jZWwgPSBvbkNhbmNlbDtcclxuXHJcbiAgICB0aGlzLl9wcm9taXNlcy5wbGF5ID0gbmV3IERlZmVycmVkKHVuZGVmaW5lZCwgb25GaW5pc2gsIG9uRXJyb3IsIG9uQ2FuY2VsKTtcclxuICAgIHRoaXMuX3Byb21pc2VzLmZpbmlzaCA9IERlZmVycmVkLmFsbChbXHJcbiAgICAgIHRoaXMuX3Byb21pc2VzLnBsYXksXHJcbiAgICAgIHRoaXMuX3Byb21pc2VzLndlaWdodCxcclxuICAgIF0pO1xyXG5cclxuICAgIHJldHVybiB0aGlzLl9wcm9taXNlcy5maW5pc2g7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQYXVzZSBwbGF5YmFjayBvZiB0aGUgc3RhdGUuIFRoaXMgcHJldmVudHMgcGVuZGluZyBwcm9taXNlcyBmcm9tIGJlaW5nIGV4ZWN1dGVkLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgcGF1c2UoKSB7XHJcbiAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXN1bWUgcGxheWJhY2sgb2YgdGhlIHN0YXRlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uRmluaXNoIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIHRoZSBzdGF0ZSBmaW5pc2hlcy5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25FcnJvciAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgaWYgdGhlIHN0YXRlIGVuY291bnRlcnNcclxuICAgKiBhbiBlcnJvciBkdXJpbmcgcGxheWJhY2suXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uQ2FuY2VsIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSBpZiBwbGF5YmFjayBpcyBjYW5jZWxlZC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH1cclxuICAgKi9cclxuICByZXN1bWUob25GaW5pc2gsIG9uRXJyb3IsIG9uQ2FuY2VsKSB7XHJcbiAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcclxuXHJcbiAgICBpZiAoIXRoaXMuX3Byb21pc2VzLnBsYXkucGVuZGluZykge1xyXG4gICAgICB0aGlzLl9wbGF5Q2FsbGJhY2tzLm9uRmluaXNoID0gb25GaW5pc2ggfHwgdGhpcy5fcGxheUNhbGxiYWNrcy5vbkZpbmlzaDtcclxuICAgICAgdGhpcy5fcGxheUNhbGxiYWNrcy5vbkVycm9yID0gb25FcnJvciB8fCB0aGlzLl9wbGF5Q2FsbGJhY2tzLm9uRXJyb3I7XHJcbiAgICAgIHRoaXMuX3BsYXlDYWxsYmFja3Mub25DYW5jZWwgPSBvbkNhbmNlbCB8fCB0aGlzLl9wbGF5Q2FsbGJhY2tzLm9uQ2FuY2VsO1xyXG5cclxuICAgICAgdGhpcy5fcHJvbWlzZXMucGxheSA9IG5ldyBEZWZlcnJlZChcclxuICAgICAgICB1bmRlZmluZWQsXHJcbiAgICAgICAgdGhpcy5fcGxheUNhbGxiYWNrcy5vbkZpbmlzaCxcclxuICAgICAgICB0aGlzLl9wbGF5Q2FsbGJhY2tzLm9uRXJyb3IsXHJcbiAgICAgICAgdGhpcy5fcGxheUNhbGxiYWNrcy5vbkNhbmNlbFxyXG4gICAgICApO1xyXG4gICAgICB0aGlzLl9wcm9taXNlcy5maW5pc2ggPSBEZWZlcnJlZC5hbGwoW1xyXG4gICAgICAgIHRoaXMuX3Byb21pc2VzLnBsYXksXHJcbiAgICAgICAgdGhpcy5fcHJvbWlzZXMud2VpZ2h0LFxyXG4gICAgICBdKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZXMuZmluaXNoO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FuY2VsIHBsYXliYWNrIG9mIHRoZSBzdGF0ZSBhbmQgY2FuY2VsIGFueSBwZW5kaW5nIHByb21pc2VzLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgY2FuY2VsKCkge1xyXG4gICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcclxuXHJcbiAgICBPYmplY3QudmFsdWVzKHRoaXMuX3Byb21pc2VzKS5mb3JFYWNoKHByb21pc2UgPT4ge1xyXG4gICAgICBwcm9taXNlLmNhbmNlbCgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdG9wIHBsYXliYWNrIG9mIHRoZSBzdGF0ZSBhbmQgcmVzb2x2ZSBhbnkgcGVuZGluZyBwcm9taXNlcy5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqL1xyXG4gIHN0b3AoKSB7XHJcbiAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xyXG5cclxuICAgIE9iamVjdC52YWx1ZXModGhpcy5fcHJvbWlzZXMpLmZvckVhY2gocHJvbWlzZSA9PiB7XHJcbiAgICAgIHByb21pc2UucmVzb2x2ZSgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYW5jZWwgYW55IHBlbmRpbmcgcHJvbWlzZXMgYW5kIHJlbW92ZSByZWZlcmVuY2UgdG8gdGhlbS5cclxuICAgKi9cclxuICBkaXNjYXJkKCkge1xyXG4gICAgdGhpcy5jYW5jZWwoKTtcclxuXHJcbiAgICBkZWxldGUgdGhpcy5fcHJvbWlzZXM7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBGb3JjZSB0aGUgaW50ZXJuYWwgd2VpZ2h0IHRvIDAuIFNob3VsZCBiZSBjYWxsZWQgYmVmb3JlIHN3aXRjaGluZyBvciB0cmFuc2l0aW9uaW5nXHJcbiAgICogdG8gYSBuZXcgc3RhdGUuXHJcbiAgICovXHJcbiAgZGVhY3RpdmF0ZSgpIHtcclxuICAgIHRoaXMudXBkYXRlSW50ZXJuYWxXZWlnaHQoMCk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBBYnN0cmFjdFN0YXRlO1xyXG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXHJcbmltcG9ydCBEZWZlcnJlZCBmcm9tICdjb3JlL0RlZmVycmVkJztcclxuaW1wb3J0IEFic3RyYWN0U3RhdGUgZnJvbSAnLi9BYnN0cmFjdFN0YXRlJztcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyBmb3Igc21vb3RoIHRyYW5zaXRpb25pbmcgYmV0d2VlbiBzdGF0ZXMgb24gYW4gYW5pbWF0aW9uIGxheWVyLlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdFN0YXRlXHJcbiAqL1xyXG5jbGFzcyBUcmFuc2l0aW9uU3RhdGUgZXh0ZW5kcyBBYnN0cmFjdFN0YXRlIHtcclxuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30pIHtcclxuICAgIHN1cGVyKG9wdGlvbnMpO1xyXG5cclxuICAgIHRoaXMuX3RvID0gbnVsbDtcclxuICAgIHRoaXMuX2Zyb20gPSBbXTtcclxuICAgIHRoaXMuX3dlaWdodFByb21pc2UgPSBEZWZlcnJlZC5yZXNvbHZlKCk7XHJcbiAgfVxyXG5cclxuICBnZXQgaW50ZXJuYWxXZWlnaHQoKSB7XHJcbiAgICAvLyBGaW5kIHRoZSBjb21iaW5lZCB3ZWlnaHQgb2YgYWxsIHN1Yi1zdGF0ZXNcclxuICAgIGxldCB0b3RhbFdlaWdodCA9IDA7XHJcblxyXG4gICAgaWYgKHRoaXMuX3RvKSB7XHJcbiAgICAgIHRvdGFsV2VpZ2h0ICs9IHRoaXMuX3RvLndlaWdodDtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9mcm9tLmZvckVhY2goc3RhdGUgPT4ge1xyXG4gICAgICB0b3RhbFdlaWdodCArPSBzdGF0ZS53ZWlnaHQ7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gdG90YWxXZWlnaHQgKiB0aGlzLl9pbnRlcm5hbFdlaWdodDtcclxuICB9XHJcblxyXG4gIHVwZGF0ZUludGVybmFsV2VpZ2h0KGZhY3Rvcikge1xyXG4gICAgc3VwZXIudXBkYXRlSW50ZXJuYWxXZWlnaHQoZmFjdG9yKTtcclxuXHJcbiAgICB0aGlzLl9mcm9tLmZvckVhY2goc3RhdGUgPT4ge1xyXG4gICAgICBzdGF0ZS51cGRhdGVJbnRlcm5hbFdlaWdodCh0aGlzLl9pbnRlcm5hbFdlaWdodCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAodGhpcy5fdG8pIHtcclxuICAgICAgdGhpcy5fdG8udXBkYXRlSW50ZXJuYWxXZWlnaHQodGhpcy5faW50ZXJuYWxXZWlnaHQpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIHN1Yi1zdGF0ZXMgdGhlIHRyYW5zaXRpb24gaXMgY29udHJvbGxpbmcgYW5kIHN0YXJ0IG5ldyB3ZWlnaHRcclxuICAgKiBhbmltYXRpb25zIG9uIGVhY2ggb25lLiBUaGlzIHNob3VsZCBiZSBjYWxsZWQgZWFjaCB0aW1lIHRoZSBjdXJyZW50IHN0YXRlIG9mXHJcbiAgICogYW4gYW5pbWF0aW9uIGxheWVyIGdldHMgdXBkYXRlZCB0byBhIG5ldyB2YWx1ZSBhbmQgYSB0cmFuc2l0aW9uIHRpbWUgZ3JlYXRlclxyXG4gICAqIHRoYXQgemVybyBpcyBzcGVjaWZpZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0FycmF5LjxBYnN0cmFjdFN0YXRlPn0gW2N1cnJlbnRTdGF0ZXM9W11dIC0gU3RhdGVzIHdob3NlIHdlaWdodCB2YWx1ZXNcclxuICAgKiB3aWxsIGJlIGFuaW1hdGVkIHRvIDAuXHJcbiAgICogQHBhcmFtIHtBYnN0cmFjdFN0YXRlPX0gdGFyZ2V0U3RhdGUgLSBTdGF0ZSB3aG9zZSB3ZWlnaHQgd2lsbCBiZSBhbmltYXRlZFxyXG4gICAqIHRvIDEuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRyYW5zaXRpb25UaW1lIC0gQW1vdW50IG9mIHRpbWUgaXQgd2lsbCBpbiBzZWNvbmRzIHRha2UgZm9yXHJcbiAgICogd2VpZ2h0IGFuaW1hdGlvbnMgdG8gY29tcGxldGUuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IGVhc2luZ0ZuIC0gRWFzaW5nIGZ1bmN0aW9uIHRvIHVzZSBmb3Igd2VpZ2h0IGFuaW1hdGlvbnMuXHJcbiAgICogRGVmYXVsdCBpcyBFYXNpbmcuTGluZWFyLkluT3V0LlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbkNvbXBsZXRlIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSBvbmNlIGFsbCB3ZWlnaHQgYW5pbWF0aW9uc1xyXG4gICAqIGNvbXBsZXRlLlxyXG4gICAqL1xyXG4gIGNvbmZpZ3VyZShcclxuICAgIGN1cnJlbnRTdGF0ZXMgPSBbXSxcclxuICAgIHRhcmdldFN0YXRlLFxyXG4gICAgdHJhbnNpdGlvblRpbWUsXHJcbiAgICBlYXNpbmdGbixcclxuICAgIG9uQ29tcGxldGVcclxuICApIHtcclxuICAgIC8vIERlYWN0aXZhdGUgYW55IHN0YXRlcyB0aGF0IGFyZW4ndCBpbiB0aGUgbmV3IGNvbmZpZ3VyYXRpb25cclxuICAgIGlmICh0aGlzLl90byA9PT0gdGFyZ2V0U3RhdGUgfHwgY3VycmVudFN0YXRlcy5pbmNsdWRlcyh0aGlzLl90bykpIHtcclxuICAgICAgdGhpcy5fdG8gPSBudWxsO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fZnJvbSA9IHRoaXMuX2Zyb20uZmlsdGVyKFxyXG4gICAgICBzdGF0ZSA9PiBzdGF0ZSAhPT0gdGFyZ2V0U3RhdGUgJiYgIWN1cnJlbnRTdGF0ZXMuaW5jbHVkZXMoc3RhdGUpXHJcbiAgICApO1xyXG4gICAgdGhpcy5kZWFjdGl2YXRlKCk7XHJcblxyXG4gICAgdGhpcy5fZnJvbSA9IGN1cnJlbnRTdGF0ZXM7XHJcbiAgICB0aGlzLl90byA9IHRhcmdldFN0YXRlO1xyXG4gICAgdGhpcy5yZXNldCh0cmFuc2l0aW9uVGltZSwgZWFzaW5nRm4sIG9uQ29tcGxldGUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RhcnQgbmV3IHdlaWdodCBhbmltYXRpb25zIHN0YXRlIHRoZSB0cmFuc2l0aW9uIGNvbnRyb2xzLiBUaGlzIHNob3VsZCBiZSBjYWxsZWRcclxuICAgKiBpZiBhbiBhbmltYXRpb24gaXMgcGxheWVkIHdpdGggYSB0cmFuc2l0aW9uIHRpbWUgZ3JlYXRlciB0aGFuIHplcm8gYW5kIGEgdHJhbnN0aW9uXHJcbiAgICogdG8gdGhhdCBhbmltYXRpb24gd2FzIGFscmVhZHkgaW4gcHJvZ3Jlc3MuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gdHJhbnNpdGlvblRpbWUgLSBBbW91bnQgb2YgdGltZSBpdCB3aWxsIGluIHNlY29uZHMgdGFrZSBmb3JcclxuICAgKiB3ZWlnaHQgYW5pbWF0aW9ucyB0byBjb21wbGV0ZS5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gZWFzaW5nRm4gLSBFYXNpbmcgZnVuY3Rpb24gdG8gdXNlIGZvciB3ZWlnaHQgYW5pbWF0aW9ucy5cclxuICAgKiBEZWZhdWx0IGlzIEVhc2luZy5MaW5lYXIuSW5PdXQuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uQ29tcGxldGUgLSBGdW5jdGlvbiB0byBleGVjdXRlIG9uY2UgYWxsIHdlaWdodCBhbmltYXRpb25zXHJcbiAgICogY29tcGxldGUuXHJcbiAgICovXHJcbiAgcmVzZXQodHJhbnNpdGlvblRpbWUsIGVhc2luZ0ZuLCBvbkNvbXBsZXRlKSB7XHJcbiAgICAvLyBTdG9wIGFueSBwZW5kaW5nIHByb21pc2VzXHJcbiAgICB0aGlzLl93ZWlnaHRQcm9taXNlLmNhbmNlbCgpO1xyXG5cclxuICAgIC8vIFN0YXJ0IHR3ZWVuaW5nIHdlaWdodCB0byAwIGZvciB0aGUgY3VycmVudCBzdGF0ZXNcclxuICAgIGNvbnN0IHdlaWdodFByb21pc2VzID0gdGhpcy5fZnJvbS5tYXAoc3RhdGUgPT5cclxuICAgICAgc3RhdGUuc2V0V2VpZ2h0KDAsIHRyYW5zaXRpb25UaW1lLCBlYXNpbmdGbilcclxuICAgICk7XHJcblxyXG4gICAgLy8gU3RhcnQgdHdlZW5pbmcgd2VpZ2h0IHRvIDEgZm9yIHRoZSB0YXJnZXQgc3RhdGVcclxuICAgIGlmICh0aGlzLl90bykge1xyXG4gICAgICB3ZWlnaHRQcm9taXNlcy5wdXNoKHRoaXMuX3RvLnNldFdlaWdodCgxLCB0cmFuc2l0aW9uVGltZSwgZWFzaW5nRm4pKTtcclxuICAgICAgdGhpcy5uYW1lID0gdGhpcy5fdG8ubmFtZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMubmFtZSA9IG51bGw7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fd2VpZ2h0UHJvbWlzZSA9IERlZmVycmVkLmFsbCh3ZWlnaHRQcm9taXNlcywgKCkgPT4ge1xyXG4gICAgICB0aGlzLl9mcm9tLmZvckVhY2goc3RhdGUgPT4ge1xyXG4gICAgICAgIHN0YXRlLmNhbmNlbCgpO1xyXG4gICAgICAgIHN0YXRlLmRlYWN0aXZhdGUoKTtcclxuICAgICAgfSk7XHJcbiAgICAgIGlmICh0eXBlb2Ygb25Db21wbGV0ZSA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIG9uQ29tcGxldGUoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBwbGF5KG9uRmluaXNoLCBvbkVycm9yLCBvbkNhbmNlbCwgb25OZXh0KSB7XHJcbiAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuX3BsYXlDYWxsYmFja3Mub25GaW5pc2ggPSBvbkZpbmlzaDtcclxuICAgIHRoaXMuX3BsYXlDYWxsYmFja3Mub25FcnJvciA9IG9uRXJyb3I7XHJcbiAgICB0aGlzLl9wbGF5Q2FsbGJhY2tzLm9uQ2FuY2VsID0gb25DYW5jZWw7XHJcblxyXG4gICAgY29uc3QgcHJvbWlzZXMgPSBbdGhpcy5fd2VpZ2h0UHJvbWlzZV07XHJcblxyXG4gICAgdGhpcy5fZnJvbS5mb3JFYWNoKHN0YXRlID0+IHtcclxuICAgICAgc3RhdGUucmVzdW1lKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAodGhpcy5fdG8pIHtcclxuICAgICAgdGhpcy5fcHJvbWlzZXMucGxheSA9IHRoaXMuX3RvLnBsYXkoXHJcbiAgICAgICAgdW5kZWZpbmVkLFxyXG4gICAgICAgIHVuZGVmaW5lZCxcclxuICAgICAgICB1bmRlZmluZWQsXHJcbiAgICAgICAgb25OZXh0XHJcbiAgICAgICk7XHJcbiAgICAgIHByb21pc2VzLnB1c2godGhpcy5fcHJvbWlzZXMucGxheSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fcHJvbWlzZXMuZmluaXNoID0gRGVmZXJyZWQuYWxsKHByb21pc2VzLCBvbkZpbmlzaCwgb25FcnJvciwgb25DYW5jZWwpO1xyXG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2VzLmZpbmlzaDtcclxuICB9XHJcblxyXG4gIHBhdXNlKCkge1xyXG4gICAgdGhpcy5fZnJvbS5mb3JFYWNoKHN0YXRlID0+IHtcclxuICAgICAgc3RhdGUucGF1c2UoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGlmICh0aGlzLl90bykge1xyXG4gICAgICB0aGlzLl90by5wYXVzZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzdXBlci5wYXVzZSgpO1xyXG4gIH1cclxuXHJcbiAgcmVzdW1lKG9uRmluaXNoLCBvbkVycm9yLCBvbkNhbmNlbCwgb25OZXh0KSB7XHJcbiAgICB0aGlzLl9wYXVzZWQgPSBmYWxzZTtcclxuXHJcbiAgICBpZiAoIXRoaXMuX3Byb21pc2VzLnBsYXkucGVuZGluZykge1xyXG4gICAgICB0aGlzLl9wbGF5Q2FsbGJhY2tzLm9uRmluaXNoID0gb25GaW5pc2ggfHwgdGhpcy5fcGxheUNhbGxiYWNrcy5vbkZpbmlzaDtcclxuICAgICAgdGhpcy5fcGxheUNhbGxiYWNrcy5vbkVycm9yID0gb25FcnJvciB8fCB0aGlzLl9wbGF5Q2FsbGJhY2tzLm9uRXJyb3I7XHJcbiAgICAgIHRoaXMuX3BsYXlDYWxsYmFja3Mub25DYW5jZWwgPSBvbkNhbmNlbCB8fCB0aGlzLl9wbGF5Q2FsbGJhY2tzLm9uQ2FuY2VsO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHByb21pc2VzID0gW3RoaXMuX3dlaWdodFByb21pc2VdO1xyXG5cclxuICAgIHRoaXMuX2Zyb20uZm9yRWFjaChzdGF0ZSA9PiB7XHJcbiAgICAgIHN0YXRlLnJlc3VtZSgpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKHRoaXMuX3RvKSB7XHJcbiAgICAgIHRoaXMuX3Byb21pc2VzLnBsYXkgPSB0aGlzLl90by5yZXN1bWUoXHJcbiAgICAgICAgdW5kZWZpbmVkLFxyXG4gICAgICAgIHVuZGVmaW5lZCxcclxuICAgICAgICB1bmRlZmluZWQsXHJcbiAgICAgICAgb25OZXh0XHJcbiAgICAgICk7XHJcbiAgICAgIHByb21pc2VzLnB1c2godGhpcy5fcHJvbWlzZXMucGxheSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fcHJvbWlzZXMuZmluaXNoID0gRGVmZXJyZWQuYWxsKFxyXG4gICAgICBwcm9taXNlcyxcclxuICAgICAgdGhpcy5fcGxheUNhbGxiYWNrcy5vbkZpbmlzaCxcclxuICAgICAgdGhpcy5fcGxheUNhbGxiYWNrcy5vbkVycm9yLFxyXG4gICAgICB0aGlzLl9wbGF5Q2FsbGJhY2tzLm9uQ2FuY2VsXHJcbiAgICApO1xyXG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2VzLmZpbmlzaDtcclxuICB9XHJcblxyXG4gIGNhbmNlbCgpIHtcclxuICAgIHRoaXMuX2Zyb20uZm9yRWFjaChzdGF0ZSA9PiB7XHJcbiAgICAgIHN0YXRlLnBhdXNlKCk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAodGhpcy5fdG8pIHtcclxuICAgICAgdGhpcy5fdG8uY2FuY2VsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fd2VpZ2h0UHJvbWlzZS5jYW5jZWwoKTtcclxuXHJcbiAgICByZXR1cm4gc3VwZXIuY2FuY2VsKCk7XHJcbiAgfVxyXG5cclxuICBzdG9wKCkge1xyXG4gICAgdGhpcy5fZnJvbS5mb3JFYWNoKHN0YXRlID0+IHtcclxuICAgICAgc3RhdGUucGF1c2UoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGlmICh0aGlzLl90bykge1xyXG4gICAgICB0aGlzLl90by5zdG9wKCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHN1cGVyLnN0b3AoKTtcclxuICB9XHJcblxyXG4gIHVwZGF0ZShkZWx0YVRpbWUpIHtcclxuICAgIHN1cGVyLnVwZGF0ZShkZWx0YVRpbWUpO1xyXG5cclxuICAgIHRoaXMuX2Zyb20uZm9yRWFjaChzdGF0ZSA9PiB7XHJcbiAgICAgIHN0YXRlLnVwZGF0ZShkZWx0YVRpbWUpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKHRoaXMuX3RvKSB7XHJcbiAgICAgIHRoaXMuX3RvLnVwZGF0ZShkZWx0YVRpbWUpO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgZGlzY2FyZCgpIHtcclxuICAgIHN1cGVyLmRpc2NhcmQoKTtcclxuXHJcbiAgICB0aGlzLl93ZWlnaHRQcm9taXNlLmNhbmNlbCgpO1xyXG4gICAgZGVsZXRlIHRoaXMuX3dlaWdodFByb21pc2U7XHJcbiAgICB0aGlzLl90byA9IG51bGw7XHJcbiAgICB0aGlzLl9mcm9tLmxlbmd0aCA9IDA7XHJcbiAgfVxyXG5cclxuICBkZWFjdGl2YXRlKCkge1xyXG4gICAgaWYgKHRoaXMuX3RvKSB7XHJcbiAgICAgIHRoaXMuX3RvLmRlYWN0aXZhdGUoKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9mcm9tLmZvckVhY2goc3RhdGUgPT4ge1xyXG4gICAgICBzdGF0ZS5kZWFjdGl2YXRlKCk7XHJcbiAgICB9KTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRyYW5zaXRpb25TdGF0ZTtcclxuIiwiLy8gQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxyXG4vKiBlc2xpbnQtZGlzYWJsZSBtYXgtY2xhc3Nlcy1wZXItZmlsZSAqL1xyXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bnVzZWQtdmFycyAqL1xyXG4vKiBlc2xpbnQtZGlzYWJsZSBuby1lbXB0eS1mdW5jdGlvbiAqL1xyXG4vKiBlc2xpbnQtZGlzYWJsZSBnZXR0ZXItcmV0dXJuICovXHJcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVzZWxlc3MtY29uc3RydWN0b3IgKi9cclxuaW1wb3J0IFRyYW5zaXRpb25TdGF0ZSBmcm9tICcuL3N0YXRlL1RyYW5zaXRpb25TdGF0ZSc7XHJcbmltcG9ydCBEZWZlcnJlZCBmcm9tICcuLi9EZWZlcnJlZCc7XHJcblxyXG4vKipcclxuICogQ2xhc3MgZmFjdG9yeSBpbnRlcmZhY2UgZm9yIGNvbnRyb2xsaW5nIHBsYXliYWNrIG9mIGEgY29sbGVjdGlvbiBvZiBhbmltYXRpb25zLlxyXG4gKiBPbmUgYW5pbWF0aW9uIGNhbiBiZSBwbGF5ZWQgYXQgYW55IGdpdmVuIHRpbWUsIGNyb3NzZmFkaW5nIGJldHdlZW4gYW5pbWF0aW9uc1xyXG4gKiB3aWxsIHJlc3VsdCBpbiBwbGF5aW5nIGEge0BsaW5rIFRyYW5zaXRpb25TdGF0ZX0uXHJcbiAqXHJcbiAqIEBpbnRlcmZhY2VcclxuICovXHJcbmNsYXNzIEFuaW1hdGlvblBsYXllckludGVyZmFjZSB7XHJcbiAgLyoqXHJcbiAgICogR2V0cyB3aGV0aGVyIG9yIG5vdCB0aGUgcGxheWVyIGlzIHVwZGF0aW5nIHN0YXRlcy5cclxuICAgKlxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGdldCBwYXVzZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcGF1c2VkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyBhbmQgc2V0cyB0aGUgZGVmYXVsdCBudW1iZXIgb2Ygc2Vjb25kcyBpdCB0YWtlcyB0byB0cmFuc2l0aW9uIHRvIGEgbmV3XHJcbiAgICogYW5pbWF0aW9uLlxyXG4gICAqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgdHJhbnNpdGlvblRpbWUoKSB7fVxyXG5cclxuICBzZXQgdHJhbnNpdGlvblRpbWUoc2Vjb25kcykge31cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyBhbmQgc2V0cyB0aGUgZGVmYXVsdCBlYXNpbmcgZnVuY3Rpb24gdG8gdXNlIHdoZW4gdHJhbnNpdGlvbmluZyBhbmRcclxuICAgKiBzZXR0aW5nIHdlaWdodHMuXHJcbiAgICpcclxuICAgKiBAdHlwZSB7RnVuY3Rpb259XHJcbiAgICovXHJcbiAgZ2V0IGVhc2luZ0ZuKCkge31cclxuXHJcbiAgc2V0IGVhc2luZ0ZuKGZuKSB7fVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSBzdGF0ZSB0aGUgbGF5ZXIgaXMgY3VycmVudGx5IGluIGNvbnRyb2wgb2YuXHJcbiAgICpcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAdHlwZSB7QWJzdHJhY3RTdGF0ZX1cclxuICAgKi9cclxuICBnZXQgY3VycmVudFN0YXRlKCkge31cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgbmFtZSBvZiB0aGUgc3RhdGUgdGhlIGxheWVyIGlzIGN1cnJlbnRseSBpbiBjb250cm9sIG9mLlxyXG4gICAqXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHR5cGUge3N0cmluZ31cclxuICAgKi9cclxuICBnZXQgY3VycmVudEFuaW1hdGlvbigpIHt9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgd2hldGhlciBvciBub3QgdGhlIGxheWVyIGlzIGN1cnJlbnRseSB0cmFuc2l0aW9uaW5nIHRvIGEgbmV3IGFuaW1hdGlvbi5cclxuICAgKlxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGdldCBpc1RyYW5zaXRpb25pbmcoKSB7fVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgdGhlIGxheWVyJ3MgY3VycmVudCBzdGF0ZSB0byBhIG5ldyB2YWx1ZS4gSWYgdHJhbnNpdGlvblRpbWUgaXMgZGVmaW5lZFxyXG4gICAqIGFuZCBncmVhdGVyIHRoYW4gemVybywgcGVyZm9ybSBhIHNtb290aCBibGVuZCBiZXR3ZWVuIGFueSBzdGF0ZXMgdGhhdCBjdXJyZW50bHlcclxuICAgKiBoYXZlIG5vbi16ZXJvIHdlaWdodCB2YWx1ZXMgYW5kIHRoZSBuZXcgc3RhdGUuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHsoc3RyaW5nfG51bGwpfSBuYW1lIC0gTmFtZSBvZiB0aGUgc3RhdGUgdG8gdHJhbnNpdGlvbiB0by5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGxheU1ldGhvZCAtIE5hbWUgb2YgdGhlIG9wZXJhdGlvbiBiZWluZyBwcmVwYXJlZCBmb3IsIHRvIGJlXHJcbiAgICogdXNlZCBpbiBlcnJvciBtZXNzYWdpbmcuXHJcbiAgICogQHBhcmFtIHtudW1iZXI9fSB0cmFuc2l0aW9uVGltZSAtIEFtb3VudCBvZiB0aW1lIGluIHNlY29uZHMgaXQgd2lsbCB0YWtlIHRvXHJcbiAgICogc3dpdGNoIHRvIHRoZSBuZXcgc3RhdGUuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IGVhc2luZ0ZuIC0gRWFzaW5nIGZ1bmN0aW9uIHRvIHVzZSB3aGVuIHRyYW5zaXRpb25pbmcgdG8gYVxyXG4gICAqIG5ldyBzdGF0ZSBvdmVyIHRpbWUuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uRXJyb3IgLSBGdW5jdGlvbiB0byBleGVjdXRlIGlmIGFuIGVycm9yIGlzIGVuY291bnRlcmVkLlxyXG4gICAqL1xyXG4gIF9wcmVwYXJlQ3VycmVudFN0YXRlKG5hbWUsIHBsYXlNZXRob2QsIHRyYW5zaXRpb25UaW1lLCBlYXNpbmdGbiwgb25FcnJvcikge31cclxuXHJcbiAgLyoqXHJcbiAgICogU3RhcnQgcGxheWJhY2sgYW4gYW5pbWF0aW9uIGZyb20gdGhlIGJlZ2lubmluZy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgYW5pbWF0aW9uIHRvIHBsYXkuXHJcbiAgICogQHBhcmFtIHtudW1iZXI9fSB0cmFuc2l0aW9uVGltZSAtIEFtb3VudCBvZiB0aW1lIGl0IHdpbGwgdGFrZSBiZWZvcmUgdGhlXHJcbiAgICogbmV3IHN0YXRlIGhhcyBmdWxsIGluZmx1ZW5jZSBmb3IgdGhlIGxheWVyLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBlYXNpbmdGbiAtIEVhc2luZyBmdW5jdGlvbiB0byB1c2UgZm9yIGJsZW5kaW5nIGlmIHRyYW5zaXRpb25UaW1lXHJcbiAgICogaXMgZ3JlYXRlciB0aGFuIHplcm8uXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uRmluaXNoIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSB3aGVuIHRoZSBhbmltYXRpb24gZmluaXNoZXMuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uRXJyb3IgLSBGdW5jdGlvbiB0byBleGVjdXRlIGlmIHRoZSBhbmltYXRpb24gZW5jb3VudGVyc1xyXG4gICAqIGFuIGVycm9yIGR1cmluZyBwbGF5YmFjay5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25DYW5jZWwgLSBGdW5jdGlvbiB0byBleGVjdXRlIGlmIHBsYXliYWNrIGlzIGNhbmNlbGVkLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbk5leHQgLSBGdW5jdGlvbiB0byBleGVjdXRlIGlmIGFuIGFuaW1hdGlvbiBxdWV1ZSBpc1xyXG4gICAqIHBsYXllZCBhbmQgaXQgYWR2YW5jZXMgdG8gdGhlIG5leHQgYW5pbWF0aW9uLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0RlZmVycmVkfVxyXG4gICAqL1xyXG4gIHBsYXlBbmltYXRpb24oXHJcbiAgICBuYW1lLFxyXG4gICAgdHJhbnNpdGlvblRpbWUsXHJcbiAgICBlYXNpbmdGbixcclxuICAgIG9uRmluaXNoLFxyXG4gICAgb25FcnJvcixcclxuICAgIG9uQ2FuY2VsLFxyXG4gICAgb25OZXh0XHJcbiAgKSB7fVxyXG5cclxuICAvKipcclxuICAgKiBDYW5jZWwgcGxheWJhY2sgb2YgdGhlIGN1cnJlbnQgYW5pbWF0aW9uLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgY2FuY2VsQW5pbWF0aW9uKCkge31cclxuXHJcbiAgLyoqXHJcbiAgICogUGF1c2UgcGxheWJhY2sgb2YgdGhlIGN1cnJlbnQgYW5pbWF0aW9uLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgcGF1c2VBbmltYXRpb24oKSB7fVxyXG5cclxuICAvKipcclxuICAgKiBSZXN1bWUgcGxheWJhY2sgb2YgYW4gYW5pbWF0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBuYW1lIC0gTmFtZSBvZiB0aGUgYW5pbWF0aW9uIHRvIHJlc3VtZSBwbGF5YmFjayBmb3IuIERlZmF1bHRcclxuICAgKiBpcyB0aGUgbGF5ZXIncyBjdXJyZW50IGFuaW1hdGlvbiBuYW1lLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gdHJhbnNpdGlvblRpbWUgLSBBbW91bnQgb2YgdGltZSBpdCB3aWxsIHRha2UgYmVmb3JlIHRoZVxyXG4gICAqIG5ldyBzdGF0ZSBoYXMgZnVsbCBpbmZsdWVuY2UgZm9yIHRoZSBsYXllci5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25GaW5pc2ggLSBGdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gdGhlIHN0YXRlIGZpbmlzaGVzLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbkVycm9yIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSBpZiB0aGUgc3RhdGUgZW5jb3VudGVyc1xyXG4gICAqIGFuIGVycm9yIGR1cmluZyBwbGF5YmFjay5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25DYW5jZWwgLSBGdW5jdGlvbiB0byBleGVjdXRlIGlmIHBsYXliYWNrIGlzIGNhbmNlbGVkLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbk5leHQgLSBGdW5jdGlvbiB0byBleGVjdXRlIGlmIGFuIGFuaW1hdGlvbiBxdWV1ZSBpc1xyXG4gICAqIHBsYXllZCBhbmQgaXQgYWR2YW5jZXMgdG8gdGhlIG5leHQgYW5pbWF0aW9uLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0RlZmVycmVkfVxyXG4gICAqL1xyXG4gIHJlc3VtZUFuaW1hdGlvbihcclxuICAgIG5hbWUsXHJcbiAgICB0cmFuc2l0aW9uVGltZSxcclxuICAgIGVhc2luZ0ZuLFxyXG4gICAgb25GaW5pc2gsXHJcbiAgICBvbkVycm9yLFxyXG4gICAgb25DYW5jZWwsXHJcbiAgICBvbk5leHRcclxuICApIHt9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0b3AgcGxheWJhY2sgb2YgdGhlIGN1cnJlbnQgYW5pbWF0aW9uLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgc3RvcEFuaW1hdGlvbigpIHt9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSB0aGUgY3VycmVudCBhbmltYXRpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGFUaW1lIC0gVGltZSBpbiBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGxhc3QgdXBkYXRlLlxyXG4gICAqL1xyXG4gIHVwZGF0ZShkZWx0YVRpbWUpIHt9XHJcblxyXG4gIC8qKlxyXG4gICAqIERpc2NhcmQgdGhlIHRyYW5zaXRpb24gc3RhdGUuXHJcbiAgICovXHJcbiAgZGlzY2FyZCgpIHt9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBjbGFzcyB0aGF0IGltcGxlbWVudHMge0BsaW5rIEFuaW1hdGlvblBsYXllckludGVyZmFjZX0gYW5kIGV4dGVuZHNcclxuICAgKiBhIHNwZWNpZmllZCBiYXNlIGNsYXNzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtDbGFzc30gW0Jhc2VDbGFzcyA9IGNsYXNze31dIC0gVGhlIGNsYXNzIHRvIGV4dGVuZC5cclxuICAgKlxyXG4gICAqIEByZXR1cm4ge0NsYXNzfSBBIGNsYXNzIHRoYXQgZXh0ZW5kcyBgQmFzZUNsYXNzYCBhbmQgaW1wbGVtZW50cyB7QGxpbmsgQW5pbWF0aW9uUGxheWVySW50ZXJmYWNlfS5cclxuICAgKi9cclxuICBzdGF0aWMgTWl4aW4oQmFzZUNsYXNzID0gY2xhc3Mge30pIHtcclxuICAgIGNvbnN0IEFuaW1hdGlvblBsYXllck1peGluID0gY2xhc3MgZXh0ZW5kcyBCYXNlQ2xhc3Mge1xyXG4gICAgICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30sIC4uLmFyZ3MpIHtcclxuICAgICAgICBzdXBlcihvcHRpb25zLCAuLi5hcmdzKTtcclxuXHJcbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvblN0YXRlID0gbmV3IFRyYW5zaXRpb25TdGF0ZSgpO1xyXG4gICAgICAgIHRoaXMuX3N0YXRlcyA9IHRoaXMuX3N0YXRlcyAhPT0gdW5kZWZpbmVkID8gdGhpcy5fc3RhdGVzIDogbmV3IE1hcCgpO1xyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRTdGF0ZSA9IG51bGw7XHJcbiAgICAgICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XHJcblxyXG4gICAgICAgIHRoaXMuX3RyYW5zaXRpb25UaW1lID1cclxuICAgICAgICAgIE51bWJlcihvcHRpb25zLnRyYW5zaXRpb25UaW1lKSA+PSAwXHJcbiAgICAgICAgICAgID8gTnVtYmVyKG9wdGlvbnMudHJhbnNpdGlvblRpbWUpXHJcbiAgICAgICAgICAgIDogMDtcclxuXHJcbiAgICAgICAgdGhpcy5fZWFzaW5nRm4gPVxyXG4gICAgICAgICAgdHlwZW9mIG9wdGlvbnMuZWFzaW5nRm4gPT09ICdmdW5jdGlvbicgPyBvcHRpb25zLmVhc2luZ0ZuIDogdW5kZWZpbmVkO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBnZXQgcGF1c2VkKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wYXVzZWQ7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGdldCB0cmFuc2l0aW9uVGltZSgpIHtcclxuICAgICAgICByZXR1cm4gdGhpcy5fdHJhbnNpdGlvblRpbWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNldCB0cmFuc2l0aW9uVGltZShzZWNvbmRzKSB7XHJcbiAgICAgICAgc2Vjb25kcyA9IE51bWJlcihzZWNvbmRzKTtcclxuXHJcbiAgICAgICAgaWYgKCEoc2Vjb25kcyA+PSAwKSkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICBgQ2Fubm90IHNldCB0cmFuc2l0aW9uIHRpbWUgZm9yICR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSB0byAke3NlY29uZHN9LiBTZWNvbmRzIG11c3QgYmUgYSBudW1lcmljIHZhbHVlIGdyZWF0aGVyIHRoYW4gb3IgZXF1YWwgdG8gemVyby5gXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgdGhpcy5fdHJhbnNpdGlvblRpbWUgPSBzZWNvbmRzO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBnZXQgZWFzaW5nRm4oKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMuX2Vhc2luZ0ZuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBzZXQgZWFzaW5nRm4oZm4pIHtcclxuICAgICAgICB0aGlzLl9lYXNpbmdGbiA9IGZuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBnZXQgY3VycmVudFN0YXRlKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50U3RhdGU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGdldCBjdXJyZW50QW5pbWF0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50U3RhdGUpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50U3RhdGUubmFtZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBudWxsO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBnZXQgaXNUcmFuc2l0aW9uaW5nKCkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50U3RhdGUgPT09IHRoaXMuX3RyYW5zaXRpb25TdGF0ZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgX3ByZXBhcmVDdXJyZW50U3RhdGUoXHJcbiAgICAgICAgbmFtZSxcclxuICAgICAgICBwbGF5TWV0aG9kLFxyXG4gICAgICAgIHRyYW5zaXRpb25UaW1lLFxyXG4gICAgICAgIGVhc2luZ0ZuLFxyXG4gICAgICAgIG9uRXJyb3JcclxuICAgICAgKSB7XHJcbiAgICAgICAgaWYgKG5hbWUgIT09IG51bGwgJiYgIXRoaXMuX3N0YXRlcy5oYXMobmFtZSkpIHtcclxuICAgICAgICAgIGNvbnN0IGUgPSBuZXcgRXJyb3IoXHJcbiAgICAgICAgICAgIGBDYW5ub3QgJHtwbGF5TWV0aG9kfSBhbmltYXRpb24gJHtuYW1lfS4gTm8gYW5pbWF0aW9uIGV4aXN0cyB3aXRoIHRoaXMgbmFtZS5gXHJcbiAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgIGlmICh0eXBlb2Ygb25FcnJvciA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgICAgICBvbkVycm9yKGUpO1xyXG4gICAgICAgICAgfVxyXG5cclxuICAgICAgICAgIHRocm93IGU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCB0YXJnZXRTdGF0ZSA9IG5hbWUgIT09IG51bGwgPyB0aGlzLl9zdGF0ZXMuZ2V0KG5hbWUpIDogbnVsbDtcclxuXHJcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBuZXcgc3RhdGUgaXNuJ3QgYWxyZWFkeSBwbGF5aW5nXHJcbiAgICAgICAgaWYgKHRoaXMuY3VycmVudEFuaW1hdGlvbiAhPT0gbmFtZSkge1xyXG4gICAgICAgICAgLy8gU3dpdGNoIHRvIHRoZSBuZXcgc3RhdGUgaW1tZWRpYXRlbHlcclxuICAgICAgICAgIGlmICh0cmFuc2l0aW9uVGltZSA8PSAwKSB7XHJcbiAgICAgICAgICAgIC8vIENhbmNlbCB0aGUgY3VycmVudCBzdGF0ZSBhbmQgc2V0IGl0cyB3ZWlnaHQgdG8gMFxyXG4gICAgICAgICAgICBpZiAodGhpcy5fY3VycmVudFN0YXRlKSB7XHJcbiAgICAgICAgICAgICAgdGhpcy5fY3VycmVudFN0YXRlLmNhbmNlbCgpO1xyXG4gICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRTdGF0ZS53ZWlnaHQgPSAwO1xyXG4gICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRTdGF0ZS5kZWFjdGl2YXRlKCk7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRTdGF0ZSA9IHRhcmdldFN0YXRlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgLy8gQmxlbmQgdG8gdGhlIG5ldyBzdGF0ZSBvdmVyIHRpbWVcclxuICAgICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgICAvLyBNYWtlIHN1cmUgdG8gdHJhbnNpdGlvbiBvdXQgb2YgYW55IHN0YXRlcyB3aXRoIG5vbi16ZXJvIHdlaWdodFxyXG4gICAgICAgICAgICBjb25zdCBjdXJyZW50U3RhdGVzID0gWy4uLnRoaXMuX3N0YXRlcy52YWx1ZXMoKV0uZmlsdGVyKFxyXG4gICAgICAgICAgICAgIHMgPT4gcyAhPT0gdGFyZ2V0U3RhdGUgJiYgKHMud2VpZ2h0IHx8IHMud2VpZ2h0UGVuZGluZylcclxuICAgICAgICAgICAgKTtcclxuXHJcbiAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgdHJhbnNpdGlvbiBzdGF0ZSB3aXRoIG5ldyBpbnB1dHNcclxuICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvblN0YXRlLmNvbmZpZ3VyZShcclxuICAgICAgICAgICAgICBjdXJyZW50U3RhdGVzLFxyXG4gICAgICAgICAgICAgIHRhcmdldFN0YXRlLFxyXG4gICAgICAgICAgICAgIHRyYW5zaXRpb25UaW1lLFxyXG4gICAgICAgICAgICAgIGVhc2luZ0ZuLFxyXG4gICAgICAgICAgICAgICgpID0+IHtcclxuICAgICAgICAgICAgICAgIHRoaXMuX2N1cnJlbnRTdGF0ZSA9IHRhcmdldFN0YXRlO1xyXG4gICAgICAgICAgICAgICAgdGhpcy5fdHJhbnNpdGlvblN0YXRlLndlaWdodCA9IDA7XHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudFN0YXRlID0gdGhpcy5fdHJhbnNpdGlvblN0YXRlO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0gZWxzZSBpZiAocGxheU1ldGhvZCA9PT0gJ3BsYXknKSB7XHJcbiAgICAgICAgICB0aGlzLl9jdXJyZW50U3RhdGUuY2FuY2VsKCk7XHJcblxyXG4gICAgICAgICAgaWYgKHRoaXMuX2N1cnJlbnRTdGF0ZSA9PT0gdGhpcy5fdHJhbnNpdGlvblN0YXRlKSB7XHJcbiAgICAgICAgICAgIHRoaXMuX3RyYW5zaXRpb25TdGF0ZS5yZXNldCh0cmFuc2l0aW9uVGltZSwgZWFzaW5nRm4sICgpID0+IHtcclxuICAgICAgICAgICAgICB0aGlzLl9jdXJyZW50U3RhdGUgPSB0YXJnZXRTdGF0ZTtcclxuICAgICAgICAgICAgICB0aGlzLl90cmFuc2l0aW9uU3RhdGUud2VpZ2h0ID0gMDtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICAvLyBVcGRhdGUgd2VpZ2h0IGZvciB0aGUgbmV3IGN1cnJlbnQgc3RhdGUgc28gaXQgaGFzIGZ1bGwgaW5mbHVlbmNlIGZvciB0aGUgcGxheWVyXHJcbiAgICAgICAgdGhpcy5fY3VycmVudFN0YXRlLndlaWdodCA9IDE7XHJcbiAgICAgICAgdGhpcy5fY3VycmVudFN0YXRlLnVwZGF0ZUludGVybmFsV2VpZ2h0KHRoaXMuX2ludGVybmFsV2VpZ2h0KTtcclxuICAgICAgfVxyXG5cclxuICAgICAgcGxheUFuaW1hdGlvbihcclxuICAgICAgICBuYW1lLFxyXG4gICAgICAgIHRyYW5zaXRpb25UaW1lLFxyXG4gICAgICAgIGVhc2luZ0ZuLFxyXG4gICAgICAgIG9uRmluaXNoLFxyXG4gICAgICAgIG9uRXJyb3IsXHJcbiAgICAgICAgb25DYW5jZWwsXHJcbiAgICAgICAgb25OZXh0XHJcbiAgICAgICkge1xyXG4gICAgICAgIGxldCBlcnJvcjtcclxuICAgICAgICBsZXQgcmVqZWN0ID0gZmFsc2U7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgIHRoaXMuX3ByZXBhcmVDdXJyZW50U3RhdGUoXHJcbiAgICAgICAgICAgIG5hbWUsXHJcbiAgICAgICAgICAgICdwbGF5JyxcclxuICAgICAgICAgICAgdHJhbnNpdGlvblRpbWUgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgID8gdHJhbnNpdGlvblRpbWVcclxuICAgICAgICAgICAgICA6IHRoaXMuX3RyYW5zaXRpb25UaW1lLFxyXG4gICAgICAgICAgICBlYXNpbmdGbiAhPT0gdW5kZWZpbmVkID8gZWFzaW5nRm4gOiB0aGlzLl9lYXNpbmdGbixcclxuICAgICAgICAgICAgb25FcnJvclxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICBlcnJvciA9IGU7XHJcbiAgICAgICAgICByZWplY3QgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHJlamVjdCkge1xyXG4gICAgICAgICAgcmV0dXJuIERlZmVycmVkLnJlamVjdChlcnJvcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudFN0YXRlLnBsYXkob25GaW5pc2gsIG9uRXJyb3IsIG9uQ2FuY2VsLCBvbk5leHQpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBwYXVzZUFuaW1hdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy5fY3VycmVudFN0YXRlKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudFN0YXRlLnBhdXNlKCk7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJlc3VtZUFuaW1hdGlvbihcclxuICAgICAgICBuYW1lLFxyXG4gICAgICAgIHRyYW5zaXRpb25UaW1lLFxyXG4gICAgICAgIGVhc2luZ0ZuLFxyXG4gICAgICAgIG9uRmluaXNoLFxyXG4gICAgICAgIG9uRXJyb3IsXHJcbiAgICAgICAgb25DYW5jZWwsXHJcbiAgICAgICAgb25OZXh0XHJcbiAgICAgICkge1xyXG4gICAgICAgIGlmIChuYW1lID09PSB1bmRlZmluZWQgJiYgdGhpcy5fY3VycmVudFN0YXRlKSB7XHJcbiAgICAgICAgICBuYW1lID0gdGhpcy5fY3VycmVudFN0YXRlLm5hbWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBsZXQgZXJyb3I7XHJcbiAgICAgICAgbGV0IHJlamVjdCA9IGZhbHNlO1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICB0aGlzLl9wcmVwYXJlQ3VycmVudFN0YXRlKFxyXG4gICAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgICAncmVzdW1lJyxcclxuICAgICAgICAgICAgdHJhbnNpdGlvblRpbWUgIT09IHVuZGVmaW5lZFxyXG4gICAgICAgICAgICAgID8gdHJhbnNpdGlvblRpbWVcclxuICAgICAgICAgICAgICA6IHRoaXMuX3RyYW5zaXRpb25UaW1lLFxyXG4gICAgICAgICAgICBlYXNpbmdGbiAhPT0gdW5kZWZpbmVkID8gZWFzaW5nRm4gOiB0aGlzLl9lYXNpbmdGbixcclxuICAgICAgICAgICAgb25FcnJvclxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7XHJcbiAgICAgICAgICBlcnJvciA9IGU7XHJcbiAgICAgICAgICByZWplY3QgPSB0cnVlO1xyXG4gICAgICAgIH1cclxuXHJcbiAgICAgICAgaWYgKHJlamVjdCkge1xyXG4gICAgICAgICAgcmV0dXJuIERlZmVycmVkLnJlamVjdChlcnJvcik7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudFN0YXRlLnJlc3VtZShvbkZpbmlzaCwgb25FcnJvciwgb25DYW5jZWwsIG9uTmV4dCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGNhbmNlbEFuaW1hdGlvbigpIHtcclxuICAgICAgICBpZiAodGhpcy5fY3VycmVudFN0YXRlKSB7XHJcbiAgICAgICAgICByZXR1cm4gdGhpcy5fY3VycmVudFN0YXRlLmNhbmNlbCgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBzdG9wQW5pbWF0aW9uKCkge1xyXG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50U3RhdGUpIHtcclxuICAgICAgICAgIHJldHVybiB0aGlzLl9jdXJyZW50U3RhdGUuc3RvcCgpO1xyXG4gICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICB1cGRhdGUoZGVsdGFUaW1lKSB7XHJcbiAgICAgICAgaWYgKHN1cGVyLnVwZGF0ZSkge1xyXG4gICAgICAgICAgc3VwZXIudXBkYXRlKGRlbHRhVGltZSk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBpZiAodGhpcy5fY3VycmVudFN0YXRlKSB7XHJcbiAgICAgICAgICB0aGlzLl9jdXJyZW50U3RhdGUudXBkYXRlKGRlbHRhVGltZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcblxyXG4gICAgICBkaXNjYXJkKCkge1xyXG4gICAgICAgIGlmIChzdXBlci5kaXNjYXJkKSB7XHJcbiAgICAgICAgICBzdXBlci5kaXNjYXJkKCk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl90cmFuc2l0aW9uU3RhdGUuZGlzY2FyZCgpO1xyXG4gICAgICAgIGRlbGV0ZSB0aGlzLl90cmFuc2l0aW9uU3RhdGU7XHJcbiAgICAgIH1cclxuICAgIH07XHJcblxyXG4gICAgcmV0dXJuIEFuaW1hdGlvblBsYXllck1peGluO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQW5pbWF0aW9uUGxheWVySW50ZXJmYWNlO1xyXG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXHJcbi8qIGVzbGludC1kaXNhYmxlIG1heC1jbGFzc2VzLXBlci1maWxlICovXHJcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXHJcbi8qIGVzbGludC1kaXNhYmxlIG5vLWVtcHR5LWZ1bmN0aW9uICovXHJcbi8qIGVzbGludC1kaXNhYmxlIGdldHRlci1yZXR1cm4gKi9cclxuXHJcbmltcG9ydCBVdGlscyBmcm9tICcuLi8uLi9VdGlscyc7XHJcblxyXG4vKipcclxuICogQ2xhc3MgZmFjdG9yeSBpbnRlcmZhY2UgZm9yIG1hbmlwdWxhdGluZyBhIGNvbGxlY3Rpb24gb2Yge0BsaW5rIEFic3RyYWN0U3RhdGV9LlxyXG4gKlxyXG4gKiBAaW50ZXJmYWNlXHJcbiAqL1xyXG5jbGFzcyBTdGF0ZUNvbnRhaW5lckludGVyZmFjZSB7XHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIHRoZSBzdGF0ZSB3aXRoIHRoZSBnaXZlbiBuYW1lLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBzdGF0ZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtBYnN0cmFjdFN0YXRlfVxyXG4gICAqL1xyXG4gIGdldFN0YXRlKG5hbWUpIHt9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgYW4gYXJyYXkgb2YgdGhlIG5hbWVzIG9mIGFsbCBzdGF0ZXMgaW4gdGhlIGNvbnRhaW5lci5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cclxuICAgKi9cclxuICBnZXRTdGF0ZU5hbWVzKCkge31cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkIGEgbmV3IHN0YXRlIHRvIGJlIGNvbnRyb2xsZWQgYnkgdGhlIGNvbnRhaW5lci4gU3RhdGVzIGFyZSBzdG9yZWQga2V5ZWRcclxuICAgKiBieSB0aGVpciBuYW1lIHByb3BlcnR5LCB3aGljaCBtdXN0IGJlIHVuaXF1ZS4gSWYgaXQgaXNuJ3QsIGEgbnVtYmVyIHdpbGxcclxuICAgKiBiZSBhZGRlZCBvciBpbmNyZW1lbnRlZCB1bnRpbCBhIHVuaXF1ZSBrZXkgaXMgZ2VuZXJhdGVkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBYnN0cmFjdFN0YXRlfSBzdGF0ZSAtIFN0YXRlIHRvIGFkZCB0byB0aGUgY29udGFpbmVyLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge3N0cmluZ30gLSBVbmlxdWUgbmFtZSBvZiB0aGUgc3RhdGUuXHJcbiAgICovXHJcbiAgYWRkU3RhdGUoc3RhdGUpIHt9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZXMgYSBzdGF0ZSB3aXRoIHRoZSBnaXZlbiBuYW1lIGZyb20gdGhlIGNvbnRhaW5lci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgc3RhdGUgdG8gcmVtb3ZlLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59IC0gV2hldGhlciBvciBub3QgYSBzdGF0ZSB3YXMgcmVtb3ZlZC5cclxuICAgKi9cclxuICByZW1vdmVTdGF0ZShuYW1lKSB7fVxyXG5cclxuICAvKipcclxuICAgKiBSZW5hbWVzIGEgc3RhdGUgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpbiB0aGUgY29udGFpbmVyLiBOYW1lIG11c3QgYmUgdW5pcXVlXHJcbiAgICogdG8gdGhlIGNvbnRhaW5lciwgaWYgaXQgaXNuJ3QgdGhlIG5hbWUgd2lsbCBiZSBpbmNyZW1lbnRlZCB1bnRpbCBpdCBpcyB1bmlxdWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gY3VycmVudE5hbWUgLSBOYW1lIG9mIHRoZSBzdGF0ZSB0byByZW5hbWUuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5ld05hbWUgLSBOYW1lIHRvIHVwZGF0ZSB0aGUgc3RhdGUgd2l0aC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVXBkYXRlZCBuYW1lIGZvciB0aGUgc3RhdGUuXHJcbiAgICovXHJcbiAgcmVuYW1lU3RhdGUoY3VycmVudE5hbWUsIG5ld05hbWUpIHt9XHJcblxyXG4gIC8qKlxyXG4gICAqIERpc2NhcmRzIGFsbCBzdGF0ZXMuXHJcbiAgICovXHJcbiAgZGlzY2FyZFN0YXRlcygpIHt9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZXMgYSBjbGFzcyB0aGF0IGltcGxlbWVudHMge0BsaW5rIFN0YXRlQ29udGFpbmVySW50ZXJmYWNlfSBhbmQgZXh0ZW5kc1xyXG4gICAqIGEgc3BlY2lmaWVkIGJhc2UgY2xhc3MuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0NsYXNzfSBbQmFzZUNsYXNzID0gY2xhc3N7fV0gLSBUaGUgY2xhc3MgdG8gZXh0ZW5kLlxyXG4gICAqXHJcbiAgICogQHJldHVybiB7Q2xhc3N9IEEgY2xhc3MgdGhhdCBleHRlbmRzIGBCYXNlQ2xhc3NgIGFuZCBpbXBsZW1lbnRzIHtAbGluayBTdGF0ZUNvbnRhaW5lckludGVyZmFjZX0uXHJcbiAgICovXHJcbiAgc3RhdGljIE1peGluKEJhc2VDbGFzcyA9IGNsYXNzIHt9KSB7XHJcbiAgICAvKipcclxuICAgICAqIFRoaXMgbWl4aW4gYWRkcyBmdW5jdGlvbmFsaXR5IGZvciBtYW5pcHVsYXRpbmcgdW5pcXVlbHktbmFtZWQgYW5pbWF0aW9uIHN0YXRlcyBpblxyXG4gICAgICogYSBtYXAuXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IFN0YXRlQ29udGFpbmVyTWl4aW4gPSBjbGFzcyBleHRlbmRzIEJhc2VDbGFzcyB7XHJcbiAgICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSwgLi4uYXJncykge1xyXG4gICAgICAgIHN1cGVyKG9wdGlvbnMsIC4uLmFyZ3MpO1xyXG5cclxuICAgICAgICB0aGlzLl9zdGF0ZXMgPSB0aGlzLl9zdGF0ZXMgIT09IHVuZGVmaW5lZCA/IHRoaXMuX3N0YXRlcyA6IG5ldyBNYXAoKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZ2V0U3RhdGUobmFtZSkge1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9zdGF0ZXMuZ2V0KG5hbWUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBnZXRTdGF0ZU5hbWVzKCkge1xyXG4gICAgICAgIHJldHVybiBbLi4udGhpcy5fc3RhdGVzLmtleXMoKV07XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIGFkZFN0YXRlKHN0YXRlKSB7XHJcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBzdGF0ZSBpcyBub3QgYWxyZWFkeSBpbiB0aGlzIGNvbnRhaW5lclxyXG4gICAgICAgIGlmIChbLi4udGhpcy5fc3RhdGVzLnZhbHVlcygpXS5pbmNsdWRlcyhzdGF0ZSkpIHtcclxuICAgICAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICAgICAgYENhbm5vdCBhZGQgYW5pbWF0aW9uIHRvIHN0YXRlICR7dGhpcy5uYW1lfS4gQW5pbWF0aW9uIHdhcyBhbHJlYWR5IGFkZGVkLmBcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICByZXR1cm4gc3RhdGUubmFtZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgc3RhdGUgbmFtZSBpcyB1bmlxdWVcclxuICAgICAgICBjb25zdCB1bmlxdWVOYW1lID0gVXRpbHMuZ2V0VW5pcXVlTmFtZShzdGF0ZS5uYW1lLCBbXHJcbiAgICAgICAgICAuLi50aGlzLl9zdGF0ZXMua2V5cygpLFxyXG4gICAgICAgIF0pO1xyXG5cclxuICAgICAgICBpZiAoc3RhdGUubmFtZSAhPT0gdW5pcXVlTmFtZSkge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKFxyXG4gICAgICAgICAgICBgQW5pbWF0aW9uIG5hbWUgJHtzdGF0ZS5uYW1lfSBpcyBub3QgdW5pcXVlIGZvciBzdGF0ZSAke3RoaXMubmFtZX0uIE5ldyBhbmltYXRpb24gd2lsbCBiZSBhZGRlZCB3aXRoIG5hbWUgJHt1bmlxdWVOYW1lfS5gXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgc3RhdGUubmFtZSA9IHVuaXF1ZU5hbWU7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICB0aGlzLl9zdGF0ZXMuc2V0KHN0YXRlLm5hbWUsIHN0YXRlKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHN0YXRlLm5hbWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJlbW92ZVN0YXRlKG5hbWUpIHtcclxuICAgICAgICAvLyBDaGVjayBpZiB0aGUgc3RhdGUgaXMgaW4gdGhpcyBjb250YWluZXJcclxuICAgICAgICBpZiAoIXRoaXMuX3N0YXRlcyB8fCAhdGhpcy5fc3RhdGVzLmhhcyhuYW1lKSkge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKFxyXG4gICAgICAgICAgICBgRGlkIG5vdCByZW1vdmUgYW5pbWF0aW9uICR7bmFtZX0gZnJvbSBzdGF0ZSAke3RoaXMubmFtZX0uIE5vIGFuaW1hdGlvbiBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYFxyXG4gICAgICAgICAgKTtcclxuICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX3N0YXRlcy5nZXQobmFtZSkuZGlzY2FyZCgpO1xyXG4gICAgICAgIHRoaXMuX3N0YXRlcy5kZWxldGUobmFtZSk7XHJcbiAgICAgICAgcmV0dXJuIHRydWU7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHJlbmFtZVN0YXRlKGN1cnJlbnROYW1lLCBuZXdOYW1lKSB7XHJcbiAgICAgICAgLy8gTWFrZSBzdXJlIHRoZSBzdGF0ZSBpcyBpbiB0aGlzIGNvbnRhaW5lclxyXG4gICAgICAgIGlmICghdGhpcy5fc3RhdGVzIHx8ICF0aGlzLl9zdGF0ZXMuaGFzKGN1cnJlbnROYW1lKSkge1xyXG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgICBgQ2Fubm90IHJlbmFtZSBhbmltYXRpb24gJHtjdXJyZW50TmFtZX0gaW4gJHt0aGlzLm5hbWV9LiBObyBhbmltYXRpb24gZXhpc3RzIHdpdGggdGhpcyBuYW1lLmBcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zdCBzdGF0ZSA9IHRoaXMuX3N0YXRlcy5nZXQoY3VycmVudE5hbWUpO1xyXG5cclxuICAgICAgICAvLyBFeGl0IGlmIHRoZSBuYW1lcyBhcmUgdGhlIHNhbWVcclxuICAgICAgICBpZiAoY3VycmVudE5hbWUgPT09IG5ld05hbWUpIHtcclxuICAgICAgICAgIHJldHVybiBjdXJyZW50TmFtZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIE1ha2Ugc3VyZSB0aGUgbmFtZSBpcyB1bmlxdWVcclxuICAgICAgICBjb25zdCB1bmlxdWVOYW1lID0gVXRpbHMuZ2V0VW5pcXVlTmFtZShcclxuICAgICAgICAgIG5ld05hbWUsXHJcbiAgICAgICAgICBbLi4udGhpcy5fc3RhdGVzLmtleXMoKV0uZmlsdGVyKHMgPT4gcy5uYW1lICE9PSBjdXJyZW50TmFtZSlcclxuICAgICAgICApO1xyXG5cclxuICAgICAgICBpZiAobmV3TmFtZSAhPT0gdW5pcXVlTmFtZSkge1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKFxyXG4gICAgICAgICAgICBgQW5pbWF0aW9uIG5hbWUgJHtuZXdOYW1lfSBpcyBub3QgdW5pcXVlIGluIHN0YXRlICR7dGhpcy5uYW1lfS4gQW5pbWF0aW9uIHdpbGwgYmUgcmVuYW1lZCB0byAke3VuaXF1ZU5hbWV9LmBcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgICBuZXdOYW1lID0gdW5pcXVlTmFtZTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHN0YXRlLm5hbWUgPSBuZXdOYW1lO1xyXG4gICAgICAgIHRoaXMuX3N0YXRlcy5kZWxldGUoY3VycmVudE5hbWUpO1xyXG4gICAgICAgIHRoaXMuX3N0YXRlcy5zZXQoc3RhdGUubmFtZSwgc3RhdGUpO1xyXG5cclxuICAgICAgICByZXR1cm4gc3RhdGUubmFtZTtcclxuICAgICAgfVxyXG5cclxuICAgICAgZGlzY2FyZFN0YXRlcygpIHtcclxuICAgICAgICB0aGlzLl9zdGF0ZXMuZm9yRWFjaChzdGF0ZSA9PiB7XHJcbiAgICAgICAgICBzdGF0ZS5kaXNjYXJkKCk7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIGRlbGV0ZSB0aGlzLl9zdGF0ZXM7XHJcbiAgICAgIH1cclxuICAgIH07XHJcbiAgICByZXR1cm4gU3RhdGVDb250YWluZXJNaXhpbjtcclxuICB9XHJcbn1cclxuZXhwb3J0IGRlZmF1bHQgU3RhdGVDb250YWluZXJJbnRlcmZhY2U7XHJcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcclxuaW1wb3J0IEFic3RyYWN0U3RhdGUgZnJvbSAnLi9BYnN0cmFjdFN0YXRlJztcclxuaW1wb3J0IEFuaW1hdGlvblBsYXllckludGVyZmFjZSBmcm9tICcuLi9BbmltYXRpb25QbGF5ZXJJbnRlcmZhY2UnO1xyXG5pbXBvcnQgU3RhdGVDb250YWluZXJJbnRlcmZhY2UgZnJvbSAnLi9TdGF0ZUNvbnRhaW5lckludGVyZmFjZSc7XHJcblxyXG4vKipcclxuICogQ2xhc3MgZm9yIHBsYXlpbmcgYW4gb3JkZXJlZCBhcnJheSBvZiBhbmltYXRpb24gc3RhdGVzIGluIHNlcXVlbmNlLlxyXG4gKlxyXG4gKiBAZXh0ZW5kcyBBYnN0cmFjdFN0YXRlXHJcbiAqIEBpbXBsZW1lbnRzIEBBbmltYXRpb25QbGF5ZXJJbnRlcmZhY2VcclxuICovXHJcbmNsYXNzIFF1ZXVlU3RhdGUgZXh0ZW5kcyBBbmltYXRpb25QbGF5ZXJJbnRlcmZhY2UuTWl4aW4oXHJcbiAgU3RhdGVDb250YWluZXJJbnRlcmZhY2UuTWl4aW4oQWJzdHJhY3RTdGF0ZSlcclxuKSB7XHJcbiAgLyoqXHJcbiAgICogQGNvbnN0cnVjdG9yXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIC0gT3B0aW9ucyBmb3IgdGhlIHN0YXRlLlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW29wdGlvbnMuYXV0b0FkdmFuY2U9dHJ1ZV0gLSBXaGV0aGVyIHRvIGF1dG1hdGljYWxseSBhZHZhbmNlXHJcbiAgICogdG8gdGhlIG5leHQgc3RhdGUgaW4gdGhlIHF1ZXVlIGFzIGVhY2ggc3RhdGUgY29tcGxldGVzLlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPEFic3RyYWN0U3RhdGU+fSBbcXVldWVTdGF0ZXM9W11dIC0gQXJyYXkgb2Ygc3RhdGVzIHRvIGJlIHBsYXllZFxyXG4gICAqIGluIG9yZGVyLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSwgcXVldWVTdGF0ZXMgPSBbXSkge1xyXG4gICAgc3VwZXIob3B0aW9ucyk7XHJcblxyXG4gICAgcXVldWVTdGF0ZXMuZm9yRWFjaChzdGF0ZSA9PiB7XHJcbiAgICAgIHRoaXMuYWRkU3RhdGUoc3RhdGUpO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5fcXVldWUgPSB0aGlzLl9zdGF0ZXMua2V5cygpO1xyXG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHdoZXRoZXIgdGhlIGFuaW1hdGlvbiBxdWV1ZSBoYXMgcmVhY2hlZCB0aGUgZW5kLlxyXG4gICAqL1xyXG4gIGdldCBkb25lKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2RvbmU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSBpbnRlcm5hbCB3ZWlnaHQuXHJcbiAgICpcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCBpbnRlcm5hbFdlaWdodCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9jdXJyZW50U3RhdGVcclxuICAgICAgPyB0aGlzLl9jdXJyZW50U3RhdGUuaW50ZXJuYWxXZWlnaHQgKiB0aGlzLl9pbnRlcm5hbFdlaWdodFxyXG4gICAgICA6IDA7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXN0YXJ0IHRoZSBxdWV1ZSBpdGVyYXRvci5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX3Jlc2V0KCkge1xyXG4gICAgdGhpcy5fcXVldWUgPSB0aGlzLl9zdGF0ZXMua2V5cygpO1xyXG4gICAgY29uc3Qge3ZhbHVlLCBkb25lfSA9IHRoaXMuX3F1ZXVlLm5leHQoKTtcclxuICAgIHRoaXMuX2RvbmUgPSBkb25lO1xyXG5cclxuICAgIHJldHVybiB2YWx1ZSB8fCBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTXVsdGlwbGllcyB0aGUgdXNlciB3ZWlnaHQgYnkgYSBmYWN0b3IgdG8gZGV0ZXJtaW5lIHRoZSBpbnRlcm5hbCB3ZWlnaHQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gZmFjdG9yIC0gMC0xIG11bHRpcGxpZXIgdG8gYXBwbHkgdG8gdGhlIHVzZXIgd2VpZ2h0LlxyXG4gICAqL1xyXG4gIHVwZGF0ZUludGVybmFsV2VpZ2h0KGZhY3Rvcikge1xyXG4gICAgc3VwZXIudXBkYXRlSW50ZXJuYWxXZWlnaHQoZmFjdG9yKTtcclxuXHJcbiAgICBpZiAodGhpcy5fY3VycmVudFN0YXRlKSB7XHJcbiAgICAgIHRoaXMuX2N1cnJlbnRTdGF0ZS51cGRhdGVJbnRlcm5hbFdlaWdodCh0aGlzLl9pbnRlcm5hbFdlaWdodCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdGFydCB0aGUgbmV4dCBhbmltYXRpb24gaW4gdGhlIHF1ZXVlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uTmV4dCAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgZWFjaCB0aW1lIGFuIGFuaW1hdGlvbiBjb21wbGV0ZXNcclxuICAgKiBhbmQgdGhlIHF1ZXVlIG1vdmVzIHRvIHRoZSBuZXh0IGFuaW1hdGlvbi5cclxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFt3cmFwPWZhbHNlXSAtIFdoZXRoZXIgb3Igbm90IHRvIHN0YXJ0IHRoZSBxdWV1ZSBmcm9tIHRoZVxyXG4gICAqIGJlZ2lubmluZyBhZ2FpbiBpZiB0aGUgZW5kIGhhcyBiZWVuIHJlYWNoZWQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9XHJcbiAgICovXHJcbiAgbmV4dChvbk5leHQsIHdyYXAgPSBmYWxzZSkge1xyXG4gICAgLy8gTW92ZSB0aGUgcXVldWUgZm9yd2FyZFxyXG4gICAgY29uc3Qge3ZhbHVlOiBuYW1lLCBkb25lfSA9IHRoaXMuX3F1ZXVlLm5leHQoKTtcclxuICAgIHRoaXMuX2RvbmUgPSBkb25lO1xyXG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XHJcblxyXG4gICAgLy8gVGhlIHF1ZXVlIGhhcyByZWFjaGVkIHRoZSBlbmRcclxuICAgIGlmIChkb25lKSB7XHJcbiAgICAgIC8vIFN0YXJ0IHRoZSBxdWV1ZSBvdmVyXHJcbiAgICAgIGlmICh3cmFwKSB7XHJcbiAgICAgICAgcmV0dXJuIHRoaXMucGxheShcclxuICAgICAgICAgIHRoaXMuX3BsYXlDYWxsYmFja3Mub25GaW5pc2gsXHJcbiAgICAgICAgICB0aGlzLl9wbGF5Q2FsbGJhY2tzLm9uRXJyb3IsXHJcbiAgICAgICAgICB0aGlzLl9wbGF5Q2FsbGJhY2tzLm9uQ2FuY2VsLFxyXG4gICAgICAgICAgb25OZXh0XHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgICAvLyBTdG9wIHRoZSBxdWV1ZVxyXG4gICAgICBlbHNlIHtcclxuICAgICAgICB0aGlzLl9wcm9taXNlcy5maW5pc2gucmVzb2x2ZSgpO1xyXG4gICAgICAgIHJldHVybiB0aGlzLl9wcm9taXNlcy5maW5pc2g7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBTaWduYWwgdGhlIG5leHQgYW5pbWF0aW9uIGlzIHN0YXJ0aW5nXHJcbiAgICBpZiAodHlwZW9mIG9uTmV4dCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICBjb25zdCBsYXN0TmFtZSA9IFsuLi50aGlzLl9zdGF0ZXMua2V5cygpXVt0aGlzLl9zdGF0ZXMuc2l6ZSAtIDFdO1xyXG4gICAgICBjb25zdCBpc1F1ZXVlRW5kID0gbmFtZSA9PT0gbGFzdE5hbWU7XHJcbiAgICAgIG9uTmV4dCh7XHJcbiAgICAgICAgbmFtZSxcclxuICAgICAgICBjYW5BZHZhbmNlOiB0aGlzLmdldFN0YXRlKG5hbWUpLmxvb3BDb3VudCAhPT0gSW5maW5pdHkgJiYgIWlzUXVldWVFbmQsXHJcbiAgICAgICAgaXNRdWV1ZUVuZCxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gU3RhcnQgdGhlIG5leHQgYW5pbWF0aW9uXHJcbiAgICB0aGlzLnBsYXlBbmltYXRpb24oXHJcbiAgICAgIG5hbWUsXHJcbiAgICAgIHRoaXMuX3RyYW5zaXRpb25UaW1lLFxyXG4gICAgICB0aGlzLl9lYXNpbmdGbixcclxuICAgICAgKCkgPT4ge1xyXG4gICAgICAgIGlmICghdGhpcy5fcGF1c2VkICYmICF0aGlzLmlzVHJhbnNpdGlvbmluZykge1xyXG4gICAgICAgICAgdGhpcy5uZXh0KG9uTmV4dCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LFxyXG4gICAgICB0aGlzLl9wbGF5Q2FsbGJhY2tzLm9uRXJyb3JcclxuICAgICk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2VzLmZpbmlzaDtcclxuICB9XHJcblxyXG4gIHBsYXkob25GaW5pc2gsIG9uRXJyb3IsIG9uQ2FuY2VsLCBvbk5leHQpIHtcclxuICAgIGNvbnN0IG5hbWUgPSB0aGlzLl9yZXNldCgpO1xyXG4gICAgc3VwZXIucGxheShvbkZpbmlzaCwgb25FcnJvciwgb25DYW5jZWwpO1xyXG5cclxuICAgIGlmICh0aGlzLl9kb25lKSB7XHJcbiAgICAgIHRoaXMuX3Byb21pc2VzLmZpbmlzaC5yZXNvbHZlKCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBTaWduYWwgdGhlIG5leHQgYW5pbWF0aW9uIGlzIHN0YXJ0aW5nXHJcbiAgICAgIGlmIChuYW1lICE9PSB0aGlzLmN1cnJlbnRBbmltYXRpb24gJiYgdHlwZW9mIG9uTmV4dCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIGNvbnN0IGxhc3ROYW1lID0gWy4uLnRoaXMuX3N0YXRlcy5rZXlzKCldW3RoaXMuX3N0YXRlcy5zaXplIC0gMV07XHJcbiAgICAgICAgY29uc3QgaXNRdWV1ZUVuZCA9IG5hbWUgPT09IGxhc3ROYW1lO1xyXG4gICAgICAgIG9uTmV4dCh7XHJcbiAgICAgICAgICBuYW1lLFxyXG4gICAgICAgICAgY2FuQWR2YW5jZTogbmFtZVxyXG4gICAgICAgICAgICA/IHRoaXMuZ2V0U3RhdGUobmFtZSkubG9vcENvdW50ICE9PSBJbmZpbml0eSAmJiAhaXNRdWV1ZUVuZFxyXG4gICAgICAgICAgICA6IHRydWUsXHJcbiAgICAgICAgICBpc1F1ZXVlRW5kOiAhbmFtZSB8fCBpc1F1ZXVlRW5kLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBTdGFydCB0aGUgbmV4dCBhbmltYXRpb25cclxuICAgICAgdGhpcy5wbGF5QW5pbWF0aW9uKFxyXG4gICAgICAgIG5hbWUsXHJcbiAgICAgICAgdGhpcy5fY3VycmVudFN0YXRlID8gdGhpcy5fdHJhbnNpdGlvblRpbWUgOiAwLFxyXG4gICAgICAgIHRoaXMuX2Vhc2luZ0ZuLFxyXG4gICAgICAgICgpID0+IHtcclxuICAgICAgICAgIGlmICghdGhpcy5fcGF1c2VkICYmICF0aGlzLmlzVHJhbnNpdGlvbmluZykge1xyXG4gICAgICAgICAgICB0aGlzLm5leHQob25OZXh0KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIG9uRXJyb3JcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZXMuZmluaXNoO1xyXG4gIH1cclxuXHJcbiAgcGF1c2UoKSB7XHJcbiAgICBjb25zdCBwYXVzZWQgPSBzdXBlci5wYXVzZSgpO1xyXG4gICAgdGhpcy5wYXVzZUFuaW1hdGlvbigpO1xyXG5cclxuICAgIHJldHVybiBwYXVzZWQ7XHJcbiAgfVxyXG5cclxuICByZXN1bWUob25GaW5pc2gsIG9uRXJyb3IsIG9uQ2FuY2VsLCBvbk5leHQpIHtcclxuICAgIGlmICh0aGlzLl9kb25lKSB7XHJcbiAgICAgIHJldHVybiB0aGlzLnBsYXkob25GaW5pc2gsIG9uRXJyb3IsIG9uQ2FuY2VsLCBvbk5leHQpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc3VwZXIucmVzdW1lKG9uRmluaXNoLCBvbkVycm9yLCBvbkNhbmNlbCk7XHJcblxyXG4gICAgICB0aGlzLnJlc3VtZUFuaW1hdGlvbihcclxuICAgICAgICB0aGlzLl9jdXJyZW50U3RhdGUubmFtZSxcclxuICAgICAgICB0aGlzLl90cmFuc2l0aW9uVGltZSxcclxuICAgICAgICB0aGlzLl9lYXNpbmdGbixcclxuICAgICAgICAoKSA9PiB7XHJcbiAgICAgICAgICBpZiAoIXRoaXMuX3BhdXNlZCAmJiAhdGhpcy5pc1RyYW5zaXRpb25pbmcpIHtcclxuICAgICAgICAgICAgdGhpcy5uZXh0KG9uTmV4dCk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBvbkVycm9yXHJcbiAgICAgICk7XHJcblxyXG4gICAgICByZXR1cm4gdGhpcy5fcHJvbWlzZXMuZmluaXNoO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgY2FuY2VsKCkge1xyXG4gICAgY29uc3QgY2FuY2VsZWQgPSBzdXBlci5jYW5jZWwoKTtcclxuXHJcbiAgICBpZiAodGhpcy5fY3VycmVudFN0YXRlKSB7XHJcbiAgICAgIHRoaXMuX2N1cnJlbnRTdGF0ZS5jYW5jZWwoKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gY2FuY2VsZWQ7XHJcbiAgfVxyXG5cclxuICBzdG9wKCkge1xyXG4gICAgY29uc3Qgc3RvcHBlZCA9IHN1cGVyLnN0b3AoKTtcclxuICAgIHRoaXMuc3RvcEFuaW1hdGlvbigpO1xyXG4gICAgdGhpcy5fZG9uZSA9IHRydWU7XHJcblxyXG4gICAgcmV0dXJuIHN0b3BwZWQ7XHJcbiAgfVxyXG5cclxuICBkaXNjYXJkKCkge1xyXG4gICAgc3VwZXIuZGlzY2FyZCgpO1xyXG5cclxuICAgIHRoaXMuZGlzY2FyZFN0YXRlcygpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgUXVldWVTdGF0ZTtcclxuIiwiLy8gQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxyXG5pbXBvcnQgRGVmZXJyZWQgZnJvbSAnY29yZS9EZWZlcnJlZCc7XHJcbmltcG9ydCBNYXRoVXRpbHMgZnJvbSAnY29yZS9NYXRoVXRpbHMnO1xyXG5pbXBvcnQgQWJzdHJhY3RTdGF0ZSBmcm9tICcuL0Fic3RyYWN0U3RhdGUnO1xyXG5pbXBvcnQgU3RhdGVDb250YWluZXJJbnRlcmZhY2UgZnJvbSAnLi9TdGF0ZUNvbnRhaW5lckludGVyZmFjZSc7XHJcblxyXG4vKipcclxuICogQmFzZSBjbGFzcyBmb3IgYSBzdGF0ZSB0aGF0IGJsZW5kcyBhIGNvbGxlY3Rpb24gb2Yge0BsaW5rIEFic3RyYWN0U3RhdGV9LlxyXG4gKlxyXG4gKiBAYWJzdHJhY3RcclxuICogQGltcGxlbWVudHMgU3RhdGVDb250YWluZXJJbnRlcmZhY2VcclxuICovXHJcbmNsYXNzIEFic3RyYWN0QmxlbmRTdGF0ZSBleHRlbmRzIFN0YXRlQ29udGFpbmVySW50ZXJmYWNlLk1peGluKEFic3RyYWN0U3RhdGUpIHtcclxuICBjb25zdHJ1Y3RvcihvcHRpb25zID0ge30sIGJsZW5kU3RhdGVzID0gW10sIC4uLmFyZ3MpIHtcclxuICAgIHN1cGVyKG9wdGlvbnMsIC4uLmFyZ3MpO1xyXG4gICAgYmxlbmRTdGF0ZXMuZm9yRWFjaChzdGF0ZSA9PiB7XHJcbiAgICAgIHRoaXMuYWRkU3RhdGUoc3RhdGUpO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSBzdW0gb2YgaW50ZXJuYWwgd2VpZ2h0cyBvZiB0aGUgc3ViLXN0YXRlcy5cclxuICAgKlxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IGludGVybmFsV2VpZ2h0KCkge1xyXG4gICAgbGV0IGJsZW5kV2VpZ2h0cyA9IDA7XHJcbiAgICB0aGlzLl9zdGF0ZXMuZm9yRWFjaChzdGF0ZSA9PiB7XHJcbiAgICAgIGJsZW5kV2VpZ2h0cyArPSBzdGF0ZS5pbnRlcm5hbFdlaWdodDtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGJsZW5kV2VpZ2h0cztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybnMgdGhlIHdlaWdodCBvZiBhIHN0YXRlIGNvbnRyb2xsZWQgYnkgdGhlIGNvbnRhaW5lci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgc3RhdGUgdG8gcmV0dXJuIHRoZSB3ZWlnaHQgZnJvbS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IC0gV2VpZ2h0IG9mIHRoZSBzdGF0ZS5cclxuICAgKi9cclxuICBnZXRCbGVuZFdlaWdodChuYW1lKSB7XHJcbiAgICAvLyBNYWtlIHN1cmUgdGhlIG5hbWUgaXMgdmFsaWRcclxuICAgIGNvbnN0IHN0YXRlID0gdGhpcy5nZXRTdGF0ZShuYW1lKTtcclxuICAgIGlmIChzdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBgQ2Fubm90IGdldCB3ZWlnaHQgb2Ygc3RhdGUgJHtuYW1lfSBmcm9tIEJsZW5kU3RhdGUgJHt0aGlzLm5hbWV9LiBObyBzdGF0ZSBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBzdGF0ZS53ZWlnaHQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHRoZSB3ZWlnaHQgb2YgYSBzdGF0ZSBjb250cm9sbGVkIGJ5IHRoZSBjb250YWluZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIHN0YXRlIHRvIHNldCB0aGUgd2VpZ2h0IG9mLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3ZWlnaHQgLSBXZWlnaHQgdmFsdWUgdG8gc2V0IG9uIHRoZSBzdGF0ZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH1cclxuICAgKi9cclxuICBzZXRCbGVuZFdlaWdodChuYW1lLCB3ZWlnaHQsIHNlY29uZHMgPSAwLCBlYXNpbmdGbikge1xyXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBuYW1lIGlzIHZhbGlkXHJcbiAgICBjb25zdCBzdGF0ZSA9IHRoaXMuZ2V0U3RhdGUobmFtZSk7XHJcblxyXG4gICAgaWYgKHN0YXRlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGBDYW5ub3Qgc2V0IHdlaWdodCBvZiBzdGF0ZSAke25hbWV9IGZyb20gQmxlbmRTdGF0ZSAke3RoaXMubmFtZX0uIE5vIHN0YXRlIGV4aXN0cyB3aXRoIHRoaXMgbmFtZS5gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgd2VpZ2h0ID0gTWF0aFV0aWxzLmNsYW1wKHdlaWdodCk7XHJcbiAgICByZXR1cm4gc3RhdGUuc2V0V2VpZ2h0KHdlaWdodCwgc2Vjb25kcywgZWFzaW5nRm4pO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTXVsdGlwbGllcyB0aGUgd2VpZ2h0IG9mIGVhY2ggc3ViLXN0YXRlIGJ5IGEgZmFjdG9yIHRvIGRldGVybWluZSB0aGUgaW50ZXJuYWwgd2VpZ2h0LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGZhY3RvciAtIDAtMSBtdWx0aXBsaWVyIHRvIGFwcGx5IHRvIHRoZSB1c2VyIHdlaWdodC5cclxuICAgKi9cclxuICB1cGRhdGVJbnRlcm5hbFdlaWdodChmYWN0b3IpIHtcclxuICAgIHN1cGVyLnVwZGF0ZUludGVybmFsV2VpZ2h0KGZhY3Rvcik7XHJcblxyXG4gICAgdGhpcy5fc3RhdGVzLmZvckVhY2goc3RhdGUgPT4ge1xyXG4gICAgICBzdGF0ZS51cGRhdGVJbnRlcm5hbFdlaWdodCh0aGlzLl9pbnRlcm5hbFdlaWdodCk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBhbnkgdmFsdWVzIG9mIHRoZSBzdWItc3RhdGVzIHRoYXQgbmVlZCB0byBiZSBldmFsdWF0ZWQgZXZlcnkgZnJhbWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gZGVsdGFUaW1lIC0gVGltZSBpbiBtaWxsaXNlY29uZHMgc2luY2UgdGhlIGxhc3QgdXBkYXRlLlxyXG4gICAqL1xyXG4gIHVwZGF0ZShkZWx0YVRpbWUpIHtcclxuICAgIHN1cGVyLnVwZGF0ZShkZWx0YVRpbWUpO1xyXG5cclxuICAgIHRoaXMuX3N0YXRlcy5mb3JFYWNoKHN0YXRlID0+IHtcclxuICAgICAgc3RhdGUudXBkYXRlKGRlbHRhVGltZSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0YXJ0IHBsYXliYWNrIG9mIHRoZSBzdWItc3RhdGVzIGZyb20gdGhlIGJlZ2lubmluZy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbkZpbmlzaCAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgd2hlbiB0aGUgc3RhdGUgZmluaXNoZXMuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uRXJyb3IgLSBGdW5jdGlvbiB0byBleGVjdXRlIGlmIHRoZSBzdGF0ZSBlbmNvdW50ZXJzXHJcbiAgICogYW4gZXJyb3IgZHVyaW5nIHBsYXliYWNrLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbkNhbmNlbCAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgaWYgcGxheWJhY2sgaXMgY2FuY2VsZWQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9XHJcbiAgICovXHJcbiAgcGxheShvbkZpbmlzaCwgb25FcnJvciwgb25DYW5jZWwpIHtcclxuICAgIGNvbnN0IHByb21pc2VzID0gW3N1cGVyLnBsYXkoKV07XHJcblxyXG4gICAgdGhpcy5fc3RhdGVzLmZvckVhY2goc3RhdGUgPT4ge1xyXG4gICAgICBwcm9taXNlcy5wdXNoKHN0YXRlLnBsYXkoKSk7XHJcbiAgICB9KTtcclxuICAgIHJldHVybiBEZWZlcnJlZC5hbGwocHJvbWlzZXMsIG9uRmluaXNoLCBvbkVycm9yLCBvbkNhbmNlbCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQYXVzZSBwbGF5YmFjayBvZiB0aGUgc3ViLXN0YXRlcy4gVGhpcyBwcmV2ZW50cyBwZW5kaW5nIHByb21pc2VzIGZyb20gYmVpbmcgZXhlY3V0ZWQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBwYXVzZSgpIHtcclxuICAgIHRoaXMuX3N0YXRlcy5mb3JFYWNoKHN0YXRlID0+IHtcclxuICAgICAgc3RhdGUucGF1c2UoKTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHN1cGVyLnBhdXNlKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXN1bWUgcGxheWJhY2sgb2YgdGhlIHN1Yi1zdGF0ZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25GaW5pc2ggLSBGdW5jdGlvbiB0byBleGVjdXRlIHdoZW4gdGhlIHN0YXRlIGZpbmlzaGVzLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbkVycm9yIC0gRnVuY3Rpb24gdG8gZXhlY3V0ZSBpZiB0aGUgc3RhdGUgZW5jb3VudGVyc1xyXG4gICAqIGFuIGVycm9yIGR1cmluZyBwbGF5YmFjay5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25DYW5jZWwgLSBGdW5jdGlvbiB0byBleGVjdXRlIGlmIHBsYXliYWNrIGlzIGNhbmNlbGVkLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0RlZmVycmVkfVxyXG4gICAqL1xyXG4gIHJlc3VtZShvbkZpbmlzaCwgb25FcnJvciwgb25DYW5jZWwpIHtcclxuICAgIGNvbnN0IHByb21pc2VzID0gW3N1cGVyLnJlc3VtZSgpXTtcclxuXHJcbiAgICB0aGlzLl9zdGF0ZXMuZm9yRWFjaChzdGF0ZSA9PiB7XHJcbiAgICAgIHByb21pc2VzLnB1c2goc3RhdGUucmVzdW1lKCkpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gRGVmZXJyZWQuYWxsKHByb21pc2VzLCBvbkZpbmlzaCwgb25FcnJvciwgb25DYW5jZWwpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2FuY2VsIHBsYXliYWNrIG9mIHRoZSBzdWItc3RhdGVzIGFuZCBjYW5jZWwgYW55IHBlbmRpbmcgcHJvbWlzZXMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBjYW5jZWwoKSB7XHJcbiAgICB0aGlzLl9zdGF0ZXMuZm9yRWFjaChzdGF0ZSA9PiB7XHJcbiAgICAgIHN0YXRlLmNhbmNlbCgpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gc3VwZXIuY2FuY2VsKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdG9wIHBsYXliYWNrIG9mIHRoZSBzdWItc3RhdGVzIGFuZCByZXNvbHZlIGFueSBwZW5kaW5nIHByb21pc2VzLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgc3RvcCgpIHtcclxuICAgIHRoaXMuX3N0YXRlcy5mb3JFYWNoKHN0YXRlID0+IHtcclxuICAgICAgc3RhdGUuc3RvcCgpO1xyXG4gICAgfSk7XHJcbiAgICByZXR1cm4gc3VwZXIuc3RvcCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGlzY2FyZHMgYWxsIHN1Yi1zdGF0ZSByZXNvdXJjZXMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBkaXNjYXJkKCkge1xyXG4gICAgc3VwZXIuZGlzY2FyZCgpO1xyXG5cclxuICAgIHRoaXMuZGlzY2FyZFN0YXRlcygpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQWJzdHJhY3RCbGVuZFN0YXRlO1xyXG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXHJcbmltcG9ydCBBYnN0cmFjdEJsZW5kU3RhdGUgZnJvbSAnLi9BYnN0cmFjdEJsZW5kU3RhdGUnO1xyXG5cclxuLyoqXHJcbiAqIENsYXNzIGZvciBibGVuZGluZyBOIG51bWJlciBvZiBibGVuZCBzdGF0ZXMuXHJcbiAqXHJcbiAqIEBleHRlbmRzIEFic3RyYWN0QmxlbmRTdGF0ZVxyXG4gKi9cclxuY2xhc3MgRnJlZUJsZW5kU3RhdGUgZXh0ZW5kcyBBYnN0cmFjdEJsZW5kU3RhdGUge1xyXG4gIC8qKlxyXG4gICAqIEBjb25zdHJ1Y3RvclxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zPXt9XSAtIE9wdGlvbnMgZm9yIHRoZSBjb250YWluZXIgc3RhdGUuXHJcbiAgICogQHBhcmFtIHtBcnJheS48QWJzdHJhY3RTdGF0ZT59IFtibGVuZFN0YXRlcz1bXV0gLSBCbGVuZCBzdGF0ZXMgdG8gYmUgY29udHJvbGxlZCBieVxyXG4gICAqIHRoaXMgY29udGFpbmVyLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSwgYmxlbmRTdGF0ZXMgPSBbXSkge1xyXG4gICAgc3VwZXIob3B0aW9ucywgYmxlbmRTdGF0ZXMpO1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlSW50ZXJuYWxXZWlnaHQoZmFjdG9yKSB7XHJcbiAgICBzdXBlci51cGRhdGVJbnRlcm5hbFdlaWdodChmYWN0b3IpO1xyXG5cclxuICAgIC8vIERldGVybWluZSB0aGUgdG90YWwgYWN0aXZlIHdlaWdodCBvZiBibGVuZCBzdGF0ZXNcclxuICAgIGxldCBzdW1XZWlnaHRzID0gMDtcclxuXHJcbiAgICB0aGlzLl9zdGF0ZXMuZm9yRWFjaChzdGF0ZSA9PiB7XHJcbiAgICAgIHN1bVdlaWdodHMgKz0gc3RhdGUud2VpZ2h0O1xyXG4gICAgfSk7XHJcblxyXG4gICAgLy8gRW5zdXJlIHRoZSBzdW0gb2YgYmxlbmQgc3RhdGUgaW50ZXJuYWwgd2VpZ2h0cyBkb2VzIG5vdCBleGNlZWQgY29udGFpbmVyIGludGVybmFsIHdlaWdodFxyXG4gICAgZmFjdG9yIC89IE1hdGgubWF4KHN1bVdlaWdodHMsIDEpO1xyXG5cclxuICAgIC8vIFN1bSBvZiBibGVuZCBzdGF0ZSBpbnRlcm5hbCB3ZWlnaHRzIHNob3VsZCBub3QgZXhjZWVkIGNvbnRhaW5lciBpbnRlcm5hbCB3ZWlnaHRcclxuICAgIHRoaXMuX3N0YXRlcy5mb3JFYWNoKHN0YXRlID0+IHtcclxuICAgICAgc3RhdGUudXBkYXRlSW50ZXJuYWxXZWlnaHQoZmFjdG9yICogdGhpcy5fd2VpZ2h0KTtcclxuICAgIH0pO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgRnJlZUJsZW5kU3RhdGU7XHJcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcclxuaW1wb3J0IERlZmVycmVkIGZyb20gJ2NvcmUvRGVmZXJyZWQnO1xyXG5pbXBvcnQgQWJzdHJhY3RCbGVuZFN0YXRlIGZyb20gJy4vQWJzdHJhY3RCbGVuZFN0YXRlJztcclxuaW1wb3J0IEFuaW1hdGlvblV0aWxzIGZyb20gJy4uL0FuaW1hdGlvblV0aWxzJztcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyBmb3IgYmxlbmRpbmcgTiBudW1iZXIgb2YgYmxlbmQgc3RhdGVzIGJhc2VkIG9uIGEgc2luZ2xlXHJcbiAqIHBhcmFtZXRlci5cclxuICpcclxuICogQGV4dGVuZHMgQWJzdHJhY3RCbGVuZFN0YXRlXHJcbiAqL1xyXG5jbGFzcyBCbGVuZDFkU3RhdGUgZXh0ZW5kcyBBYnN0cmFjdEJsZW5kU3RhdGUge1xyXG4gIC8qKlxyXG4gICAqIEBjb25zdHJ1Y3RvclxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IFtvcHRpb25zXSAtIE9wdGlvbnMgZm9yIHRoZSBjb250YWluZXIgc3RhdGVcclxuICAgKiBAcGFyYW0ge0FycmF5LjxBYnN0cmFjdEJsZW5kU3RhdGU+fSBbYmxlbmRTdGF0ZXM9W11dIC0gQmxlbmQgc3RhdGVzIHRvIGJlXHJcbiAgICogY29udHJvbGxlZCBieSB0aGlzIGNvbnRhaW5lci5cclxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBbYmxlbmRUaHJlc2hvbGRzPVtdXSAtIFRocmVzaG9sZCB2YWx1ZXMgZm9yIGFjdGl2YXRpbmdcclxuICAgKiBlYWNoIGJsZW5kIHN0YXRlLlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPGJvb2xlYW4+fSBbcGhhc2VNYXRjaGVzPVtdXSAtIEJvb2xlYW5zIGluZGljYXRpbmcgd2hldGhlciBvciBub3RcclxuICAgKiBlYWNoIGJsZW5kIHN0YXRlIHNob3VsZCBiZSBwaGFzZSBtYXRjaGVkLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgb3B0aW9ucyA9IHt9LFxyXG4gICAgYmxlbmRTdGF0ZXMgPSBbXSxcclxuICAgIGJsZW5kVGhyZXNob2xkcyA9IFtdLFxyXG4gICAgcGhhc2VNYXRjaGVzID0gW11cclxuICApIHtcclxuICAgIHN1cGVyKG9wdGlvbnMsIGJsZW5kU3RhdGVzKTtcclxuXHJcbiAgICB0aGlzLl9ibGVuZFZhbHVlID0gMDtcclxuICAgIHRoaXMuX3Byb21pc2VzID0ge1xyXG4gICAgICAuLi50aGlzLl9wcm9taXNlcyxcclxuICAgICAgYmxlbmRWYWx1ZTogRGVmZXJyZWQucmVzb2x2ZSgpLFxyXG4gICAgfTtcclxuXHJcbiAgICAvLyBWYWxpZGF0ZSB0aGVyZSBhcmUgbm8gZHVwbGljYXRlIHRocmVzaG9sZHNcclxuICAgIGNvbnN0IG5vblplcm9EaWZmZXJlbnRTaXplID1cclxuICAgICAgYmxlbmRTdGF0ZXMubGVuZ3RoICE9PSAwICYmIGJsZW5kU3RhdGVzLmxlbmd0aCAhPT0gYmxlbmRUaHJlc2hvbGRzLmxlbmd0aDtcclxuICAgIGlmIChub25aZXJvRGlmZmVyZW50U2l6ZSkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgYENhbm5vdCBjcmVhdGUgQmxlbmQxZFN0YXRlIHdpdGggYmxlbmRUaHJlc2hvbGRzICR7YmxlbmRUaHJlc2hvbGRzfS4gQmxlbmRUaHJlc2hvbGRzIGNvdW50IGRvZXMgbm90IG1hdGNoIGJsZW5kU3RhdGVzIGNvdW50LmBcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjb250YWluc0R1cGxpY2F0ZXMgPVxyXG4gICAgICBuZXcgU2V0KGJsZW5kVGhyZXNob2xkcykuc2l6ZSAhPT0gYmxlbmRUaHJlc2hvbGRzLmxlbmd0aDtcclxuICAgIGlmIChjb250YWluc0R1cGxpY2F0ZXMpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGBDYW5ub3QgY3JlYXRlIEJsZW5kMWRTdGF0ZSB3aXRoIGJsZW5kVGhyZXNob2xkcyAke2JsZW5kVGhyZXNob2xkc30uIEJsZW5kVGhyZXNob2xkcyBjb250YWlucyBkdXBsaWNhdGUgdmFsdWVzYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEluaXRpYWxpemUgdGhlIHRocmVzaG9sZHMgbWFwXHJcbiAgICB0aGlzLl90aHJlc2hvbGRzID0gW107XHJcbiAgICBbLi4udGhpcy5fc3RhdGVzLnZhbHVlcygpXS5mb3JFYWNoKChzdGF0ZSwgaW5kZXgpID0+IHtcclxuICAgICAgdGhpcy5fdGhyZXNob2xkcy5wdXNoKHtcclxuICAgICAgICB2YWx1ZTogYmxlbmRUaHJlc2hvbGRzW2luZGV4XSxcclxuICAgICAgICBuYW1lOiBzdGF0ZS5uYW1lLFxyXG4gICAgICAgIHBoYXNlTWF0Y2g6IHBoYXNlTWF0Y2hlc1tpbmRleF0gfHwgZmFsc2UsXHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5fc29ydFRocmVzaG9sZHMoKTtcclxuICAgIHRoaXMuX2ZvcmNlTm9UaHJlc2hvbGREdXBlcyA9IHRydWU7XHJcblxyXG4gICAgdGhpcy5fcGhhc2VMZWFkU3RhdGUgPSBudWxsO1xyXG5cclxuICAgIHRoaXMuX3VwZGF0ZUJsZW5kV2VpZ2h0cygpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyBhbmQgc2V0cyB0aGUgYmxlbmQgcGFyYW1ldGVyIHZhbHVlLlxyXG4gICAqL1xyXG4gIGdldCBibGVuZFZhbHVlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2JsZW5kVmFsdWU7XHJcbiAgfVxyXG5cclxuICBzZXQgYmxlbmRWYWx1ZSh2YWx1ZSkge1xyXG4gICAgdGhpcy5fYmxlbmRWYWx1ZSA9IHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB3aGV0aGVyIG9yIG5vdCB0aGUgYmxlbmQgdmFsdWUgaXMgY3VycmVudGx5IGJlaW5nIGFuaW1hdGVkLlxyXG4gICAqL1xyXG4gIGdldCBibGVuZFZhbHVlUGVuZGluZygpIHtcclxuICAgIHJldHVybiB0aGlzLl9wcm9taXNlcy5ibGVuZFZhbHVlICYmIHRoaXMuX3Byb21pc2VzLmJsZW5kVmFsdWUucGVuZGluZztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgdGhlIHVzZXIgZGVmaW5lZCB3ZWlnaHQgb3ZlciB0aW1lLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudWxsfSBuYW1lIC0gVW51c2VkIHBhcmFtZXRlci5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gd2VpZ2h0IC0gVGhlIHRhcmdldCB3ZWlnaHQgdmFsdWUuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtzZWNvbmRzPTBdIC0gVGhlIGFtb3VudCBvZiB0aW1lIGl0IHdpbGwgdGFrZSB0byByZWFjaCB0aGVcclxuICAgKiB0YXJnZXQgd2VpZ2h0LlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBlYXNpbmdGbiAtIFRoZSBlYXNpbmcgZnVuY3Rpb24gdG8gdXNlIGZvciBpbnRlcnBvbGF0aW9uLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0RlZmVycmVkfVxyXG4gICAqL1xyXG4gIHNldEJsZW5kV2VpZ2h0KG5hbWUsIHZhbHVlLCBzZWNvbmRzID0gMCwgZWFzaW5nRm4pIHtcclxuICAgIHRoaXMuX3Byb21pc2VzLmJsZW5kVmFsdWUuY2FuY2VsKCk7XHJcblxyXG4gICAgdGhpcy5fcHJvbWlzZXMuYmxlbmRWYWx1ZSA9IEFuaW1hdGlvblV0aWxzLmludGVycG9sYXRlUHJvcGVydHkoXHJcbiAgICAgIHRoaXMsXHJcbiAgICAgICdibGVuZFZhbHVlJyxcclxuICAgICAgdmFsdWUsXHJcbiAgICAgIHtcclxuICAgICAgICBzZWNvbmRzLFxyXG4gICAgICAgIGVhc2luZ0ZuLFxyXG4gICAgICAgIG9uUHJvZ3Jlc3M6ICgpID0+IHtcclxuICAgICAgICAgIHRoaXMuX3VwZGF0ZUJsZW5kV2VpZ2h0cygpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25GaW5pc2g6ICgpID0+IHtcclxuICAgICAgICAgIHRoaXMuX3VwZGF0ZUJsZW5kV2VpZ2h0cygpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgIH1cclxuICAgICk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2VzLmJsZW5kVmFsdWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSB1c2VyIGRlZmluZWQgd2VpZ2h0LlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cclxuICBnZXRCbGVuZFdlaWdodCgpIHtcclxuICAgIHJldHVybiB0aGlzLmJsZW5kVmFsdWU7XHJcbiAgfVxyXG5cclxuICBhZGRTdGF0ZShzdGF0ZSwgdGhyZXNob2xkVmFsdWUgPSAwLCBwaGFzZU1hdGNoID0gZmFsc2UpIHtcclxuICAgIHRoaXMuX3RocmVzaG9sZHMgPSB0aGlzLl90aHJlc2hvbGRzIHx8IFtdO1xyXG5cclxuICAgIC8vIE1ha2Ugc3VyZSB0aGVyZSBpcyBub3QgYWxyZWFkeSBhIHN0YXRlIHdpdGggdGhpcyB0aHJlc2hvbGRcclxuICAgIGNvbnN0IHNhbWVWYWx1ZSA9IHRoaXMuX3RocmVzaG9sZHMuZmluZChcclxuICAgICAgdGhyZXNob2xkID0+IHRocmVzaG9sZC52YWx1ZSA9PT0gdGhyZXNob2xkVmFsdWVcclxuICAgICk7XHJcbiAgICBpZiAodGhpcy5fZm9yY2VOb1RocmVzaG9sZER1cGVzICYmIHNhbWVWYWx1ZSAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBgQ2Fubm90IHNldCBibGVuZCB0aHJlc2hvbGQgb2YgJHt0aHJlc2hvbGRWYWx1ZX0gZm9yIHN0YXRlICR7c3RhdGUubmFtZX0gb24gJHt0aGlzLm5hbWV9LiBBIHN0YXRlIGFscmVhZHkgZXhpc3RzIHdpdGggdGhhdCB0aHJlc2hvbGQuYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHN1cGVyLmFkZFN0YXRlKHN0YXRlKTtcclxuICAgIHRoaXMuX3RocmVzaG9sZHMucHVzaCh7XHJcbiAgICAgIHZhbHVlOiB0aHJlc2hvbGRWYWx1ZSxcclxuICAgICAgbmFtZTogc3RhdGUubmFtZSxcclxuICAgICAgcGhhc2VNYXRjaDogcGhhc2VNYXRjaCB8fCBmYWxzZSxcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuX3NvcnRUaHJlc2hvbGRzKCk7XHJcblxyXG4gICAgcmV0dXJuIHN0YXRlLm5hbWU7XHJcbiAgfVxyXG5cclxuICByZW1vdmVTdGF0ZShuYW1lKSB7XHJcbiAgICBjb25zdCByZW1vdmVkID0gc3VwZXIucmVtb3ZlU3RhdGUobmFtZSk7XHJcblxyXG4gICAgaWYgKHJlbW92ZWQpIHtcclxuICAgICAgY29uc3QgaW5kZXggPSB0aGlzLl90aHJlc2hvbGRzLmZpbmRJbmRleChcclxuICAgICAgICB0aHJlc2hvbGQgPT4gdGhyZXNob2xkLm5hbWUgPT09IG5hbWVcclxuICAgICAgKTtcclxuICAgICAgdGhpcy5fdGhyZXNob2xkcy5zcGxpY2UoaW5kZXgsIDEpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByZW1vdmVkO1xyXG4gIH1cclxuXHJcbiAgcmVuYW1lU3RhdGUoY3VycmVudE5hbWUsIG5ld05hbWUpIHtcclxuICAgIG5ld05hbWUgPSBzdXBlci5yZW5hbWVTdGF0ZShjdXJyZW50TmFtZSwgbmV3TmFtZSk7XHJcblxyXG4gICAgY29uc3QgdGhyZXNob2xkID0gdGhpcy5fdGhyZXNob2xkcy5maW5kKFxyXG4gICAgICB0aHJlc2hvbGQgPT4gdGhyZXNob2xkLm5hbWUgPT09IGN1cnJlbnROYW1lXHJcbiAgICApO1xyXG4gICAgdGhyZXNob2xkLm5hbWUgPSBuZXdOYW1lO1xyXG5cclxuICAgIHJldHVybiBuZXdOYW1lO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgdGhyZXNob2xkIHZhbHVlIG9mIGEgYmxlbmQgd2l0aCB0aGUgY29ycmVzcG9uZGluZyBuYW1lLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBibGVuZCB0byBnZXQgdGhlIHRocmVzaG9sZCBvZi5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9IFRocmVob2xkIHZhbHVlLlxyXG4gICAqL1xyXG4gIGdldEJsZW5kVGhyZXNob2xkKG5hbWUpIHtcclxuICAgIGNvbnN0IHRocmVzaG9sZCA9IHRoaXMuX3RocmVzaG9sZHMuZmluZChcclxuICAgICAgdGhyZXNob2xkID0+IHRocmVzaG9sZC5uYW1lID09PSBuYW1lXHJcbiAgICApO1xyXG5cclxuICAgIGlmICh0aHJlc2hvbGQgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgYENhbm5vdCBnZXQgYmxlbmQgdGhyZXNob2xkIG9mIHN0YXRlICR7bmFtZX0gb24gJHt0aGlzLm5hbWV9LiBObyBzdGF0ZSBleGlzdHMgd2l0aCB0aGF0IG5hbWUuYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0aHJlc2hvbGQudmFsdWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIHRoZSB0aHJlc2hvbGQgdmFsdWUgb2YgYSBibGVuZCB3aXRoIHRoZSBjb3JyZXNwb25kaW5nIG5hbWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIGJsZW5kIHRvIHNldCB0aGUgdGhyZXNob2xkLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2YWx1ZSAtIFZhbHVlIG9mIHRoZSB0aHJlc2hvbGQgdG8gc2V0LlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge251bWJlcn0gU2V0IHRocmVzaG9sZCB2YWx1ZS5cclxuICAgKi9cclxuICBzZXRCbGVuZFRocmVzaG9sZChuYW1lLCB2YWx1ZSkge1xyXG4gICAgLy8gTWFrZSBzdXJlIHRoZXJlIGlzIG5vdCBhbHJlYWR5IGEgc3RhdGUgd2l0aCB0aGlzIHRocmVzaG9sZFxyXG4gICAgY29uc3Qgc2FtZVZhbHVlID0gdGhpcy5fdGhyZXNob2xkcy5maW5kKFxyXG4gICAgICB0aHJlc2hvbGQgPT4gdGhyZXNob2xkLnZhbHVlID09PSB2YWx1ZVxyXG4gICAgKTtcclxuICAgIGlmIChzYW1lVmFsdWUgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgYENhbm5vdCBzZXQgYmxlbmQgdGhyZXNob2xkIG9mICR7dmFsdWV9IGZvciBzdGF0ZSAke25hbWV9IG9uICR7dGhpcy5uYW1lfS4gQSBzdGF0ZSBhbHJlYWR5IGV4aXN0cyB3aXRoIHRoYXQgdGhyZXNob2xkLmBcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCB0aHJlc2hvbGQgPSB0aGlzLl90aHJlc2hvbGRzLmZpbmQoXHJcbiAgICAgIHRocmVzaG9sZCA9PiB0aHJlc2hvbGQubmFtZSA9PT0gbmFtZVxyXG4gICAgKTtcclxuXHJcbiAgICBpZiAodGhyZXNob2xkID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGBDYW5ub3Qgc2V0IGJsZW5kIHRocmVzaG9sZCBvZiBzdGF0ZSAke25hbWV9IG9uICR7dGhpcy5uYW1lfS4gTm8gc3RhdGUgZXhpc3RzIHdpdGggdGhhdCBuYW1lLmBcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICB0aHJlc2hvbGQudmFsdWUgPSB2YWx1ZTtcclxuXHJcbiAgICB0aGlzLl9zb3J0VGhyZXNob2xkcygpO1xyXG5cclxuICAgIHJldHVybiB0aHJlc2hvbGQudmFsdWU7XHJcbiAgfVxyXG5cclxuICB1cGRhdGVJbnRlcm5hbFdlaWdodChmYWN0b3IpIHtcclxuICAgIHN1cGVyLnVwZGF0ZUludGVybmFsV2VpZ2h0KGZhY3Rvcik7XHJcblxyXG4gICAgaWYgKHRoaXMuX3BoYXNlTGVhZFN0YXRlKSB7XHJcbiAgICAgIHRoaXMuX3N0YXRlcy5mb3JFYWNoKHN0YXRlID0+IHtcclxuICAgICAgICBpZiAoc3RhdGUud2VpZ2h0ICE9PSAwKSB7XHJcbiAgICAgICAgICBzdGF0ZS5ub3JtYWxpemVkVGltZSA9IHRoaXMuX3BoYXNlTGVhZFN0YXRlLm5vcm1hbGl6ZWRUaW1lO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGVzIHRoZSBibGVuZCB3ZWlnaHRzIGJhc2VkIG9uIHRoZWlyIGNvcnJlc3BvbmRpbmcgdGhyZXNob2xkIHZhbHVlc1xyXG4gICAqIGFuZCB0aGUgY3VycmVudCBibGVuZFZhbHVlLiBBZGRpdGlvbmFsbHksIHNldHMgYSBsZWFkIHBoYXNlIHN0YXRlIGlmIHRoZVxyXG4gICAqIGNvbmRpdGlvbnMgZm9yIHBoYXNlLW1hdGNoaW5nIGhhdmUgYmVlbiBzYXRpc2ZpZWQuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF91cGRhdGVCbGVuZFdlaWdodHMoKSB7XHJcbiAgICBpZiAodGhpcy5fdGhyZXNob2xkcy5sZW5ndGggPT09IDApIHJldHVybjtcclxuXHJcbiAgICBpZiAodGhpcy5fdGhyZXNob2xkcy5sZW5ndGggPT09IDEpIHtcclxuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZXMuZ2V0KHRoaXMuX3RocmVzaG9sZHNbMF0ubmFtZSk7XHJcbiAgICAgIHN0YXRlLnNldFdlaWdodCgxKTtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEluaXRpYWxseSBzZXQgYWxsIHN1Yi1zdGF0ZSB3ZWlnaHRzIHRvIHplcm9cclxuICAgIHRoaXMuX3N0YXRlcy5mb3JFYWNoKHN0YXRlID0+IHtcclxuICAgICAgc3RhdGUuc2V0V2VpZ2h0KDApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgdGhpcy5fcGhhc2VMZWFkU3RhdGUgPSBudWxsO1xyXG5cclxuICAgIC8vIEZpbmQgdGhlIGZpcnN0IHRocmVzaG9sZCB0aGF0IGlzIGdyZWF0ZXIgdGhhbiBvciBlcXVhbCB0byB0aGUgcGFyYW1ldGVyIHZhbHVlXHJcbiAgICBsZXQgdGFyZ2V0SW5kZXggPSB0aGlzLl90aHJlc2hvbGRzLmZpbmRJbmRleCh0aHJlc2hvbGQgPT4ge1xyXG4gICAgICByZXR1cm4gdGhyZXNob2xkLnZhbHVlID49IHRoaXMuX2JsZW5kVmFsdWU7XHJcbiAgICB9KTtcclxuXHJcbiAgICBpZiAodGFyZ2V0SW5kZXggPT09IDAgfHwgdGFyZ2V0SW5kZXggPT09IC0xKSB7XHJcbiAgICAgIC8vIEdpdmUgb25lIHN0YXRlIGZ1bGwgaW5mbHVlbmNlXHJcbiAgICAgIHRhcmdldEluZGV4ID0gdGFyZ2V0SW5kZXggPT09IC0xID8gdGhpcy5fdGhyZXNob2xkcy5sZW5ndGggLSAxIDogMDtcclxuICAgICAgY29uc3Qgc3RhdGUgPSB0aGlzLl9zdGF0ZXMuZ2V0KHRoaXMuX3RocmVzaG9sZHNbdGFyZ2V0SW5kZXhdLm5hbWUpO1xyXG4gICAgICBzdGF0ZS5zZXRXZWlnaHQoMSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBMaW5lYXIgaW50ZXJwb2xhdGUgaW5mbHVlbmNlIGJldHdlZW4gdHdvIHN0YXRlc1xyXG4gICAgICBjb25zdCB0aHJlc2hvbGRBID0gdGhpcy5fdGhyZXNob2xkc1t0YXJnZXRJbmRleCAtIDFdO1xyXG4gICAgICBjb25zdCB0aHJlc2hvbGRCID0gdGhpcy5fdGhyZXNob2xkc1t0YXJnZXRJbmRleF07XHJcblxyXG4gICAgICBjb25zdCBmYWN0b3JCID1cclxuICAgICAgICAodGhpcy5ibGVuZFZhbHVlIC0gdGhyZXNob2xkQS52YWx1ZSkgL1xyXG4gICAgICAgICh0aHJlc2hvbGRCLnZhbHVlIC0gdGhyZXNob2xkQS52YWx1ZSk7XHJcbiAgICAgIGNvbnN0IGZhY3RvckEgPSAxIC0gZmFjdG9yQjtcclxuXHJcbiAgICAgIGNvbnN0IHN0YXRlQSA9IHRoaXMuX3N0YXRlcy5nZXQodGhyZXNob2xkQS5uYW1lKTtcclxuICAgICAgY29uc3Qgc3RhdGVCID0gdGhpcy5fc3RhdGVzLmdldCh0aHJlc2hvbGRCLm5hbWUpO1xyXG5cclxuICAgICAgc3RhdGVBLnNldFdlaWdodChmYWN0b3JBKTtcclxuICAgICAgc3RhdGVCLnNldFdlaWdodChmYWN0b3JCKTtcclxuXHJcbiAgICAgIC8vIFNldCBwaGFzZS1tYXRjaGluZyBpZiBuZWVkZWRcclxuICAgICAgaWYgKHRocmVzaG9sZEEucGhhc2VNYXRjaCAmJiB0aHJlc2hvbGRCLnBoYXNlTWF0Y2gpIHtcclxuICAgICAgICB0aGlzLl9waGFzZUxlYWRTdGF0ZSA9IGZhY3RvckEgPiBmYWN0b3JCID8gc3RhdGVBIDogc3RhdGVCO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTb3J0cyB0aGUgdGhyZXNob2xkcyBmcm9tIGxvdyB0byBoaWdoIGJhc2VkIG9uIHZhbHVlLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfc29ydFRocmVzaG9sZHMoKSB7XHJcbiAgICB0aGlzLl90aHJlc2hvbGRzLnNvcnQoKGEsIGIpID0+IGEudmFsdWUgLSBiLnZhbHVlKTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEJsZW5kMWRTdGF0ZTtcclxuIiwiLy8gQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxyXG4vKiBlc2xpbnQtZGlzYWJsZSBuby11bmRlcnNjb3JlLWRhbmdsZSAqL1xyXG5pbXBvcnQgRGVmZXJyZWQgZnJvbSAnY29yZS9EZWZlcnJlZCc7XHJcbmltcG9ydCBNYXRoVXRpbHMgZnJvbSAnY29yZS9NYXRoVXRpbHMnO1xyXG5pbXBvcnQgQWJzdHJhY3RCbGVuZFN0YXRlIGZyb20gJy4vQWJzdHJhY3RCbGVuZFN0YXRlJztcclxuaW1wb3J0IEFuaW1hdGlvblV0aWxzIGZyb20gJy4uL0FuaW1hdGlvblV0aWxzJztcclxuXHJcbi8qKlxyXG4gKiBDbGFzcyBmb3IgYmxlbmRpbmcgTiBudW1iZXIgb2YgYmxlbmQgc3RhdGVzIGJhc2VkIG9uIHR3b1xyXG4gKiBwYXJhbXRlcnMuXHJcbiAqXHJcbiAqIEBleHRlbmRzIEFic3RyYWN0QmxlbmRTdGF0ZVxyXG4gKi9cclxuY2xhc3MgQmxlbmQyZFN0YXRlIGV4dGVuZHMgQWJzdHJhY3RCbGVuZFN0YXRlIHtcclxuICAvKipcclxuICAgKiBAY29uc3RydWN0b3JcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBbb3B0aW9uc10gLSBPcHRpb25zIGZvciB0aGUgY29udGFpbmVyIHN0YXRlXHJcbiAgICogQHBhcmFtIHtBcnJheS48QWJzdHJhY3RCbGVuZFN0YXRlPn0gW2JsZW5kU3RhdGVzPVtdXSAtIEJsZW5kIHN0YXRlcyB0byBiZVxyXG4gICAqIGNvbnRyb2xsZWQgYnkgdGhpcyBjb250YWluZXIuXHJcbiAgICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSBbYmxlbmRUaHJlc2hvbGRzPVtdXSAtIFRocmVzaG9sZCB2YWx1ZXMgZm9yIGFjdGl2YXRpbmdcclxuICAgKiBlYWNoIGJsZW5kIHN0YXRlLlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPGJvb2xlYW4+fSBbcGhhc2VNYXRjaGVzPVtdXSAtIEJvb2xlYW5zIGluZGljYXRpbmcgd2hldGhlciBvciBub3RcclxuICAgKiBlYWNoIGJsZW5kIHN0YXRlIHNob3VsZCBiZSBwaGFzZSBtYXRjaGVkLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKFxyXG4gICAgb3B0aW9ucyA9IHt9LFxyXG4gICAgYmxlbmRTdGF0ZXMgPSBbXSxcclxuICAgIGJsZW5kVGhyZXNob2xkcyA9IFtdLFxyXG4gICAgcGhhc2VNYXRjaGVzID0gW11cclxuICApIHtcclxuICAgIHN1cGVyKG9wdGlvbnMsIGJsZW5kU3RhdGVzKTtcclxuXHJcbiAgICBpZiAoYmxlbmRTdGF0ZXMubGVuZ3RoICE9PSBibGVuZFRocmVzaG9sZHMubGVuZ3RoKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBgQ2Fubm90IGNyZWF0ZSBCbGVuZDJkU3RhdGUgd2l0aCBibGVuZFN0YXRlcyAke2JsZW5kU3RhdGVzfSBhbmQgYmxlbmRUaHJlc2hvbGRzICR7YmxlbmRUaHJlc2hvbGRzfS4gQ291bnQgb2YgYmxlbmRTdGF0ZXMgbXVzdCBtYXRjaCBjb3VudCBvZiBibGVuZFRocmVzaG9sZHMuYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGJsZW5kVGhyZXNob2xkc1xyXG4gICAgICAuc2xpY2UoMCwgYmxlbmRUaHJlc2hvbGRzLmxlbmd0aCAtIDEpXHJcbiAgICAgIC5mb3JFYWNoKCh0aHJlc2hvbGQsIGluZGV4KSA9PiB7XHJcbiAgICAgICAgYmxlbmRUaHJlc2hvbGRzLnNsaWNlKGluZGV4ICsgMSkuZm9yRWFjaChvdGhlclRocmVzaG9sZCA9PiB7XHJcbiAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIHRocmVzaG9sZFswXSA9PT0gb3RoZXJUaHJlc2hvbGRbMF0gJiZcclxuICAgICAgICAgICAgdGhyZXNob2xkWzFdID09PSBvdGhlclRocmVzaG9sZFsxXVxyXG4gICAgICAgICAgKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAgICAgICBgQ2Fubm90IGNyZWF0ZSBCbGVuZDJkU3RhdGUgd2l0aCBibGVuZFRocmVzaG9sZHMgJHtibGVuZFRocmVzaG9sZHN9LiBObyBkdXBsaWNhdGUgdmFsdWVzIGFsbG93ZWQgaW4gYmxlbmRUaHJlc2hvbGRzLmBcclxuICAgICAgICAgICAgKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfSk7XHJcblxyXG4gICAgdGhpcy5fYmxlbmRWYWx1ZVggPSAwO1xyXG4gICAgdGhpcy5fYmxlbmRWYWx1ZVkgPSAwO1xyXG5cclxuICAgIHRoaXMuX3Byb21pc2VzID0ge1xyXG4gICAgICAuLi50aGlzLl9wcm9taXNlcyxcclxuICAgICAgYmxlbmRWYWx1ZVg6IERlZmVycmVkLnJlc29sdmUoKSxcclxuICAgICAgYmxlbmRWYWx1ZVk6IERlZmVycmVkLnJlc29sdmUoKSxcclxuICAgIH07XHJcblxyXG4gICAgdGhpcy5fdGhyZXNob2xkcyA9IFtdO1xyXG4gICAgWy4uLnRoaXMuX3N0YXRlcy52YWx1ZXMoKV0uZm9yRWFjaCgoc3RhdGUsIGluZGV4KSA9PiB7XHJcbiAgICAgIHRoaXMuX3RocmVzaG9sZHMucHVzaCh7XHJcbiAgICAgICAgbmFtZTogc3RhdGUubmFtZSxcclxuICAgICAgICBwaGFzZU1hdGNoOiBwaGFzZU1hdGNoZXNbaW5kZXhdIHx8IGZhbHNlLFxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuX3ZlcnRpY2VzID0gYmxlbmRUaHJlc2hvbGRzO1xyXG5cclxuICAgIGlmICh0aGlzLl92ZXJ0aWNlcy5sZW5ndGggPj0gMykge1xyXG4gICAgICB0aGlzLl90cmlhbmdsZXMgPSBNYXRoVXRpbHMuZ2V0RGVsYXVuYXlUcmlhbmd1bGF0aW9uKHRoaXMuX3ZlcnRpY2VzKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9waGFzZUxlYWRTdGF0ZSA9IG51bGw7XHJcblxyXG4gICAgdGhpcy5fdXBkYXRlQmxlbmRXZWlnaHRzKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGVzIHRoZSB1c2VyIGRlZmluZWQgd2VpZ2h0IG92ZXIgdGltZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gTmFtZSBvZiBibGVuZCB3ZWlnaHQgdG8gdXBkYXRlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3ZWlnaHQgLSBUYXJnZXQgd2VpZ2h0IHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc2Vjb25kcz0wXSAtIFRoZSBhbW91bnQgb2YgdGltZSBpdCB3aWxsIHRha2UgdG8gcmVhY2ggdGhlXHJcbiAgICogdGFyZ2V0IHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBlYXNpbmdGbiAtIFRoZSBlYXNpbmcgZnVuY3Rpb24gdG8gdXNlIGZvciBpbnRlcnBvbGF0aW9uLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0RlZmVycmVkfVxyXG4gICAqL1xyXG4gIHNldEJsZW5kV2VpZ2h0KG5hbWUsIHZhbHVlLCBzZWNvbmRzID0gMCwgZWFzaW5nRm4pIHtcclxuICAgIGNvbnN0IHByb3BlcnR5ID0gYGJsZW5kVmFsdWUke25hbWUudG9VcHBlckNhc2UoKX1gO1xyXG4gICAgaWYgKHByb3BlcnR5ICE9PSAnYmxlbmRWYWx1ZVgnICYmIHByb3BlcnR5ICE9PSAnYmxlbmRWYWx1ZVknKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBgQ2Fubm90IHNldCBibGVuZCB3ZWlnaHQgZm9yICR7bmFtZX0gb24gJHt0aGlzLm5hbWV9LiBCbGVuZDJkU3RhdGUgb25seSBhY2NlcHRzICdYJyBvciAnWScgZm9yIHNldEJsZW5kV2VpZ2h0YFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX3Byb21pc2VzW3Byb3BlcnR5XS5jYW5jZWwoKTtcclxuXHJcbiAgICB0aGlzLl9wcm9taXNlc1twcm9wZXJ0eV0gPSBBbmltYXRpb25VdGlscy5pbnRlcnBvbGF0ZVByb3BlcnR5KFxyXG4gICAgICB0aGlzLFxyXG4gICAgICBwcm9wZXJ0eSxcclxuICAgICAgdmFsdWUsXHJcbiAgICAgIHtcclxuICAgICAgICBzZWNvbmRzLFxyXG4gICAgICAgIGVhc2luZ0ZuLFxyXG4gICAgICAgIG9uUHJvZ3Jlc3M6ICgpID0+IHtcclxuICAgICAgICAgIHRoaXMuX3VwZGF0ZUJsZW5kV2VpZ2h0cygpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgb25GaW5pc2g6ICgpID0+IHtcclxuICAgICAgICAgIHRoaXMuX3VwZGF0ZUJsZW5kV2VpZ2h0cygpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgIH1cclxuICAgICk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2VzW3Byb3BlcnR5XTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIHVzZXIgZGVmaW5lZCB3ZWlnaHQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIE5hbWUgb2YgYmxlbmQgd2VpZ2h0LlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge251bWJlcn1cclxuICAgKi9cclxuICBnZXRCbGVuZFdlaWdodChuYW1lKSB7XHJcbiAgICBjb25zdCBwcm9wZXJ0eSA9IG5hbWUudG9VcHBlckNhc2UoKTtcclxuICAgIGlmIChwcm9wZXJ0eSAhPT0gJ1gnICYmIHByb3BlcnR5ICE9PSAnWScpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGBDYW5ub3QgZ2V0IGJsZW5kIHdlaWdodCBmb3IgJHtuYW1lfSBvbiAke3RoaXMubmFtZX0uIEJsZW5kMmRTdGF0ZSBvbmx5IGFjY2VwdHMgJ1gnIG9yICdZJyBmb3IgZ2V0QmxlbmRXZWlnaHRgXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHByb3BlcnR5ID09PSAnWCcgPyB0aGlzLl9ibGVuZFZhbHVlWCA6IHRoaXMuX2JsZW5kVmFsdWVZO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyBhbmQgc2V0cyB0aGUgeCBibGVuZCB3ZWlnaHQuXHJcbiAgICovXHJcbiAgZ2V0IGJsZW5kVmFsdWVYKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2JsZW5kVmFsdWVYO1xyXG4gIH1cclxuXHJcbiAgc2V0IGJsZW5kVmFsdWVYKHZhbHVlKSB7XHJcbiAgICB0aGlzLl9ibGVuZFZhbHVlWCA9IHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyBhbmQgc2V0cyB0aGUgeSBibGVuZCB3ZWlnaHQuXHJcbiAgICovXHJcbiAgZ2V0IGJsZW5kVmFsdWVZKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2JsZW5kVmFsdWVZO1xyXG4gIH1cclxuXHJcbiAgc2V0IGJsZW5kVmFsdWVZKHZhbHVlKSB7XHJcbiAgICB0aGlzLl9ibGVuZFZhbHVlWSA9IHZhbHVlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB3aGV0aGVyIG9yIG5vdCB0aGUgeCBibGVuZCB2YWx1ZSBpcyBjdXJyZW50bHkgYmVpbmcgYW5pbWF0ZWQuXHJcbiAgICovXHJcbiAgZ2V0IGJsZW5kVmFsdWVYUGVuZGluZygpIHtcclxuICAgIHJldHVybiB0aGlzLl9wcm9taXNlcy5ibGVuZFZhbHVlWCAmJiB0aGlzLl9wcm9taXNlcy5ibGVuZFZhbHVlWC5wZW5kaW5nO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB3aGV0aGVyIG9yIG5vdCB0aGUgeSBibGVuZCB2YWx1ZSBpcyBjdXJyZW50bHkgYmVpbmcgYW5pbWF0ZWQuXHJcbiAgICovXHJcbiAgZ2V0IGJsZW5kVmFsdWVZUGVuZGluZygpIHtcclxuICAgIHJldHVybiB0aGlzLl9wcm9taXNlcy5ibGVuZFZhbHVlWSAmJiB0aGlzLl9wcm9taXNlcy5ibGVuZFZhbHVlWS5wZW5kaW5nO1xyXG4gIH1cclxuXHJcbiAgdXBkYXRlSW50ZXJuYWxXZWlnaHQoZmFjdG9yKSB7XHJcbiAgICBzdXBlci51cGRhdGVJbnRlcm5hbFdlaWdodChmYWN0b3IpO1xyXG5cclxuICAgIGlmICh0aGlzLl9waGFzZUxlYWRTdGF0ZSkge1xyXG4gICAgICBbLi4udGhpcy5fc3RhdGVzLnZhbHVlcygpXS5mb3JFYWNoKChzdGF0ZSwgaW5kZXgpID0+IHtcclxuICAgICAgICBpZiAoc3RhdGUud2VpZ2h0ICE9PSAwICYmIHRoaXMuX3RocmVzaG9sZHNbaW5kZXhdLnBoYXNlTWF0Y2gpIHtcclxuICAgICAgICAgIHN0YXRlLm5vcm1hbGl6ZWRUaW1lID0gdGhpcy5fcGhhc2VMZWFkU3RhdGUubm9ybWFsaXplZFRpbWU7XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgdGhlIGJsZW5kIHdlaWdodHMgYmFzZWQgb24gdGhlaXIgY29ycmVzcG9uZGluZyB0aHJlc2hvbGQgdmFsdWVzXHJcbiAgICogYW5kIHRoZSBjdXJyZW50IFt4LHldIGJsZW5kVmFsdWUuIEFkZGl0aW9uYWxseSwgc2V0cyBhIGxlYWQgcGhhc2Ugc3RhdGUgaWYgdGhlXHJcbiAgICogY29uZGl0aW9ucyBmb3IgcGhhc2UtbWF0Y2hpbmcgaGF2ZSBiZWVuIHNhdGlzZmllZC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX3VwZGF0ZUJsZW5kV2VpZ2h0cygpIHtcclxuICAgIGlmICghdGhpcy5fdmVydGljZXMgfHwgdGhpcy5fdmVydGljZXMubGVuZ3RoID09PSAwKSByZXR1cm47XHJcblxyXG4gICAgaWYgKHRoaXMuX3ZlcnRpY2VzLmxlbmd0aCA9PT0gMSkge1xyXG4gICAgICBbLi4udGhpcy5fc3RhdGVzLnZhbHVlcygpXVswXS53ZWlnaHQgPSAxO1xyXG4gICAgICByZXR1cm47XHJcbiAgICB9XHJcblxyXG4gICAgLy8gSW5pdGlhbGx5IHNldCBhbGwgc3ViLXN0YXRlIHdlaWdodHMgdG8gemVyb1xyXG4gICAgdGhpcy5fc3RhdGVzLmZvckVhY2goc3RhdGUgPT4ge1xyXG4gICAgICBzdGF0ZS5zZXRXZWlnaHQoMCk7XHJcbiAgICB9KTtcclxuICAgIHRoaXMuX3BoYXNlTGVhZFN0YXRlID0gbnVsbDtcclxuXHJcbiAgICBjb25zdCBwID0gW3RoaXMuX2JsZW5kVmFsdWVYLCB0aGlzLl9ibGVuZFZhbHVlWV07XHJcblxyXG4gICAgaWYgKHRoaXMuX3ZlcnRpY2VzLmxlbmd0aCA9PT0gMikge1xyXG4gICAgICB0aGlzLl9zZXRJbmZsdWVuY2VDbG9zZXN0UG9pbnRPbkxpbmUocCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zdCB0cmlhbmdsZSA9IHRoaXMuX3RyaWFuZ2xlcy5maW5kKHRyaWFuZ2xlID0+IHtcclxuICAgICAgICByZXR1cm4gTWF0aFV0aWxzLmlzUG9pbnRJblRyaWFuZ2xlKFxyXG4gICAgICAgICAgdGhpcy5fdmVydGljZXNbdHJpYW5nbGVbMF1dLFxyXG4gICAgICAgICAgdGhpcy5fdmVydGljZXNbdHJpYW5nbGVbMV1dLFxyXG4gICAgICAgICAgdGhpcy5fdmVydGljZXNbdHJpYW5nbGVbMl1dLFxyXG4gICAgICAgICAgcFxyXG4gICAgICAgICk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgICAgaWYgKHRyaWFuZ2xlKSB7XHJcbiAgICAgICAgdGhpcy5fc2V0SW5mbHVlbmNlVHJpYW5nbGUodHJpYW5nbGUsIHApO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIHRoaXMuX3NldEluZmx1ZW5jZUNsb3Nlc3RQb2ludEluVHJpYW5nbGVzKHApO1xyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXRzIGJsZW5kIHdlaWdodHMgZm9yIHN0YXRlcyBjb3JyZXNwb25kaW5nIHRvIGFcclxuICAgKiB0cmlhbmdsZSBvZiB0aHJlc2hvbGRzIGFuZCBhIGdpdmVuIFt4LHldIGJsZW5kVmFsdWVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBcnJheS48QXJyYXkuPG51bWJlcj4+fSB0cmlhbmdsZSAtIFNldCBvZiB0cmlhbmdsdWF0ZWQgaW5kaWNlc1xyXG4gICAqIHRoYXQgY29ycmVzcG9uZCB0byBibGVuZCB0aHJlc2hvbGRzLlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHAgLSBHaXZlbiBbeCx5XSBibGVuZFZhbHVlLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfc2V0SW5mbHVlbmNlVHJpYW5nbGUodHJpYW5nbGUsIHApIHtcclxuICAgIGNvbnN0IGFyZWFBID0gTWF0aFV0aWxzLnRyaWFuZ2xlQXJlYShcclxuICAgICAgdGhpcy5fdmVydGljZXNbdHJpYW5nbGVbMV1dLFxyXG4gICAgICB0aGlzLl92ZXJ0aWNlc1t0cmlhbmdsZVsyXV0sXHJcbiAgICAgIHBcclxuICAgICk7XHJcblxyXG4gICAgY29uc3QgYXJlYUIgPSBNYXRoVXRpbHMudHJpYW5nbGVBcmVhKFxyXG4gICAgICB0aGlzLl92ZXJ0aWNlc1t0cmlhbmdsZVswXV0sXHJcbiAgICAgIHRoaXMuX3ZlcnRpY2VzW3RyaWFuZ2xlWzJdXSxcclxuICAgICAgcFxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBhcmVhQyA9IE1hdGhVdGlscy50cmlhbmdsZUFyZWEoXHJcbiAgICAgIHRoaXMuX3ZlcnRpY2VzW3RyaWFuZ2xlWzBdXSxcclxuICAgICAgdGhpcy5fdmVydGljZXNbdHJpYW5nbGVbMV1dLFxyXG4gICAgICBwXHJcbiAgICApO1xyXG5cclxuICAgIGNvbnN0IHRvdGFsQXJlYSA9IGFyZWFBICsgYXJlYUIgKyBhcmVhQztcclxuXHJcbiAgICBjb25zdCB3ZWlnaHRBID0gYXJlYUEgLyB0b3RhbEFyZWE7XHJcbiAgICBjb25zdCB3ZWlnaHRCID0gYXJlYUIgLyB0b3RhbEFyZWE7XHJcbiAgICBjb25zdCB3ZWlnaHRDID0gYXJlYUMgLyB0b3RhbEFyZWE7XHJcblxyXG4gICAgY29uc3QgdGhyZXNob2xkQSA9IHRoaXMuX3RocmVzaG9sZHNbdHJpYW5nbGVbMF1dO1xyXG4gICAgY29uc3QgdGhyZXNob2xkQiA9IHRoaXMuX3RocmVzaG9sZHNbdHJpYW5nbGVbMV1dO1xyXG4gICAgY29uc3QgdGhyZXNob2xkQyA9IHRoaXMuX3RocmVzaG9sZHNbdHJpYW5nbGVbMl1dO1xyXG5cclxuICAgIGNvbnN0IHN0YXRlQSA9IHRoaXMuX3N0YXRlcy5nZXQodGhyZXNob2xkQS5uYW1lKTtcclxuICAgIGNvbnN0IHN0YXRlQiA9IHRoaXMuX3N0YXRlcy5nZXQodGhyZXNob2xkQi5uYW1lKTtcclxuICAgIGNvbnN0IHN0YXRlQyA9IHRoaXMuX3N0YXRlcy5nZXQodGhyZXNob2xkQy5uYW1lKTtcclxuXHJcbiAgICBzdGF0ZUEuc2V0V2VpZ2h0KHdlaWdodEEpO1xyXG4gICAgc3RhdGVCLnNldFdlaWdodCh3ZWlnaHRCKTtcclxuICAgIHN0YXRlQy5zZXRXZWlnaHQod2VpZ2h0Qyk7XHJcblxyXG4gICAgdGhpcy5fc2V0UGhhc2VMZWFkU3RhdGUoXHJcbiAgICAgIFtzdGF0ZUEsIHN0YXRlQiwgc3RhdGVDXSxcclxuICAgICAgW3RocmVzaG9sZEEucGhhc2VNYXRjaCwgdGhyZXNob2xkQi5waGFzZU1hdGNoLCB0aHJlc2hvbGRDLnBoYXNlTWF0Y2hdXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0ZXJtaW5lcyB0aGUgY2xvc2VzdCBwb2ludCB3aXRoaW4gYSB0cmlhbmdsZSBvZlxyXG4gICAqIHRocmVzaG9sZHMgYmFzZWQgb24gdGhlIGN1cnJlbnQgW3gseV0gYmxlbmRWYWx1ZXMgYW5kXHJcbiAgICogdGhlbiBzZXRzIGJsZW5kIHdlaWdodHMgZm9yIHRoZSBjb3JyZXNwb25kaW5nIHN0YXRlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IHAgLSBHaXZlbiBbeCx5XSBibGVuZFZhbHVlLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfc2V0SW5mbHVlbmNlQ2xvc2VzdFBvaW50SW5UcmlhbmdsZXMocCkge1xyXG4gICAgbGV0IGdsb2JhbENsb3Nlc3RQb2ludCA9IG51bGw7XHJcbiAgICBsZXQgZ2xvYmFsTWluRGlzdCA9IE51bWJlci5QT1NJVElWRV9JTkZJTklUWTtcclxuICAgIGxldCBjbG9zZXN0VHJpYW5nbGUgPSAtMTtcclxuXHJcbiAgICB0aGlzLl90cmlhbmdsZXMuZm9yRWFjaCgodHJpYW5nbGUsIGluZGV4KSA9PiB7XHJcbiAgICAgIGNvbnN0IHBvaW50QSA9IE1hdGhVdGlscy5jbG9zZXN0UG9pbnRPbkxpbmUoXHJcbiAgICAgICAgdGhpcy5fdmVydGljZXNbdHJpYW5nbGVbMF1dLFxyXG4gICAgICAgIHRoaXMuX3ZlcnRpY2VzW3RyaWFuZ2xlWzFdXSxcclxuICAgICAgICBwXHJcbiAgICAgICk7XHJcbiAgICAgIGNvbnN0IHBvaW50QiA9IE1hdGhVdGlscy5jbG9zZXN0UG9pbnRPbkxpbmUoXHJcbiAgICAgICAgdGhpcy5fdmVydGljZXNbdHJpYW5nbGVbMV1dLFxyXG4gICAgICAgIHRoaXMuX3ZlcnRpY2VzW3RyaWFuZ2xlWzJdXSxcclxuICAgICAgICBwXHJcbiAgICAgICk7XHJcbiAgICAgIGNvbnN0IHBvaW50QyA9IE1hdGhVdGlscy5jbG9zZXN0UG9pbnRPbkxpbmUoXHJcbiAgICAgICAgdGhpcy5fdmVydGljZXNbdHJpYW5nbGVbMl1dLFxyXG4gICAgICAgIHRoaXMuX3ZlcnRpY2VzW3RyaWFuZ2xlWzBdXSxcclxuICAgICAgICBwXHJcbiAgICAgICk7XHJcblxyXG4gICAgICBjb25zdCBkaXN0QSA9IE1hdGhVdGlscy5kaXN0YW5jZVNxdWFyZWQocG9pbnRBLCBwKTtcclxuICAgICAgY29uc3QgZGlzdEIgPSBNYXRoVXRpbHMuZGlzdGFuY2VTcXVhcmVkKHBvaW50QiwgcCk7XHJcbiAgICAgIGNvbnN0IGRpc3RDID0gTWF0aFV0aWxzLmRpc3RhbmNlU3F1YXJlZChwb2ludEMsIHApO1xyXG5cclxuICAgICAgbGV0IGxvY2FsQ2xvc2VzdFBvaW50ID0gcG9pbnRDO1xyXG4gICAgICBsZXQgbG9jYWxNaW5EaXN0ID0gZGlzdEM7XHJcblxyXG4gICAgICBpZiAoZGlzdEEgPCBsb2NhbE1pbkRpc3QpIHtcclxuICAgICAgICBsb2NhbENsb3Nlc3RQb2ludCA9IHBvaW50QTtcclxuICAgICAgICBsb2NhbE1pbkRpc3QgPSBkaXN0QTtcclxuICAgICAgfVxyXG4gICAgICBpZiAoZGlzdEIgPCBsb2NhbE1pbkRpc3QpIHtcclxuICAgICAgICBsb2NhbENsb3Nlc3RQb2ludCA9IHBvaW50QjtcclxuICAgICAgICBsb2NhbE1pbkRpc3QgPSBkaXN0QjtcclxuICAgICAgfVxyXG5cclxuICAgICAgaWYgKGxvY2FsTWluRGlzdCA8IGdsb2JhbE1pbkRpc3QpIHtcclxuICAgICAgICBnbG9iYWxNaW5EaXN0ID0gbG9jYWxNaW5EaXN0O1xyXG4gICAgICAgIGdsb2JhbENsb3Nlc3RQb2ludCA9IFsuLi5sb2NhbENsb3Nlc3RQb2ludF07XHJcbiAgICAgICAgY2xvc2VzdFRyaWFuZ2xlID0gaW5kZXg7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHRoaXMuX3NldEluZmx1ZW5jZVRyaWFuZ2xlKFxyXG4gICAgICB0aGlzLl90cmlhbmdsZXNbY2xvc2VzdFRyaWFuZ2xlXSxcclxuICAgICAgZ2xvYmFsQ2xvc2VzdFBvaW50XHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRGV0ZXJtaW5lcyB0aGUgY2xvc2VzdCBwb2ludCBvbiB0aGUgbGluZSBmb3JtZWQgYmV0d2VlbiB0aGVcclxuICAgKiB0d28gYmxlbmQgdGhyZXNob2xkcyBiYXNlZCBvbiB0aGUgY3VycmVudCBbeCx5XSBibGVuZFZhbHVlcyBhbmRcclxuICAgKiB0aGVuIHNldHMgYmxlbmQgd2VpZ2h0cyBmb3IgdGhlIGNvcnJlc3BvbmRpbmcgc3RhdGVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gcCAtIEdpdmVuIFt4LHldIGJsZW5kVmFsdWUuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9zZXRJbmZsdWVuY2VDbG9zZXN0UG9pbnRPbkxpbmUocCkge1xyXG4gICAgY29uc3QgY2xvc2VzdFBvaW50ID0gTWF0aFV0aWxzLmNsb3Nlc3RQb2ludE9uTGluZShcclxuICAgICAgdGhpcy5fdmVydGljZXNbWzBdXSxcclxuICAgICAgdGhpcy5fdmVydGljZXNbWzFdXSxcclxuICAgICAgcFxyXG4gICAgKTtcclxuXHJcbiAgICBjb25zdCBkaXN0QSA9IE1hdGhVdGlscy5kaXN0YW5jZVNxdWFyZWQodGhpcy5fdmVydGljZXNbMF0sIGNsb3Nlc3RQb2ludCk7XHJcbiAgICBjb25zdCBkaXN0QiA9IE1hdGhVdGlscy5kaXN0YW5jZVNxdWFyZWQodGhpcy5fdmVydGljZXNbMV0sIGNsb3Nlc3RQb2ludCk7XHJcblxyXG4gICAgY29uc3Qgd2VpZ2h0QSA9IGRpc3RCIC8gKGRpc3RBICsgZGlzdEIpO1xyXG4gICAgY29uc3Qgd2VpZ2h0QiA9IGRpc3RBIC8gKGRpc3RBICsgZGlzdEIpO1xyXG5cclxuICAgIGNvbnN0IHRocmVzaG9sZEEgPSB0aGlzLl90aHJlc2hvbGRzWzBdO1xyXG4gICAgY29uc3QgdGhyZXNob2xkQiA9IHRoaXMuX3RocmVzaG9sZHNbMV07XHJcblxyXG4gICAgY29uc3Qgc3RhdGVBID0gdGhpcy5fc3RhdGVzLmdldCh0aHJlc2hvbGRBLm5hbWUpO1xyXG4gICAgY29uc3Qgc3RhdGVCID0gdGhpcy5fc3RhdGVzLmdldCh0aHJlc2hvbGRCLm5hbWUpO1xyXG5cclxuICAgIHN0YXRlQS5zZXRXZWlnaHQod2VpZ2h0QSk7XHJcbiAgICBzdGF0ZUIuc2V0V2VpZ2h0KHdlaWdodEIpO1xyXG5cclxuICAgIHRoaXMuX3NldFBoYXNlTGVhZFN0YXRlKFxyXG4gICAgICBbc3RhdGVBLCBzdGF0ZUJdLFxyXG4gICAgICBbdGhyZXNob2xkQS5waGFzZU1hdGNoLCB0aHJlc2hvbGRCLnBoYXNlTWF0Y2hdXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0cyBhIGxlYWQgcGhhc2Ugc3RhdGUgaWYgdGhlIGNvbmRpdGlvbnNcclxuICAgKiBmb3IgcGhhc2UtbWF0Y2hpbmcgYXJlIHNhdGlzZmllZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPEFic3RyYWN0QmxlbmRTdGF0ZT59IHN0YXRlcyAtIFN0YXRlcyB0b1xyXG4gICAqIGNoZWNrIHBoYXNlLW1hdGNoaW5nIGNyaXRlcmlhLlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPGJvb2xlYW4+fSBwaGFzZU1hdGNoZWQgLSBMaXN0IG9mIHBoYXNlLW1hdGNoIGJvb2xlYW5zLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfc2V0UGhhc2VMZWFkU3RhdGUoc3RhdGVzLCBwaGFzZU1hdGNoZWQpIHtcclxuICAgIGxldCBtYXggPSAwO1xyXG4gICAgc3RhdGVzLmZvckVhY2goKHN0YXRlLCBpbmRleCkgPT4ge1xyXG4gICAgICBpZiAocGhhc2VNYXRjaGVkW2luZGV4XSAmJiBzdGF0ZS53ZWlnaHQgPiBtYXgpIHtcclxuICAgICAgICB0aGlzLl9waGFzZUxlYWRTdGF0ZSA9IHN0YXRlO1xyXG4gICAgICAgIG1heCA9IHN0YXRlLndlaWdodDtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBCbGVuZDJkU3RhdGU7XHJcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcclxuaW1wb3J0IEFic3RyYWN0QmxlbmRTdGF0ZSBmcm9tICcuL3N0YXRlL0Fic3RyYWN0QmxlbmRTdGF0ZSc7XHJcbmltcG9ydCBBbmltYXRpb25QbGF5ZXJJbnRlcmZhY2UgZnJvbSAnLi9BbmltYXRpb25QbGF5ZXJJbnRlcmZhY2UnO1xyXG5pbXBvcnQgQW5pbWF0aW9uVXRpbHMgZnJvbSAnLi9BbmltYXRpb25VdGlscyc7XHJcbmltcG9ydCBNYXRoVXRpbHMgZnJvbSAnLi4vTWF0aFV0aWxzJztcclxuaW1wb3J0IERlZmVycmVkIGZyb20gJy4uL0RlZmVycmVkJztcclxuaW1wb3J0IFN0YXRlQ29udGFpbmVySW50ZXJmYWNlIGZyb20gJy4vc3RhdGUvU3RhdGVDb250YWluZXJJbnRlcmZhY2UnO1xyXG5cclxuLyoqXHJcbiAqIEVudW0gZm9yIHR5cGVzIG9mIHtAbGluayBBbmltYXRpb25MYXllcn0gYmxlbmRpbmcuXHJcbiAqXHJcbiAqIEByZWFkb25seVxyXG4gKiBAZW51bSB7c3RyaW5nfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IExheWVyQmxlbmRNb2RlcyA9IHtPdmVycmlkZTogJ092ZXJyaWRlJywgQWRkaXRpdmU6ICdBZGRpdGl2ZSd9O1xyXG5cclxuLyoqXHJcbiAqIFRoZSBkZWZhdWx0IGJsZW5kaW5nIG1vZGUge0BsaW5rIEFuaW1hdGlvbkxheWVyfS5cclxuICpcclxuICogQHJlYWRvbmx5XHJcbiAqIEB0eXBlIHtzdHJpbmd9XHJcbiAqL1xyXG5leHBvcnQgY29uc3QgRGVmYXVsdExheWVyQmxlbmRNb2RlID0gJ092ZXJyaWRlJztcclxuXHJcbi8qKlxyXG4gKiBDaGVja3MgaWYgYSBnaXZlbiBibGVuZE1vZGUgaXMgcHJlc2VudCBpbiB0aGUgdmFsdWVzIG9mIHtAbGluayBMYXllckJsZW5kTW9kZXN9LlxyXG4gKiBJZiBpdCBpcywgcmV0dXJuIHRoZSBvcmlnaW5hbCB2YWx1ZSwgb3RoZXJ3aXNlIHJldHVybiB7QGxpbmsgRGVmYXVsdExheWVyQmxlbmRNb2RlfS5cclxuICpcclxuICogQHBhcmFtIHtzdHJpbmd9IGJsZW5kTW9kZSAtIFRoZSBuYW1lIG9mIHRoZSB0eXBlIG9mIGJsZW5kaW5nLlxyXG4gKlxyXG4gKiBAcmV0dXJucyB7KHN0cmluZ3xEZWZhdWx0TGF5ZXJCbGVuZE1vZGUpfVxyXG4gKi9cclxuZXhwb3J0IGZ1bmN0aW9uIHZhbGlkYXRlQmxlbmRNb2RlKGJsZW5kTW9kZSkge1xyXG4gIGlmIChBcnJheS5mcm9tKE9iamVjdC52YWx1ZXMoTGF5ZXJCbGVuZE1vZGVzKSkuaW5jbHVkZXMoYmxlbmRNb2RlKSkge1xyXG4gICAgcmV0dXJuIGJsZW5kTW9kZTtcclxuICB9IGVsc2Uge1xyXG4gICAgcmV0dXJuIERlZmF1bHRMYXllckJsZW5kTW9kZTtcclxuICB9XHJcbn1cclxuXHJcbi8qKlxyXG4gKiBDbGFzcyBmb3IgbWFuYWdpbmcgYSBzZXQgb2YgYW5pbWF0aW9ucyB3aGVyZSBvbmx5IG9uZSBzdGF0ZSBjYW4gYmUgYWN0aXZlIGF0XHJcbiAqIGFueSBnaXZlbiB0aW1lLlxyXG4gKlxyXG4gKiBAaW1wbGVtZW50cyBBbmltYXRpb25QbGF5ZXJJbnRlcmZhY2VcclxuICogQGltcGxlbWVudHMgU3RhdGVDb250YWluZXJJbnRlcmZhY2VcclxuICovXHJcbmNsYXNzIEFuaW1hdGlvbkxheWVyIGV4dGVuZHMgQW5pbWF0aW9uUGxheWVySW50ZXJmYWNlLk1peGluKFxyXG4gIFN0YXRlQ29udGFpbmVySW50ZXJmYWNlLk1peGluKClcclxuKSB7XHJcbiAgLyoqXHJcbiAgICogQGNvbnN0cnVjdG9yXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgLSAgT3B0aW9ucyBmb3IgdGhlIGFuaW1hdGlvbiBsYXllci5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gb3B0aW9ucy5uYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIuIE5hbWVzIG11c3QgYmUgdW5pcXVlIHRvIHRoZVxyXG4gICAqIGFuaW1hdGlvbiBmZWF0dXJlIHRoYXQgY29udGFpbnMgdGhlIGxheWVyLlxyXG4gICAqIEBwYXJhbSB7TGF5ZXJCbGVuZE1vZGVzfSBbb3B0aW9ucy5ibGVuZE1vZGU9RGVmYXVsdExheWVyQmxlbmRNb2RlXSAtXHJcbiAgICogVHlwZSBvZiBibGVuZGluZyB0byB1c2UgZm9yIGFsbCBzdGF0ZXMgY29udHJvbGxlZCBieSB0aGUgbGF5ZXIuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLndlaWdodD0xXSAtIFRoZSBhbW91bnQgb2YgaW5mbHVlbmNlIHRoZSBsYXllcidzIGN1cnJlbnRcclxuICAgKiBhbmltYXRpb24gaGFzIG92ZXIgdGhlIHJlc3VsdCBmb3IgdGhlIGhvc3QuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnRyYW5zaXRpb25UaW1lPTBdIC0gVGhlIGRlZmF1bHQgYW1vdW50IG9mIHRpbWUgdG8gdXNlIHdoZW5cclxuICAgKiBwbGF5aW5nIGFuZCByZXN1bWluZyBhbmltYXRpb25zLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvcHRpb25zLmVhc2luZ0ZuIC0gVGhlIGRlZmF1bHQgZWFzaW5nIGZ1bmN0aW9uIHRvIHVzZSB3aGVuXHJcbiAgICogdHJhbnNpdGlvbmluZyBiZXR3ZWVuIGFuaW1hdGlvbnMgYW5kIHNldHRpbmcgbGF5ZXIgd2VpZ2h0LlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3VwZXIob3B0aW9ucyk7XHJcblxyXG4gICAgdGhpcy5uYW1lID0gb3B0aW9ucy5uYW1lID09PSB1bmRlZmluZWQgPyAnQW5pbWF0aW9uTGF5ZXInIDogb3B0aW9ucy5uYW1lO1xyXG4gICAgdGhpcy5fYmxlbmRNb2RlID0gQXJyYXkuZnJvbShPYmplY3QudmFsdWVzKExheWVyQmxlbmRNb2RlcykpLmluY2x1ZGVzKFxyXG4gICAgICBvcHRpb25zLmJsZW5kTW9kZVxyXG4gICAgKVxyXG4gICAgICA/IG9wdGlvbnMuYmxlbmRNb2RlXHJcbiAgICAgIDogRGVmYXVsdExheWVyQmxlbmRNb2RlO1xyXG4gICAgdGhpcy5fcHJvbWlzZXMgPSB7XHJcbiAgICAgIHdlaWdodDogRGVmZXJyZWQucmVzb2x2ZSgpLFxyXG4gICAgfTtcclxuICAgIHRoaXMuX3dlaWdodFBhdXNlZCA9IGZhbHNlO1xyXG5cclxuICAgIHRoaXMud2VpZ2h0ID0gdHlwZW9mIG9wdGlvbnMud2VpZ2h0ID09PSAnbnVtYmVyJyA/IG9wdGlvbnMud2VpZ2h0IDogMTtcclxuICAgIHRoaXMuX2ludGVybmFsV2VpZ2h0ID0gdGhpcy5fd2VpZ2h0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgdHlwZSBvZiBibGVuZGluZyB1c2VkIGZvciBzdGF0ZXMgY29udHJvbGxlZCBieSB0aGUgbGF5ZXIuXHJcbiAgICpcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAqL1xyXG4gIGdldCBibGVuZE1vZGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fYmxlbmRNb2RlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyBhbmQgc2V0cyB0aGUgYW1vdW50IG9mIGluZmx1ZW5jZSB0aGUgbGF5ZXIncyBjdXJyZW50IGFuaW1hdGlvbiBoYXMgb3ZlclxyXG4gICAqIHRoZSByZXN1bHQgZm9yIHRoZSBob3N0LlxyXG4gICAqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBzZXQgd2VpZ2h0KHdlaWdodCkge1xyXG4gICAgdGhpcy5fd2VpZ2h0ID0gTWF0aFV0aWxzLmNsYW1wKHdlaWdodCwgMCwgMSk7XHJcbiAgfVxyXG5cclxuICBnZXQgd2VpZ2h0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3dlaWdodDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgd2hldGhlciBvciBub3QgdGhlIGxheWVyJ3Mgd2VpZ2h0IHZhbHVlIGlzIGN1cnJlbnRseSBiZWluZyBhbmltYXRlZC5cclxuICAgKlxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGdldCB3ZWlnaHRQZW5kaW5nKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3Byb21pc2VzLndlaWdodCAmJiB0aGlzLl9wcm9taXNlcy53ZWlnaHQucGVuZGluZztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhdXNlIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBzdGF0ZSBhbmQgYW55IGludGVycG9sYXRpb24gaGFwcGVuaW5nIG9uIHRoZSBsYXllcidzXHJcbiAgICogd2VpZ2h0IHByb3BlcnR5LlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgcGF1c2UoKSB7XHJcbiAgICB0aGlzLl9wYXVzZWQgPSB0cnVlO1xyXG4gICAgdGhpcy5fd2VpZ2h0UGF1c2VkID0gdHJ1ZTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5wYXVzZUFuaW1hdGlvbigpIHx8IHRoaXMud2VpZ2h0UGVuZGluZztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc3VtZSB0aGUgY3VycmVudCBhbmltYXRpb24gc3RhdGUgYW5kIGFueSBpbnRlcnBvbGF0aW9uIGhhcHBlbmluZyBvbiB0aGUgbGF5ZXInc1xyXG4gICAqIHdlaWdodCBwcm9wZXJ0eS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqL1xyXG4gIHJlc3VtZSgpIHtcclxuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xyXG4gICAgdGhpcy5fd2VpZ2h0UGF1c2VkID0gZmFsc2U7XHJcblxyXG4gICAgY29uc3QgaXNXZWlnaHRBY3RpdmUgPSB0aGlzLndlaWdodFBlbmRpbmc7XHJcblxyXG4gICAgaWYgKHRoaXMuX2N1cnJlbnRTdGF0ZSkge1xyXG4gICAgICByZXR1cm4gdGhpcy5yZXN1bWVBbmltYXRpb24oKSB8fCBpc1dlaWdodEFjdGl2ZTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBpc1dlaWdodEFjdGl2ZTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgdGhlIHVzZXIgZGVmaW5lZCB3ZWlnaHQgb3ZlciB0aW1lLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHdlaWdodCAtIFRoZSB0YXJnZXQgd2VpZ2h0IHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc2Vjb25kcz0wXSAtIFRoZSBhbW91bnQgb2YgdGltZSBpdCB3aWxsIHRha2UgdG8gcmVhY2ggdGhlXHJcbiAgICogdGFyZ2V0IHdlaWdodC5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gZWFzaW5nRm4gLSBUaGUgZWFzaW5nIGZ1bmN0aW9uIHRvIHVzZSBmb3IgaW50ZXJwb2xhdGlvbi5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH1cclxuICAgKi9cclxuICBzZXRXZWlnaHQod2VpZ2h0LCBzZWNvbmRzID0gMCwgZWFzaW5nRm4pIHtcclxuICAgIGlmICh0aGlzLndlaWdodFBlbmRpbmcpIHtcclxuICAgICAgdGhpcy5fcHJvbWlzZXMud2VpZ2h0LmNhbmNlbCgpO1xyXG4gICAgfVxyXG5cclxuICAgIHdlaWdodCA9IE1hdGhVdGlscy5jbGFtcCh3ZWlnaHQpO1xyXG4gICAgdGhpcy5fcHJvbWlzZXMud2VpZ2h0ID0gQW5pbWF0aW9uVXRpbHMuaW50ZXJwb2xhdGVQcm9wZXJ0eShcclxuICAgICAgdGhpcyxcclxuICAgICAgJ3dlaWdodCcsXHJcbiAgICAgIHdlaWdodCxcclxuICAgICAge1xyXG4gICAgICAgIHNlY29uZHMsXHJcbiAgICAgICAgZWFzaW5nRm46IGVhc2luZ0ZuICE9PSB1bmRlZmluZWQgPyBlYXNpbmdGbiA6IHRoaXMuX2Vhc2luZ0ZuLFxyXG4gICAgICB9XHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiB0aGlzLl9wcm9taXNlcy53ZWlnaHQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQYXVzZSBhbnkgaW50ZXJwb2xhdGlvbiBoYXBwZW5pbmcgb24gdGhlIGxheWVyJ3Mgd2VpZ2h0IHByb3BlcnR5LlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgcGF1c2VXZWlnaHQoKSB7XHJcbiAgICB0aGlzLl93ZWlnaHRQYXVzZWQgPSB0cnVlO1xyXG5cclxuICAgIHJldHVybiB0aGlzLndlaWdodFBlbmRpbmc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXN1bWUgYW55IGludGVycG9sYXRpb24gaGFwcGVuaW5nIG9uIHRoZSBsYXllcidzIHdlaWdodCBwcm9wZXJ0eS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqL1xyXG4gIHJlc3VtZVdlaWdodCgpIHtcclxuICAgIHRoaXMuX3dlaWdodFBhdXNlZCA9IGZhbHNlO1xyXG5cclxuICAgIHJldHVybiB0aGlzLndlaWdodFBlbmRpbmc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNdWx0aXBsaWVzIHRoZSB1c2VyIHdlaWdodCBieSBhIGZhY3RvciB0byBkZXRlcm1pbmUgdGhlIGludGVybmFsIHdlaWdodC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmYWN0b3IgLSAwLTEgbXVsdGlwbGllciB0byBhcHBseSB0byB0aGUgdXNlciB3ZWlnaHQuXHJcbiAgICovXHJcbiAgdXBkYXRlSW50ZXJuYWxXZWlnaHQoZmFjdG9yKSB7XHJcbiAgICB0aGlzLl9pbnRlcm5hbFdlaWdodCA9IHRoaXMuX3dlaWdodCAqIGZhY3RvcjtcclxuXHJcbiAgICBpZiAodGhpcy5fY3VycmVudFN0YXRlKSB7XHJcbiAgICAgIHRoaXMuX2N1cnJlbnRTdGF0ZS51cGRhdGVJbnRlcm5hbFdlaWdodCh0aGlzLl9pbnRlcm5hbFdlaWdodCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBuYW1lcyBvZiBibGVuZCBzdGF0ZXMgaW4gYW4gYW5pbWF0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFuaW1hdGlvbk5hbWUgLSBOYW1lIG9mIHRoZSBhbmltYXRpb24uXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7QXJyYXkuPHN0cmluZz59IC0gTmFtZXMgb2YgYmxlbmQgc3RhdGVzLlxyXG4gICAqL1xyXG4gIGdldEFuaW1hdGlvbkJsZW5kTmFtZXMoYW5pbWF0aW9uTmFtZSkge1xyXG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldFN0YXRlKGFuaW1hdGlvbk5hbWUpO1xyXG5cclxuICAgIGlmIChzdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBgQ2Fubm90IGdldCBibGVuZCBuYW1lcyBvZiBhbmltYXRpb24gJHthbmltYXRpb25OYW1lfSBvbiBsYXllciAke3RoaXMubmFtZX0uIE5vIGFuaW1hdGlvbiBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChzdGF0ZSBpbnN0YW5jZW9mIEFic3RyYWN0QmxlbmRTdGF0ZSkge1xyXG4gICAgICByZXR1cm4gc3RhdGUuZ2V0U3RhdGVOYW1lcygpO1xyXG4gICAgfVxyXG5cclxuICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgYENhbm5vdCBnZXQgYmxlbmQgbmFtZXMgb2YgYW5pbWF0aW9uICR7YW5pbWF0aW9uTmFtZX0gb24gbGF5ZXIgJHt0aGlzLm5hbWV9LiBBbmltYXRpb24gaXMgbm90IGFuIGluc3RhbmNlIG9mIEFic3RyYWN0QmxlbmRTdGF0ZS5gXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIHRoZSB3ZWlnaHQgZm9yIGEgYmxlbmQgc3RhdGUgb2YgYW4gYW5pbWF0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFuaW1hdGlvbk5hbWUgLSBOYW1lIG9mIHRoZSBhbmltYXRpb24gY29udGFpbmluZyB0aGUgYmxlbmQgc3RhdGVcclxuICAgKiB0byB1cGRhdGUuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGJsZW5kTmFtZSAtIE5hbWUgb2YgdGhlIGJsZW5kIHN0YXRlIHRvIHVwZGF0ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gd2VpZ2h0IC0gV2VpZ2h0IHZhbHVlIHRvIHNldCBvbiB0aGUgYW5pbWF0aW9uLiBUaGlzIG51bWJlciBzaG91ZGxkIGJlXHJcbiAgICogaW4gdGhlIDAtMSByYW5nZS5cclxuICAgKiBAcGFyYW0ge251bWJlcj19IHNlY29uZHMgLSBOdW1iZXIgb2Ygc2Vjb25kcyBpdCBzaG91bGQgdGFrZSB0byByZWFjaCB0aGUgbmV3IHdlaWdodC5cclxuICAgKiBEZWZhdWx0IGlzIHplcm8gYW5kIHdpbGwgc2V0IGltbWVkaWF0ZWx5LlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBlYXNpbmdGbiAtIEVhc2luZyBmdW5jdGlvbiB0byB1c2Ugd2hpbGUgaW50ZXJwb2xhdGluZyB0aGUgbmV3XHJcbiAgICogd2VpZ2h0LiBEZWZhdWx0IGlzIEVhc2luZy5MaW5lYXIuSW5PdXQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9IC0gUHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSBvbmNlIHRoZSBhbmltYXRpb24ncyB3ZWlnaHQgcmVhY2hlc1xyXG4gICAqIHRoZSB0YXJnZXQgdmFsdWUuXHJcbiAgICovXHJcbiAgc2V0QW5pbWF0aW9uQmxlbmRXZWlnaHQoXHJcbiAgICBhbmltYXRpb25OYW1lLFxyXG4gICAgYmxlbmROYW1lLFxyXG4gICAgd2VpZ2h0LFxyXG4gICAgc2Vjb25kcyA9IDAsXHJcbiAgICBlYXNpbmdGblxyXG4gICkge1xyXG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldFN0YXRlKGFuaW1hdGlvbk5hbWUpO1xyXG5cclxuICAgIGlmIChzdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBgQ2Fubm90IHNldCBibGVuZCB3ZWlnaHQgb2YgYW5pbWF0aW9uICR7YW5pbWF0aW9uTmFtZX0gb24gbGF5ZXIgJHt0aGlzLm5hbWV9LiBObyBhbmltYXRpb24gZXhpc3RzIHdpdGggdGhpcyBuYW1lLmBcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc3RhdGUgaW5zdGFuY2VvZiBBYnN0cmFjdEJsZW5kU3RhdGUpIHtcclxuICAgICAgcmV0dXJuIHN0YXRlLnNldEJsZW5kV2VpZ2h0KGJsZW5kTmFtZSwgd2VpZ2h0LCBzZWNvbmRzLCBlYXNpbmdGbik7XHJcbiAgICB9XHJcblxyXG4gICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICBgQ2Fubm90IHNldCBibGVuZCB3ZWlnaHQgb2YgYW5pbWF0aW9uICR7YW5pbWF0aW9uTmFtZX0gb24gbGF5ZXIgJHt0aGlzLm5hbWV9LiBBbmltYXRpb24gaXMgbm90IGFuIGluc3RhbmNlIG9mIEFic3RyYWN0QmxlbmRTdGF0ZS5gXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgd2VpZ2h0IGZvciBhIGJsZW5kIHN0YXRlIG9mIGFuIGFuaW1hdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhbmltYXRpb25OYW1lIC0gTmFtZSBvZiB0aGUgYW5pbWF0aW9uIGNvbnRhaW5pbmcgdGhlIGJsZW5kIHN0YXRlXHJcbiAgICogdG8gdXBkYXRlLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBibGVuZE5hbWUgLSBOYW1lIG9mIHRoZSBibGVuZCBzdGF0ZSB0byByZXRyaWV2ZSB0aGUgd2VpZ2h0IG9mLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge251bWJlcn0gLSBXZWlnaHQgb2YgdGhlIGJsZW5kIHN0YXRlLlxyXG4gICAqL1xyXG4gIGdldEFuaW1hdGlvbkJsZW5kV2VpZ2h0KGFuaW1hdGlvbk5hbWUsIGJsZW5kTmFtZSkge1xyXG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzLmdldFN0YXRlKGFuaW1hdGlvbk5hbWUpO1xyXG5cclxuICAgIGlmIChzdGF0ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBgQ2Fubm90IGdldCBibGVuZCB3ZWlnaHQgb2YgYW5pbWF0aW9uICR7YW5pbWF0aW9uTmFtZX0gb24gbGF5ZXIgJHt0aGlzLm5hbWV9LiBObyBhbmltYXRpb24gZXhpc3RzIHdpdGggdGhpcyBuYW1lLmBcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoc3RhdGUgaW5zdGFuY2VvZiBBYnN0cmFjdEJsZW5kU3RhdGUpIHtcclxuICAgICAgcmV0dXJuIHN0YXRlLmdldEJsZW5kV2VpZ2h0KGJsZW5kTmFtZSk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICBgQ2Fubm90IGdldCBibGVuZCB3ZWlnaHQgb2YgYW5pbWF0aW9uICR7YW5pbWF0aW9uTmFtZX0gb24gbGF5ZXIgJHt0aGlzLm5hbWV9LiBBbmltYXRpb24gaXMgbm90IGFuIGluc3RhbmNlIG9mIEFic3RyYWN0QmxlbmRTdGF0ZS5gXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIGFueSB3ZWlnaHQgaW50ZXJwb2xhdG9ycyBhbmQgdGhlIGN1cnJlbnQgYW5pbWF0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGRlbHRhVGltZSAtIFRpbWUgaW4gbWlsbGlzZWNvbmRzIHNpbmNlIHRoZSBsYXN0IHVwZGF0ZS5cclxuICAgKi9cclxuICB1cGRhdGUoZGVsdGFUaW1lKSB7XHJcbiAgICBzdXBlci51cGRhdGUoZGVsdGFUaW1lKTtcclxuXHJcbiAgICBpZiAoIXRoaXMuX3BhdXNlZCAmJiAhdGhpcy5fd2VpZ2h0UGF1c2VkKSB7XHJcbiAgICAgIHRoaXMuX3Byb21pc2VzLndlaWdodC5leGVjdXRlKGRlbHRhVGltZSk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYW5jZWwgYW55IHBlbmRpbmcgcHJvbWlzZXMgYW5kIGRpc2NhcmQgc3RhdGVzIGNvbnRyb2xsZWQgYnkgdGhlIGxheWVyLlxyXG4gICAqL1xyXG4gIGRpc2NhcmQoKSB7XHJcbiAgICBzdXBlci5kaXNjYXJkKCk7XHJcblxyXG4gICAgdGhpcy5kaXNjYXJkU3RhdGVzKCk7XHJcblxyXG4gICAgdGhpcy5fcHJvbWlzZXMud2VpZ2h0LmNhbmNlbCgpO1xyXG4gICAgZGVsZXRlIHRoaXMuX3Byb21pc2VzO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgQW5pbWF0aW9uTGF5ZXI7XHJcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcclxuaW1wb3J0IERlZmVycmVkIGZyb20gJ2NvcmUvRGVmZXJyZWQnO1xyXG5pbXBvcnQgQWJzdHJhY3RTdGF0ZSBmcm9tICcuL0Fic3RyYWN0U3RhdGUnO1xyXG5pbXBvcnQge3ZhbGlkYXRlQmxlbmRNb2RlfSBmcm9tICcuLi9BbmltYXRpb25MYXllcic7XHJcbmltcG9ydCBBbmltYXRpb25VdGlscyBmcm9tICcuLi9BbmltYXRpb25VdGlscyc7XHJcblxyXG4vKipcclxuICogQ2xhc3MgZm9yIHBsYXlpbmcgYSBzaW5nbGUgYW5pbWF0aW9uIGNsaXAuXHJcbiAqXHJcbiAqIEBleHRlbmRzIEFic3RyYWN0U3RhdGVcclxuICogQGFsaWFzIGNvcmUvU2luZ2xlU3RhdGVcclxuICovXHJcbmNsYXNzIFNpbmdsZVN0YXRlIGV4dGVuZHMgQWJzdHJhY3RTdGF0ZSB7XHJcbiAgLyoqXHJcbiAgICogQGNvbnN0cnVjdG9yXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgYW5pbWF0aW9uIHN0YXRlLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0aW9ucy5uYW1lIC0gTmFtZSBmb3IgdGhlIGFuaW1hdGlvbiBzdGF0ZS4gTmFtZXMgbXVzdCBiZVxyXG4gICAqIHVuaXF1ZSBmb3IgdGhlIGxheWVyIHRoZSBzdGF0ZSBpcyBhcHBsaWVkIHRvLlxyXG4gICAqIEBwYXJhbSB7d2VpZ2h0fSBbb3B0aW9ucy53ZWlnaHQ9MF0gLSBUaGUgMC0xIGFtb3VudCBvZiBpbmZsdWVuY2UgdGhlIHN0YXRlIHdpbGwgaGF2ZS5cclxuICAgKiBAcGFyYW0ge3RpbWVTY2FsZX0gW29wdGlvbnMudGltZVNjYWxlPTFdIC0gRmFjdG9yIHRvIHNjYWxlIHRoZSBwbGF5YmFjayBzcGVlZCBvZiB0aGVcclxuICAgKiBhbmltYXRpb24uXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxvb3BDb3VudD1JbmZpbml0eV0gLSBOdW1iZXIgb2YgdGltZXMgdGhlIGFuaW1hdGlvbiBzaG91bGRcclxuICAgKiByZXBlYXQgYmVmb3JlIGZpbmlzaGluZy5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYmxlbmRNb2RlPURlZmF1bHRMYXllckJsZW5kTW9kZV0gLSBUeXBlIG9mXHJcbiAgICogYmxlbmRpbmcgdGhlIGFuaW1hdGlvbiBzaG91bGQgdXNlLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSkge1xyXG4gICAgc3VwZXIob3B0aW9ucyk7XHJcblxyXG4gICAgdGhpcy5fdGltZVNjYWxlID0gb3B0aW9ucy50aW1lU2NhbGUgIT09IHVuZGVmaW5lZCA/IG9wdGlvbnMudGltZVNjYWxlIDogMTtcclxuICAgIHRoaXMuX3Byb21pc2VzLnRpbWVTY2FsZSA9IERlZmVycmVkLnJlc29sdmUoKTtcclxuICAgIHRoaXMuX2xvb3BDb3VudCA9XHJcbiAgICAgIG9wdGlvbnMubG9vcENvdW50ICE9PSB1bmRlZmluZWQgPyBvcHRpb25zLmxvb3BDb3VudCA6IEluZmluaXR5O1xyXG4gICAgdGhpcy5fYmxlbmRNb2RlID0gdmFsaWRhdGVCbGVuZE1vZGUob3B0aW9ucy5ibGVuZE1vZGUpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyBhbmQgc2V0cyB0aGUgbm9ybWFsaXplZCBwbGF5aW5nIHRpbWUgb2YgdGhlIGN1cnJlbnQgYW5pbWF0aW9uXHJcbiAgICpcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCBub3JtYWxpemVkVGltZSgpIHtcclxuICAgIHJldHVybiAwO1xyXG4gIH1cclxuXHJcbiAgc2V0IG5vcm1hbGl6ZWRUaW1lKHRpbWUpIHtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgYW5kIHNldHMgdGhlIGEgZmFjdG9yIHRvIHNjYWxlIGFuaW1hdGlvbiBwbGF5YmFjayBzcGVlZCB3aXRoLlxyXG4gICAqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgdGltZVNjYWxlKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3RpbWVTY2FsZTtcclxuICB9XHJcblxyXG4gIHNldCB0aW1lU2NhbGUodGltZVNjYWxlKSB7XHJcbiAgICB0aGlzLl90aW1lU2NhbGUgPSB0aW1lU2NhbGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHdoZXRoZXIgb3Igbm90IHRoZSB0aW1lU2NhbGUgaXMgY3VycmVudGx5IGJlaW5nIGFuaW1hdGVkLlxyXG4gICAqXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgZ2V0IHRpbWVTY2FsZVBlbmRpbmcoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZXMudGltZVNjYWxlLnBlbmRpbmc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGVzIHRoZSB0aW1lU2NhbGUgdmFsdWUgb3ZlciB0aW1lLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHdlaWdodCAtIFRoZSB0YXJnZXQgdGltZVNjYWxlIHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc2Vjb25kcz0wXSAtIFRoZSBhbW91bnQgb2YgdGltZSBpdCB3aWxsIHRha2UgdG8gcmVhY2ggdGhlXHJcbiAgICogdGFyZ2V0IHRpbWVTY2FsZS5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gZWFzaW5nRm4gLSBUaGUgZWFzaW5nIGZ1bmN0aW9uIHRvIHVzZSBmb3IgaW50ZXJwb2xhdGlvbi5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH1cclxuICAgKi9cclxuICBzZXRUaW1lU2NhbGUodGltZVNjYWxlLCBzZWNvbmRzID0gMCwgZWFzaW5nRm4pIHtcclxuICAgIHRoaXMuX3Byb21pc2VzLnRpbWVTY2FsZS5jYW5jZWwoKTtcclxuXHJcbiAgICB0aGlzLl9wcm9taXNlcy50aW1lU2NhbGUgPSBBbmltYXRpb25VdGlscy5pbnRlcnBvbGF0ZVByb3BlcnR5KFxyXG4gICAgICB0aGlzLFxyXG4gICAgICAndGltZVNjYWxlJyxcclxuICAgICAgdGltZVNjYWxlLFxyXG4gICAgICB7c2Vjb25kcywgZWFzaW5nRm59XHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiB0aGlzLl9wcm9taXNlcy50aW1lU2NhbGU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIGFuZCBzZXRzIHRoZSBudW1iZXIgb2YgdGltZXMgdGhlIGFuaW1hdGlvbiB3aWxsIHJlcGVhdCBiZWZvcmUgZmluaXNoaW5nLlxyXG4gICAqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgbG9vcENvdW50KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2xvb3BDb3VudDtcclxuICB9XHJcblxyXG4gIHNldCBsb29wQ291bnQobG9vcENvdW50KSB7XHJcbiAgICB0aGlzLl9sb29wQ291bnQgPSBsb29wQ291bnQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSB0eXBlIG9mIGJsZW5kaW5nIHVzZWQgZm9yIHRoZSBhbmltYXRpb24uXHJcbiAgICpcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAqL1xyXG4gIGdldCBibGVuZE1vZGUoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fYmxlbmRNb2RlO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgU2luZ2xlU3RhdGU7XHJcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcclxuaW1wb3J0IEFic3RyYWN0U3RhdGUgZnJvbSAnLi9BYnN0cmFjdFN0YXRlJztcclxuaW1wb3J0IFN0YXRlQ29udGFpbmVySW50ZXJmYWNlIGZyb20gJy4vU3RhdGVDb250YWluZXJJbnRlcmZhY2UnO1xyXG5pbXBvcnQgQW5pbWF0aW9uUGxheWVySW50ZXJmYWNlIGZyb20gJy4uL0FuaW1hdGlvblBsYXllckludGVyZmFjZSc7XHJcbmltcG9ydCBVdGlscyBmcm9tICcuLi8uLi9VdGlscyc7XHJcblxyXG4vKipcclxuICogQ2xhc3MgZm9yIHBsYXlpbmcgcmFuZG9tIGFuaW1hdGlvbnMgYXQgcmFuZG9tIGludGVydmFscyB3aXRoaW4gdGhpcyBzdGF0ZS5cclxuICpcclxuICogQGV4dGVuZHMgQWJzdHJhY3RTdGF0ZVxyXG4gKiBAaW1wbGVtZW50cyBBbmltYXRpb25QbGF5ZXJJbnRlcmZhY2VcclxuICogQGltcGxlbWVudHMgU3RhdGVDb250YWluZXJJbnRlcmZhY2VcclxuICovXHJcbmNsYXNzIFJhbmRvbUFuaW1hdGlvblN0YXRlIGV4dGVuZHMgQW5pbWF0aW9uUGxheWVySW50ZXJmYWNlLk1peGluKFN0YXRlQ29udGFpbmVySW50ZXJmYWNlLk1peGluKEFic3RyYWN0U3RhdGUpKSB7XHJcbiAgLyoqXHJcbiAgICogQGNvbnN0cnVjdG9yXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIC0gT3B0aW9ucyBmb3IgdGhlIGNvbnRhaW5lciBzdGF0ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMucGxheUludGVydmFsPTNdIC0gVGhlIGJhc2UgYW5pbWF0aW9uIHBsYXliYWNrIGludGVydmFsLlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPEFic3RyYWN0U3RhdGU+fSBbc3ViU3RhdGVzPVtdXSAtIHN0YXRlcyB0byBiZSByYW5kb21seSBwaWNrZWQgdG8gcGxheVxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMgPSB7fSwgc3ViU3RhdGVzID0gW10pIHtcclxuICAgIHN1cGVyKG9wdGlvbnMpO1xyXG5cclxuICAgIHRoaXMuX3BsYXlJbnRlcnZhbCA9IG9wdGlvbnMucGxheUludGVydmFsID8gb3B0aW9ucy5wbGF5SW50ZXJ2YWwgOiAzO1xyXG5cclxuICAgIHN1YlN0YXRlcy5mb3JFYWNoKHN0YXRlID0+IHtcclxuICAgICAgdGhpcy5hZGRTdGF0ZShzdGF0ZSk7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgYW5kIHNldHMgdGhlIGJhc2UgYW5pbWF0aW9uIHBsYXkgaW50ZXJ2YWxcclxuICAgKlxyXG4gICAqIEB0eXBlIHtmbG9hdH1cclxuICAgKi9cclxuICBnZXQgcGxheUludGVydmFsKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3BsYXlJbnRlcnZhbDtcclxuICB9XHJcblxyXG4gIHNldCBwbGF5SW50ZXJ2YWwocGxheUludGVydmFsKSB7XHJcbiAgICB0aGlzLl9wbGF5SW50ZXJ2YWwgPSBwbGF5SW50ZXJ2YWw7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXNldCB0aGUgaW50ZXJuYWwgdGltZXIgZm9yIGFuaW1hdGlvbiBwbGF5IGludGVydmFsXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9yZXNldFRpbWVyKCkge1xyXG4gICAgY29uc3QgcGxheVRpbWVyID0gVXRpbHMuZ2V0UmFuZG9tRmxvYXQodGhpcy5fcGxheUludGVydmFsIC8gNCwgdGhpcy5fcGxheUludGVydmFsICogMik7XHJcbiAgICBjb25zdCBvbkZpbmlzaCA9ICgpID0+IHtcclxuICAgICAgdGhpcy5wbGF5UmFuZG9tQW5pbWF0aW9uKHRoaXMuX3BsYXlDYWxsYmFja3Mub25FcnJvcik7XHJcbiAgICB9XHJcbiAgICB0aGlzLl9wcm9taXNlcy50aW1lciA9IFV0aWxzLndhaXQocGxheVRpbWVyLCB7b25GaW5pc2h9KTtcclxuICB9XHJcblxyXG4gIHVwZGF0ZUludGVybmFsV2VpZ2h0KGZhY3Rvcikge1xyXG4gICAgc3VwZXIudXBkYXRlSW50ZXJuYWxXZWlnaHQoZmFjdG9yKTtcclxuXHJcbiAgICBpZiAodGhpcy5fY3VycmVudFN0YXRlKSB7XHJcbiAgICAgIHRoaXMuX2N1cnJlbnRTdGF0ZS51cGRhdGVJbnRlcm5hbFdlaWdodCh0aGlzLl9pbnRlcm5hbFdlaWdodCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQaWNrIGEgcmFuZG9tIGFuaW1hdGlvbiBhbmQgdXRpbGl6ZSBBbmltYXRpb25QbGF5ZXJJbnRlcmZhY2UgdG8gcGxheSB0aGF0IGFuaW1hdGlvblxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uRXJyb3IgLSBGdW5jdGlvbiB0byBleGVjdXRlIGlmIHRoZSBzdGF0ZSBlbmNvdW50ZXJzXHJcbiAgICogYW4gZXJyb3IgZHVyaW5nIHBsYXliYWNrLlxyXG4gICAqL1xyXG4gIHBsYXlSYW5kb21BbmltYXRpb24ob25FcnJvcikge1xyXG4gICAgdGhpcy5fcmVzZXRUaW1lcigpO1xyXG5cclxuICAgIGNvbnN0IHN0YXRlcyA9IHRoaXMuZ2V0U3RhdGVOYW1lcygpO1xyXG4gICAgaWYgKHRoaXMuX2N1cnJlbnRTdGF0ZSkge1xyXG4gICAgICBzdGF0ZXMuc3BsaWNlKHN0YXRlcy5pbmRleE9mKHRoaXMuX2N1cnJlbnRTdGF0ZS5uYW1lKSwgMSk7XHJcbiAgICB9XHJcbiAgICBjb25zdCByYW5kb21TdGF0ZSA9ICBzdGF0ZXNbVXRpbHMuZ2V0UmFuZG9tSW50KDAsIHN0YXRlcy5sZW5ndGgpXTtcclxuXHJcbiAgICB0aGlzLnBsYXlBbmltYXRpb24ocmFuZG9tU3RhdGUsIHRoaXMuX3RyYW5zaXRpb25UaW1lLCB0aGlzLl9lYXNpbmdGbiwgdW5kZWZpbmVkLCBvbkVycm9yLCB1bmRlZmluZWQpO1xyXG4gIH1cclxuXHJcbiAgcGxheShvbkZpbmlzaCwgb25FcnJvciwgb25DYW5jZWwpIHtcclxuICAgIHRoaXMucGxheVJhbmRvbUFuaW1hdGlvbihvbkVycm9yKTtcclxuICAgIHJldHVybiBzdXBlci5wbGF5KG9uRmluaXNoLCBvbkVycm9yLCBvbkNhbmNlbCk7XHJcbiAgfVxyXG5cclxuICBwYXVzZSgpIHtcclxuICAgIHJldHVybiBzdXBlci5wYXVzZSgpICYmIHRoaXMucGF1c2VBbmltYXRpb24oKTtcclxuICB9XHJcblxyXG4gIHJlc3VtZShvbkZpbmlzaCwgb25FcnJvciwgb25DYW5jZWwpIHtcclxuICAgIGlmICh0aGlzLl9jdXJyZW50U3RhdGUpIHtcclxuICAgICAgdGhpcy5yZXN1bWVBbmltYXRpb24odGhpcy5fY3VycmVudFN0YXRlLm5hbWUsIHRoaXMuX3RyYW5zaXRpb25UaW1lLCB0aGlzLl9lYXNpbmdGbiwgdW5kZWZpbmVkLCBvbkVycm9yLCB1bmRlZmluZWQpO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIHN1cGVyLnJlc3VtZShvbkZpbmlzaCwgb25FcnJvciwgb25DYW5jZWwpO1xyXG4gIH1cclxuXHJcbiAgY2FuY2VsKCkge1xyXG4gICAgcmV0dXJuIHN1cGVyLmNhbmNlbCgpICYmIHRoaXMuY2FuY2VsQW5pbWF0aW9uKCk7XHJcbiAgfVxyXG5cclxuICBzdG9wKCkge1xyXG4gICAgcmV0dXJuIHN1cGVyLnN0b3AoKSAmJiB0aGlzLnN0b3BBbmltYXRpb24oKTtcclxuICB9XHJcblxyXG4gIGRpc2NhcmQoKSB7XHJcbiAgICBzdXBlci5kaXNjYXJkKCk7XHJcbiAgICB0aGlzLmRpc2NhcmRTdGF0ZXMoKTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFJhbmRvbUFuaW1hdGlvblN0YXRlO1xyXG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXHJcbmltcG9ydCBBYnN0cmFjdEhvc3RGZWF0dXJlIGZyb20gJ2NvcmUvQWJzdHJhY3RIb3N0RmVhdHVyZSc7XHJcbmltcG9ydCBVdGlscyBmcm9tICdjb3JlL1V0aWxzJztcclxuaW1wb3J0IFF1ZXVlU3RhdGUgZnJvbSAnLi9zdGF0ZS9RdWV1ZVN0YXRlJztcclxuaW1wb3J0IEZyZWVCbGVuZFN0YXRlIGZyb20gJy4vc3RhdGUvRnJlZUJsZW5kU3RhdGUnO1xyXG5pbXBvcnQgQmxlbmQxZFN0YXRlIGZyb20gJy4vc3RhdGUvQmxlbmQxZFN0YXRlJztcclxuaW1wb3J0IEJsZW5kMmRTdGF0ZSBmcm9tICcuL3N0YXRlL0JsZW5kMmRTdGF0ZSc7XHJcbmltcG9ydCBTaW5nbGVTdGF0ZSBmcm9tICcuL3N0YXRlL1NpbmdsZVN0YXRlJztcclxuaW1wb3J0IFJhbmRvbUFuaW1hdGlvblN0YXRlIGZyb20gJy4vc3RhdGUvUmFuZG9tQW5pbWF0aW9uU3RhdGUnO1xyXG5pbXBvcnQgQW5pbWF0aW9uTGF5ZXIsIHtMYXllckJsZW5kTW9kZXN9IGZyb20gJy4vQW5pbWF0aW9uTGF5ZXInO1xyXG5pbXBvcnQgRGVmZXJyZWQgZnJvbSAnLi4vRGVmZXJyZWQnO1xyXG5cclxuLyoqXHJcbiAqIEVudW0gZm9yIGFuaW1hdGlvbiBzdGF0ZSBjbGFzc2VzLlxyXG4gKlxyXG4gKiBAcmVhZG9ubHlcclxuICogQGVudW0ge0NsYXNzfVxyXG4gKi9cclxuZXhwb3J0IGNvbnN0IEFuaW1hdGlvblR5cGVzID0ge1xyXG4gIHNpbmdsZTogU2luZ2xlU3RhdGUsXHJcbiAgZnJlZUJsZW5kOiBGcmVlQmxlbmRTdGF0ZSxcclxuICBxdWV1ZTogUXVldWVTdGF0ZSxcclxuICByYW5kb21BbmltYXRpb246IFJhbmRvbUFuaW1hdGlvblN0YXRlLFxyXG4gIGJsZW5kMWQ6IEJsZW5kMWRTdGF0ZSxcclxuICBibGVuZDJkOiBCbGVuZDJkU3RhdGUsXHJcbn07XHJcblxyXG4vKipcclxuICogRmVhdHVyZSBmb3IgbWFuYWdpbmcgYW5pbWF0aW9ucyBvbiBhbiBvYmplY3QuXHJcbiAqXHJcbiAqIEBleHRlbmRzIEFic3RyYWN0SG9zdEZlYXR1cmVcclxuICogQGFsaWFzIGNvcmUvQW5pbWF0aW9uRmVhdHVyZVxyXG4gKlxyXG4gKiBAcHJvcGVydHkge09iamVjdH0gRVZFTlRTIC0gQnVpbHQtaW4gbWVzc2FnZXMgdGhhdCB0aGUgZmVhdHVyZSBlbWl0cy4gV2hlbiB0aGVcclxuICogZmVhdHVyZSBpcyBhZGRlZCB0byBhIHtAbGluayBjb3JlL0hvc3RPYmplY3R9LCBldmVudCBuYW1lcyB3aWxsIGJlIHByZWZpeGVkIGJ5IHRoZVxyXG4gKiBuYW1lIG9mIHRoZSBmZWF0dXJlIGNsYXNzICsgJy4nLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UUy5hZGRMYXllcj1vbkFkZExheWVyRXZlbnRdIC0gTWVzc2FnZSB0aGF0IGlzIGVtaXR0ZWQgYWZ0ZXJcclxuICogW2FkZExheWVyXXtAbGluayBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjYWRkTGF5ZXJ9IGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBleGVjdXRlZC5cclxuICogQW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgbmFtZSBvZiB0aGUgbGF5ZXIgdGhhdCB3YXMgYWRkZWQgYW5kIGl0cyBpbmRleCBpblxyXG4gKiB0aGUgbGF5ZXIgc3RhY2sgd2l0aCB0aGUgc2lnbmF0dXJlIHtuYW1lOiBzdHJpbmcsIGluZGV4OiBudW1iZXJ9IGlzIHN1cHBsaWVkXHJcbiAqIGFzIGFuIGFyZ3VtZW50IHRvIGxpc3RlbmVyIGZ1bmN0aW9ucy5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVFMucmVtb3ZlTGF5ZXI9b25SZW1vdmVMYXllckV2ZW50XSAtIE1lc3NhZ2UgdGhhdCBpc1xyXG4gKiBlbWl0dGVkIGFmdGVyIFtyZW1vdmVMYXllcl17QGxpbmsgY29yZS9BbmltYXRpb25GZWF0dXJlI3JlbW92ZUxheWVyfSBoYXMgYmVlblxyXG4gKiBzdWNjZXNzZnVsbHkgZXhlY3V0ZWQuIEFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIG5hbWUgb2YgdGhlIGxheWVyIHRoYXQgd2FzXHJcbiAqIHJlbW92ZWQgYW5kIGl0cyBpbmRleCBpbiB0aGUgbGF5ZXIgc3RhY2sgd2l0aCB0aGUgc2lnbmF0dXJlIHtuYW1lOiBzdHJpbmcsIGluZGV4OiBudW1iZXJ9XHJcbiAqIGlzIHN1cHBsaWVkIGFzIGFuIGFyZ3VtZW50IHRvIGxpc3RlbmVyIGZ1bmN0aW9ucy5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVFMucmVuYW1lTGF5ZXI9b25SZW5hbWVMYXllckV2ZW50XSAtIE1lc3NhZ2UgdGhhdCBpc1xyXG4gKiBlbWl0dGVkIGFmdGVyIFtyZW5hbWVMYXllcl17QGxpbmsgY29yZS9BbmltYXRpb25GZWF0dXJlI3JlbmFtZUxheWVyfSBoYXMgYmVlblxyXG4gKiBzdWNjZXNzZnVsbHkgZXhlY3V0ZWQuIEFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIG9yaWdpbmFsIG5hbWUgb2YgdGhlIGxheWVyXHJcbiAqIHRoYXQgd2FzIHJlbmFtZWQgYW5kIGl0cyB1cGRhdGVkIG5hbWUgd2l0aCB0aGUgc2lnbmF0dXJlIHtvbGROYW1lOiBzdHJpbmcsIG5ld05hbWU6IHN0cmluZ31cclxuICogaXMgc3VwcGxpZWQgYXMgYW4gYXJndW1lbnQgdG8gbGlzdGVuZXIgZnVuY3Rpb25zLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UUy5hZGRBbmltYXRpb249b25BZGRBbmltYXRpb25FdmVudF0gLSBNZXNzYWdlIHRoYXQgaXNcclxuICogZW1pdHRlZCBhZnRlciBbYWRkQW5pbWF0aW9uXXtAbGluayBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjYWRkQW5pbWF0aW9ufSBoYXMgYmVlblxyXG4gKiBzdWNjZXNzZnVsbHkgZXhlY3V0ZWQuIEFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIG5hbWUgb2YgdGhlIGxheWVyIHRoYXQgdGhlXHJcbiAqIGFuaW1hdGlvbiB3YXMgYWRkZWQgdG8gYW5kIHRoZSBuYW1lIG9mIHRoZSBhbmltYXRpb24gdGhhdCB3YXMgYWRkZWQgd2l0aCB0aGVcclxuICogc2lnbmF0dXJlIHtsYXllck5hbWU6IHN0cmluZywgYW5pbWF0aW9uTmFtZTogc3RyaW5nfSBpcyBzdXBwbGllZCBhcyBhbiBhcmd1bWVudFxyXG4gKiB0byBsaXN0ZW5lciBmdW5jdGlvbnMuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRTLnJlbW92ZUFuaW1hdGlvbj1vblJlbW92ZWRBbmltYXRpb25FdmVudF0gLSBNZXNzYWdlXHJcbiAqIHRoYXQgaXMgZW1pdHRlZCBhZnRlciBbcmVtb3ZlQW5pbWF0aW9uXXtAbGluayBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjcmVtb3ZlQW5pbWF0aW9ufVxyXG4gKiBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgZXhlY3V0ZWQuIEFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIG5hbWUgb2YgdGhlIGxheWVyXHJcbiAqIHRoYXQgdGhlIGFuaW1hdGlvbiB3YXMgcmVtb3ZlZCBmcm9tIGFuZCB0aGUgbmFtZSBvZiB0aGUgYW5pbWF0aW9uIHRoYXQgd2FzIHJlbW92ZWRcclxuICogd2l0aCB0aGUgc2lnbmF0dXJlIHtsYXllck5hbWU6IHN0cmluZywgYW5pbWF0aW9uTmFtZTogc3RyaW5nfSBpcyBzdXBwbGllZCBhc1xyXG4gKiBhbiBhcmd1bWVudCB0byBsaXN0ZW5lciBmdW5jdGlvbnMuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRTLnJlbmFtZUFuaW1hdGlvbj1vblJlbmFtZUFuaW1hdGlvbkV2ZW50XSAtIE1lc3NhZ2VcclxuICogdGhhdCBpcyBlbWl0dGVkIGFmdGVyIFtyZW5hbWVBbmltYXRpb25de0BsaW5rIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNyZW5hbWVBbmltYXRpb259XHJcbiAqIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBleGVjdXRlZC4gQW4gb2JqZWN0IHJlcHJlc2VudGluZyB0aGUgbmFtZSBvZiB0aGUgbGF5ZXJcclxuICogdGhhdCBjb250YWlucyB0aGUgYW5pbWF0aW9uIHRoYXQgd2FzIHJlbmFtZWQsIHRoZSBvcmlnaW5hbCBuYW1lIG9mIHRoZSBhbmltYXRpb25cclxuICogdGhhdCB3YXMgcmVuYW1lZCBhbmQgaXRzIHVwZGF0ZWQgbmFtZSB3aXRoIHRoZSBzaWduYXR1cmUge2xheWVyTmFtZTogc3RyaW5nLCBvbGROYW1lOiBzdHJpbmcsIG5ld05hbWU6IHN0cmluZ31cclxuICogaXMgc3VwcGxpZWQgYXMgYW4gYXJndW1lbnQgdG8gbGlzdGVuZXIgZnVuY3Rpb25zLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UUy5wbGF5PW9uUGxheUV2ZW50XSAtIE1lc3NhZ2UgdGhhdCBpcyBlbWl0dGVkIGFmdGVyXHJcbiAqIGVhY2ggY2FsbCB0byBbcGxheV17QGxpbmsgY29yZS9BbmltYXRpb25GZWF0dXJlI3BsYXlBbmltYXRpb259LiBBbiBvYmplY3QgcmVwcmVzZW50aW5nXHJcbiAqIHRoZSBuYW1lIG9mIHRoZSBsYXllciBjb250YWlucyB0aGUgYW5pbWF0aW9uIHRoYXQgd2FzIHBsYXllZCBhbmQgdGhlIG5hbWUgb2ZcclxuICogdGhlIGFuaW1hdGlvbiB0aGF0IHdhcyBwbGF5ZWQgd2l0aCB0aGUgc2lnbmF0dXJlIHtsYXllck5hbWU6IHN0cmluZywgYW5pbWF0aW9uTmFtZTogc3RyaW5nfVxyXG4gKiBpcyBzdXBwbGllZCBhcyBhbiBhcmd1bWVudCB0byBsaXN0ZW5lciBmdW5jdGlvbnMuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRTLnBhdXNlPW9uUGF1c2VFdmVudF0gLSBNZXNzYWdlIHRoYXQgaXMgZW1pdHRlZCBhZnRlclxyXG4gKiBlYWNoIGNhbGwgdG8gW3BhdXNlXXtAbGluayBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjcGF1c2VBbmltYXRpb259LiBBbiBvYmplY3QgcmVwcmVzZW50aW5nXHJcbiAqIHRoZSBuYW1lIG9mIHRoZSBsYXllciBjb250YWlucyB0aGUgYW5pbWF0aW9uIHRoYXQgd2FzIHBhdXNlZCBhbmQgdGhlIG5hbWUgb2ZcclxuICogdGhlIGFuaW1hdGlvbiB0aGF0IHdhcyBwYXVzZWQgd2l0aCB0aGUgc2lnbmF0dXJlIHtsYXllck5hbWU6IHN0cmluZywgYW5pbWF0aW9uTmFtZTogc3RyaW5nfVxyXG4gKiBpcyBzdXBwbGllZCBhcyBhbiBhcmd1bWVudCB0byBsaXN0ZW5lciBmdW5jdGlvbnMuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRTLnJlc3VtZT1vblJlc3VtZUV2ZW50XSAtIE1lc3NhZ2UgdGhhdCBpcyBlbWl0dGVkIGFmdGVyXHJcbiAqIGVhY2ggY2FsbCB0byBbcmVzdW1lXXtAbGluayBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjcmVzdW1lQW5pbWF0aW9ufS4gQW4gb2JqZWN0IHJlcHJlc2VudGluZ1xyXG4gKiB0aGUgbmFtZSBvZiB0aGUgbGF5ZXIgY29udGFpbnMgdGhlIGFuaW1hdGlvbiB0aGF0IHdhcyByZXN1bWVkIGFuZCB0aGUgbmFtZSBvZlxyXG4gKiB0aGUgYW5pbWF0aW9uIHRoYXQgd2FzIHJlc3VtZWQgd2l0aCB0aGUgc2lnbmF0dXJlIHtsYXllck5hbWU6IHN0cmluZywgYW5pbWF0aW9uTmFtZTogc3RyaW5nfVxyXG4gKiBpcyBzdXBwbGllZCBhcyBhbiBhcmd1bWVudCB0byBsaXN0ZW5lciBmdW5jdGlvbnMuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRTLmludGVycnVwdD1vbkludGVycnVwdEV2ZW50XSAtIE1lc3NhZ2UgdGhhdCBpcyBlbWl0dGVkXHJcbiAqIGlmIHRoZXJlIGlzIGEgY3VycmVudCBzcGVlY2ggaW4gcHJvZ3Jlc3MgYW5kIFtwbGF5XXtAbGluayBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjcGxheUFuaW1hdGlvbn1cclxuICogb3IgW3Jlc3VtZV17QGxpbmsgY29yZS9BbmltYXRpb25GZWF0dXJlI3Jlc3VtZUFuaW1hdGlvbn0gYXJlIGV4ZWN1dGVkIGZvciBhIG5ldyBzcGVlY2guXHJcbiAqIEFuIG9iamVjdCByZXByZXNlbnRpbmcgdGhlIG5hbWUgb2YgdGhlIGxheWVyIGNvbnRhaW5zIHRoZSBhbmltYXRpb24gdGhhdCB3YXNcclxuICogaW50ZXJydXB0ZWQgYW5kIHRoZSBuYW1lIG9mIHRoZSBhbmltYXRpb24gdGhhdCB3YXMgaW50ZXJydXB0ZWQgd2l0aCB0aGUgc2lnbmF0dXJlXHJcbiAqIHtsYXllck5hbWU6IHN0cmluZywgYW5pbWF0aW9uTmFtZTogc3RyaW5nfSBpcyBzdXBwbGllZCBhcyBhbiBhcmd1bWVudCB0byBsaXN0ZW5lclxyXG4gKiBmdW5jdGlvbnMuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRTLnN0b3A9b25TdG9wRXZlbnRdIC0gTWVzc2FnZSB0aGF0IGlzIGVtaXR0ZWQgYWZ0ZXJcclxuICogZWFjaCBjYWxsIHRvIFtzdG9wXXtAbGluayBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjc3RvcEFuaW1hdGlvbn0gYW5kIHdoZW4gYSBzcGVlY2ggcmVhY2hlc1xyXG4gKiB0aGUgZW5kIG9mIHBsYXliYWNrLiBBbiBvYmplY3QgcmVwcmVzZW50aW5nXHJcbiAqIHRoZSBuYW1lIG9mIHRoZSBsYXllciBjb250YWlucyB0aGUgYW5pbWF0aW9uIHRoYXQgd2FzIHN0b3BwZWQgYW5kIHRoZSBuYW1lIG9mXHJcbiAqIHRoZSBhbmltYXRpb24gdGhhdCB3YXMgc3RvcHBlZCB3aXRoIHRoZSBzaWduYXR1cmUge2xheWVyTmFtZTogc3RyaW5nLCBhbmltYXRpb25OYW1lOiBzdHJpbmd9XHJcbiAqIGlzIHN1cHBsaWVkIGFzIGFuIGFyZ3VtZW50IHRvIGxpc3RlbmVyIGZ1bmN0aW9ucy5cclxuICovXHJcbmNsYXNzIEFuaW1hdGlvbkZlYXR1cmUgZXh0ZW5kcyBBYnN0cmFjdEhvc3RGZWF0dXJlIHtcclxuICAvKipcclxuICAgKiBAY29uc3RydWN0b3JcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7Y29yZS9Ib3N0T2JqZWN0fSBob3N0IC0gSG9zdCBvYmplY3QgdGhhdCBvd25zIHRoZSBmZWF0dXJlLlxyXG4gICAqL1xyXG4gIGNvbnN0cnVjdG9yKGhvc3QpIHtcclxuICAgIHN1cGVyKGhvc3QpO1xyXG5cclxuICAgIHRoaXMuX2xheWVycyA9IFtdO1xyXG4gICAgdGhpcy5fbGF5ZXJNYXAgPSB7fTtcclxuICAgIHRoaXMuX3BhdXNlZCA9IGZhbHNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogTWFrZSBzdXJlIGEgc3VwcGxpZWQgbGF5ZXIgaW5kZXggaXMgd2l0aGluIHRoZSByYW5nZSBvZiBsYXllcnMuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGluZGV4XHJcbiAgICogQHBhcmFtIHtib29sZWFufSBbZXhpc3Rpbmc9dHJ1ZV0gLSBXaGV0aGVyIHRoZSBpbmRleCByZXByZXNlbnRzIGFuZCBleGlzdGluZ1xyXG4gICAqIGxheWVyIG9yIGEgbmV3IGxheWVyIHRvIGJlIGFkZGVkLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge251bWJlcj19XHJcbiAgICovXHJcbiAgX3ZhbGlkYXRlSW5kZXgoaW5kZXgsIGV4aXN0aW5nID0gdHJ1ZSkge1xyXG4gICAgLy8gSW5kZXggaXMgaW52YWxpZCBpZiB0aGVyZSBhcmUgbm8gbGF5ZXJzIGFuZCB3ZSdyZSBjaGVja2luZyBmb3IgYW4gZXhpc3RpbmcgbGF5ZXIgaW5kZXhcclxuICAgIGlmICh0aGlzLl9sYXllcnMubGVuZ3RoID09PSAwICYmIGV4aXN0aW5nKSB7XHJcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgbGFzdEluZGV4ID0gZXhpc3RpbmcgPyB0aGlzLl9sYXllcnMubGVuZ3RoIC0gMSA6IHRoaXMuX2xheWVycy5sZW5ndGg7XHJcblxyXG4gICAgLy8gQ291bnQgZnJvbSB0aGUgZW5kIG9mIHRoZSBhcnJheSBmb3IgbmVnYXRpdmUgaW5kaWNlc1xyXG4gICAgaWYgKGluZGV4IDwgMCkge1xyXG4gICAgICBpbmRleCA9IGxhc3RJbmRleCArIGluZGV4ICsgMTtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoaW5kZXggPCAwIHx8IGluZGV4ID4gbGFzdEluZGV4KSB7XHJcbiAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICByZXR1cm4gaW5kZXg7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZS1ldmFsdWF0ZSBpbnRlcm5hbCB3ZWlnaHQgdmFsdWVzIG9mIGxheWVycyBzdGFydGluZyBmcm9tIHRoZSB0b3Agb2YgdGhlXHJcbiAgICogc3RhY2suIE92ZXJyaWRlIGxheWVycycgd2VpZ2h0cyBhZmZlY3QgdGhlIHZhbHVlcyBvZiBhbGwgbGF5ZXJzIGxvd2VyIGluIHRoZVxyXG4gICAqIHN0YWNrLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfdXBkYXRlSW50ZXJuYWxXZWlnaHRzKCkge1xyXG4gICAgY29uc3QgbnVtTGF5ZXJzID0gdGhpcy5fbGF5ZXJzLmxlbmd0aDtcclxuICAgIGxldCB3ZWlnaHRNdWx0aXBsaWVyID0gMTtcclxuXHJcbiAgICAvLyBVcGRhdGUgaW50ZXJuYWwgd2VpZ2h0IHZhbHVlcyBvbiBsYXllcnMgaW4gcmV2ZXJzZSBvcmRlclxyXG4gICAgZm9yIChsZXQgaSA9IG51bUxheWVycyAtIDE7IGkgPj0gMDsgaS0tKSB7XHJcbiAgICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbGF5ZXJzW2ldO1xyXG4gICAgICBsYXllci51cGRhdGVJbnRlcm5hbFdlaWdodCh3ZWlnaHRNdWx0aXBsaWVyKTtcclxuXHJcbiAgICAgIC8vIElmIHRoZSBsYXllciBpcyBvdmVycmlkZSwgdXBkYXRlIHRoZSBtdWx0aXBsaWVyIHdpdGggdGhlIHJlbWFpbmRlciBvZiB0aGUgZnVsbCB3ZWlnaHRcclxuICAgICAgaWYgKGxheWVyLmJsZW5kTW9kZSA9PT0gTGF5ZXJCbGVuZE1vZGVzLk92ZXJyaWRlICYmIGxheWVyLmN1cnJlbnRTdGF0ZSkge1xyXG4gICAgICAgIHdlaWdodE11bHRpcGxpZXIgKj0gMSAtIGxheWVyLmN1cnJlbnRTdGF0ZS5pbnRlcm5hbFdlaWdodDtcclxuICAgICAgfVxyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIGEgbmV3IGluc3RhbmNlIG9mIGEgU2luZ2xlU3RhdGUuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIHRvIHBhc3MgdG8gdGhlIFNpbmdsZVN0YXRlIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0aW9ucy5uYW1lIC0gTmFtZSBmb3IgdGhlIGFuaW1hdGlvbiBzdGF0ZS4gTmFtZXMgbXVzdCBiZVxyXG4gICAqIHVuaXF1ZSBmb3IgdGhlIGxheWVyIHRoZSBzdGF0ZSBpcyBhcHBsaWVkIHRvLlxyXG4gICAqIEBwYXJhbSB7d2VpZ2h0fSBbb3B0aW9ucy53ZWlnaHQ9MF0gLSBUaGUgMC0xIGFtb3VudCBvZiBpbmZsdWVuY2UgdGhlIHN0YXRlIHdpbGwgaGF2ZS5cclxuICAgKiBAcGFyYW0ge3RpbWVTY2FsZX0gW29wdGlvbnMudGltZVNjYWxlPTFdIC0gRmFjdG9yIHRvIHNjYWxlIHRoZSBwbGF5YmFjayBzcGVlZCBvZiB0aGVcclxuICAgKiBhbmltYXRpb24uXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxvb3BDb3VudD1JbmZpbml0eV0gLSBOdW1iZXIgb2YgdGltZXMgdGhlIGFuaW1hdGlvbiBzaG91bGRcclxuICAgKiByZXBlYXQgYmVmb3JlIGZpbmlzaGluZy5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYmxlbmRNb2RlPUxheWVyQmxlbmRNb2Rlc1tEZWZhdWx0TGF5ZXJCbGVuZE1vZGVdXSAtIFR5cGUgb2ZcclxuICAgKiBibGVuZGluZyB0aGUgYW5pbWF0aW9uIHNob3VsZCB1c2UuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7Y29yZS9TaW5nbGVTdGF0ZX1cclxuICAgKi9cclxuICBfY3JlYXRlU2luZ2xlU3RhdGUob3B0aW9ucykge1xyXG4gICAgcmV0dXJuIG5ldyBTaW5nbGVTdGF0ZShvcHRpb25zKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiBhIG5ldyBpbnN0YW5jZSBvZiBhIEZyZWVCbGVuZFN0YXRlLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyB0byBwYXNzIHRvIHRoZSBGcmVlQmxlbmRTdGF0ZSBjb25zdHJ1Y3Rvci5cclxuICAgKiBAcGFyYW0ge3N0cmluZz19IG9wdGlvbnMubmFtZSAtIE5hbWUgZm9yIHRoZSBhbmltYXRpb24gc3RhdGUuIE5hbWVzIG11c3QgYmVcclxuICAgKiB1bmlxdWUgZm9yIHRoZSBsYXllciB0aGUgc3RhdGUgaXMgYXBwbGllZCB0by5cclxuICAgKiBAcGFyYW0ge3dlaWdodH0gW29wdGlvbnMud2VpZ2h0PTBdIC0gVGhlIDAtMSBhbW91bnQgb2YgaW5mbHVlbmNlIHRoZSBzdGF0ZSB3aWxsIGhhdmUuXHJcbiAgICogQHBhcmFtIHt0aW1lU2NhbGV9IFtvcHRpb25zLnRpbWVTY2FsZT0xXSAtIEZhY3RvciB0byBzY2FsZSB0aGUgcGxheWJhY2sgc3BlZWQgb2YgdGhlXHJcbiAgICogYW5pbWF0aW9uLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5sb29wQ291bnQ9SW5maW5pdHldIC0gTnVtYmVyIG9mIHRpbWVzIHRoZSBhbmltYXRpb24gc2hvdWxkXHJcbiAgICogcmVwZWF0IGJlZm9yZSBmaW5pc2hpbmcuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmJsZW5kTW9kZT1MYXllckJsZW5kTW9kZXNbRGVmYXVsdExheWVyQmxlbmRNb2RlXV0gLSBUeXBlIG9mXHJcbiAgICogYmxlbmRpbmcgdGhlIGFuaW1hdGlvbiBzaG91bGQgdXNlLlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IFtvcHRpb25zLmJsZW5kU3RhdGVPcHRpb25zXSAtIEFycmF5IG9mIG9wdGlvbnMgdXNlZCB0byBjcmVhdGUgdGhlXHJcbiAgICogYmxlbmQgc3RhdGVzIGZvciB0aGlzIGNvbnRhaW5lci5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtGcmVlQmxlbmRTdGF0ZX1cclxuICAgKi9cclxuICBfY3JlYXRlRnJlZUJsZW5kU3RhdGUob3B0aW9ucykge1xyXG4gICAgY29uc3Qge2JsZW5kU3RhdGVPcHRpb25zID0gW119ID0gb3B0aW9ucztcclxuXHJcbiAgICBjb25zdCBibGVuZFN0YXRlcyA9IFtdO1xyXG4gICAgYmxlbmRTdGF0ZU9wdGlvbnMuZm9yRWFjaChibGVuZE9wdGlvbnMgPT4ge1xyXG4gICAgICBibGVuZFN0YXRlcy5wdXNoKFxyXG4gICAgICAgIHRoaXMuX2NyZWF0ZVNpbmdsZVN0YXRlKHsuLi5ibGVuZE9wdGlvbnMsIGJsZW5kTW9kZTogb3B0aW9ucy5ibGVuZE1vZGV9KVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBGcmVlQmxlbmRTdGF0ZShvcHRpb25zLCBibGVuZFN0YXRlcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gYSBuZXcgaW5zdGFuY2Ugb2YgYSBRdWV1ZVN0YXRlLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zIC0gT3B0aW9ucyB0byBwYXNzIHRvIHRoZSBRdWV1ZVN0YXRlIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0aW9ucy5uYW1lIC0gTmFtZSBmb3IgdGhlIGFuaW1hdGlvbiBzdGF0ZS4gTmFtZXMgbXVzdCBiZVxyXG4gICAqIHVuaXF1ZSBmb3IgdGhlIGxheWVyIHRoZSBzdGF0ZSBpcyBhcHBsaWVkIHRvLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy53ZWlnaHQ9MF0gLSBUaGUgMC0xIGFtb3VudCBvZiBpbmZsdWVuY2UgdGhlIHN0YXRlIHdpbGwgaGF2ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcj19IG9wdGlvbnMudHJhbnNpdGlvblRpbWUgLSBUaGUgYW1vdW50IG9mIHRpbWUgaXQgdGFrZXMgdG8gdHJhbnNpdGlvblxyXG4gICAqIGJldHdlZW4gcXVldWVkIHN0YXRlcy5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYmxlbmRNb2RlPUxheWVyQmxlbmRNb2Rlc1tEZWZhdWx0TGF5ZXJCbGVuZE1vZGVdXSAtIFR5cGUgb2ZcclxuICAgKiBibGVuZGluZyB0aGUgYW5pbWF0aW9uIHNob3VsZCB1c2UuXHJcbiAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gW29wdGlvbnMucXVldWVPcHRpb25zXSAtIEFycmF5IG9mIG9wdGlvbnMgdXNlZCB0byBjcmVhdGUgdGhlXHJcbiAgICogcXVldWUgc3RhdGVzIGZvciB0aGlzIGNvbnRhaW5lci5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtRdWV1ZVN0YXRlfVxyXG4gICAqL1xyXG4gIF9jcmVhdGVRdWV1ZVN0YXRlKG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IHtxdWV1ZU9wdGlvbnMgPSBbXX0gPSBvcHRpb25zO1xyXG5cclxuICAgIGNvbnN0IHF1ZXVlU3RhdGVzID0gcXVldWVPcHRpb25zLm1hcChxdWV1ZU9wdGlvbiA9PlxyXG4gICAgICB0aGlzLl9jcmVhdGVTaW5nbGVTdGF0ZSh7XHJcbiAgICAgICAgdHJhbnNpdGlvblRpbWU6IG9wdGlvbnMudHJhbnNpdGlvblRpbWUsXHJcbiAgICAgICAgLi4ucXVldWVPcHRpb24sXHJcbiAgICAgICAgYmxlbmRNb2RlOiBvcHRpb25zLmJsZW5kTW9kZSxcclxuICAgICAgfSlcclxuICAgICk7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBRdWV1ZVN0YXRlKG9wdGlvbnMsIHF1ZXVlU3RhdGVzKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiBhIG5ldyBpbnN0YW5jZSBvZiBhIEJsZW5kMWRTdGF0ZS5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gcGFzcyB0byB0aGUgQmxlbmQxZFN0YXRlIGNvbnN0cnVjdG9yLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0aW9ucy5uYW1lIC0gTmFtZSBmb3IgdGhlIGFuaW1hdGlvbiBzdGF0ZS4gTmFtZXMgbXVzdCBiZVxyXG4gICAqIHVuaXF1ZSBmb3IgdGhlIGxheWVyIHRoZSBzdGF0ZSBpcyBhcHBsaWVkIHRvLlxyXG4gICAqIEBwYXJhbSB7d2VpZ2h0fSBbb3B0aW9ucy53ZWlnaHQ9MF0gLSBUaGUgMC0xIGFtb3VudCBvZiBpbmZsdWVuY2UgdGhlIHN0YXRlIHdpbGwgaGF2ZS5cclxuICAgKiBAcGFyYW0ge3RpbWVTY2FsZX0gW29wdGlvbnMudGltZVNjYWxlPTFdIC0gRmFjdG9yIHRvIHNjYWxlIHRoZSBwbGF5YmFjayBzcGVlZCBvZiB0aGVcclxuICAgKiBhbmltYXRpb24uXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmxvb3BDb3VudD1JbmZpbml0eV0gLSBOdW1iZXIgb2YgdGltZXMgdGhlIGFuaW1hdGlvbiBzaG91bGRcclxuICAgKiByZXBlYXQgYmVmb3JlIGZpbmlzaGluZy5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYmxlbmRNb2RlPUxheWVyQmxlbmRNb2Rlc1tEZWZhdWx0TGF5ZXJCbGVuZE1vZGVdXSAtIFR5cGUgb2ZcclxuICAgKiBibGVuZGluZyB0aGUgYW5pbWF0aW9uIHNob3VsZCB1c2UuXHJcbiAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gW29wdGlvbnMuYmxlbmRTdGF0ZU9wdGlvbnNdIC0gQXJyYXkgb2Ygb3B0aW9ucyB1c2VkIHRvIGNyZWF0ZSB0aGVcclxuICAgKiBibGVuZCBzdGF0ZXMgZm9yIHRoaXMgY29udGFpbmVyLlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPG51bWJlcj59IFtvcHRpb25zLmJsZW5kVGhyZXNob2xkc10gLSBBcnJheSBvZiBudW1iZXJzIHVzZWQgdG8gc2V0IHRoZVxyXG4gICAqIHRocmVzaG9sZHMgZm9yIGVhY2ggYmxlbmQgc3RhdGUgaW4gdGhpcyBjb250YWluZXIuXHJcbiAgICogQHBhcmFtIHtBcnJheS48Ym9vbGVhbj59IFtvcHRpb25zLmJsZW5kTWF0Y2hQaGFzZXM9W11dIC0gT3B0aW9uYWwgYXJyYXkgb2YgYm9vbGVhbnMgdXNlZCB0b1xyXG4gICAqIHNldCB3aGV0aGVyIG9yIG5vdCBlYWNoIGJsZW5kIHN0YXRlIGluIHRoaXMgY29udGFpbmVyIHdpbGwgbWF0Y2ggcGhhc2VzLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0JsZW5kMWRTdGF0ZX1cclxuICAgKi9cclxuICBfY3JlYXRlQmxlbmQxZFN0YXRlKG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IHtibGVuZFN0YXRlT3B0aW9ucyA9IFtdfSA9IG9wdGlvbnM7XHJcbiAgICBjb25zdCB7YmxlbmRUaHJlc2hvbGRzID0gW119ID0gb3B0aW9ucztcclxuICAgIGNvbnN0IHtibGVuZE1hdGNoUGhhc2VzID0gW119ID0gb3B0aW9ucztcclxuXHJcbiAgICBjb25zdCBibGVuZFN0YXRlcyA9IFtdO1xyXG4gICAgYmxlbmRTdGF0ZU9wdGlvbnMuZm9yRWFjaChibGVuZE9wdGlvbnMgPT4ge1xyXG4gICAgICBibGVuZFN0YXRlcy5wdXNoKFxyXG4gICAgICAgIHRoaXMuX2NyZWF0ZVNpbmdsZVN0YXRlKHsuLi5ibGVuZE9wdGlvbnMsIGJsZW5kTW9kZTogb3B0aW9ucy5ibGVuZE1vZGV9KVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBCbGVuZDFkU3RhdGUoXHJcbiAgICAgIG9wdGlvbnMsXHJcbiAgICAgIGJsZW5kU3RhdGVzLFxyXG4gICAgICBibGVuZFRocmVzaG9sZHMsXHJcbiAgICAgIGJsZW5kTWF0Y2hQaGFzZXNcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gYSBuZXcgaW5zdGFuY2Ugb2YgYSBCbGVuZDJkU3RhdGUuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBPcHRpb25zIHRvIHBhc3MgdG8gdGhlIEJsZW5kMWRTdGF0ZSBjb25zdHJ1Y3Rvci5cclxuICAgKiBAcGFyYW0ge3N0cmluZz19IG9wdGlvbnMubmFtZSAtIE5hbWUgZm9yIHRoZSBhbmltYXRpb24gc3RhdGUuIE5hbWVzIG11c3QgYmVcclxuICAgKiB1bmlxdWUgZm9yIHRoZSBsYXllciB0aGUgc3RhdGUgaXMgYXBwbGllZCB0by5cclxuICAgKiBAcGFyYW0ge3dlaWdodH0gW29wdGlvbnMud2VpZ2h0PTBdIC0gVGhlIDAtMSBhbW91bnQgb2YgaW5mbHVlbmNlIHRoZSBzdGF0ZSB3aWxsIGhhdmUuXHJcbiAgICogQHBhcmFtIHt0aW1lU2NhbGV9IFtvcHRpb25zLnRpbWVTY2FsZT0xXSAtIEZhY3RvciB0byBzY2FsZSB0aGUgcGxheWJhY2sgc3BlZWQgb2YgdGhlXHJcbiAgICogYW5pbWF0aW9uLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5sb29wQ291bnQ9SW5maW5pdHldIC0gTnVtYmVyIG9mIHRpbWVzIHRoZSBhbmltYXRpb24gc2hvdWxkXHJcbiAgICogcmVwZWF0IGJlZm9yZSBmaW5pc2hpbmcuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmJsZW5kTW9kZT1MYXllckJsZW5kTW9kZXNbRGVmYXVsdExheWVyQmxlbmRNb2RlXV0gLSBUeXBlIG9mXHJcbiAgICogYmxlbmRpbmcgdGhlIGFuaW1hdGlvbiBzaG91bGQgdXNlLlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IFtvcHRpb25zLmJsZW5kU3RhdGVPcHRpb25zXSAtIEFycmF5IG9mIG9wdGlvbnMgdXNlZCB0byBjcmVhdGUgdGhlXHJcbiAgICogYmxlbmQgc3RhdGVzIGZvciB0aGlzIGNvbnRhaW5lci5cclxuICAgKiBAcGFyYW0ge0FycmF5LjxBcnJheS48bnVtYmVyPj59IFtvcHRpb25zLmJsZW5kVGhyZXNob2xkc10gLSBBcnJheSBvZiBBcnJheSBvZiBudW1iZXJzIHVzZWQgdG8gc2V0IHRoZVxyXG4gICAqIHRocmVzaG9sZHMgZm9yIGVhY2ggYmxlbmQgc3RhdGUgaW4gdGhpcyBjb250YWluZXIuXHJcbiAgICogQHBhcmFtIHtBcnJheS48Ym9vbGVhbj59IFtvcHRpb25zLmJsZW5kTWF0Y2hQaGFzZXM9W11dIC0gT3B0aW9uYWwgYXJyYXkgb2YgYm9vbGVhbnMgdXNlZCB0b1xyXG4gICAqIHNldCB3aGV0aGVyIG9yIG5vdCBlYWNoIGJsZW5kIHN0YXRlIGluIHRoaXMgY29udGFpbmVyIHdpbGwgbWF0Y2ggcGhhc2VzLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0JsZW5kMWRTdGF0ZX1cclxuICAgKi9cclxuICBfY3JlYXRlQmxlbmQyZFN0YXRlKG9wdGlvbnMpIHtcclxuICAgIGNvbnN0IHtibGVuZFN0YXRlT3B0aW9ucyA9IFtdfSA9IG9wdGlvbnM7XHJcbiAgICBjb25zdCB7YmxlbmRUaHJlc2hvbGRzID0gW119ID0gb3B0aW9ucztcclxuICAgIGNvbnN0IHtibGVuZE1hdGNoUGhhc2VzID0gW119ID0gb3B0aW9ucztcclxuXHJcbiAgICBjb25zdCBibGVuZFN0YXRlcyA9IFtdO1xyXG4gICAgYmxlbmRTdGF0ZU9wdGlvbnMuZm9yRWFjaChibGVuZE9wdGlvbnMgPT4ge1xyXG4gICAgICBibGVuZFN0YXRlcy5wdXNoKFxyXG4gICAgICAgIHRoaXMuX2NyZWF0ZVNpbmdsZVN0YXRlKHsuLi5ibGVuZE9wdGlvbnMsIGJsZW5kTW9kZTogb3B0aW9ucy5ibGVuZE1vZGV9KVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIG5ldyBCbGVuZDJkU3RhdGUoXHJcbiAgICAgIG9wdGlvbnMsXHJcbiAgICAgIGJsZW5kU3RhdGVzLFxyXG4gICAgICBibGVuZFRocmVzaG9sZHMsXHJcbiAgICAgIGJsZW5kTWF0Y2hQaGFzZXNcclxuICAgICk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gYSBuZXcgaW5zdGFuY2Ugb2YgYSBSYW5kb21BbmltYXRpb25TdGF0ZS5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9ucyAtIE9wdGlvbnMgdG8gcGFzcyB0byB0aGUgUmFuZG9tQW5pbWF0aW9uU3RhdGUgY29uc3RydWN0b3IuXHJcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRpb25zLm5hbWUgLSBOYW1lIGZvciB0aGUgYW5pbWF0aW9uIHN0YXRlLiBOYW1lcyBtdXN0IGJlXHJcbiAgICogdW5pcXVlIGZvciB0aGUgbGF5ZXIgdGhlIHN0YXRlIGlzIGFwcGxpZWQgdG8uXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnBsYXlJbnRlcnZhbD0zXSAtIFRoZSBiYXNlIGFuaW1hdGlvbiBwbGF5YmFjayBpbnRlcnZhbC5cclxuICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBbb3B0aW9ucy5zdWJTdGF0ZU9wdGlvbnNdIC0gQXJyYXkgb2Ygb3B0aW9ucyB1c2VkIHRvIGNyZWF0ZSB0aGVcclxuICAgKiBzdWIgc3RhdGVzIGZvciB0aGlzIGNvbnRhaW5lci5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtSYW5kb21BbmltYXRpb25TdGF0ZX1cclxuICAgKi9cclxuICBfY3JlYXRlUmFuZG9tQW5pbWF0aW9uU3RhdGUob3B0aW9ucykge1xyXG4gICAgY29uc3Qge3N1YlN0YXRlT3B0aW9ucyA9IFtdfSA9IG9wdGlvbnM7XHJcblxyXG4gICAgY29uc3Qgc3ViU3RhdGVzID0gW107XHJcbiAgICBzdWJTdGF0ZU9wdGlvbnMuZm9yRWFjaChzdWJTdGF0ZU9wdGlvbnMgPT4ge1xyXG4gICAgICBzdWJTdGF0ZXMucHVzaChcclxuICAgICAgICB0aGlzLl9jcmVhdGVTaW5nbGVTdGF0ZSh7XHJcbiAgICAgICAgICAuLi5zdWJTdGF0ZU9wdGlvbnMsXHJcbiAgICAgICAgICBibGVuZE1vZGU6IG9wdGlvbnMuYmxlbmRNb2RlLFxyXG4gICAgICAgIH0pXHJcbiAgICAgICk7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gbmV3IFJhbmRvbUFuaW1hdGlvblN0YXRlKG9wdGlvbnMsIHN1YlN0YXRlcyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBNYWtlIHN1cmUgdGhlIGxheWVyIHdpdGggdGhlIGdpdmVuIG5hbWUgZXhpc3RzIGFuZCByZXR1cm4gYSB1bmlxdWUgdmVyc2lvblxyXG4gICAqIG9mIHRoZSBhbmltYXRpb24gbmFtZSBzdXBwbGllZCBmb3IgdGhhdCBsYXllci5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdG8gY2hlY2sgYWdhaW5zdC5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gYW5pbWF0aW9uTmFtZSAtIE5hbWUgb2YgdGhlIGFuaW1hdGlvbiB0byB2YWxpZGF0ZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IFZhbGlkYXRlZCBhbmltYXRpb24gbmFtZS5cclxuICAgKi9cclxuICBfdmFsaWRhdGVOZXdBbmltYXRpb24obGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lKSB7XHJcbiAgICAvLyBNYWtlIHN1cmUgdGhlIGxheWVyTmFtZSBpcyB2YWxpZFxyXG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9sYXllck1hcFtsYXllck5hbWVdO1xyXG5cclxuICAgIGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBgQ2Fubm90IGFkZCBhbmltYXRpb24gdG8gbGF5ZXIgJHtsYXllck5hbWV9IGZyb20gaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBObyBsYXllciBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgYW5pbWF0aW9uTmFtZSBpcyB1bmlxdWVcclxuICAgIGNvbnN0IG5hbWUgPSBVdGlscy5nZXRVbmlxdWVOYW1lKGFuaW1hdGlvbk5hbWUsIGxheWVyLmdldFN0YXRlTmFtZXMoKSk7XHJcblxyXG4gICAgaWYgKG5hbWUgIT09IGFuaW1hdGlvbk5hbWUpIHtcclxuICAgICAgY29uc29sZS53YXJuKFxyXG4gICAgICAgIGBBbmltYXRpb24gbmFtZSAke2FuaW1hdGlvbk5hbWV9IGlzIG5vdCB1bmlxdWUgZm9yIGxheWVyICR7bGF5ZXIubmFtZX0uIEFuaW1hdGlvbiB3aWxsIGJlIHJlbmFtZWQgdG8gJHtuYW1lfS5gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIG5hbWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHdoZXRoZXIgb3Igbm90IGFsbCBhbmltYXRpb25zIGFyZSBwYXVzZWQuXHJcbiAgICpcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBnZXQgcGF1c2VkKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3BhdXNlZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgYW4gYXJyYXkgb2YgbmFtZXMgb2YgYW5pbWF0aW9uIGxheWVycy5cclxuICAgKlxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEB0eXBlIHtBcnJheS48c3RyaW5nPn1cclxuICAgKi9cclxuICBnZXQgbGF5ZXJzKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2xheWVycy5tYXAobGF5ZXIgPT4gbGF5ZXIubmFtZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgYW5kIHN0b3JlIGEgbmV3IGFuaW1hdGlvbiBsYXllci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBbbmFtZT0nTmV3TGF5ZXInXSAtIE5hbWUgZm9yIHRoZSBsYXllci5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gW29wdGlvbnM9e31dIC0gT3B0aW9ucyB0byBwYXNzIHRvIHtAbGluayBBbmltYXRpb25MYXllciNjb25zdHJ1Y3Rvcn1cclxuICAgKiBAcGFyYW0ge2luZGV4PX0gaW5kZXggLSBJbmRleCB0byBpbnNlcnQgdGhlIG5ldyBsYXllciBhdC4gSWYgbm9uZSBpcyBwcm92aWRlZFxyXG4gICAqIGl0IHdpbGwgYmUgYWRkZWQgdG8gdGhlIGVuZCBvZiB0aGUgc3RhY2suXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBJbmRleCBvZiB0aGUgbmV3IGxheWVyLlxyXG4gICAqL1xyXG4gIGFkZExheWVyKG5hbWUgPSAnTmV3TGF5ZXInLCBvcHRpb25zID0ge30sIGluZGV4KSB7XHJcbiAgICBjb25zdCBudW1MYXllcnMgPSB0aGlzLl9sYXllcnMubGVuZ3RoO1xyXG4gICAgbGV0IGxheWVySW5kZXggPSBpbmRleDtcclxuXHJcbiAgICAvLyBNYWtlIHN1cmUgdGhlIGdpdmVuIGluZGV4IGlzIHdpdGhpbiB0aGUgcmFuZ2Ugb2YgbGF5ZXJzXHJcbiAgICBpZiAoaW5kZXggPT09IHVuZGVmaW5lZCB8fCBpbmRleCA9PT0gLTEpIHtcclxuICAgICAgbGF5ZXJJbmRleCA9IHRoaXMuX2xheWVycy5sZW5ndGg7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBsYXllckluZGV4ID0gdGhpcy5fdmFsaWRhdGVJbmRleChpbmRleCwgZmFsc2UpO1xyXG5cclxuICAgICAgaWYgKGxheWVySW5kZXggPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIC8vIEluc2VydCBhdCB0aGUgYmVnaW5uaW5nIGlmIHRoZSB1c2VyIHBhc3NlZCBpbiBhIG5lZ2F0aXZlIGluZGV4XHJcbiAgICAgICAgaWYgKGluZGV4IDwgMCkge1xyXG4gICAgICAgICAgbGF5ZXJJbmRleCA9IDA7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIC8vIE90aGVyd2lzZSBhcHBlbmQgdG8gdGhlIGVuZFxyXG4gICAgICAgIGVsc2Uge1xyXG4gICAgICAgICAgbGF5ZXJJbmRleCA9IHRoaXMuX2xheWVycy5sZW5ndGg7XHJcbiAgICAgICAgfVxyXG5cclxuICAgICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgICBgSW5kZXggJHtpbmRleH0gaXMgaW52YWxpZCBmb3IgaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBOZXcgbGF5ZXIgd2lsbCBiZSBhZGRlZCBhdCB0aGUgY2xvc2VzdCB2YWxpZCBpbmRleDogJHtsYXllckluZGV4fS5gXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfVxyXG5cclxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgbGF5ZXIgbmFtZSBpcyB1bmlxdWVcclxuICAgIGNvbnN0IGxheWVyTmFtZSA9IFV0aWxzLmdldFVuaXF1ZU5hbWUobmFtZSwgT2JqZWN0LmtleXModGhpcy5fbGF5ZXJNYXApKTtcclxuXHJcbiAgICBpZiAobmFtZSAhPT0gbGF5ZXJOYW1lKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICBgTGF5ZXIgbmFtZSAke25hbWV9IGlzIG5vdCB1bmlxdWUuIE5ldyBsYXllciB3aWxsIGJlIGFkZGVkIHdpdGggdGhlIG5hbWUgJHtsYXllck5hbWV9LmBcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBsYXllciA9IG5ldyBBbmltYXRpb25MYXllcih7Li4ub3B0aW9ucywgbmFtZTogbGF5ZXJOYW1lfSk7XHJcbiAgICB0aGlzLl9sYXllck1hcFtsYXllck5hbWVdID0gbGF5ZXI7XHJcblxyXG4gICAgaWYgKGxheWVySW5kZXggPT09IG51bUxheWVycykge1xyXG4gICAgICB0aGlzLl9sYXllcnMucHVzaChsYXllcik7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl9sYXllcnMuc3BsaWNlKGxheWVySW5kZXgsIDAsIGxheWVyKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBOb3RpZnkgdGhhdCBhIGxheWVyIGhhcyBiZWVuIGFkZGVkIHRvIHRoZSBmZWF0dXJlXHJcbiAgICBjb25zdCBldmVudERhdGEgPSB7bmFtZTogbGF5ZXJOYW1lLCBpbmRleDogbGF5ZXJJbmRleH07XHJcbiAgICB0aGlzLmVtaXQodGhpcy5jb25zdHJ1Y3Rvci5FVkVOVFMuYWRkTGF5ZXIsIGV2ZW50RGF0YSk7XHJcblxyXG4gICAgcmV0dXJuIGV2ZW50RGF0YTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlbW92ZSBhbiBhbmltYXRpb24gbGF5ZXIgZnJvbSB0aGUgc3RhY2suIEFuaW1hdGlvbnMgb24gdGhpcyBsYXllciB3aWxsIG5vXHJcbiAgICogbG9uZ2VyIGJlIGV2YWx1YXRlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gTmFtZSBmb3IgdGhlIGxheWVyIHRvIHJlbW92ZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufSBXaGV0aGVyIG9yIG5vdCByZW1vdmFsIHdhcyBzdWNjZXNzZnVsLlxyXG4gICAqL1xyXG4gIHJlbW92ZUxheWVyKG5hbWUpIHtcclxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbGF5ZXJNYXBbbmFtZV07XHJcblxyXG4gICAgaWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgY29uc29sZS53YXJuKFxyXG4gICAgICAgIGBEaWQgbm90IHJlbW92ZSBsYXllciAke25hbWV9IGZyb20gaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBObyBsYXllciBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYFxyXG4gICAgICApO1xyXG4gICAgICByZXR1cm4gZmFsc2U7XHJcbiAgICB9XHJcblxyXG4gICAgbGF5ZXIuZGlzY2FyZCgpO1xyXG5cclxuICAgIGNvbnN0IGluZGV4ID0gdGhpcy5fbGF5ZXJzLmluZGV4T2YobGF5ZXIpO1xyXG4gICAgdGhpcy5fbGF5ZXJzLnNwbGljZShpbmRleCwgMSk7XHJcbiAgICBkZWxldGUgdGhpcy5fbGF5ZXJNYXBbbmFtZV07XHJcblxyXG4gICAgLy8gTm90aWZ5IHRoYXQgYSBsYXllciBoYXMgYmVlbiByZW1vdmVkIGZyb20gdGhlIGZlYXR1cmVcclxuICAgIHRoaXMuZW1pdCh0aGlzLmNvbnN0cnVjdG9yLkVWRU5UUy5yZW1vdmVMYXllciwge25hbWUsIGluZGV4fSk7XHJcblxyXG4gICAgcmV0dXJuIHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZS1vcmRlciB0aGUgbGF5ZXIgc3RhY2sgc28gdGhhdCB0aGUgbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpcyBwb3NpdGlvbmVkXHJcbiAgICogYXQgdGhlIGdpdmVuIGluZGV4LlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0byBtb3ZlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBpbmRleCAtIE5ldyBpbmRleCB0byBwb3NpdGlvbiB0aGUgbGF5ZXIgYXQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfSBUaGUgbmV3IGluZGV4IG9mIHRoZSBsYXllclxyXG4gICAqL1xyXG4gIG1vdmVMYXllcihuYW1lLCBpbmRleCkge1xyXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBuYW1lIGlzIHZhbGlkXHJcbiAgICBjb25zdCBsYXllciA9IHRoaXMuX2xheWVyTWFwW25hbWVdO1xyXG5cclxuICAgIGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBgQ2Fubm90IG1vdmUgbGF5ZXIgJHtuYW1lfSBmcm9tIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gTm8gbGF5ZXIgZXhpc3RzIHdpdGggdGhpcyBuYW1lLmBcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBNYWtlIHN1cmUgdGhlIGluZGV4IGZhbGxzIGluIHRoZSByYW5nZSBvZiBleGlzdGluZyBsYXllcnNcclxuICAgIGNvbnN0IGxheWVySW5kZXggPSB0aGlzLl92YWxpZGF0ZUluZGV4KGluZGV4LCB0cnVlKTtcclxuICAgIGNvbnN0IGxhc3RJbmRleCA9IHRoaXMuX2xheWVycy5sZW5ndGggLSAxO1xyXG5cclxuICAgIGlmIChsYXllckluZGV4ID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGBDYW5ub3QgbW92ZSBsYXllciAke25hbWV9IGZyb20gaG9zdCAke3RoaXMuX2hvc3QuaWR9IHRvIGluZGV4ICR7aW5kZXh9LiBJbmRleCBtdXN0IGJlIGluIHRoZSAwIC0gJHtsYXN0SW5kZXh9IHJhbmdlLmBcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBjdXJyZW50SW5kZXggPSB0aGlzLl9sYXllcnMuaW5kZXhPZihsYXllcik7XHJcbiAgICBpZiAoY3VycmVudEluZGV4ID09PSBsYXllckluZGV4KSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZW1vdmUgZnJvbSB0aGUgY3VycmVudCBwb3NpdGlvblxyXG4gICAgdGhpcy5fbGF5ZXJzLnNwbGljZShjdXJyZW50SW5kZXgsIDEpO1xyXG5cclxuICAgIC8vIEluc2VydCBhdCB0aGUgbmV3IHBvc2l0aW9uXHJcbiAgICBpZiAobGF5ZXJJbmRleCA9PT0gbGFzdEluZGV4KSB7XHJcbiAgICAgIHRoaXMuX2xheWVycy5wdXNoKGxheWVyKTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRoaXMuX2xheWVycy5zcGxpY2UobGF5ZXJJbmRleCwgMCwgbGF5ZXIpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBsYXllckluZGV4O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIHRoZSBuYW1lIG9mIGEgbGF5ZXIuIE5hbWVzIG11c3QgYmUgdW5pcXVlLCBpZiB0aGUgbmV3IG5hbWUgaXMgbm90XHJcbiAgICogdW5pcXVlIGl0IHdpbGwgaGF2ZSB0cmFpbGluZyBudW1iZXJzIGFwcGVuZGVkIHVudGlsIGl0IGlzIHVuaXF1ZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjdXJyZW50TmFtZSAtIEN1cnJlbnQgbmFtZSBvZiB0aGUgbGF5ZXIuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5ld05hbWUgLSBOZXcgbmFtZSB0byBzZXQgb24gdGhlIGxheWVyLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge3N0cmluZ30gVGhlIG5ldyBuYW1lIG9mIHRoZSBsYXllclxyXG4gICAqL1xyXG4gIHJlbmFtZUxheWVyKGN1cnJlbnROYW1lLCBuZXdOYW1lKSB7XHJcbiAgICAvLyBNYWtlIHN1cmUgdGhlIG5hbWUgaXMgdmFsaWRcclxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbGF5ZXJNYXBbY3VycmVudE5hbWVdO1xyXG5cclxuICAgIGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBgQ2Fubm90IHJlbmFtZSBsYXllciAke2N1cnJlbnROYW1lfSBmcm9tIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gTm8gbGF5ZXIgZXhpc3RzIHdpdGggdGhpcyBuYW1lLmBcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBNYWtlIHN1cmUgdGhlIGxheWVyIG5hbWUgaXMgdW5pcXVlXHJcbiAgICBjb25zdCBuYW1lID0gVXRpbHMuZ2V0VW5pcXVlTmFtZShuZXdOYW1lLCBPYmplY3Qua2V5cyh0aGlzLl9sYXllck1hcCkpO1xyXG5cclxuICAgIGlmIChuYW1lICE9PSBuZXdOYW1lKSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICBgTGF5ZXIgbmFtZSAke25ld05hbWV9IGlzIG5vdCB1bmlxdWUuIExheWVyIHdpbGwgYmUgcmVuYW1lZCB0byAke25hbWV9LmBcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBkZWxldGUgdGhpcy5fbGF5ZXJNYXBbY3VycmVudE5hbWVdO1xyXG4gICAgdGhpcy5fbGF5ZXJNYXBbbmFtZV0gPSBsYXllcjtcclxuICAgIGxheWVyLm5hbWUgPSBuYW1lO1xyXG5cclxuICAgIC8vIE5vdGlmeSB0aGF0IGEgbGF5ZXIgaGFzIGJlZW4gcmVuYW1lZCBvbiB0aGUgZmVhdHVyZVxyXG4gICAgdGhpcy5lbWl0KHRoaXMuY29uc3RydWN0b3IuRVZFTlRTLnJlbmFtZUxheWVyLCB7XHJcbiAgICAgIG9sZE5hbWU6IGN1cnJlbnROYW1lLFxyXG4gICAgICBuZXdOYW1lOiBuYW1lLFxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIG5hbWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gdGhlIHdlaWdodCBvZiBhbiBhbmltYXRpb24gbGF5ZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRvIHJldHVybiB3ZWlnaHQgZnJvbS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0TGF5ZXJXZWlnaHQobmFtZSkge1xyXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBuYW1lIGlzIHZhbGlkXHJcbiAgICBjb25zdCBsYXllciA9IHRoaXMuX2xheWVyTWFwW25hbWVdO1xyXG5cclxuICAgIGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBgQ2Fubm90IGdldCB3ZWlnaHQgb24gbGF5ZXIgJHtuYW1lfSBmcm9tIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gTm8gbGF5ZXIgZXhpc3RzIHdpdGggdGhpcyBuYW1lLmBcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbGF5ZXIud2VpZ2h0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIHRoZSB3ZWlnaHQgb2YgYW4gYW5pbWF0aW9uIGxheWVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBUaGUgbmFtZSBvZiB0aGUgbGF5ZXIgdG8gdXBkYXRlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB3ZWlnaHQgLSBUaGUgd2VpZ2h0IHZhbHVlIHRvIHNldCBvbiB0aGUgbGF5ZXIuIFRoaXMgbnVtYmVyXHJcbiAgICogc2hvdWxkIGJlIGluIHRoZSAwLTEgcmFuZ2UuXHJcbiAgICogQHBhcmFtIHtudW1iZXI9fSBzZWNvbmRzIC0gVGhlIG51bWJlciBvZiBzZWNvbmRzIGl0IHNob3VsZCB0YWtlIHRvIHJlYWNoIHRoZVxyXG4gICAqIG5ldyB3ZWlnaHQuIERlZmF1bHQgaXMgemVybyBhbmQgd2lsbCBzZXQgaW1tZWRpYXRlbHkuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IGVhc2luZ0ZuIC0gVGhlIGVhc2luZyBmdW5jdGlvbiB0byB1c2Ugd2hpbGUgaW50ZXJwb2xhdGluZ1xyXG4gICAqIHRoZSB3ZWlnaHQuIERlZmF1bHQgaXMgRWFzaW5nLkxpbmVhci5Jbk91dC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH0gQSBwcm9taXNlIHRoYXQgd2lsbCByZXNvbHZlIG9uY2UgdGhlIGxheWVyJ3Mgd2VpZ2h0IHJlYWNoZXNcclxuICAgKiB0aGUgdGFyZ2V0IHZhbHVlLlxyXG4gICAqL1xyXG4gIHNldExheWVyV2VpZ2h0KG5hbWUsIHdlaWdodCwgc2Vjb25kcywgZWFzaW5nRm4pIHtcclxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgbmFtZSBpcyB2YWxpZFxyXG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9sYXllck1hcFtuYW1lXTtcclxuXHJcbiAgICBpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBjb25zdCBlID0gYENhbm5vdCBzZXQgd2VpZ2h0IG9uIGxheWVyICR7bmFtZX0gZnJvbSBob3N0ICR7dGhpcy5faG9zdC5pZH0uIE5vIGxheWVyIGV4aXN0cyB3aXRoIHRoaXMgbmFtZS5gO1xyXG4gICAgICByZXR1cm4gRGVmZXJyZWQucmVqZWN0KGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBsYXllci5zZXRXZWlnaHQod2VpZ2h0LCBzZWNvbmRzLCBlYXNpbmdGbik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIHRoZSBuYW1lcyBvZiBibGVuZCBzdGF0ZXMgaW4gYW4gYW5pbWF0aW9uIGluIGEgbGF5ZXIuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgY29udGFpbmluZyB0aGUgYW5pbWF0aW9uIGNvbnRhaW5pbmdcclxuICAgKiB0aGUgYmxlbmQgc3RhdGUgdG8gdXBkYXRlLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhbmltYXRpb25OYW1lIC0gTmFtZSBvZiB0aGUgYW5pbWF0aW9uIGNvbnRhaW5pbmcgdGhlIGJsZW5kIHN0YXRlXHJcbiAgICogdG8gdXBkYXRlLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0FycmF5LjxzdHJpbmc+fSAtIE5hbWVzIG9mIGJsZW5kIHN0YXRlcy5cclxuICAgKi9cclxuICBnZXRBbmltYXRpb25CbGVuZE5hbWVzKGxheWVyTmFtZSwgYW5pbWF0aW9uTmFtZSkge1xyXG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9sYXllck1hcFtsYXllck5hbWVdO1xyXG5cclxuICAgIGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBgQ2Fubm90IGdldCBibGVuZCBuYW1lcyBvbiBsYXllciAke2xheWVyTmFtZX0gZnJvbSBob3N0ICR7dGhpcy5faG9zdC5pZH0uIE5vIGxheWVyIGV4aXN0cyB3aXRoIHRoaXMgbmFtZS5gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGxheWVyLmdldEFuaW1hdGlvbkJsZW5kTmFtZXMoYW5pbWF0aW9uTmFtZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgdGhlIHdlaWdodCBmb3IgYSBibGVuZCBzdGF0ZSBpbiBhbiBhbmltYXRpb24gaW4gYSBsYXllci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllck5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciBjb250YWluaW5nIHRoZSBhbmltYXRpb24gY29udGFpbmluZ1xyXG4gICAqIHRoZSBibGVuZCBzdGF0ZSB0byB1cGRhdGUuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGFuaW1hdGlvbk5hbWUgLSBOYW1lIG9mIHRoZSBhbmltYXRpb24gY29udGFpbmluZyB0aGUgYmxlbmQgc3RhdGVcclxuICAgKiB0byB1cGRhdGUuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGJsZW5kTmFtZSAtIE5hbWUgb2YgdGhlIGJsZW5kIHN0YXRlIHRvIHVwZGF0ZS5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gd2VpZ2h0IC0gV2VpZ2h0IHZhbHVlIHRvIHNldCBvbiB0aGUgYW5pbWF0aW9uLiBUaGlzIG51bWJlciBzaG91ZGxkIGJlXHJcbiAgICogaW4gdGhlIDAtMSByYW5nZS5cclxuICAgKiBAcGFyYW0ge251bWJlcj19IHNlY29uZHMgLSBOdW1iZXIgb2Ygc2Vjb25kcyBpdCBzaG91bGQgdGFrZSB0byByZWFjaCB0aGUgbmV3IHdlaWdodC5cclxuICAgKiBEZWZhdWx0IGlzIHplcm8gYW5kIHdpbGwgc2V0IGltbWVkaWF0ZWx5LlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBlYXNpbmdGbiAtIEVhc2luZyBmdW5jdGlvbiB0byB1c2Ugd2hpbGUgaW50ZXJwb2xhdGluZyB0aGUgbmV3XHJcbiAgICogd2VpZ2h0LiBEZWZhdWx0IGlzIEVhc2luZy5MaW5lYXIuSW5PdXQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9IC0gUHJvbWlzZSB0aGF0IHdpbGwgcmVzb2x2ZSBvbmNlIHRoZSBhbmltYXRpb24ncyB3ZWlnaHQgcmVhY2hlc1xyXG4gICAqIHRoZSB0YXJnZXQgdmFsdWUuXHJcbiAgICovXHJcbiAgc2V0QW5pbWF0aW9uQmxlbmRXZWlnaHQoXHJcbiAgICBsYXllck5hbWUsXHJcbiAgICBhbmltYXRpb25OYW1lLFxyXG4gICAgYmxlbmROYW1lLFxyXG4gICAgd2VpZ2h0LFxyXG4gICAgc2Vjb25kcyxcclxuICAgIGVhc2luZ0ZuXHJcbiAgKSB7XHJcbiAgICBjb25zdCBsYXllciA9IHRoaXMuX2xheWVyTWFwW2xheWVyTmFtZV07XHJcblxyXG4gICAgaWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgY29uc3QgZSA9IGBDYW5ub3Qgc2V0IGJsZW5kIHdlaWdodCBvbiBsYXllciAke2xheWVyTmFtZX0gZnJvbSBob3N0ICR7dGhpcy5faG9zdC5pZH0uIE5vIGxheWVyIGV4aXN0cyB3aXRoIHRoaXMgbmFtZS5gO1xyXG4gICAgICByZXR1cm4gRGVmZXJyZWQucmVqZWN0KGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBsYXllci5zZXRBbmltYXRpb25CbGVuZFdlaWdodChcclxuICAgICAgYW5pbWF0aW9uTmFtZSxcclxuICAgICAgYmxlbmROYW1lLFxyXG4gICAgICB3ZWlnaHQsXHJcbiAgICAgIHNlY29uZHMsXHJcbiAgICAgIGVhc2luZ0ZuXHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyB0aGUgd2VpZ2h0IGZvciBhIGJsZW5kIHN0YXRlIGluIGFuIGFuaW1hdGlvbiBpbiBhIGxheWVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIGNvbnRhaW5pbmcgdGhlIGFuaW1hdGlvbiBjb250YWluaW5nXHJcbiAgICogdGhlIGJsZW5kIHN0YXRlIHRvIHVwZGF0ZS5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gYW5pbWF0aW9uTmFtZSAtIE5hbWUgb2YgdGhlIGFuaW1hdGlvbiBjb250YWluaW5nIHRoZSBibGVuZCBzdGF0ZVxyXG4gICAqIHRvIHVwZGF0ZS5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gYmxlbmROYW1lIC0gTmFtZSBvZiB0aGUgYmxlbmQgc3RhdGUgdG8gdXBkYXRlLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge251bWJlcn0gLSBXZWlnaHQgb2YgdGhlIGJsZW5kIHN0YXRlLlxyXG4gICAqL1xyXG4gIGdldEFuaW1hdGlvbkJsZW5kV2VpZ2h0KGxheWVyTmFtZSwgYW5pbWF0aW9uTmFtZSwgYmxlbmROYW1lKSB7XHJcbiAgICBjb25zdCBsYXllciA9IHRoaXMuX2xheWVyTWFwW2xheWVyTmFtZV07XHJcblxyXG4gICAgaWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGBDYW5ub3QgZ2V0IGJsZW5kIHdlaWdodCBvbiBsYXllciAke2xheWVyTmFtZX0gZnJvbSBob3N0ICR7dGhpcy5faG9zdC5pZH0uIE5vIGxheWVyIGV4aXN0cyB3aXRoIHRoaXMgbmFtZS5gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGxheWVyLmdldEFuaW1hdGlvbkJsZW5kV2VpZ2h0KGFuaW1hdGlvbk5hbWUsIGJsZW5kTmFtZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQYXVzZSB3ZWlnaHQgaW50ZXJwb2xhdGlvbiBhbmltYXRpb24gb24gYSBsYXllciB3aXRoIHRoZSBnaXZlbiBuYW1lLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0byBwYXVzZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufSAtIFdoZXRoZXIgb3Igbm90IHRoZXJlIHdhcyBhbiBleGlzdGluZyBpbnRlcnBvbGF0aW9uIHRvIHBhdXNlLlxyXG4gICAqL1xyXG4gIHBhdXNlTGF5ZXJXZWlnaHQobmFtZSkge1xyXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBuYW1lIGlzIHZhbGlkXHJcbiAgICBjb25zdCBsYXllciA9IHRoaXMuX2xheWVyTWFwW25hbWVdO1xyXG5cclxuICAgIGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBgQ2Fubm90IHBhdXNlIHdlaWdodCBpbnRlcnBvbGF0aW9uIG9uIGxheWVyICR7bmFtZX0gZnJvbSBob3N0ICR7dGhpcy5faG9zdC5pZH0uIE5vIGxheWVyIGV4aXN0cyB3aXRoIHRoaXMgbmFtZS5gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGxheWVyLnBhdXNlV2VpZ2h0KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXN1bWUgd2VpZ2h0IGludGVycG9sYXRpb24gYW5pbWF0aW9uIG9uIGEgbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gbmFtZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdG8gcmVzdW1lLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0RlZmVycmVkfSAtIFJlc29sdmVzIG9uY2UgdGhlIGxheWVyJ3Mgd2VpZ2h0IHJlYWNoZXMgaXRzIHRhcmdldCB2YWx1ZS5cclxuICAgKi9cclxuICByZXN1bWVMYXllcldlaWdodChuYW1lKSB7XHJcbiAgICAvLyBNYWtlIHN1cmUgdGhlIG5hbWUgaXMgdmFsaWRcclxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbGF5ZXJNYXBbbmFtZV07XHJcblxyXG4gICAgaWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgY29uc3QgZSA9IGBDYW5ub3QgcmVzdW1lIHdlaWdodCBpbnRlcnBvbGF0aW9uIG9uIGxheWVyICR7bmFtZX0gZnJvbSBob3N0ICR7dGhpcy5faG9zdC5pZH0uIE5vIGxheWVyIGV4aXN0cyB3aXRoIHRoaXMgbmFtZS5gO1xyXG4gICAgICByZXR1cm4gRGVmZXJyZWQucmVqZWN0KGUpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBsYXllci5yZXN1bWVXZWlnaHQoKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhdXNlIGN1cnJlbnQgYW5pbWF0aW9uIGFuZCB3ZWlnaHQgaW50ZXJwb2xhdGlvbiBhbmltYXRpb24gb24gYSBsYXllciB3aXRoXHJcbiAgICogdGhlIGdpdmVuIG5hbWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRvIHBhdXNlLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59IC0gV2hldGhlciBvciBub3QgdGhlcmUgd2FzIGFuIGV4aXN0aW5nIGludGVycG9sYXRpb24gb3JcclxuICAgKiBjdXJyZW50IGFuaW1hdGlvbiB0byBwYXVzZS5cclxuICAgKi9cclxuICBwYXVzZUxheWVyKG5hbWUpIHtcclxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgbmFtZSBpcyB2YWxpZFxyXG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9sYXllck1hcFtuYW1lXTtcclxuXHJcbiAgICBpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgYENhbm5vdCBwYXVzZSBsYXllciAke25hbWV9IGZyb20gaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBObyBsYXllciBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBsYXllci5wYXVzZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzdW1lIGN1cnJlbnQgYW5pbWF0aW9uIGFuZCB3ZWlnaHQgaW50ZXJwb2xhdGlvbiBhbmltYXRpb24gb24gYSBsYXllciB3aXRoXHJcbiAgICogdGhlIGdpdmVuIG5hbWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRvIHJlc3VtZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH0gLSBSZXNvbHZlcyBvbmNlIHRoZSBsYXllcidzIHdlaWdodCByZWFjaGVzIGl0cyB0YXJnZXQgdmFsdWVcclxuICAgKiBhbmQgaXQncyBjdXJyZW50IGFuaW1hdGlvbiBmaW5pc2hlcyBwbGF5aW5nLlxyXG4gICAqL1xyXG4gIHJlc3VtZUxheWVyKG5hbWUpIHtcclxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgbmFtZSBpcyB2YWxpZFxyXG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9sYXllck1hcFtuYW1lXTtcclxuXHJcbiAgICBpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBjb25zdCBlID0gYENhbm5vdCByZXN1bWUgbGF5ZXIgJHtuYW1lfSBmcm9tIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gTm8gbGF5ZXIgZXhpc3RzIHdpdGggdGhpcyBuYW1lLmA7XHJcbiAgICAgIHJldHVybiBEZWZlcnJlZC5yZWplY3QoZSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGxheWVyLnJlc3VtZSgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIHdoZXRoZXIgb3Igbm90IHRoZSBhbmltYXRpb24gbGF5ZXIgd2l0aCB0aGUgZ2l2ZW4gbmFtZSBpcyBjdXJyZW50bHlcclxuICAgKiB0cmFuc2l0aW9uaW5nIGJldHdlZW4gYW5pbWF0aW9ucy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllck5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0byBjaGVjay5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGdldFRyYW5zaXRpb25pbmcobGF5ZXJOYW1lKSB7XHJcbiAgICAvLyBNYWtlIHN1cmUgdGhlIGxheWVyTmFtZSBpcyB2YWxpZFxyXG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9sYXllck1hcFtsYXllck5hbWVdO1xyXG5cclxuICAgIGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBgR2V0IHRyYW5zaXRpb25pbmcgb24gbGF5ZXIgJHtsYXllck5hbWV9IGZyb20gaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBObyBsYXllciBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBsYXllci5pc1RyYW5zaXRpb25pbmc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gYW4gYXJyYXkgb2YgdGhlIG5hbWVzIG9mIGFsbCBzdGF0ZXMgdGhlIGxheWVyIHdpdGggdGhlIGdpdmVuIG5hbWUgY29udHJvbHMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdG8gc2VhcmNoLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0FycmF5LjxzdHJpbmc+fVxyXG4gICAqL1xyXG4gIGdldEFuaW1hdGlvbnMobGF5ZXJOYW1lKSB7XHJcbiAgICAvLyBNYWtlIHN1cmUgdGhlIGxheWVyTmFtZSBpcyB2YWxpZFxyXG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9sYXllck1hcFtsYXllck5hbWVdO1xyXG5cclxuICAgIGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBgR2V0IGFuaW1hdGlvbnMgb24gbGF5ZXIgJHtsYXllck5hbWV9IGZyb20gaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBObyBsYXllciBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBsYXllci5nZXRTdGF0ZU5hbWVzKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gdGhlIG5hbWUgb2YgdGhlIHN0YXRlIGN1cnJlbnRseSBhY3RpdmUgb24gdGhlIGxheWVyIHdpdGggdGhlIGdpdmVuIG5hbWUuXHJcbiAgICogUmV0dXJuIG51bGwgaWYgdGhlcmUgaXMgbm8gY3VycmVudCBhbmltYXRpb24gZm9yIHRoZSBsYXllci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllck5hbWUgLSBOYW1lIG9mIHRoZSBsYXllci5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHsoc3RyaW5nfG51bGwpfVxyXG4gICAqL1xyXG4gIGdldEN1cnJlbnRBbmltYXRpb24obGF5ZXJOYW1lKSB7XHJcbiAgICAvLyBNYWtlIHN1cmUgdGhlIGxheWVyTmFtZSBpcyB2YWxpZFxyXG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9sYXllck1hcFtsYXllck5hbWVdO1xyXG5cclxuICAgIGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICBgR2V0IGN1cnJlbnQgYW5pbWF0aW9uIG9uIGxheWVyICR7bGF5ZXJOYW1lfSBmcm9tIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gTm8gbGF5ZXIgZXhpc3RzIHdpdGggdGhpcyBuYW1lLmBcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbGF5ZXIuY3VycmVudEFuaW1hdGlvbjtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiB3aGV0aGVyIG9yIG5vdCBhIGxheWVyIHdpdGggdGhlIGdpdmVuIG5hbWUgaXMgY3VycmVudGx5IHBsYXlpbmcgYW5cclxuICAgKiBhbmltYXRpb24gYW5kIHRoYXQgYW5pbWF0aW9uIGlzIHBhdXNlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllck5hbWUgLSBOYW1lIG9mIHRoZSBsYXllci5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGdldFBhdXNlZChsYXllck5hbWUpIHtcclxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgbGF5ZXJOYW1lIGlzIHZhbGlkXHJcbiAgICBjb25zdCBsYXllciA9IHRoaXMuX2xheWVyTWFwW2xheWVyTmFtZV07XHJcblxyXG4gICAgaWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGBHZXQgcGF1c2VkIG9uIGxheWVyICR7bGF5ZXJOYW1lfSBmcm9tIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gTm8gbGF5ZXIgZXhpc3RzIHdpdGggdGhpcyBuYW1lLmBcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gbGF5ZXIuY3VycmVudFN0YXRlICYmIGxheWVyLmN1cnJlbnRTdGF0ZS5wYXVzZWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gdGhlIHR5cGUgbmFtZSBvZiB0aGUgZ2l2ZW4gYW5pbWF0aW9uLiBAc2VlIEFuaW1hdGlvblR5cGVzLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRoYXQgY29udGFpbnMgdGhlIGFuaW1hdGlvbi5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gYW5pbWF0aW9uTmFtZSAtIE5hbWUgb2YgdGhlIGFuaW1hdGlvbiB0byBjaGVjay5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICovXHJcbiAgZ2V0QW5pbWF0aW9uVHlwZShsYXllck5hbWUsIGFuaW1hdGlvbk5hbWUpIHtcclxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgbGF5ZXJOYW1lIGlzIHZhbGlkXHJcbiAgICBjb25zdCBsYXllciA9IHRoaXMuX2xheWVyTWFwW2xheWVyTmFtZV07XHJcblxyXG4gICAgaWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGBHZXQgYW5pbWF0aW9uIHR5cGUgb24gbGF5ZXIgJHtsYXllck5hbWV9IGZyb20gaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBObyBsYXllciBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IHN0YXRlID0gbGF5ZXIuZ2V0U3RhdGUoYW5pbWF0aW9uTmFtZSk7XHJcblxyXG4gICAgaWYgKHN0YXRlID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGBHZXQgYW5pbWF0aW9uIHR5cGUgZm9yIGFuaW1hdGlvbiAke2FuaW1hdGlvbk5hbWV9IG9uIGxheWVyICR7bGF5ZXJOYW1lfSBmcm9tIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gTm8gYW5pbWF0aW9uIGV4aXN0cyB3aXRoIHRoaXMgbmFtZS5gXHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3Qge2NvbnN0cnVjdG9yfSA9IHN0YXRlO1xyXG5cclxuICAgIHJldHVybiBPYmplY3Qua2V5cyhBbmltYXRpb25UeXBlcykuZmluZChcclxuICAgICAgdHlwZU5hbWUgPT4gQW5pbWF0aW9uVHlwZXNbdHlwZU5hbWVdID09PSBjb25zdHJ1Y3RvclxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZCBhIG5ldyBhbmltYXRpb24gdG8gYW4gYW5pbWF0aW9uIGxheWVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRvIGFkZCB0aGUgYW5pbWF0aW9uIHRvLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBhbmltYXRpb25OYW1lIC0gTmFtZSB0byB1c2Ugd2hlbiBjYWxsaW5nIHRoZSBhbmltYXRpb24uXHJcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zIC0gT3B0aW9ucyB0byBwYXNzIHRvIHRoZSBjb25zdHJ1Y3RvciBmb3IgdGhlIG5ld1xyXG4gICAqIFNpbmdsZVN0YXRlIGFuaW1hdGlvbi5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVGhlIG5hbWUgb2YgdGhlIGFuaW1hdGlvbiB0aGF0IHdhcyBhZGRlZFxyXG4gICAqL1xyXG4gIGFkZEFuaW1hdGlvbihcclxuICAgIGxheWVyTmFtZSxcclxuICAgIGFuaW1hdGlvbk5hbWUsXHJcbiAgICBhbmltYXRpb25UeXBlID0gQW5pbWF0aW9uVHlwZXMuc2luZ2xlLFxyXG4gICAgb3B0aW9ucyA9IHt9XHJcbiAgKSB7XHJcbiAgICBvcHRpb25zLm5hbWUgPSB0aGlzLl92YWxpZGF0ZU5ld0FuaW1hdGlvbihsYXllck5hbWUsIGFuaW1hdGlvbk5hbWUpO1xyXG5cclxuICAgIC8vIE1ha2Ugc3VyZSB0aGUgYW5pbWF0aW9uIHR5cGUgaXMgdmFsaWRcclxuICAgIGlmICghT2JqZWN0LnZhbHVlcyhBbmltYXRpb25UeXBlcykuaW5jbHVkZXMoYW5pbWF0aW9uVHlwZSkpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGBDYW5ub3QgYWRkIGFuaW1hdGlvbiAke2FuaW1hdGlvbk5hbWV9IHRvIGxheWVyICR7bGF5ZXJOYW1lfSBvbiBob3N0ICR7dGhpcy5faG9zdC5pZH0uIEludmFsaWQgYW5pbWF0aW9uIHR5cGUuYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbGF5ZXJNYXBbbGF5ZXJOYW1lXTtcclxuICAgIG9wdGlvbnMuYmxlbmRNb2RlID0gbGF5ZXIuYmxlbmRNb2RlO1xyXG4gICAgb3B0aW9ucy50cmFuc2l0aW9uVGltZSA9IGxheWVyLnRyYW5zaXRpb25UaW1lO1xyXG4gICAgY29uc3Qgc3RhdGUgPSB0aGlzW2BfY3JlYXRlJHthbmltYXRpb25UeXBlLm5hbWV9YF0ob3B0aW9ucyk7XHJcblxyXG4gICAgY29uc3QgbmFtZSA9IGxheWVyLmFkZFN0YXRlKHN0YXRlKTtcclxuXHJcbiAgICAvLyBOb3RpZnkgdGhhdCBhbiBhbmltYXRpb24gaGFzIGJlZW4gYWRkZWQgdG8gdGhlIGZlYXR1cmVcclxuICAgIHRoaXMuZW1pdCh0aGlzLmNvbnN0cnVjdG9yLkVWRU5UUy5hZGRBbmltYXRpb24sIHtcclxuICAgICAgbGF5ZXJOYW1lLFxyXG4gICAgICBhbmltYXRpb25OYW1lOiBuYW1lLFxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIG5hbWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZW1vdmUgYW4gYW5pbWF0aW9uIGZyb20gYW4gYW5pbWF0aW9uIGxheWVyLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRvIHJlbW92ZSB0aGUgYW5pbWF0aW9uIGZyb20uXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBhbmltYXRpb24gdG8gcmVtb3ZlLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgcmVtb3ZlQW5pbWF0aW9uKGxheWVyTmFtZSwgYW5pbWF0aW9uTmFtZSkge1xyXG4gICAgLy8gTWFrZSBzdXJlIHRoZSBuYW1lIGlzIHZhbGlkXHJcbiAgICBjb25zdCBsYXllciA9IHRoaXMuX2xheWVyTWFwW2xheWVyTmFtZV07XHJcblxyXG4gICAgaWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgIGBDYW5ub3QgcmVtb3ZlIGFuaW1hdGlvbiBmcm9tIGxheWVyICR7bGF5ZXJOYW1lfSBmcm9tIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gTm8gbGF5ZXIgZXhpc3RzIHdpdGggdGhpcyBuYW1lLmBcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCByZW1vdmVkID0gbGF5ZXIucmVtb3ZlU3RhdGUoYW5pbWF0aW9uTmFtZSk7XHJcblxyXG4gICAgLy8gTm90aWZ5IHRoYXQgYW4gYW5pbWF0aW9uIGhhcyBiZWVuIHJlbW92ZWQgZnJvbSB0aGUgZmVhdHVyZVxyXG4gICAgaWYgKHJlbW92ZWQgPT09IHRydWUpIHtcclxuICAgICAgdGhpcy5lbWl0KHRoaXMuY29uc3RydWN0b3IuRVZFTlRTLnJlbW92ZUFuaW1hdGlvbiwge1xyXG4gICAgICAgIGxheWVyTmFtZSxcclxuICAgICAgICBhbmltYXRpb25OYW1lLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuXHJcbiAgICByZXR1cm4gcmVtb3ZlZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSB0aGUgbmFtZSBvZiBhbiBhbmltYXRpb24uIE5hbWVzIG11c3QgYmUgdW5pcXVlIG9uIGVhY2ggbGF5ZXIsIGlmIHRoZSBuZXdcclxuICAgKiBuYW1lIGlzIG5vdCB1bmlxdWUgaXQgd2lsbCBoYXZlIHRyYWlsaW5nIG51bWJlcnMgYXBwZW5kZWQgdW50aWwgaXQgaXMgdW5pcXVlLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRoYXQgY29udGFpbnMgdGhlIGFuaW1hdGlvbiB0aGF0XHJcbiAgICogd2lsbCBiZSByZW5hbWVkLFxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBjdXJyZW50QW5pbWF0aW9uTmFtZSAtIEN1cnJlbnQgbmFtZSBvZiB0aGUgYW5pbWF0aW9uLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuZXdBbmltYXRpb25OYW1lIC0gTmV3IG5hbWUgdG8gc2V0IG9uIHRoZSBhbmltYXRpb24uXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIFRoZSBuZXcgbmFtZSBvZiB0aGUgYW5pbWF0aW9uXHJcbiAgICovXHJcbiAgcmVuYW1lQW5pbWF0aW9uKGxheWVyTmFtZSwgY3VycmVudEFuaW1hdGlvbk5hbWUsIG5ld0FuaW1hdGlvbk5hbWUpIHtcclxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbGF5ZXJNYXBbbGF5ZXJOYW1lXTtcclxuXHJcbiAgICBpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgYENhbm5vdCByZW5hbWUgYW5pbWF0aW9uICR7Y3VycmVudEFuaW1hdGlvbk5hbWV9IG9uIGxheWVyICR7bGF5ZXJOYW1lfSBmb3IgaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBObyBsYXllciBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG5hbWUgPSBsYXllci5yZW5hbWVTdGF0ZShjdXJyZW50QW5pbWF0aW9uTmFtZSwgbmV3QW5pbWF0aW9uTmFtZSk7XHJcblxyXG4gICAgLy8gTm90aWZ5IHRoYXQgYW4gYW5pbWF0aW9uIGhhcyBiZWVuIHJlbmFtZWQgb24gdGhlIGZlYXR1cmVcclxuICAgIHRoaXMuZW1pdCh0aGlzLmNvbnN0cnVjdG9yLkVWRU5UUy5yZW5hbWVBbmltYXRpb24sIHtcclxuICAgICAgbGF5ZXJOYW1lLFxyXG4gICAgICBvbGROYW1lOiBjdXJyZW50QW5pbWF0aW9uTmFtZSxcclxuICAgICAgbmV3TmFtZTogbmFtZSxcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBuYW1lO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGF1c2UgdGhlIGN1cnJlbnRseSBwbGF5aW5nIGFuaW1hdGlvbiBhbmQgcGxheSBhIG5ldyBhbmltYXRpb24gZnJvbSB0aGUgYmVnaW5uaW5nLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRoYXQgY29udGFpbnMgdGhlIGFuaW1hdGlvbi5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gYW5pbWF0aW9uTmFtZSAtIE5hbWUgb2YgdGhlIGFuaW1hdGlvbiBzdGF0ZSB0byBwbGF5LlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gc2Vjb25kcyAtIFRoZSBudW1iZXIgb2Ygc2Vjb25kcyBpdCBzaG91bGQgdGFrZSB0byB0cmFuc2l0aW9uXHJcbiAgICogdG8gdGhlIG5ldyBhbmltYXRpb24uIERlZmF1bHQgaXMgemVybyBhbmQgd2lsbCBzZXQgaW1tZWRpYXRlbHkuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IGVhc2luZ0ZuIC0gVGhlIGVhc2luZyBmdW5jdGlvbiB0byB1c2Ugd2hpbGUgdHJhbnNpdGlvbmluZ1xyXG4gICAqIGJldHdlZW4gYW5pbWF0aW9ucy4gRGVmYXVsdCBpcyBFYXNpbmcuTGluZWFyLkluT3V0LlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0RlZmVycmVkfSAtIFJlc29sdmVzIG9uY2UgdGhlIGFuaW1hdGlvbiByZWFjaGVzIHRoZSBlbmQgb2YgaXRzXHJcbiAgICogdGltZWxpbmUuIExvb3BpbmcgYW5pbWF0aW9ucyBjYW4gb25seSByZXNvbHZlIGlmIHRoZXkgYXJlIGludGVycnVwdGVkIG9yXHJcbiAgICogbWFudWFsbHkgc3RvcHBlZC5cclxuICAgKi9cclxuICBwbGF5QW5pbWF0aW9uKGxheWVyTmFtZSwgYW5pbWF0aW9uTmFtZSwgc2Vjb25kcywgZWFzaW5nRm4pIHtcclxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbGF5ZXJNYXBbbGF5ZXJOYW1lXTtcclxuXHJcbiAgICBpZiAobGF5ZXIgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBjb25zdCBlID0gYENhbm5vdCBwbGF5IGFuaW1hdGlvbiAke2FuaW1hdGlvbk5hbWV9IG9uIGxheWVyICR7bGF5ZXJOYW1lfSBmb3IgaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBObyBsYXllciBleGlzdHMgd2l0aCB0aGlzIG5hbWUuYDtcclxuICAgICAgcmV0dXJuIERlZmVycmVkLnJlamVjdChlKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBOb3RpZnkgdGhhdCBhIG5ldyBhbmltYXRpb24gaGFzIGJlZ3VuXHJcbiAgICB0aGlzLmVtaXQodGhpcy5jb25zdHJ1Y3Rvci5FVkVOVFMucGxheUFuaW1hdGlvbiwge1xyXG4gICAgICBsYXllck5hbWUsXHJcbiAgICAgIGFuaW1hdGlvbk5hbWUsXHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gbGF5ZXIucGxheUFuaW1hdGlvbihcclxuICAgICAgYW5pbWF0aW9uTmFtZSxcclxuICAgICAgc2Vjb25kcyxcclxuICAgICAgZWFzaW5nRm4sXHJcbiAgICAgICgpID0+IHtcclxuICAgICAgICAvLyBOb3RpZnkgdGhhdCBhbiBhbmltYXRpb24gaGFzIHN0b3BwZWRcclxuICAgICAgICB0aGlzLmVtaXQodGhpcy5jb25zdHJ1Y3Rvci5FVkVOVFMuc3RvcEFuaW1hdGlvbiwge1xyXG4gICAgICAgICAgbGF5ZXJOYW1lLFxyXG4gICAgICAgICAgYW5pbWF0aW9uTmFtZSxcclxuICAgICAgICB9KTtcclxuICAgICAgfSxcclxuICAgICAgdW5kZWZpbmVkLFxyXG4gICAgICAoKSA9PiB7XHJcbiAgICAgICAgLy8gTm90aWZ5IHRoYXQgYW4gYW5pbWF0aW9uIGhhcyBiZWVuIGludGVycnVwdGVkXHJcbiAgICAgICAgdGhpcy5lbWl0KHRoaXMuY29uc3RydWN0b3IuRVZFTlRTLmludGVycnVwdEFuaW1hdGlvbiwge1xyXG4gICAgICAgICAgbGF5ZXJOYW1lLFxyXG4gICAgICAgICAgYW5pbWF0aW9uTmFtZSxcclxuICAgICAgICB9KTtcclxuICAgICAgfSxcclxuICAgICAgKHtuYW1lLCBjYW5BZHZhbmNlLCBpc1F1ZXVlRW5kfSkgPT4ge1xyXG4gICAgICAgIGlmIChsYXllci5jdXJyZW50QW5pbWF0aW9uID09PSBhbmltYXRpb25OYW1lKSB7XHJcbiAgICAgICAgICAvLyBOb3RpZnkgdGhhdCBhIG5ldyBhbmltYXRpb24gaGFzIGJlZ3VuXHJcbiAgICAgICAgICB0aGlzLmVtaXQodGhpcy5jb25zdHJ1Y3Rvci5FVkVOVFMucGxheU5leHRBbmltYXRpb24sIHtcclxuICAgICAgICAgICAgbGF5ZXJOYW1lLFxyXG4gICAgICAgICAgICBhbmltYXRpb25OYW1lLFxyXG4gICAgICAgICAgICBuZXh0UXVldWVkQW5pbWF0aW9uOiBuYW1lLFxyXG4gICAgICAgICAgICBjYW5BZHZhbmNlLFxyXG4gICAgICAgICAgICBpc1F1ZXVlRW5kLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICApO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGxheSB0aGUgbmV4dCBhbmltYXRpb24gaW4gdGhlIHF1ZXVlIG9mIGEgUXVldWVTdGF0ZSBhbmltYXRpb24uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdGhhdCBjb250YWlucyB0aGUgcXVldWUgYW5pbWF0aW9uLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gYW5pbWF0aW9uTmFtZSAtIE5hbWUgb2YgdGhlIGFuaW1hdGlvbiBxdWV1ZSBhbmltYXRpb24uIERlZmF1bHRzXHJcbiAgICogdG8gdGhlIG5hbWUgb2YgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIGZvciB0aGUgbGF5ZXIuXHJcbiAgICogQHBhcmFtIHtudW1iZXI9fSBzZWNvbmRzIC0gVGhlIG51bWJlciBvZiBzZWNvbmRzIGl0IHNob3VsZCB0YWtlIHRvIHRyYW5zaXRpb25cclxuICAgKiB0byB0aGUgcXVldWUgYW5pbWF0aW9uIGlmIGl0J3Mgbm90IGFscmVhZHkgY3VycmVudGx5IHBsYXlpbmcuIERlZmF1bHQgaXMgemVyb1xyXG4gICAqIGFuZCB3aWxsIHNldCBpbW1lZGlhdGVseS5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gZWFzaW5nRm4gLSBUaGUgZWFzaW5nIGZ1bmN0aW9uIHRvIHVzZSB3aGlsZSB0cmFuc2l0aW9uaW5nXHJcbiAgICogdG8gdGhlIHF1ZXVlIGFuaW1hdGlvbiBpZiBpdCBpc24ndCBhbHJlYWR5IHBsYXlpbmcuIERlZmF1bHQgaXMgRWFzaW5nLkxpbmVhci5Jbk91dC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH0gLSBSZXNvbHZlcyBvbmNlIHRoZSBsYXN0IGFuaW1hdGlvbiBpbiB0aGUgcXVldWUgZmluaXNoZXNcclxuICAgKiBwbGF5aW5nLlxyXG4gICAqL1xyXG4gIHBsYXlOZXh0QW5pbWF0aW9uKGxheWVyTmFtZSwgYW5pbWF0aW9uTmFtZSwgdHJhbnNpdGlvblRpbWUsIGVhc2luZ0ZuKSB7XHJcbiAgICBjb25zdCBsYXllciA9IHRoaXMuX2xheWVyTWFwW2xheWVyTmFtZV07XHJcblxyXG4gICAgaWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgY29uc3QgZSA9IGBDYW5ub3QgcGxheSBuZXh0IGFuaW1hdGlvbiBvbiBsYXllciAke2xheWVyTmFtZX0gZm9yIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gTm8gbGF5ZXIgZXhpc3RzIHdpdGggdGhpcyBuYW1lLmA7XHJcbiAgICAgIHJldHVybiBEZWZlcnJlZC5yZWplY3QoZSk7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGFuaW1hdGlvbk5hbWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICBhbmltYXRpb25OYW1lID0gbGF5ZXIuY3VycmVudEFuaW1hdGlvbjtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBhbmltYXRpb24gPSBsYXllci5nZXRTdGF0ZShsYXllci5jdXJyZW50QW5pbWF0aW9uKTtcclxuXHJcbiAgICBpZiAoYW5pbWF0aW9uID09PSBudWxsKSB7XHJcbiAgICAgIGNvbnN0IGUgPSBgQ2Fubm90IHBsYXkgbmV4dCBhbmltYXRpb24gb24gbGF5ZXIgJHtsYXllck5hbWV9IGZvciBob3N0ICR7dGhpcy5faG9zdC5pZH0uIE5vIGFuaW1hdGlvbiBleGlzdHMgd2l0aCBuYW1lICR7YW5pbWF0aW9uTmFtZX0uYDtcclxuICAgICAgcmV0dXJuIERlZmVycmVkLnJlamVjdChlKTtcclxuICAgIH0gZWxzZSBpZiAodGhpcy5nZXRBbmltYXRpb25UeXBlKGxheWVyTmFtZSwgYW5pbWF0aW9uTmFtZSkgIT09ICdxdWV1ZScpIHtcclxuICAgICAgY29uc3QgZSA9IGBDYW5ub3QgcGxheSBuZXh0IGFuaW1hdGlvbiBvbiBsYXllciAke2xheWVyTmFtZX0gZm9yIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gJHthbmltYXRpb25OYW1lfSBpcyBub3QgYSBxdWV1ZSBzdGF0ZS5gO1xyXG4gICAgICByZXR1cm4gRGVmZXJyZWQucmVqZWN0KGUpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IG9uTmV4dCA9ICh7bmFtZSwgY2FuQWR2YW5jZSwgaXNRdWV1ZUVuZH0pID0+IHtcclxuICAgICAgaWYgKGxheWVyLmN1cnJlbnRBbmltYXRpb24gPT09IGFuaW1hdGlvbk5hbWUpIHtcclxuICAgICAgICAvLyBOb3RpZnkgdGhhdCBhIG5ldyBhbmltYXRpb24gaGFzIGJlZ3VuXHJcbiAgICAgICAgdGhpcy5lbWl0KHRoaXMuY29uc3RydWN0b3IuRVZFTlRTLnBsYXlOZXh0QW5pbWF0aW9uLCB7XHJcbiAgICAgICAgICBsYXllck5hbWUsXHJcbiAgICAgICAgICBhbmltYXRpb25OYW1lLFxyXG4gICAgICAgICAgbmV4dFF1ZXVlZEFuaW1hdGlvbjogbmFtZSxcclxuICAgICAgICAgIGNhbkFkdmFuY2UsXHJcbiAgICAgICAgICBpc1F1ZXVlRW5kLFxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9O1xyXG5cclxuICAgIC8vIE1ha2UgdGhlIHF1ZXVlIGFuaW1hdGlvbiBjdXJyZW50IGlmIGl0IHdhc24ndCBhbHJlYWR5XHJcbiAgICBpZiAobGF5ZXIuY3VycmVudEFuaW1hdGlvbiA9PT0gbnVsbCkge1xyXG4gICAgICBsYXllci5yZXN1bWVBbmltYXRpb24oXHJcbiAgICAgICAgYW5pbWF0aW9uLm5hbWUsXHJcbiAgICAgICAgdHJhbnNpdGlvblRpbWUsXHJcbiAgICAgICAgZWFzaW5nRm4sXHJcbiAgICAgICAgdW5kZWZpbmVkLFxyXG4gICAgICAgIHVuZGVmaW5lZCxcclxuICAgICAgICB1bmRlZmluZWQsXHJcbiAgICAgICAgb25OZXh0XHJcbiAgICAgICk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGFuaW1hdGlvbi5uZXh0KG9uTmV4dCwgdHJ1ZSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQYXVzZSB0aGUgY3VycmVudCBhbmltYXRpb24gb24gYSBsYXllci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdG8gcGF1c2UuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgYW4gYW5pbWF0aW9uIHdhcyBzdWNjZXNzZnVsbHkgcGF1c2VkLlxyXG4gICAqL1xyXG4gIHBhdXNlQW5pbWF0aW9uKG5hbWUpIHtcclxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbGF5ZXJNYXBbbmFtZV07XHJcblxyXG4gICAgaWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgY29uc29sZS53YXJuKFxyXG4gICAgICAgIGBEaWQgbm90IHBhdXNlIGFuaW1hdGlvbiBvbiBsYXllciAke25hbWV9IGZvciBob3N0ICR7dGhpcy5faG9zdC5pZH0uIE5vIGxheWVyIGV4aXN0cyB3aXRoIHRoaXMgbmFtZS5gXHJcbiAgICAgICk7XHJcbiAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuXHJcbiAgICBjb25zdCBwYXVzZWQgPSBsYXllci5wYXVzZUFuaW1hdGlvbigpO1xyXG5cclxuICAgIC8vIE5vdGlmeSB0aGF0IGFuIGFuaW1hdGlvbiB3YXMgcGF1c2VkXHJcbiAgICBpZiAocGF1c2VkKSB7XHJcbiAgICAgIGNvbnN0IGFuaW1hdGlvbk5hbWUgPSBsYXllci5jdXJyZW50QW5pbWF0aW9uO1xyXG4gICAgICB0aGlzLmVtaXQodGhpcy5jb25zdHJ1Y3Rvci5FVkVOVFMucGF1c2VBbmltYXRpb24sIHtcclxuICAgICAgICBsYXllck5hbWU6IG5hbWUsXHJcbiAgICAgICAgYW5pbWF0aW9uTmFtZSxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHBhdXNlZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhdXNlIHRoZSBjdXJyZW50bHkgcGxheWluZyBhbmltYXRpb24gYW5kIHBsYXkgYSBuZXcgYW5pbWF0aW9uIGZyb20gd2hlcmUgaXRcclxuICAgKiBsYXN0IGxlZnQgb2ZmLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRoYXQgY29udGFpbnMgdGhlIGFuaW1hdGlvbi5cclxuICAgKiBAcGFyYW0ge3N0cmluZz19IGFuaW1hdGlvbk5hbWUgLSBOYW1lIG9mIHRoZSBhbmltYXRpb24gc3RhdGUgdG8gcmVzdW1lLiBEZWZhdWx0c1xyXG4gICAqIHRvIHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50IGFuaW1hdGlvbiBmb3IgdGhlIGxheWVyLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyPX0gc2Vjb25kcyAtIFRoZSBudW1iZXIgb2Ygc2Vjb25kcyBpdCBzaG91bGQgdGFrZSB0byB0cmFuc2l0aW9uXHJcbiAgICogdG8gdGhlIG5ldyBhbmltYXRpb24uIERlZmF1bHQgaXMgemVybyBhbmQgd2lsbCBzZXQgaW1tZWRpYXRlbHkuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IGVhc2luZ0ZuIC0gVGhlIGVhc2luZyBmdW5jdGlvbiB0byB1c2Ugd2hpbGUgdHJhbnNpdGlvbmluZ1xyXG4gICAqIGJldHdlZW4gYW5pbWF0aW9ucy4gRGVmYXVsdCBpcyBFYXNpbmcuTGluZWFyLkluT3V0LlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0RlZmVycmVkfSAtIFJlc29sdmVzIG9uY2UgdGhlIGFuaW1hdGlvbiByZWFjaGVzIHRoZSBlbmQgb2YgaXRzXHJcbiAgICogdGltZWxpbmUuIExvb3BpbmcgYW5pbWF0aW9ucyBjYW4gb25seSByZXNvbHZlIGlmIHRoZXkgYXJlIGludGVycnVwdGVkIG9yXHJcbiAgICogbWFudWFsbHkgc3RvcHBlZC5cclxuICAgKi9cclxuICByZXN1bWVBbmltYXRpb24obGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lLCBzZWNvbmRzLCBlYXNpbmdGbikge1xyXG4gICAgY29uc3QgbGF5ZXIgPSB0aGlzLl9sYXllck1hcFtsYXllck5hbWVdO1xyXG5cclxuICAgIGlmIChsYXllciA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgIGNvbnN0IGUgPSBgQ2Fubm90IHJlc3VtZSBhbmltYXRpb24gJHthbmltYXRpb25OYW1lfSBvbiBsYXllciAke2xheWVyTmFtZX0gZm9yIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gTm8gbGF5ZXIgZXhpc3RzIHdpdGggdGhpcyBuYW1lLmA7XHJcbiAgICAgIHJldHVybiBEZWZlcnJlZC5yZWplY3QoZSk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gTm90aWZ5IHRoYXQgYW4gYW5pbWF0aW9uIHdhcyByZXN1bWVkXHJcbiAgICB0aGlzLmVtaXQodGhpcy5jb25zdHJ1Y3Rvci5FVkVOVFMucmVzdW1lQW5pbWF0aW9uLCB7XHJcbiAgICAgIGxheWVyTmFtZSxcclxuICAgICAgYW5pbWF0aW9uTmFtZSxcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBsYXllci5yZXN1bWVBbmltYXRpb24oXHJcbiAgICAgIGFuaW1hdGlvbk5hbWUsXHJcbiAgICAgIHNlY29uZHMsXHJcbiAgICAgIGVhc2luZ0ZuLFxyXG4gICAgICAoKSA9PiB7XHJcbiAgICAgICAgLy8gTm90aWZ5IHRoYXQgYW4gYW5pbWF0aW9uIGhhcyBzdG9wcGVkXHJcbiAgICAgICAgdGhpcy5lbWl0KHRoaXMuY29uc3RydWN0b3IuRVZFTlRTLnN0b3BBbmltYXRpb24sIHtcclxuICAgICAgICAgIGxheWVyTmFtZSxcclxuICAgICAgICAgIGFuaW1hdGlvbk5hbWUsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0sXHJcbiAgICAgIHVuZGVmaW5lZCxcclxuICAgICAgKCkgPT4ge1xyXG4gICAgICAgIC8vIE5vdGlmeSB0aGF0IGFuIGFuaW1hdGlvbiBoYXMgYmVlbiBpbnRlcnJ1cHRlZFxyXG4gICAgICAgIHRoaXMuZW1pdCh0aGlzLmNvbnN0cnVjdG9yLkVWRU5UUy5pbnRlcnJ1cHRBbmltYXRpb24sIHtcclxuICAgICAgICAgIGxheWVyTmFtZSxcclxuICAgICAgICAgIGFuaW1hdGlvbk5hbWUsXHJcbiAgICAgICAgfSk7XHJcbiAgICAgIH0sXHJcbiAgICAgICh7bmFtZSwgY2FuQWR2YW5jZSwgaXNRdWV1ZUVuZH0pID0+IHtcclxuICAgICAgICBpZiAobGF5ZXIuY3VycmVudEFuaW1hdGlvbiA9PT0gYW5pbWF0aW9uTmFtZSkge1xyXG4gICAgICAgICAgLy8gTm90aWZ5IHRoYXQgYSBuZXcgYW5pbWF0aW9uIGhhcyBiZWd1blxyXG4gICAgICAgICAgdGhpcy5lbWl0KHRoaXMuY29uc3RydWN0b3IuRVZFTlRTLnBsYXlOZXh0QW5pbWF0aW9uLCB7XHJcbiAgICAgICAgICAgIGxheWVyTmFtZSxcclxuICAgICAgICAgICAgYW5pbWF0aW9uTmFtZSxcclxuICAgICAgICAgICAgbmV4dFF1ZXVlZEFuaW1hdGlvbjogbmFtZSxcclxuICAgICAgICAgICAgY2FuQWR2YW5jZSxcclxuICAgICAgICAgICAgaXNRdWV1ZUVuZCxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0b3AgdGhlIGN1cnJlbnQgYW5pbWF0aW9uIG9uIGEgbGF5ZXIuIFN0b3AgcmV3aW5kcyB0aGUgYW5pbWF0aW9uIHRvIHRoZVxyXG4gICAqIGJlZ2lubmluZyBhbmQgcHJldmVudHMgaXQgZnJvbSBwcm9ncmVzc2luZyBmb3J3YXJkLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0aGF0IGNvbnRhaW5zIHRoZSBhbmltYXRpb24uXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gV2hldGhlciBvciBub3QgYW4gYW5pbWF0aW9uIHdhcyBzdWNjZXNzZnVsbHkgc3RvcHBlZC5cclxuICAgKi9cclxuICBzdG9wQW5pbWF0aW9uKG5hbWUpIHtcclxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbGF5ZXJNYXBbbmFtZV07XHJcblxyXG4gICAgaWYgKGxheWVyID09PSB1bmRlZmluZWQpIHtcclxuICAgICAgY29uc29sZS53YXJuKFxyXG4gICAgICAgIGBEaWQgbm90IHN0b3AgYW5pbWF0aW9uIG9uIGxheWVyICR7bmFtZX0gZm9yIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gTm8gbGF5ZXIgZXhpc3RzIHdpdGggdGhpcyBuYW1lLmBcclxuICAgICAgKTtcclxuICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBsYXllci5zdG9wQW5pbWF0aW9uKCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQYXVzZSBjdXJyZW50IGFuaW1hdGlvbiBhbmQgd2VpZ2h0IGludGVycG9sYXRpb24gYW5pbWF0aW9uIG9uIGFsbCBsYXllcnMuXHJcblxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufSAtIFdoZXRoZXIgb3Igbm90IHRoZXJlIHdhcyBhbiBleGlzdGluZyBpbnRlcnBvbGF0aW9uIG9yXHJcbiAgICogY3VycmVudCBhbmltYXRpb25zIHRvIHBhdXNlLlxyXG4gICAqL1xyXG4gIHBhdXNlKCkge1xyXG4gICAgdGhpcy5fcGF1c2VkID0gdHJ1ZTtcclxuXHJcbiAgICBsZXQgcGF1c2VkID0gZmFsc2U7XHJcbiAgICB0aGlzLl9sYXllcnMuZm9yRWFjaChsID0+IHtcclxuICAgICAgaWYgKGwucGF1c2UoKSkge1xyXG4gICAgICAgIHBhdXNlZCA9IHRydWU7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBwYXVzZWQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXN1bWUgY3VycmVudCBhbmltYXRpb24gYW5kIHdlaWdodCBpbnRlcnBvbGF0aW9uIGFuaW1hdGlvbiBvbiBhbGwgbGF5ZXJzLlxyXG5cclxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gLSBXaGV0aGVyIG9yIG5vdCB0aGVyZSB3YXMgYW4gZXhpc3RpbmcgaW50ZXJwb2xhdGlvbiBvclxyXG4gICAqIGN1cnJlbnQgYW5pbWF0aW9ucyB0byByZXN1bWUuXHJcbiAgICovXHJcbiAgcmVzdW1lKCkge1xyXG4gICAgdGhpcy5fcGF1c2VkID0gZmFsc2U7XHJcblxyXG4gICAgbGV0IHJlc3VtZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuX2xheWVycy5mb3JFYWNoKGwgPT4ge1xyXG4gICAgICBpZiAobC5yZXN1bWUoKSkge1xyXG4gICAgICAgIHJlc3VtZWQgPSB0cnVlO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gcmVzdW1lZDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFkZHMgYSBuYW1lc3BhY2UgdG8gdGhlIGhvc3Qgd2l0aCB0aGUgbmFtZSBvZiB0aGUgZmVhdHVyZSB0byBjb250YWluIHByb3BlcnRpZXNcclxuICAgKiBhbmQgbWV0aG9kcyBmcm9tIHRoZSBmZWF0dXJlIHRoYXQgdXNlcnMgb2YgdGhlIGhvc3QgbmVlZCBhY2Nlc3MgdG8uXHJcbiAgICpcclxuICAgKiBAc2VlIEFuaW1hdGlvbkZlYXR1cmVcclxuICAgKi9cclxuICBpbnN0YWxsQXBpKCkge1xyXG4gICAgLyoqXHJcbiAgICAgKiBAaW5uZXJcclxuICAgICAqIEBuYW1lc3BhY2UgQW5pbWF0aW9uRmVhdHVyZVxyXG4gICAgICovXHJcbiAgICBjb25zdCBhcGkgPSBzdXBlci5pbnN0YWxsQXBpKCk7XHJcblxyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoYXBpLCB7XHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uRmVhdHVyZVxyXG4gICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICogQHNlZSBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjcGF1c2VkXHJcbiAgICAgICAqL1xyXG4gICAgICBwYXVzZWQ6IHtcclxuICAgICAgICBnZXQ6ICgpID0+IHRoaXMucGF1c2VkLFxyXG4gICAgICB9LFxyXG4gICAgICAvKipcclxuICAgICAgICogQG1lbWJlcm9mIEFuaW1hdGlvbkZlYXR1cmVcclxuICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAqIEBzZWUgY29yZS9BbmltYXRpb25GZWF0dXJlI2xheWVyc1xyXG4gICAgICAgKi9cclxuICAgICAgbGF5ZXJzOiB7XHJcbiAgICAgICAgZ2V0OiAoKSA9PiB0aGlzLmxheWVycyxcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG5cclxuICAgIE9iamVjdC5hc3NpZ24oYXBpLCB7XHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uRmVhdHVyZVxyXG4gICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgKiBAc2VlIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNhZGRMYXllclxyXG4gICAgICAgKi9cclxuICAgICAgYWRkTGF5ZXI6IHRoaXMuYWRkTGF5ZXIuYmluZCh0aGlzKSxcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBtZW1iZXJvZiBBbmltYXRpb25GZWF0dXJlXHJcbiAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAqIEBzZWUgY29yZS9BbmltYXRpb25GZWF0dXJlI3JlbW92ZUxheWVyXHJcbiAgICAgICAqL1xyXG4gICAgICByZW1vdmVMYXllcjogdGhpcy5yZW1vdmVMYXllci5iaW5kKHRoaXMpLFxyXG4gICAgICAvKipcclxuICAgICAgICogQG1lbWJlcm9mIEFuaW1hdGlvbkZlYXR1cmVcclxuICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAqIEBtZXRob2RcclxuICAgICAgICogQHNlZSBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjbW92ZUxheWVyXHJcbiAgICAgICAqL1xyXG4gICAgICBtb3ZlTGF5ZXI6IHRoaXMubW92ZUxheWVyLmJpbmQodGhpcyksXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uRmVhdHVyZVxyXG4gICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgKiBAc2VlIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNyZW5hbWVMYXllclxyXG4gICAgICAgKi9cclxuICAgICAgcmVuYW1lTGF5ZXI6IHRoaXMucmVuYW1lTGF5ZXIuYmluZCh0aGlzKSxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uRmVhdHVyZVxyXG4gICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgKiBAc2VlIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNnZXRMYXllcldlaWdodFxyXG4gICAgICAgKi9cclxuICAgICAgZ2V0TGF5ZXJXZWlnaHQ6IHRoaXMuZ2V0TGF5ZXJXZWlnaHQuYmluZCh0aGlzKSxcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBtZW1iZXJvZiBBbmltYXRpb25GZWF0dXJlXHJcbiAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAqIEBzZWUgY29yZS9BbmltYXRpb25GZWF0dXJlI3NldExheWVyV2VpZ2h0XHJcbiAgICAgICAqL1xyXG4gICAgICBzZXRMYXllcldlaWdodDogdGhpcy5zZXRMYXllcldlaWdodC5iaW5kKHRoaXMpLFxyXG4gICAgICAvKipcclxuICAgICAgICogQG1lbWJlcm9mIEFuaW1hdGlvbkZlYXR1cmVcclxuICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAqIEBtZXRob2RcclxuICAgICAgICogQHNlZSBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjcGF1c2VMYXllcldlaWdodFxyXG4gICAgICAgKi9cclxuICAgICAgcGF1c2VMYXllcldlaWdodDogdGhpcy5wYXVzZUxheWVyV2VpZ2h0LmJpbmQodGhpcyksXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uRmVhdHVyZVxyXG4gICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgKiBAc2VlIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNyZXN1bWVMYXllcldlaWdodFxyXG4gICAgICAgKi9cclxuICAgICAgcmVzdW1lTGF5ZXJXZWlnaHQ6IHRoaXMucmVzdW1lTGF5ZXJXZWlnaHQuYmluZCh0aGlzKSxcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBtZW1iZXJvZiBBbmltYXRpb25GZWF0dXJlXHJcbiAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAqIEBzZWUgY29yZS9BbmltYXRpb25GZWF0dXJlI3BhdXNlTGF5ZXJcclxuICAgICAgICovXHJcbiAgICAgIHBhdXNlTGF5ZXI6IHRoaXMucGF1c2VMYXllci5iaW5kKHRoaXMpLFxyXG4gICAgICAvKipcclxuICAgICAgICogQG1lbWJlcm9mIEFuaW1hdGlvbkZlYXR1cmVcclxuICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAqIEBtZXRob2RcclxuICAgICAgICogQHNlZSBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjcmVzdW1lTGF5ZXJcclxuICAgICAgICovXHJcbiAgICAgIHJlc3VtZUxheWVyOiB0aGlzLnJlc3VtZUxheWVyLmJpbmQodGhpcyksXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogQG1lbWJlcm9mIEFuaW1hdGlvbkZlYXR1cmVcclxuICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAqIEBtZXRob2RcclxuICAgICAgICogQHNlZSBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjZ2V0VHJhbnNpdGlvbmluZ1xyXG4gICAgICAgKi9cclxuICAgICAgZ2V0VHJhbnNpdGlvbmluZzogdGhpcy5nZXRUcmFuc2l0aW9uaW5nLmJpbmQodGhpcyksXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uRmVhdHVyZVxyXG4gICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgKiBAc2VlIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNnZXRBbmltYXRpb25zXHJcbiAgICAgICAqL1xyXG4gICAgICBnZXRBbmltYXRpb25zOiB0aGlzLmdldEFuaW1hdGlvbnMuYmluZCh0aGlzKSxcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBtZW1iZXJvZiBBbmltYXRpb25GZWF0dXJlXHJcbiAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAqIEBzZWUgY29yZS9BbmltYXRpb25GZWF0dXJlI2dldEN1cnJlbnRBbmltYXRpb25cclxuICAgICAgICovXHJcbiAgICAgIGdldEN1cnJlbnRBbmltYXRpb246IHRoaXMuZ2V0Q3VycmVudEFuaW1hdGlvbi5iaW5kKHRoaXMpLFxyXG4gICAgICAvKipcclxuICAgICAgICogQG1lbWJlcm9mIEFuaW1hdGlvbkZlYXR1cmVcclxuICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAqIEBtZXRob2RcclxuICAgICAgICogQHNlZSBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjZ2V0UGF1c2VkXHJcbiAgICAgICAqL1xyXG4gICAgICBnZXRQYXVzZWQ6IHRoaXMuZ2V0UGF1c2VkLmJpbmQodGhpcyksXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uRmVhdHVyZVxyXG4gICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgKiBAc2VlIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNnZXRBbmltYXRpb25UeXBlXHJcbiAgICAgICAqL1xyXG4gICAgICBnZXRBbmltYXRpb25UeXBlOiB0aGlzLmdldEFuaW1hdGlvblR5cGUuYmluZCh0aGlzKSxcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBtZW1iZXJvZiBBbmltYXRpb25GZWF0dXJlXHJcbiAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAqIEBzZWUgY29yZS9BbmltYXRpb25GZWF0dXJlI2FkZEFuaW1hdGlvblxyXG4gICAgICAgKi9cclxuICAgICAgYWRkQW5pbWF0aW9uOiB0aGlzLmFkZEFuaW1hdGlvbi5iaW5kKHRoaXMpLFxyXG4gICAgICAvKipcclxuICAgICAgICogQG1lbWJlcm9mIEFuaW1hdGlvbkZlYXR1cmVcclxuICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAqIEBtZXRob2RcclxuICAgICAgICogQHNlZSBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjcmVtb3ZlQW5pbWF0aW9uXHJcbiAgICAgICAqL1xyXG4gICAgICByZW1vdmVBbmltYXRpb246IHRoaXMucmVtb3ZlQW5pbWF0aW9uLmJpbmQodGhpcyksXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uRmVhdHVyZVxyXG4gICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgKiBAc2VlIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNyZW5hbWVBbmltYXRpb25cclxuICAgICAgICovXHJcbiAgICAgIHJlbmFtZUFuaW1hdGlvbjogdGhpcy5yZW5hbWVBbmltYXRpb24uYmluZCh0aGlzKSxcclxuXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uRmVhdHVyZVxyXG4gICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgKiBAc2VlIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNnZXRBbmltYXRpb25CbGVuZE5hbWVzXHJcbiAgICAgICAqL1xyXG4gICAgICBnZXRBbmltYXRpb25CbGVuZE5hbWVzOiB0aGlzLmdldEFuaW1hdGlvbkJsZW5kTmFtZXMuYmluZCh0aGlzKSxcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBtZW1iZXJvZiBBbmltYXRpb25GZWF0dXJlXHJcbiAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAqIEBzZWUgY29yZS9BbmltYXRpb25GZWF0dXJlI2dldEFuaW1hdGlvbkJsZW5kV2VpZ2h0XHJcbiAgICAgICAqL1xyXG4gICAgICBnZXRBbmltYXRpb25CbGVuZFdlaWdodDogdGhpcy5nZXRBbmltYXRpb25CbGVuZFdlaWdodC5iaW5kKHRoaXMpLFxyXG4gICAgICAvKipcclxuICAgICAgICogQG1lbWJlcm9mIEFuaW1hdGlvbkZlYXR1cmVcclxuICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAqIEBtZXRob2RcclxuICAgICAgICogQHNlZSBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjc2V0QW5pbWF0aW9uQmxlbmRXZWlnaHRcclxuICAgICAgICovXHJcbiAgICAgIHNldEFuaW1hdGlvbkJsZW5kV2VpZ2h0OiB0aGlzLnNldEFuaW1hdGlvbkJsZW5kV2VpZ2h0LmJpbmQodGhpcyksXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogQG1lbWJlcm9mIEFuaW1hdGlvbkZlYXR1cmVcclxuICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAqIEBtZXRob2RcclxuICAgICAgICogQHNlZSBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjcGxheUFuaW1hdGlvblxyXG4gICAgICAgKi9cclxuICAgICAgcGxheUFuaW1hdGlvbjogdGhpcy5wbGF5QW5pbWF0aW9uLmJpbmQodGhpcyksXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogQG1lbWJlcm9mIEFuaW1hdGlvbkZlYXR1cmVcclxuICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAqIEBtZXRob2RcclxuICAgICAgICogQHNlZSBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjcGxheU5leHRBbmltYXRpb25cclxuICAgICAgICovXHJcbiAgICAgIHBsYXlOZXh0QW5pbWF0aW9uOiB0aGlzLnBsYXlOZXh0QW5pbWF0aW9uLmJpbmQodGhpcyksXHJcblxyXG4gICAgICAvKipcclxuICAgICAgICogQG1lbWJlcm9mIEFuaW1hdGlvbkZlYXR1cmVcclxuICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAqIEBtZXRob2RcclxuICAgICAgICogQHNlZSBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjcGF1c2VBbmltYXRpb25cclxuICAgICAgICovXHJcbiAgICAgIHBhdXNlQW5pbWF0aW9uOiB0aGlzLnBhdXNlQW5pbWF0aW9uLmJpbmQodGhpcyksXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbWVtYmVyb2YgQW5pbWF0aW9uRmVhdHVyZVxyXG4gICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgKiBAc2VlIGNvcmUvQW5pbWF0aW9uRmVhdHVyZSNyZXN1bWVBbmltYXRpb25cclxuICAgICAgICovXHJcbiAgICAgIHJlc3VtZUFuaW1hdGlvbjogdGhpcy5yZXN1bWVBbmltYXRpb24uYmluZCh0aGlzKSxcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBtZW1iZXJvZiBBbmltYXRpb25GZWF0dXJlXHJcbiAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAqIEBzZWUgY29yZS9BbmltYXRpb25GZWF0dXJlI3N0b3BBbmltYXRpb25cclxuICAgICAgICovXHJcbiAgICAgIHN0b3BBbmltYXRpb246IHRoaXMuc3RvcEFuaW1hdGlvbi5iaW5kKHRoaXMpLFxyXG5cclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBtZW1iZXJvZiBBbmltYXRpb25GZWF0dXJlXHJcbiAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAqIEBzZWUgY29yZS9BbmltYXRpb25GZWF0dXJlI3BhdXNlXHJcbiAgICAgICAqL1xyXG4gICAgICBwYXVzZTogdGhpcy5wYXVzZS5iaW5kKHRoaXMpLFxyXG4gICAgICAvKipcclxuICAgICAgICogQG1lbWJlcm9mIEFuaW1hdGlvbkZlYXR1cmVcclxuICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAqIEBtZXRob2RcclxuICAgICAgICogQHNlZSBjb3JlL0FuaW1hdGlvbkZlYXR1cmUjcmVzdW1lXHJcbiAgICAgICAqL1xyXG4gICAgICByZXN1bWU6IHRoaXMucmVzdW1lLmJpbmQodGhpcyksXHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBlYWNoIGFuaW1hdGlvbiBsYXllci5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVRpbWUgLSBUaW1lIHNpbmNlIHRoZSBsYXN0IHVwZGF0ZS5cclxuICAgKi9cclxuICB1cGRhdGUoZGVsdGFUaW1lKSB7XHJcbiAgICBpZiAoIXRoaXMuX2xheWVycy5sZW5ndGgpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9wYXVzZWQpIHtcclxuICAgICAgZGVsdGFUaW1lID0gMDtcclxuICAgIH1cclxuXHJcbiAgICAvLyBSZS1ldmFsdWF0ZSBpbnRlcm5hbCB3ZWlnaHRzIGZvciBsYXllcnNcclxuICAgIHRoaXMuX3VwZGF0ZUludGVybmFsV2VpZ2h0cygpO1xyXG5cclxuICAgIC8vIFVwZGF0ZSBsYXllcnNcclxuICAgIHRoaXMuX2xheWVycy5mb3JFYWNoKGxheWVyID0+IHtcclxuICAgICAgbGF5ZXIudXBkYXRlKGRlbHRhVGltZSk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBzdXBlci51cGRhdGUoZGVsdGFUaW1lKTtcclxuICB9XHJcblxyXG4gIGRpc2NhcmQoKSB7XHJcbiAgICB0aGlzLl9sYXllcnMuZm9yRWFjaChsYXllciA9PiB7XHJcbiAgICAgIGxheWVyLmRpc2NhcmQoKTtcclxuICAgIH0pO1xyXG5cclxuICAgIGRlbGV0ZSB0aGlzLl9sYXllcnM7XHJcbiAgICBkZWxldGUgdGhpcy5fbGF5ZXJNYXA7XHJcblxyXG4gICAgc3VwZXIuZGlzY2FyZCgpO1xyXG4gIH1cclxufVxyXG5cclxuT2JqZWN0LmRlZmluZVByb3BlcnR5KEFuaW1hdGlvbkZlYXR1cmUsICdFVkVOVFMnLCB7XHJcbiAgdmFsdWU6IHtcclxuICAgIC4uLk9iamVjdC5nZXRQcm90b3R5cGVPZihBYnN0cmFjdEhvc3RGZWF0dXJlKS5FVkVOVFMsXHJcbiAgICBhZGRMYXllcjogJ29uQWRkTGF5ZXJFdmVudCcsXHJcbiAgICByZW1vdmVMYXllcjogJ29uUmVtb3ZlTGF5ZXJFdmVudCcsXHJcbiAgICByZW5hbWVMYXllcjogJ29uUmVuYW1lTGF5ZXJFdmVudCcsXHJcbiAgICBhZGRBbmltYXRpb246ICdvbkFkZEFuaW1hdGlvbkV2ZW50JyxcclxuICAgIHJlbW92ZUFuaW1hdGlvbjogJ29uUmVtb3ZlZEFuaW1hdGlvbkV2ZW50JyxcclxuICAgIHJlbmFtZUFuaW1hdGlvbjogJ29uUmVuYW1lQW5pbWF0aW9uRXZlbnQnLFxyXG4gICAgcGxheUFuaW1hdGlvbjogJ29uUGxheUV2ZW50JyxcclxuICAgIHBsYXlOZXh0QW5pbWF0aW9uOiAnb25OZXh0RXZlbnQnLFxyXG4gICAgcGF1c2VBbmltYXRpb246ICdvblBhdXNlRXZlbnQnLFxyXG4gICAgcmVzdW1lQW5pbWF0aW9uOiAnb25SZXN1bWVFdmVudCcsXHJcbiAgICBpbnRlcnJ1cHRBbmltYXRpb246ICdvbkludGVycnVwdEV2ZW50JyxcclxuICAgIHN0b3BBbmltYXRpb246ICdvblN0b3BFdmVudCcsXHJcbiAgfSxcclxufSk7XHJcblxyXG5leHBvcnQgZGVmYXVsdCBBbmltYXRpb25GZWF0dXJlO1xyXG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXHJcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVuZGVyc2NvcmUtZGFuZ2xlICovXHJcbi8qIGVzbGludC1kaXNhYmxlIG5vLXVudXNlZC12YXJzICovXHJcbmltcG9ydCBNYW5hZ2VkQW5pbWF0aW9uTGF5ZXJJbnRlcmZhY2UgZnJvbSAnLi9hbmltcGFjay9NYW5hZ2VkQW5pbWF0aW9uTGF5ZXJJbnRlcmZhY2UnO1xyXG5pbXBvcnQgeyBBbmltYXRpb25UeXBlcyB9IGZyb20gJy4vYW5pbXBhY2svQW5pbWF0aW9uRmVhdHVyZSc7XHJcbmltcG9ydCBTU01MU3BlZWNobWFya0ludGVyZmFjZSBmcm9tICcuL2F3c3BhY2svU1NNTFNwZWVjaG1hcmtJbnRlcmZhY2UnO1xyXG5pbXBvcnQgQWJzdHJhY3RIb3N0RmVhdHVyZSBmcm9tICcuL0Fic3RyYWN0SG9zdEZlYXR1cmUnO1xyXG5pbXBvcnQgeyBRdWFkcmF0aWMgfSBmcm9tICcuL2FuaW1wYWNrL0Vhc2luZyc7XHJcbmltcG9ydCBNYXRoVXRpbHMgZnJvbSAnLi9NYXRoVXRpbHMnO1xyXG5pbXBvcnQgVXRpbHMgZnJvbSAnLi9VdGlscyc7XHJcblxyXG4vKipcclxuICogRW51bSBmb3IgYXhpcyBkaXJlY3Rpb25zLlxyXG4gKlxyXG4gKiBAcmVhZG9ubHlcclxuICogQGVudW0ge0NsYXNzfVxyXG4gKi9cclxuY29uc3QgQXhpc01hcCA9IHtcclxuICBQb3NpdGl2ZVg6IFsxLCAwLCAwXSxcclxuICBOZWdhdGl2ZVg6IFstMSwgMCwgMF0sXHJcbiAgUG9zaXRpdmVZOiBbMCwgMSwgMF0sXHJcbiAgTmVnYXRpdmVZOiBbMCwgLTEsIDBdLFxyXG4gIFBvc2l0aXZlWjogWzAsIDAsIDFdLFxyXG4gIE5lZ2F0aXZlWjogWzAsIDAsIC0xXSxcclxufTtcclxuXHJcbmNvbnN0IEZhY2VUYXJnZXRUeXBlcyA9IHtcclxuICBFeWVDZW50ZXI6IDAsXHJcbiAgRXllTGVmdDogMSxcclxuICBFeWVSaWdodDogMixcclxuICBNb3V0aDogMyxcclxufVxyXG5cclxuLy8gQXZlcmFnZSBkaXN0YW5jZSBiZXR3ZWVuIHB1cGlscyBpcyAuMDY0bSwgZ29sZGVuIHJhdGlvIHNheXMgdGhhdCB0aGUgZGlzdGFuY2VcclxuLy8gZnJvbSBjZW50ZXIgb2YgdGhlIHB1cGlscyB0byB0aGUgY2VudGVyIG9mIHRoZSBtb3V0aCBzaG91bGQgYmUgYWJvdXQgdGhlIHNhbWUuXHJcbmNvbnN0IEZhY2VWZWN0b3JzID0gW1xyXG4gIFswLCAwLCAwXSxcclxuICBbLS4wMzIsIDAsIDBdLFxyXG4gIFsuMDMyLCAwLCAwXSxcclxuICBbMCwgLS4wNjQsIDBdXHJcbl07XHJcblxyXG4vLyBUaW1lIHJhbmdlcyB0byB1c2Ugd2hlbiBjaG9vc2luZyBhIG5ldyByYW5kb20gd2FpdCB0aW1lIGJldHdlZW4gc2FjY2FkZXNcclxuY29uc3QgTWljcm9TYWNjYWRlV2FpdFJhbmdlcyA9IHtcclxuICBkZWZhdWx0OiBbMC44LCAxLjc1XSxcclxuICBwb3N0TWFjcm86IFswLjYsIDEuMzEyNV0sXHJcbn07XHJcblxyXG5jb25zdCBNYWNyb1NhY2NhZGVXYWl0UmFuZ2VzID0ge1xyXG4gIGRlZmF1bHQ6IFs1LjAsIDguMF0sXHJcbiAgbW91dGhUYXJnZXQ6IFswLjIsIDAuNzVdLCAvLyBMb29rIGF3YXkgZnJvbSBhIG1vdXRoIHRhcmdldCB0aGUgZmFzdGVzdFxyXG4gIGV5ZVRhcmdldDogWzEuNSwgNC4wXVxyXG59O1xyXG5cclxuLy8gTWluaW11bSBhbmdsZSBpbiBkZWdyZWVzIHRoZSBleWUgZGlyZWN0aW9uIG11c3QgY2hhbmdlIHRvIHRyaWdnZXIgYSBibGluayBhbmltYXRpb25cclxuY29uc3QgQmxpbmtUaHJlc2hvbGQgPSAzNTtcclxuXHJcbi8vIE1heGltdW0gbnVtYmVyIG9mIG1pbGxpc2Vjb25kcyB0byB1c2UgZm9yIGNhbGN1bGF0aW5nIGxvb2sgc3BlZWRcclxuY29uc3QgTWF4RGVsdGEgPSAxMDAgLyAzO1xyXG5cclxuLyoqXHJcbiAqIFBvaW50T2ZJbnRlcmVzdCBjb250cm9scyB0aGUgZ2F6ZSBkaXJlY3Rpb24gb2YgdGhlIGhvc3QuIEdpdmVuIG9uZSBvciBtb3JlXHJcbiAqIGFuaW1hdGlvbnMgb2YgdHlwZSBCbGVuZDJkU3RhdGUsIGl0IGNhbGN1bGF0ZXMgdGhlIGFuZ2xlcyBiZXR3ZWVuIHRoZSBsb29rVHJhY2tlclxyXG4gKiBvYmplY3QgKGdlbmVyYWxseSBhIGpvaW50IGluIHRoZSBob3N0J3Mgc2tlbGV0b24pIGFuZCB0aGUgbG9va1RhcmdldCAodGhlIG9iamVjdFxyXG4gKiB0aGUgaG9zdCBzaG91bGQgbG9vayBhdCkgYW5kIGRyaXZlcyB0aGUgbWFuYWdlZCBCbGVuZDJkU3RhdGVzJyBYIGFuZCBZIGJsZW5kXHJcbiAqIHZhbHVlcyB1c2luZyB0aGUgcmVzdWx0LiBZb3UgY2FuIG9wdGlvbmFsbHkgYWRkIHNhY2NhZGljIG1vdmVtZW50IHRvIGFueSBtYW5hZ2VkXHJcbiAqIGFuaW1hdGlvbiB0byBoZWxwIG1ha2UgdGhlIGhvc3QncyBleWVzIGFwcGVhciBhbGl2ZSB3aGVuIGZvY3VzZWQgb24gdGhlIHNhbWVcclxuICogcG9pbnQgZm9yIGV4dGVkZWQgcGVyaW9kcyBvZiB0aW1lLiBJZiBibGluayBhbmltYXRpb25zIGFyZSBzcGVjaWZpZWQsIGEgYmxpbmtcclxuICogd2lsbCBiZSBwbGF5ZWQgZHVyaW5nIGxhcmdlIGNoYW5nZXMgaW4gZ2F6ZSBkaXJlY3Rpb24uXHJcbiAqXHJcbiAqIEBleHRlbmRzIEFic3RyYWN0SG9zdEZlYXR1cmVcclxuICogQGFsaWFzIGNvcmUvUG9pbnRPZkludGVyZXN0RmVhdHVyZVxyXG4gKiBAaW1wbGVtZW50cyBTU01MU3BlZWNobWFya0ludGVyZmFjZVxyXG4gKiBAaW1wbGVtZW50cyBNYW5hZ2VkQW5pbWF0aW9uTGF5ZXJJbnRlcmZhY2VcclxuICovXHJcbmNsYXNzIFBvaW50T2ZJbnRlcmVzdEZlYXR1cmUgZXh0ZW5kcyBBYnN0cmFjdEhvc3RGZWF0dXJlLm1peChcclxuICBTU01MU3BlZWNobWFya0ludGVyZmFjZS5NaXhpbixcclxuICBNYW5hZ2VkQW5pbWF0aW9uTGF5ZXJJbnRlcmZhY2UuTWl4aW5cclxuKSB7XHJcbiAgLyoqXHJcbiAgICogQGNvbnN0cnVjdG9yXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2NvcmUvSG9zdE9iamVjdH0gaG9zdCAtIEhvc3QgdGhhdCBvd25zIHRoZSBmZWF0dXJlLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBmZWF0dXJlLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gdGFyZ2V0IC0gM0QgdHJhbnNmb3JtYXRpb24gbm9kZSB0aGF0IHRoZSBob3N0IHNob3VsZCB0cnkgdG9cclxuICAgKiBsb29rIGF0LlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zLmxvb2tUcmFja2VyIC0gM0QgdHJhbnNmb3JtYXRpb24gbm9kZSB0aGF0IHJlcHJlc2VudHNcclxuICAgKiB0aGUgZGlyZWN0aW9uIHRoZSBob3N0IGlzIGN1cnJlbnRseSBsb29raW5nIGR1cmluZyBhbmltYXRpb24uXHJcbiAgICogQHBhcmFtIHtPYmplY3Q9fSBvcHRpb25zLnNjZW5lIC0gRW5naW5lLXNwZWNpZmljIHNjZW5lIG9iamVjdCB0aGF0IGNvbnRhaW5zXHJcbiAgICogdGhlIGhvc3QuIFRoaXMgb2JqZWN0IG11c3QgYmUgZGVmaW5lZCBpZiB1c2luZyAnc2V0VGFyZ2V0QnlOYW1lJyBvciAnU2V0VGFyZ2V0QnlJZCdcclxuICAgKiBtZXRob2RzLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gbG9va09wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgbG9vayBhbmltYXRpb24gbGF5ZXJzLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbG9va09wdGlvbnMuYmxlbmRUaW1lPTAuMV0gLSBEZWZhdWx0IGFtb3VudCBvZiB0aW1lIGl0IHdpbGxcclxuICAgKiB0YWtlIHRvIG1hbmlwdWxhdGUgdGhlIHdlaWdodHMgb2YgdGhlIGxvb2sgbGF5ZXJzLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbbG9va09wdGlvbnMuZWFzaW5nRm49UXVhZHJhdGljLkluT3V0XSAtIERlZmF1bHQgZWFzaW5nIGZ1bmN0aW9uXHJcbiAgICogdG8gdXNlIHdoZW4gbWFuaXB1bGF0aW5nIGxvb2sgbGF5ZXIgd2VpZ2h0cy5cclxuICAgKiBAcGFyYW0ge0FycmF5LjxPYmplY3Q+fSBbbG9va09wdGlvbnMubGF5ZXJzPVtdXSAtIEFuIGFycmF5IG9mIGxheWVyIG9wdGlvbnNcclxuICAgKiBvYmplY3RzIHRvIHJlZ2lzdGVyIGFzIGxvb2sgbGF5ZXJzLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gYmxpbmtPcHRpb25zIC0gT3B0aW9ucyBmb3IgdGhlIGJsaW5rIGFuaW1hdGlvbiBsYXllcnMuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtibGlua09wdGlvbnMuYmxlbmRUaW1lPTAuMDc1XSAtIERlZmF1bHQgYW1vdW50IG9mIHRpbWUgaXRcclxuICAgKiB3aWxsIHRha2UgdG8gbWFuaXB1bGF0ZSB0aGUgd2VpZ2h0cyBvZiB0aGUgYmxpbmsgbGF5ZXJzLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbYmxpbmtPcHRpb25zLmVhc2luZ0ZuPVF1YWRyYXRpYy5Jbk91dF0gLSBEZWZhdWx0IGVhc2luZyBmdW5jdGlvblxyXG4gICAqIHRvIHVzZSB3aGVuIG1hbmlwdWxhdGluZyBibGluayBsYXllciB3ZWlnaHRzLlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPE9iamVjdD59IFtibGlua09wdGlvbnMubGF5ZXJzPVtdXSAtIEFuIGFycmF5IG9mIGxheWVyIG9wdGlvbnNcclxuICAgKiBvYmplY3RzIHRvIHJlZ2lzdGVyIGFzIGJsaW5rIGxheWVycy5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihcclxuICAgIGhvc3QsXHJcbiAgICB7XHJcbiAgICAgIHRhcmdldCxcclxuICAgICAgbG9va1RyYWNrZXIsXHJcbiAgICAgIHNjZW5lXHJcbiAgICB9ID0ge30sXHJcbiAgICB7XHJcbiAgICAgIGJsZW5kVGltZTogbG9va0JsZW5kVGltZSA9IDAuMSxcclxuICAgICAgZWFzaW5nRm46IGxvb2tFYXNpbmdGbiA9IFF1YWRyYXRpYy5Jbk91dCxcclxuICAgICAgbGF5ZXJzOiBsb29rTGF5ZXJzID0gW10sXHJcbiAgICB9ID0ge30sXHJcbiAgICB7XHJcbiAgICAgIGJsZW5kVGltZTogYmxpbmtCbGVuZFRpbWUgPSAwLjA3NSxcclxuICAgICAgZWFzaW5nRm46IGJsaW5rRWFzaW5nRm4gPSBRdWFkcmF0aWMuSW5PdXQsXHJcbiAgICAgIGxheWVyczogYmxpbmtMYXllcnMgPSBbXSxcclxuICAgIH0gPSB7fVxyXG4gICkge1xyXG4gICAgc3VwZXIoaG9zdCk7XHJcblxyXG4gICAgaWYgKCF0aGlzLmNvbnN0cnVjdG9yLl92YWxpZGF0ZVRyYW5zZm9ybU9iamVjdChsb29rVHJhY2tlcikpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgaW5pdGlhbGl6ZSBQb2ludE9mSW50ZXJlc3RGZWF0dXJlIG9uIGhvc3QgJHt0aGlzLl9ob3N0LmlkfS4gTG9va1RyYWNrZXIgbXVzdCBiZSBkZWZpbmVkIGFzIGEgdmFsaWQgdHJhbnNmb3JtYXRpb24gb2JqZWN0LmApO1xyXG4gICAgfVxyXG4gICAgdGhpcy5fbG9va1RyYWNrZXIgPSBsb29rVHJhY2tlcjtcclxuXHJcbiAgICB0aGlzLl9zY2VuZSA9IHNjZW5lO1xyXG4gICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0IHx8IG51bGw7XHJcbiAgICB0aGlzLl9wcmV2VGFyZ2V0UG9zID0gWzAsIDAsIDBdO1xyXG4gICAgdGhpcy5faXNUYXJnZXRNb3ZpbmcgPSBmYWxzZTtcclxuICAgIHRoaXMuX2xvb2tMYXllcnMgPSB0aGlzLl9sb29rTGF5ZXJzIHx8IHt9O1xyXG4gICAgdGhpcy5fdHJhY2tpbmdDb25maWdzID0gdGhpcy5fdHJhY2tpbmdDb25maWdzIHx8IFtdO1xyXG4gICAgdGhpcy5fYmxpbmtMYXllcnMgPSB0aGlzLl9ibGlua0xheWVycyB8fCB7fTtcclxuXHJcbiAgICAvLyBSZWdpc3RlciB0aGUgbG9vayBsYXllcnNcclxuICAgIGxvb2tMYXllcnMuZm9yRWFjaCgoe1xyXG4gICAgICBuYW1lLFxyXG4gICAgICBhbmltYXRpb24sXHJcbiAgICAgIG1heFNwZWVkLFxyXG4gICAgICByZWZlcmVuY2UsXHJcbiAgICAgIGZvcndhcmRBeGlzLFxyXG4gICAgICBoYXNTYWNjYWRlLFxyXG4gICAgICBibGVuZFRpbWUsXHJcbiAgICAgIGVhc2luZ0ZuXHJcbiAgICB9KSA9PiB7XHJcbiAgICAgIHRoaXMucmVnaXN0ZXJMb29rTGF5ZXIobmFtZSwge1xyXG4gICAgICAgIGFuaW1hdGlvbixcclxuICAgICAgICBtYXhTcGVlZCxcclxuICAgICAgICByZWZlcmVuY2UsXHJcbiAgICAgICAgZm9yd2FyZEF4aXMsXHJcbiAgICAgICAgaGFzU2FjY2FkZSxcclxuICAgICAgICBibGVuZFRpbWU6IGJsZW5kVGltZSAhPT0gdW5kZWZpbmVkID8gYmxlbmRUaW1lIDogbG9va0JsZW5kVGltZSxcclxuICAgICAgICBlYXNpbmdGbjogZWFzaW5nRm4gIT09IHVuZGVmaW5lZCA/IGVhc2luZ0ZuIDogbG9va0Vhc2luZ0ZuLFxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFJlZ2lzdGVyIHRoZSBibGluayBsYXllcnNcclxuICAgIGJsaW5rTGF5ZXJzLmZvckVhY2goKHsgbmFtZSwgYW5pbWF0aW9uLCBibGVuZFRpbWUsIGVhc2luZ0ZuIH0pID0+IHtcclxuICAgICAgdGhpcy5yZWdpc3RlckJsaW5rTGF5ZXIobmFtZSwge1xyXG4gICAgICAgIGFuaW1hdGlvbixcclxuICAgICAgICBibGVuZFRpbWU6IGJsZW5kVGltZSAhPT0gdW5kZWZpbmVkID8gYmxlbmRUaW1lIDogYmxpbmtCbGVuZFRpbWUsXHJcbiAgICAgICAgZWFzaW5nRm46IGVhc2luZ0ZuICE9PSB1bmRlZmluZWQgPyBlYXNpbmdGbiA6IGJsaW5rRWFzaW5nRm4sXHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIGFuZCBzZXRzIHRoZSB0YXJnZXQgb2JqZWN0IHRoZSBob3N0IHNob3VsZCBsb29rIGF0LlxyXG4gICAqXHJcbiAgICogQHR5cGUge09iamVjdHxudWxsfVxyXG4gICAqL1xyXG4gIGdldCB0YXJnZXQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fdGFyZ2V0O1xyXG4gIH1cclxuXHJcbiAgc2V0IHRhcmdldCh0YXJnZXQpIHtcclxuICAgIHRoaXMuX3RhcmdldCA9IHRhcmdldCB8fCBudWxsO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIGEgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgZ2xvYmFsIHBvc2l0aW9uIG9mIGFuIG9iamVjdC4gU2hvdWxkIGJlXHJcbiAgICogb3ZlcmxvYWRlZCBmb3IgZWFjaCByZW5kZXJpbmcgZW5naW5lIGltcGxlbWVudGF0aW9uLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7YW55fSBfb2JqIC0gRW5naW5lLXNwZWNpZmljIDNEIHRyYW5zZm9ybSBvYmplY3QuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59IC0gQW4gYXJyYXkgY29uc2lzdGluZyBvZiB0aHJlZSBudW1iZXJzIHJlcHJlc2VudGluZ1xyXG4gICAqIHgsIHkgYW5kIHogY29vcmRpbmF0ZXMuXHJcbiAgICovXHJcbiAgc3RhdGljIF9nZXRXb3JsZFBvc2l0aW9uKG9iaikge1xyXG4gICAgcmV0dXJuIFswLCAwLCAwXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiBhIG1hdHJpeCByZXByZXNlbnRpbmcgdGhlIGdsb2JhbCB0cmFuc2Zvcm1hdGlvbiBtYXRyaXggb2YgYW4gb2JqZWN0LlxyXG4gICAqIFNob3VsZCBiZSBvdmVybG9hZGVkIGZvciBlYWNoIHJlbmRlcmluZyBlbmdpbmUgaW1wbGVtZW50YXRpb24uXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHthbnl9IG9iaiAtIEVuZ2luZS1zcGVjaWZpYyAzRCB0cmFuc2Zvcm0gb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0FycmF5LjxudW1iZXI+fSAtIEFuIGFycmF5IGNvbnNpc3Rpbmcgb2YgMTYgbnVtYmVycyByZXByZXNlbnRpbmdcclxuICAgKiB0aGUgM2QgdHJhbnNmb3JtYXRpb24uXHJcbiAgICovXHJcbiAgc3RhdGljIF9nZXRXb3JsZE1hdHJpeChvYmopIHtcclxuICAgIHJldHVybiBbMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMSwgMCwgMCwgMCwgMCwgMV07XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSb3RhdGUgdGhlIGdpdmVuIGxvY2FsIGRpcmVjdGlvbiB2ZWN0b3IgYnkgdGhlIG9iamVjdCdzIHdvcmxkIHJvdGF0aW9uIG1hdHJpeC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2FueX0gb2JqIC0gRW5naW5lLXNwZWNpZmljIDNEIHRyYW5zZm9ybSBvYmplY3QuXHJcbiAgICogQHBhcmFtIHtBcnJheS48bnVtYmVyPn0gZm9yd2FyZFZlY3RvciAtIFVuaXQgdmVjdG9yIHJlcHJlc2VudGluZyB0aGUgbG9jYWxcclxuICAgKiBmb3J3YXJkIGRpcmVjdGlvbiBvZiB0aGUgb2JqZWN0LlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0FycmF5LjxudW1iZXI+fVxyXG4gICAqL1xyXG4gIHN0YXRpYyBfZ2V0T2JqZWN0RGlyZWN0aW9uKG9iaiwgZm9yd2FyZFZlY3RvciA9IEF4aXNNYXAuUG9zaXRpdmVaKSB7XHJcbiAgICBjb25zdCByb3RhdGlvbiA9IE1hdGhVdGlscy5nZXRSb3RhdGlvbk1hdHJpeCh0aGlzLl9nZXRXb3JsZE1hdHJpeChvYmopKTtcclxuXHJcbiAgICByZXR1cm4gTWF0aFV0aWxzLnJvdGF0ZVZlY3Rvcihmb3J3YXJkVmVjdG9yLCByb3RhdGlvbik7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDYWxjdWxhdGUgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgbG9vayBhbmdsZXMgaW4gZGVncmVlcyBnaXZlbiBzcGhlcmljYWwgdGhldGFcclxuICAgKiBhbmQgcGhpIGFuZ2xlcyBpbiByYWRpYW5zLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRoZXRhIC0gVmVydGljYWwvcG9sYXIgYW5nbGUgaW4gcmFkaWFucyB3aGVyZSAwIHBvaW50cyBkaXJlY3RseVxyXG4gICAqIGFsb25nIHBvc2l0aXZlIFkgYXhpcy5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gcGhpIC0gSG9yaXpvbnRhbC9hemltdXRoYWwgYW5nbGUgaW4gcmFkaWFucy5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IC0gQW4gb2JqZWN0IHdpdGggdGhlIHNpZ25hdHVyZSB7aDogbnVtYmVyLCB2OiBudW1iZXJ9IHdoZXJlXHJcbiAgICogaCByZXByZXNlbnRzIGhvcml6b250YWwgcm90YXRpb24gaW4gZGVncmVlcyBhbmQgdiByZXByZXNlbnRzIHZlcnRpY2FsIHJvdGF0aW9uXHJcbiAgICogaW4gZGVncmVlcy5cclxuICAgKi9cclxuICBzdGF0aWMgX3NwaGVyaWNhbFRvQmxlbmRWYWx1ZSh0aGV0YSwgcGhpKSB7XHJcbiAgICBjb25zdCBoID0gTWF0aFV0aWxzLnRvRGVncmVlcyhwaGkpO1xyXG5cclxuICAgIC8vIE9mZnNldCB0aGUgdmVydGljYWwgYW5nbGUgc28gMCBpcyBwb2ludGluZyBmb3J3YXJkIGluc3RlYWQgb2YgdXBcclxuICAgIGNvbnN0IHYgPSBNYXRoVXRpbHMudG9EZWdyZWVzKHRoZXRhKSAtIDkwO1xyXG5cclxuICAgIC8vIENvbnZlcnQgdmVydGljYWwgYW5nbGUgdG8gLTE4MCwgMTgwIHJhbmdlXHJcbiAgICByZXR1cm4geyBoLCB2IH1cclxuICB9XHJcblxyXG4gIF9vbkxheWVyQWRkZWQoeyBuYW1lIH0pIHtcclxuICAgIHRoaXMuX2xvb2tMYXllcnMgPSB0aGlzLl9sb29rTGF5ZXJzIHx8IHt9O1xyXG4gICAgdGhpcy5fYmxpbmtMYXllcnMgPSB0aGlzLl9ibGlua0xheWVycyB8fCB7fTtcclxuXHJcbiAgICBzdXBlci5fb25MYXllckFkZGVkKHsgbmFtZSB9KTtcclxuXHJcbiAgICAvLyBWYWxpZGF0ZSB0aGUgbG9vayBhbmltYXRpb25cclxuICAgIGlmICh0aGlzLl9sb29rTGF5ZXJzW25hbWVdICE9PSB1bmRlZmluZWQpIHtcclxuICAgICAgdGhpcy5fcmVnaXN0ZXJMb29rQW5pbWF0aW9uKG5hbWUsIHRoaXMuX2xvb2tMYXllcnNbbmFtZV0pO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgX29uQW5pbWF0aW9uQWRkZWQoeyBsYXllck5hbWUsIGFuaW1hdGlvbk5hbWUgfSkge1xyXG4gICAgdGhpcy5fbG9va0xheWVycyA9IHRoaXMuX2xvb2tMYXllcnMgfHwge307XHJcbiAgICB0aGlzLl9ibGlua0xheWVycyA9IHRoaXMuX2JsaW5rTGF5ZXJzIHx8IHt9O1xyXG5cclxuICAgIHN1cGVyLl9vbkFuaW1hdGlvbkFkZGVkKHsgbGF5ZXJOYW1lIH0pO1xyXG5cclxuICAgIC8vIFZhbGlkYXRlIHRoZSBsb29rIGFuaW1hdGlvblxyXG4gICAgaWYgKHRoaXMuX2xvb2tMYXllcnNbbGF5ZXJOYW1lXSA9PT0gYW5pbWF0aW9uTmFtZSkge1xyXG4gICAgICB0aGlzLl9yZWdpc3Rlckxvb2tBbmltYXRpb24obGF5ZXJOYW1lLCBhbmltYXRpb25OYW1lKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEVuc3VyZSB0aGF0IHJlZ2lzdGVyZWQgbG9vayBhbmltYXRpb25zIGFyZSBCbGVuZDJkU3RhdGVzLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllck5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0aGF0IGNvbnRhaW5zIHRoZSBsb29rIGFuaW1hdGlvbi5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gYW5pbWF0aW9uTmFtZSAtIE5hbWUgb2YgdGhlIGFuaW1hdGlvbi5cclxuICAgKi9cclxuICBfcmVnaXN0ZXJMb29rQW5pbWF0aW9uKGxheWVyTmFtZSwgYW5pbWF0aW9uTmFtZSkge1xyXG4gICAgaWYgKHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXS5hbmltYXRpb25zW2FuaW1hdGlvbk5hbWVdLmlzQWN0aXZlKSB7XHJcbiAgICAgIGlmIChcclxuICAgICAgICBBbmltYXRpb25UeXBlc1t0aGlzLl9ob3N0LkFuaW1hdGlvbkZlYXR1cmUuZ2V0QW5pbWF0aW9uVHlwZShcclxuICAgICAgICAgIGxheWVyTmFtZSxcclxuICAgICAgICAgIGFuaW1hdGlvbk5hbWVcclxuICAgICAgICApXSAhPT0gQW5pbWF0aW9uVHlwZXMuYmxlbmQyZFxyXG4gICAgICApIHtcclxuICAgICAgICAvLyBXYXJuIGFuZCBkZWFjdGl2YXRlIGlmIHRoZSByZWdpc3RlcmVkIHN0YXRlIGlzIG5vdCBibGVuZDJkXHJcbiAgICAgICAgY29uc29sZS53YXJuKFxyXG4gICAgICAgICAgYENhbm5vdCByZWdpc3RlciBQb2ludCBvZiBJbnRlcmVzdCBsb29rIGFuaW1hdGlvbiAke2FuaW1hdGlvbk5hbWV9IG9uIGxheWVyICR7bGF5ZXJOYW1lfSBmb3IgaG9zdCAke3RoaXMuX2hvc3QuaWR9LiBMb29rIGFuaW1hdGlvbnMgbXVzdCBiZSBvZiB0eXBlICdibGVuZDJkJy5gXHJcbiAgICAgICAgKTtcclxuICAgICAgICB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV0uYW5pbWF0aW9uc1tcclxuICAgICAgICAgIGFuaW1hdGlvbk5hbWVcclxuICAgICAgICBdLmlzQWN0aXZlID0gZmFsc2U7XHJcbiAgICAgIH1cclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrIGlmIHRoZSBnaXZlbiBvYmplY3QgaXMgbm90IG9mIGFuIGVuZ2luZS1zcGVjaWZpYyB0eXBlLiBTaG91bGRcclxuICAgKiBiZSBvdmVybG9hZGVkIGZvciBlYWNoIHJlbmRlcmluZyBlbmdpbmUgaW1wbGVtZW50YXRpb24uXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHthbnl9IG9iaiAtIE9iamVjdCB0byB2YWxpZGF0ZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqL1xyXG4gIHN0YXRpYyBfdmFsaWRhdGVUcmFuc2Zvcm1PYmplY3Qob2JqKSB7XHJcbiAgICByZXR1cm4gb2JqIGluc3RhbmNlb2YgT2JqZWN0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2sgaWYgdGhlIGdpdmVuIGNvbmZpZ3VyYXRpb24gb2JqZWN0IGhhcyBhbHJlYWR5IGJlZW4gc3RvcmVkIGFzIGEgdHJhY2tpbmdcclxuICAgKiBjb25maWcuIElmIGl0IGhhcywgcmV0dXJuIHRoZSBzdG9yZWQgY29uZmlndXJhdGlvbi4gT3RoZXJ3aXNlLCBzdG9yZSBhbmRcclxuICAgKiByZXR1cm4gaXQuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyAtIE9iamVjdCBjb250YWluaW5nIHRyYWNrZXIsIHJlZmVyZW5jZSBhbmQgZm9yd2FyZEF4aXNcclxuICAgKiBwcm9wZXJ0aWVzLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge09iamVjdH1cclxuICAgKi9cclxuICBfYWRkVHJhY2tpbmdDb25maWcoY29uZmlnKSB7XHJcbiAgICBjb25zdCB0cmFja2luZ0NvbmZpZyA9IHRoaXMuX3RyYWNraW5nQ29uZmlncy5maW5kKGMgPT5cclxuICAgICAgYy5yZWZlcmVuY2UgPT09IGNvbmZpZy5yZWZlcmVuY2UgJiYgYy5mb3J3YXJkQXhpcyA9PT0gY29uZmlnLmZvcndhcmRBeGlzXHJcbiAgICApO1xyXG5cclxuICAgIGlmICh0cmFja2luZ0NvbmZpZykge1xyXG4gICAgICByZXR1cm4gdHJhY2tpbmdDb25maWc7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25maWcuYW5nbGVzID0geyBoOiAwLCB2OiAwIH07XHJcbiAgICAgIGNvbmZpZy5wcmV2QW5nbGVzID0geyBoOiAwLCB2OiAwIH07XHJcbiAgICAgIHRoaXMuX3RyYWNraW5nQ29uZmlncy5wdXNoKGNvbmZpZyk7XHJcbiAgICAgIHJldHVybiBjb25maWc7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gdGhlIGRpc3RhbmNlIGJldHdlZW4gdGhlIGxvb2sgdHJhY2tlciBhbmQgdGhlIGxvb2sgdGFyZ2V0LlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgX2dldFRhcmdldERpc3RhbmNlKCkge1xyXG4gICAgLy8gRmluZCB0aGUgdmVjdG9yIGJldHdlZW4gdGhlIGdsb2JhbCBwb3NpdGlvbnMgb2YgdHJhY2tlciBhbmQgdGFyZ2V0XHJcbiAgICBjb25zdCBzb3VyY2VQb3NpdGlvbiA9IHRoaXMuY29uc3RydWN0b3IuX2dldFdvcmxkUG9zaXRpb24odGhpcy5fbG9va1RyYWNrZXIpO1xyXG4gICAgY29uc3QgdGFyZ2V0UG9zaXRpb24gPSB0aGlzLmNvbnN0cnVjdG9yLl9nZXRXb3JsZFBvc2l0aW9uKHRoaXMuX3RhcmdldCk7XHJcbiAgICBjb25zdCBsb29rVmVjdG9yID0gW1xyXG4gICAgICB0YXJnZXRQb3NpdGlvblswXSAtIHNvdXJjZVBvc2l0aW9uWzBdLFxyXG4gICAgICB0YXJnZXRQb3NpdGlvblsxXSAtIHNvdXJjZVBvc2l0aW9uWzFdLFxyXG4gICAgICB0YXJnZXRQb3NpdGlvblsyXSAtIHNvdXJjZVBvc2l0aW9uWzJdXHJcbiAgICBdO1xyXG5cclxuICAgIHJldHVybiBNYXRoVXRpbHMuZ2V0VmVjdG9yTWFnbml0dWRlKGxvb2tWZWN0b3IpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzZXQgYWxsIHN0b3JlZCB0cmFja2luZyBhbmdsZXMgdG8gMC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX3Jlc2V0TG9va0FuZ2xlcygpIHtcclxuICAgIHRoaXMuX3RyYWNraW5nQ29uZmlncy5mb3JFYWNoKCh7IGFuZ2xlcyB9KSA9PiB7XHJcbiAgICAgIGFuZ2xlcy5oID0gMDtcclxuICAgICAgYW5nbGVzLnYgPSAwO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdG9yZSB0aGUgZGlmZmVyZW5jZSBpbiBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCByb3RhdGlvbiBmb3IgdGhlIHRyYWNrZXInc1xyXG4gICAqIHJlZmVyZW5jZSByb3RhdGlvbiBhbmQgdGhlIGRpcmVjdGlvbiBvZiB0aGUgdGFyZ2V0IGZyb20gdGhlIHRyYWNrZXIuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9zZXRMb29rQW5nbGVzKCkge1xyXG4gICAgLy8gR2V0IHRoZSBjdXJyZW50IHBvc2l0aW9ucyBvZiB0aGUgdHJhY2tlciBhbmQgdGFyZ2V0IG9iamVjdHNcclxuICAgIGNvbnN0IHRhcmdldFBvcyA9IHRoaXMuY29uc3RydWN0b3IuX2dldFdvcmxkUG9zaXRpb24odGhpcy5fdGFyZ2V0KTtcclxuICAgIGNvbnN0IHRyYWNrZXJQb3MgPSB0aGlzLmNvbnN0cnVjdG9yLl9nZXRXb3JsZFBvc2l0aW9uKHRoaXMuX2xvb2tUcmFja2VyKTtcclxuXHJcbiAgICAvLyBDaGVjayBpZiB0aGUgdGFyZ2V0IGhhcyBtb3ZlZFxyXG4gICAgdGhpcy5faXNUYXJnZXRNb3ZpbmcgPSBNYXRoVXRpbHMuZ2V0VmVjdG9yTWFnbml0dWRlKFtcclxuICAgICAgdGFyZ2V0UG9zWzBdIC0gdGhpcy5fcHJldlRhcmdldFBvc1swXSxcclxuICAgICAgdGFyZ2V0UG9zWzFdIC0gdGhpcy5fcHJldlRhcmdldFBvc1sxXSxcclxuICAgICAgdGFyZ2V0UG9zWzJdIC0gdGhpcy5fcHJldlRhcmdldFBvc1syXV1cclxuICAgICkgPiAwO1xyXG4gICAgT2JqZWN0LmFzc2lnbih0aGlzLl9wcmV2VGFyZ2V0UG9zLCB0YXJnZXRQb3MpO1xyXG5cclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgdGhlIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIGFuZ2xlcyB0byByb3RhdGUgdG8gdGhlIHRhcmdldFxyXG4gICAgY29uc3QgdGFyZ2V0U3BoZXJpY2FsID0gTWF0aFV0aWxzLmNhcnRlc2lhblRvU3BoZXJpY2FsKFxyXG4gICAgICB0YXJnZXRQb3NbMF0gLSB0cmFja2VyUG9zWzBdLFxyXG4gICAgICB0YXJnZXRQb3NbMV0gLSB0cmFja2VyUG9zWzFdLFxyXG4gICAgICB0YXJnZXRQb3NbMl0gLSB0cmFja2VyUG9zWzJdXHJcbiAgICApO1xyXG4gICAgY29uc3QgdGFyZ2V0QW5nbGVzID0gdGhpcy5jb25zdHJ1Y3Rvci5fc3BoZXJpY2FsVG9CbGVuZFZhbHVlKFxyXG4gICAgICB0YXJnZXRTcGhlcmljYWxbMV0sXHJcbiAgICAgIHRhcmdldFNwaGVyaWNhbFsyXVxyXG4gICAgKTtcclxuXHJcbiAgICAvLyBDYWxjdWxhdGUgYW5nbGVzIHJlbGF0aXZlIHRvIHRoZSByZWZlcmVuY2Ugb2JqZWN0c1xyXG4gICAgdGhpcy5fdHJhY2tpbmdDb25maWdzLmZvckVhY2goKHtcclxuICAgICAgcmVmZXJlbmNlLFxyXG4gICAgICBmb3J3YXJkQXhpcyxcclxuICAgICAgYW5nbGVzXHJcbiAgICB9KSA9PiB7XHJcbiAgICAgIC8vIENhbGN1bGF0ZSB0aGUgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgYW5nbGVzIHRvIHJvdGF0ZSB0byB0aGUgZGlyZWN0aW9uIG9mIHRoZSB0cmFja2VyXHJcbiAgICAgIGNvbnN0IHJlZkRpcmVjdGlvbiA9IHRoaXMuY29uc3RydWN0b3IuX2dldE9iamVjdERpcmVjdGlvbihcclxuICAgICAgICByZWZlcmVuY2UsXHJcbiAgICAgICAgZm9yd2FyZEF4aXMsXHJcbiAgICAgICk7XHJcbiAgICAgIGNvbnN0IHJlZlNwaGVyaWNhbCA9IE1hdGhVdGlscy5jYXJ0ZXNpYW5Ub1NwaGVyaWNhbCguLi5yZWZEaXJlY3Rpb24pO1xyXG4gICAgICBjb25zdCByZWZBbmdsZXMgPSB0aGlzLmNvbnN0cnVjdG9yLl9zcGhlcmljYWxUb0JsZW5kVmFsdWUoXHJcbiAgICAgICAgcmVmU3BoZXJpY2FsWzFdLFxyXG4gICAgICAgIHJlZlNwaGVyaWNhbFsyXVxyXG4gICAgICApO1xyXG5cclxuICAgICAgLy8gU3RvcmUgdGhlIGRpZmZlcmVuY2VcclxuICAgICAgYW5nbGVzLmggPSB0YXJnZXRBbmdsZXMuaCAtIHJlZkFuZ2xlcy5oO1xyXG4gICAgICBhbmdsZXMudiA9IHRhcmdldEFuZ2xlcy52IC0gcmVmQW5nbGVzLnY7XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJldHVybiB0aGUgaG9yaXpvbnRhbCBhbmQgdmVydGljYWwgYW5nbGVzIGl0IHdvdWxkIHJlcXVpcmUgdG8gc2ltdWxhdGUgbG9va2luZ1xyXG4gICAqIGF0IHRoZSBnaXZlbiB0eXBlIG9mIGZhY2UgdGFyZ2V0XHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHRhcmdldFR5cGUgLSBJbnRlZ2VyIHJlcHJlc2VudGluZyB0aGUgRmFjZVRhcmdldFR5cGUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7T2JqZWN0fS0gQW4gb2JqZWN0IHdpdGggc2lnbmF0dXJlIHtyOiBudW1iZXIsIGg6IG51bWJlciwgdjogbnVtYmVyfVxyXG4gICAqIHdoZXJlICdyJyByZXByZXNlbnRzIHJhZGl1cywgaCByZXByZXNlbnRzIHRoZSBob3Jpem9udGFsL2F6aW11dGhhbCBhbmdsZSBhbmRcclxuICAgKiB2IHJlcHJlc2VudHMgdGhlIHZlcnRpY2FsL3BvbGFyIGFuZ2xlLlxyXG4gICAqL1xyXG4gIF9nZXRGYWNlVGFyZ2V0QW5nbGVzKHRhcmdldFR5cGUpIHtcclxuICAgIC8vIE5vIG9mZnNldCB3aGVuIHRoZSB0YXJnZXQgaXMgdGhlIGNlbnRlciBvZiB0aGUgZXllc1xyXG4gICAgaWYgKHRhcmdldFR5cGUgPT09IDApIHtcclxuICAgICAgcmV0dXJuIHsgaDogMCwgdjogMCB9O1xyXG4gICAgfVxyXG5cclxuICAgIC8vIEJ1aWxkIGEgdmVjdG9yIHRvIHRoZSBmYWNlIHRhcmdldCB0eXBlIHVzaW5nIHRoZSBjdXJyZW50IGRpc3RhbmNlIHRvIHRoZSB0YXJnZXRcclxuICAgIGNvbnN0IGRpc3RhbmNlID0gdGhpcy5fZ2V0VGFyZ2V0RGlzdGFuY2UodGhpcy5fbG9va1RyYWNrZXIpO1xyXG4gICAgY29uc3QgZmFjZVZlY3RvciA9IFsuLi5GYWNlVmVjdG9yc1t0YXJnZXRUeXBlXV07XHJcbiAgICBmYWNlVmVjdG9yWzJdID0gZGlzdGFuY2U7XHJcbiAgICBjb25zdCBzcGhlcmljYWwgPSBNYXRoVXRpbHMuY2FydGVzaWFuVG9TcGhlcmljYWwoLi4uZmFjZVZlY3Rvcik7XHJcblxyXG4gICAgLy8gTWFrZSBzdXJlIHZhbHVlcyBhcmUgY2xhbXBlZCB3aXRoaW4gdGhlIHJhbmdlIG9mIG1vdGlvbiBvZiB0aGUgaHVtYW4gZXllLCBpbiBjYXNlIHRoZSB0YXJnZXQgaXMgdmVyeSBjbG9zZVxyXG4gICAgY29uc3QgYmxlbmRWYWx1ZXMgPSB0aGlzLmNvbnN0cnVjdG9yLl9zcGhlcmljYWxUb0JsZW5kVmFsdWUoc3BoZXJpY2FsWzFdLCBzcGhlcmljYWxbMl0pO1xyXG4gICAgYmxlbmRWYWx1ZXMuaCA9IE1hdGhVdGlscy5jbGFtcChibGVuZFZhbHVlcy5oLCAtMzUsIDM1KTtcclxuICAgIGJsZW5kVmFsdWVzLnYgPSBNYXRoVXRpbHMuY2xhbXAoYmxlbmRWYWx1ZXMudiwgLTI1LCAzMCk7XHJcblxyXG4gICAgcmV0dXJuIGJsZW5kVmFsdWVzO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlZCB0aGUgc3RvcmVkIHNwZWVkIGFuZCBkdXJhdGlvbiB2YXJpYWJsZXMgZm9yIGEgbGF5ZXIgYmFzZWQgb24gdGhlXHJcbiAgICogY2hhbmdlIGluIGhvcml6b250YWwgYW5kIHZlcnRpY2FsIGFuZ2xlcyBvZiB0aGUgdHJhY2tlci5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdG8gc3RvcmUgdmFsdWVzIG9uLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBoIC0gQ2hhbmdlIGluIGhvcml6b250YWwgYW5nbGUsIGluIGRlZ3JlZXMuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IHYgLSBDaGFuZ2UgaW4gdmVydGljYWwgYW5nbGUsIGluIGRlZ3JlZXMuXHJcbiAgICovXHJcbiAgX3VwZGF0ZUxheWVyU3BlZWQobGF5ZXJOYW1lLCBoLCB2KSB7XHJcbiAgICBjb25zdCBsYXllciA9IHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXTtcclxuXHJcbiAgICAvLyBGcm9tIFwiUmVhbGlzdGljIEF2YXRhciBhbmQgaGVhZCBBbmltYXRpb24gVXNpbmcgYSBOZXVyb2Jpb2xvZ2ljYWwgTW9kZWwgb2YgVmlzdWFsIEF0dGVudGlvblwiLCBJdHRpLCBEaGF2YWxlLCBQaWdoaW5cclxuICAgIGxheWVyLm1heEhTcGVlZCA9IDQ3MyAqICgxIC0gTWF0aC5leHAoLWggLyA3LjgpKTtcclxuICAgIGxheWVyLm1heFZTcGVlZCA9IDQ3MyAqICgxIC0gTWF0aC5leHAoLXYgLyA3LjgpKTtcclxuXHJcbiAgICAvLyBGcm9tIFwiRXllcyBBbGl2ZVwiLCBMZWUsIEJhZGxlclxyXG4gICAgY29uc3QgRDAgPSAwLjAyNTtcclxuICAgIGNvbnN0IGQgPSAwLjAwMjM1O1xyXG4gICAgbGF5ZXIuaER1cmF0aW9uID0gRDAgKyBkICogaDtcclxuICAgIGxheWVyLnZEdXJhdGlvbiA9IEQwICsgZCAqIHY7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgdGhlIG1pY3JvU2FjY2FkZSBvYmplY3Qgd2l0aCBuZXcgcmFuZG9taXplZCB2YWx1ZXMuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRoYXQgb3ducyB0aGUgc2FjY2FkZSBtb3Rpb24uXHJcbiAgICovXHJcbiAgX3NldE1pY3JvU2FjY2FkZShsYXllck5hbWUpIHtcclxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdO1xyXG4gICAgY29uc3QgeyBtaWNyb1NhY2NhZGUgfSA9IGxheWVyO1xyXG5cclxuICAgIGlmICh0aGlzLl90YXJnZXQpIHtcclxuICAgICAgLy8gTWljcm8gbW92ZW1lbnRzIHNob3VsZCBiZSBzbWFsbGVyIHdoZW4gZm9jdXNlZCBvbiBhIHRhcmdldFxyXG4gICAgICBtaWNyb1NhY2NhZGUuaCA9IFV0aWxzLmdldFJhbmRvbUZsb2F0KC4wMSwgLjE1KTtcclxuICAgICAgbWljcm9TYWNjYWRlLnYgPSBVdGlscy5nZXRSYW5kb21GbG9hdCguMDEsIC4xNSk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICAvLyBNaWNyb3NhY2NhZGVzLiBFbmN5Y2xvcGVkaWEgb2YgTmV1cm9zY2llbmNlLiAoMjAwOSkgU3ByaW5nZXIsIEJlcmxpbiwgSGVpZGVsYmVyZy4gaHR0cHM6Ly9kb2kub3JnLzEwLjEwMDcvOTc4LTMtNTQwLTI5Njc4LTJfMzQ5MlxyXG4gICAgICBtaWNyb1NhY2NhZGUuaCA9IFV0aWxzLmdldFJhbmRvbUZsb2F0KC4wMSwgLjMpO1xyXG4gICAgICBtaWNyb1NhY2NhZGUudiA9IFV0aWxzLmdldFJhbmRvbUZsb2F0KC4wMSwgLjMpO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX3VwZGF0ZUxheWVyU3BlZWQobGF5ZXJOYW1lLCBtaWNyb1NhY2NhZGUuaCwgbWljcm9TYWNjYWRlLnYpO1xyXG5cclxuICAgIC8vIFJlc3RhcnQgdGhlIHRpbWVyXHJcbiAgICB0aGlzLl9pbml0aWFsaXplTWljcm9UaW1lcihsYXllck5hbWUsIC4uLk1pY3JvU2FjY2FkZVdhaXRSYW5nZXMuZGVmYXVsdCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTZXQgdGhlIG1hY3JvU2FjY2FkZSBvYmplY3Qgd2l0aCBuZXcgcmFuZG9taXplZCB2YWx1ZXMuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRoYXQgb3ducyB0aGUgc2FjY2FkZSBtb3Rpb24uXHJcbiAgICovXHJcbiAgX3NldE1hY3JvU2FjY2FkZShsYXllck5hbWUpIHtcclxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdO1xyXG4gICAgY29uc3QgeyBtYWNyb1NhY2NhZGUgfSA9IGxheWVyO1xyXG4gICAgbGV0IG1hY3JvU2FjY2FkZVdhaXRSYW5nZTtcclxuXHJcbiAgICAvLyBJbmNyZWFzZSByYW5kb20gdmFsdWUgcmFuZ2Ugd2hlbiBub3QgZm9jdXNlZCBvbiBhIHRhcmdldFxyXG4gICAgaWYgKCF0aGlzLl90YXJnZXQpIHtcclxuICAgICAgbWFjcm9TYWNjYWRlV2FpdFJhbmdlID0gTWFjcm9TYWNjYWRlV2FpdFJhbmdlcy5kZWZhdWx0O1xyXG5cclxuICAgICAgLy8gTm9ybWFsIGh1bWFuIGhvcml6b250YWwgZXllIHJvdGF0aW9uIGxpbWl0IGlzIGFib3V0IDM1IGRlZ3JlZXNcclxuICAgICAgY29uc3QgaExpbWl0ID0gVXRpbHMuZ2V0UmFuZG9tRmxvYXQoLjE0MywgLjI4Nik7XHJcbiAgICAgIGNvbnN0IGhGYWN0b3IgPSBVdGlscy5nZXRSYW5kb21GbG9hdCgtaExpbWl0LCBoTGltaXQpO1xyXG4gICAgICBtYWNyb1NhY2NhZGUuaCA9IGhGYWN0b3IgKiAzNTtcclxuXHJcbiAgICAgIC8vIE5vcm1hbCBodW1hbiB2ZXJ0aWNhbCBleWUgcm90YXRpb24gbGltaXQgaXMgYWJvdXQgMjUgZGVncmVlcyB1cHdhcmQgYW5kIDMwIGRlZ3JlZXMgZG93bndhcmRcclxuICAgICAgY29uc3QgdkxpbWl0ID0gVXRpbHMuZ2V0UmFuZG9tRmxvYXQoLjA5MywgLjE4Nik7XHJcbiAgICAgIGNvbnN0IHZGYWN0b3IgPSBVdGlscy5nZXRSYW5kb21GbG9hdCgtdkxpbWl0LCB2TGltaXQpO1xyXG4gICAgICBtYWNyb1NhY2NhZGUudiA9IHZGYWN0b3IgPiAwID8gdkZhY3RvciAqIDI1IDogdkZhY3RvciAqIDMwO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFBpY2sgYSBuZXcgZmFjZSB0YXJnZXRcclxuICAgIGVsc2Uge1xyXG4gICAgICAvLyBTb2NpYWwgdHJpYW5nbGUgLSBzYWNjYWRlIGJldHdlZW4gZXllcyBhbmQgbW91dGgsIHdlaWdodGVkIHRvIGxvb2sgYXQgZXllcyBtb3JlIG9mdGVuXHJcbiAgICAgIHN3aXRjaCAobGF5ZXIuc2FjY2FkZVRhcmdldCkge1xyXG4gICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgIG1hY3JvU2FjY2FkZVdhaXRSYW5nZSA9IE1hY3JvU2FjY2FkZVdhaXRSYW5nZXMuZXllVGFyZ2V0O1xyXG4gICAgICAgICAgbGF5ZXIuc2FjY2FkZVRhcmdldCA9IE1hdGgucmFuZG9tKCkgPCAwLjc1ID8gRmFjZVRhcmdldFR5cGVzLkV5ZVJpZ2h0XHJcbiAgICAgICAgICAgIDogRmFjZVRhcmdldFR5cGVzLk1vdXRoO1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgbWFjcm9TYWNjYWRlV2FpdFJhbmdlID0gTWFjcm9TYWNjYWRlV2FpdFJhbmdlcy5leWVUYXJnZXQ7XHJcbiAgICAgICAgICBsYXllci5zYWNjYWRlVGFyZ2V0ID0gTWF0aC5yYW5kb20oKSA8IDAuNzUgPyBGYWNlVGFyZ2V0VHlwZXMuRXllTGVmdFxyXG4gICAgICAgICAgICA6IEZhY2VUYXJnZXRUeXBlcy5Nb3V0aDtcclxuICAgICAgICAgIGJyZWFrO1xyXG4gICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgIG1hY3JvU2FjY2FkZVdhaXRSYW5nZSA9IE1hY3JvU2FjY2FkZVdhaXRSYW5nZXMubW91dGhUYXJnZXQ7XHJcbiAgICAgICAgICBsYXllci5zYWNjYWRlVGFyZ2V0ID0gTWF0aC5yYW5kb20oKSA8IDAuNSA/IEZhY2VUYXJnZXRUeXBlcy5FeWVMZWZ0XHJcbiAgICAgICAgICAgIDogRmFjZVRhcmdldFR5cGVzLkV5ZVJpZ2h0O1xyXG4gICAgICAgICAgYnJlYWs7XHJcbiAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICBtYWNyb1NhY2NhZGVXYWl0UmFuZ2UgPSBNYWNyb1NhY2NhZGVXYWl0UmFuZ2VzLmV5ZVRhcmdldDtcclxuICAgICAgICAgIGxheWVyLnNhY2NhZGVUYXJnZXQgPSBNYXRoLnJhbmRvbSgpIDwgMC41ID8gRmFjZVRhcmdldFR5cGVzLkV5ZUxlZnRcclxuICAgICAgICAgICAgOiBGYWNlVGFyZ2V0VHlwZXMuRXllUmlnaHQ7XHJcbiAgICAgICAgICBicmVhaztcclxuICAgICAgfVxyXG5cclxuICAgICAgY29uc3QgeyBoLCB2IH0gPSB0aGlzLl9nZXRGYWNlVGFyZ2V0QW5nbGVzKGxheWVyLnNhY2NhZGVUYXJnZXQpO1xyXG4gICAgICBtYWNyb1NhY2NhZGUuaCA9IGg7XHJcbiAgICAgIG1hY3JvU2FjY2FkZS52ID0gdjtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl91cGRhdGVMYXllclNwZWVkKGxheWVyTmFtZSwgbWFjcm9TYWNjYWRlLmgsIG1hY3JvU2FjY2FkZS52KTtcclxuXHJcbiAgICAvLyBSZXN0YXJ0IHRoZSB0aW1lcnNcclxuICAgIHRoaXMuX2luaXRpYWxpemVNaWNyb1RpbWVyKGxheWVyTmFtZSwgLi4uTWljcm9TYWNjYWRlV2FpdFJhbmdlcy5wb3N0TWFjcm8pO1xyXG4gICAgdGhpcy5faW5pdGlhbGl6ZU1hY3JvVGltZXIobGF5ZXJOYW1lLCAuLi5tYWNyb1NhY2NhZGVXYWl0UmFuZ2UpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RhcnQgYSBuZXcgd2FpdCB0aW1lciB0aGF0IHdpbGwgc2V0IGEgbmV3IG1pY3JvIHNhY2NhZGUgbW92ZW1lbnQgd2hlbiBpdFxyXG4gICAqIHJlc29sdmVzLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllck5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0aGF0IG93bnMgdGhlIHNhY2NhZGUgbW90aW9uLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtaW5XYWl0VGltZSAtIE1pbmltdW0gbnVtYmVyIG9mIHNlY29uZHMgYmVmb3JlIGEgbmV3IHNhY2NhZGVcclxuICAgKiB3aWxsIGJlIHRyaWdnZXJlZC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gbWF4V2FpdFRpbWUgLSBNYXhpbXVtIG51bWJlciBvZiBzZWNvbmRzIGJlZm9yZSBhIG5ldyBzYWNjYWRlXHJcbiAgICogd2lsbCBiZSB0cmlnZ2VyZWQuXHJcbiAgICovXHJcbiAgX2luaXRpYWxpemVNaWNyb1RpbWVyKGxheWVyTmFtZSwgbWluV2FpdFRpbWUsIG1heFdhaXRUaW1lKSB7XHJcbiAgICBjb25zdCBsYXllciA9IHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXTtcclxuICAgIGNvbnN0IHdhaXRUaW1lID0gVXRpbHMuZ2V0UmFuZG9tRmxvYXQobWluV2FpdFRpbWUsIG1heFdhaXRUaW1lKTtcclxuXHJcbiAgICBpZiAobGF5ZXIubWljcm9TYWNjYWRlVGltZXIpIHtcclxuICAgICAgbGF5ZXIubWljcm9TYWNjYWRlVGltZXIuY2FuY2VsKCk7XHJcbiAgICB9XHJcbiAgICBsYXllci5taWNyb1NhY2NhZGVUaW1lciA9IFV0aWxzLndhaXQod2FpdFRpbWUsIHtcclxuICAgICAgb25GaW5pc2g6ICgpID0+IHsgdGhpcy5fc2V0TWljcm9TYWNjYWRlKGxheWVyTmFtZSkgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBTdGFydCBhIG5ldyB3YWl0IHRpbWVyIHRoYXQgd2lsbCBzZXQgYSBuZXcgbWFjcm8gc2FjY2FkZSBtb3ZlbWVudCB3aGVuIGl0XHJcbiAgICogcmVzb2x2ZXMuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGxheWVyTmFtZSAtIE5hbWUgb2YgdGhlIGxheWVyIHRoYXQgb3ducyB0aGUgc2FjY2FkZSBtb3Rpb24uXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IG1pbldhaXRUaW1lIC0gTWluaW11bSBudW1iZXIgb2Ygc2Vjb25kcyBiZWZvcmUgYSBuZXcgc2FjY2FkZVxyXG4gICAqIHdpbGwgYmUgdHJpZ2dlcmVkLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBtYXhXYWl0VGltZSAtIE1heGltdW0gbnVtYmVyIG9mIHNlY29uZHMgYmVmb3JlIGEgbmV3IHNhY2NhZGVcclxuICAgKiB3aWxsIGJlIHRyaWdnZXJlZC5cclxuICAgKi9cclxuICBfaW5pdGlhbGl6ZU1hY3JvVGltZXIobGF5ZXJOYW1lLCBtaW5XYWl0VGltZSwgbWF4V2FpdFRpbWUpIHtcclxuICAgIGNvbnN0IGxheWVyID0gdGhpcy5fbWFuYWdlZExheWVyc1tsYXllck5hbWVdO1xyXG4gICAgY29uc3Qgd2FpdFRpbWUgPSBVdGlscy5nZXRSYW5kb21GbG9hdChtaW5XYWl0VGltZSwgbWF4V2FpdFRpbWUpO1xyXG5cclxuICAgIGlmIChsYXllci5tYWNyb1NhY2NhZGVUaW1lcikge1xyXG4gICAgICBsYXllci5tYWNyb1NhY2NhZGVUaW1lci5jYW5jZWwoKTtcclxuICAgIH1cclxuICAgIGxheWVyLm1hY3JvU2FjY2FkZVRpbWVyID0gVXRpbHMud2FpdCh3YWl0VGltZSwge1xyXG4gICAgICBvbkZpbmlzaDogKCkgPT4geyB0aGlzLl9zZXRNYWNyb1NhY2NhZGUobGF5ZXJOYW1lKSB9XHJcbiAgICB9KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgYSBuZXcgdGFyZ2V0IHRvIGxvb2sgYXQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdHxudWxsfSB0YXJnZXQgLSBUaGUgbmV3IHRhcmdldCB0byBsb29rIGF0LlxyXG4gICAqL1xyXG4gIHNldFRhcmdldCh0YXJnZXQpIHtcclxuICAgIHRoaXMudGFyZ2V0ID0gdGFyZ2V0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogRmluZHMgYW4gb2JqZWN0IGdpdmVuIGl0cyBuYW1lIGFuZCBzZXRzIGl0IGFzIHRoZSBuZXcgdGFyZ2V0IHRvIGxvb2sgYXQuXHJcbiAgICogU2hvdWxkIGJlIG92ZXJsb2FkZWQgZm9yIGVhY2ggcmVuZGVyaW5nIGVuZ2luZSBpbXBsZW1lbnRhdGlvbi5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0YXJnZXQgLSBOYW1lIHRvIHNlYXJjaCBmb3IuXHJcbiAgICovXHJcbiAgc2V0VGFyZ2V0QnlOYW1lKG5hbWUpIHtcclxuICAgIGlmICghbmFtZSkge1xyXG4gICAgICB0aGlzLl90YXJnZXQgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICghdGhpcy5fc2NlbmUpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3Qgc2V0IFBvaW50T2ZJbnRlcmVzdEZlYXR1cmUgdGFyZ2V0IHVzaW5nIG5hbWUgJHtuYW1lfSBvbiBob3N0ICR7dGhpcy5faG9zdC5pZH0uIFNjZW5lIG11c3QgYmUgZGVmaW5lZC5gKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEZpbmRzIGFuIG9iamVjdCBnaXZlbiBpdHMgaWQgYW5kIHNldHMgaXQgYXMgdGhlIG5ldyB0YXJnZXQgdG8gbG9vayBhdC5cclxuICAgKiBTaG91bGQgYmUgb3ZlcmxvYWRlZCBmb3IgZWFjaCByZW5kZXJpbmcgZW5naW5lIGltcGxlbWVudGF0aW9uLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd8bnVtYmVyfSB0YXJnZXQgLSBJZCB0byBzZWFyY2ggZm9yLlxyXG4gICAqL1xyXG4gIHNldFRhcmdldEJ5SWQoaWQpIHtcclxuICAgIGlmICghaWQpIHtcclxuICAgICAgdGhpcy5fdGFyZ2V0ID0gbnVsbDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoIXRoaXMuX3NjZW5lKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihgQ2Fubm90IHNldCBQb2ludE9mSW50ZXJlc3RGZWF0dXJlIHRhcmdldCB1c2luZyBpZCAke2lkfSBvbiBob3N0ICR7dGhpcy5faG9zdC5pZH0uIFNjZW5lIG11c3QgYmUgZGVmaW5lZC5gKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0YXJ0IGtlZXBpbmcgdHJhY2sgb2YgYW4gYW5pbWF0aW9uIGxheWVyIHRoYXQgb3ducyBhIGJsZW5kMmQgYW5pbWF0aW9uIHdpdGhcclxuICAgKiBibGVuZFdlaWdodHMgY29ycmVzcG9uZGluZyB0byBob3Jpem9udGFsIGFuZCB2ZXJ0aWNhbCBsb29rIGFuZ2xlcy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBsYXllck5hbWUgLSBOYW1lIG9mIHRoZSBsYXllciB0byBrZWVwIHRyYWNrIG9mLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyAtIE9wdGlvbnMgZm9yIHRoZSBsYXllci5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdGlvbnMuYW5pbWF0aW9uID0gJ2xvb2snXSAtIE5hbWUgb2YgdGhlIGFuaW1hdGlvbiBvbiB0aGVcclxuICAgKiBsYXllciB3aG9zZSBibGVuZFdlaWdodHMgd2lsbCBiZSBkcml2ZW4gYmFzZWQgb24gdGhlIGFuZ2xlIGJldHdlZW4gdGhlIGxvb2tUcmFja2VyXHJcbiAgICogYW5kIHRoZSBsb29rVGFyZ2V0LiBUaGlzIGFuaW1hdGlvbiBtdXN0IGJlIG9mIHR5cGUgYmxlbmQyZC5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWF4U3BlZWQgPSAyNV0gLSBUaGUgbWF4aW11bSBzcGVlZCBhdCB3aGljaCB0aGUgYmxlbmQyZFxyXG4gICAqIGJsZW5kV2VpZ2h0cyBjYW4gYmUgbWFuaXB1bGF0ZWQuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmZvcndhcmRBeGlzID0gJ1Bvc2l0aXZlWiddIC0gQXhpcyBwb2ludGluZyBmcm9tIHRoZVxyXG4gICAqIGZyb250IG9mIHRoZSBsb29rUmVmZXJlbmNlIG9iamVjdC4gVmFsaWQgb3B0aW9ucyBhcmUgJ1Bvc2l0aXZlWCcsICdOZWdhdGl2ZVgnLFxyXG4gICAqICdQb3NpdGl2ZVknLCAnTmVnYXRpdmVZJywgJ1Bvc2l0aXZlWicsICdOZWdhdGl2ZVonLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucy5sb29rUmVmZXJlbmNlIC0gM0QgdHJhbnNmb3JtYXRpb24gbm9kZSB0aGF0IHRoZSBsb29rVHJhY2tlclxyXG4gICAqIHJvdGF0aW9uIGxpbWl0cyBzaG91bGQgYmUgY2FsY3VsYXRlZCByZWxhdGl2ZSB0by4gRGVmYXVsdHMgdG8gdGhlIGhvc3Qgb3duZXIuXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLmhhc1NhY2NhZGUgPSBmYWxzZV0gLSBXaGV0aGVyIG9yIG5vdCB0byBpbmNsdWRlXHJcbiAgICogc2FjY2FkaWMgbW90aW9uIG9udG8gdGhlIGJsZW5kV2VpZ2h0IGFuaW1hdGlvbi4gVGhpcyBzaG91bGQgb25seSBiZSBzZXQgdG9cclxuICAgKiB0cnVlIGZvciBibGVuZDJkIGFuaW1hdGlvbnMgcmVwcmVzZW50aW5nIGV5ZSBhbmltYXRpb24uXHJcbiAgICogQHBhcmFtIHtudW1iZXI9fSBbb3B0aW9ucy5ibGVuZFRpbWU9W1BvaW50T2ZJbnRlcmVzdEZlYXR1cmUuREVGQVVMVF9MQVlFUl9PUFRJT05TLmJsZW5kVGltZV17QGxpbmsgUG9pbnRPZkludGVyZXN0RmVhdHVyZSNERUZBVUxUX0xBWUVSX09QVElPTlMjYmxlbmRUaW1lfV0gLVxyXG4gICAqIERlZmF1bHQgYW1vdW50IG9mIHRpbWUgdG8gdXNlIHdoZW4gbWFuaXB1bGF0aW5nIGxheWVyIHdlaWdodC5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb3B0aW9ucy5lYXNpbmdGbiAtIERlZmF1bHQgZWFzaW5nIGZ1bmN0aW9uIHRvIHVzZSB3aGVuXHJcbiAgICogbWFuaXB1bGF0aW5nIGxheWVyIHdlaWdodC5cclxuICAgKi9cclxuICByZWdpc3Rlckxvb2tMYXllcihcclxuICAgIGxheWVyTmFtZSxcclxuICAgIHtcclxuICAgICAgYW5pbWF0aW9uID0gJ2xvb2snLFxyXG4gICAgICBtYXhTcGVlZCA9IDI1LFxyXG4gICAgICByZWZlcmVuY2UsXHJcbiAgICAgIGZvcndhcmRBeGlzID0gJ1Bvc2l0aXZlWicsXHJcbiAgICAgIGhhc1NhY2NhZGUgPSBmYWxzZSxcclxuICAgICAgYmxlbmRUaW1lID0gUG9pbnRPZkludGVyZXN0RmVhdHVyZS5ERUZBVUxUX0xBWUVSX09QVElPTlMuYmxlbmRUaW1lLFxyXG4gICAgICBlYXNpbmdGblxyXG4gICAgfSA9IHt9XHJcbiAgKSB7XHJcbiAgICAvLyBWYWxpZGF0ZSByZWZlcmVuY2Ugb2JqZWN0XHJcbiAgICByZWZlcmVuY2UgPSByZWZlcmVuY2UgfHwgdGhpcy5faG9zdC5vd25lcjtcclxuXHJcbiAgICBpZiAoIXRoaXMuY29uc3RydWN0b3IuX3ZhbGlkYXRlVHJhbnNmb3JtT2JqZWN0KHJlZmVyZW5jZSkpIHtcclxuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDYW5ub3QgaW5pdGlhbGl6ZSByZWdpc3RlciBsb29rIGxheWVyICR7bGF5ZXJOYW1lfSBmb3IgUG9pbnRPZkludGVyZXN0RmVhdHVyZSBvbiBob3N0ICR7dGhpcy5faG9zdC5pZH0uIFJlZmVyZW5jZSBtdXN0IGJlIGRlZmluZWQgYXMgYSB2YWxpZCB0cmFuc2Zvcm1hdGlvbiBvYmplY3QuYCk7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gRmluZCB2ZWN0b3IgYXNzb2NpYXRlZCB3aXRoIGF4aXMgc3RyaW5nXHJcbiAgICBmb3J3YXJkQXhpcyA9IEF4aXNNYXBbZm9yd2FyZEF4aXNdICE9PSB1bmRlZmluZWRcclxuICAgICAgPyBBeGlzTWFwW2ZvcndhcmRBeGlzXVxyXG4gICAgICA6IEF4aXNNYXAuUG9zaXRpdmVaO1xyXG5cclxuICAgIC8vIFN0b3JlIHRyYWNraW5nIGNvbmZpZ3VyYXRpb25cclxuICAgIGNvbnN0IHRyYWNraW5nQ29uZmlnID0gdGhpcy5fYWRkVHJhY2tpbmdDb25maWcoe1xyXG4gICAgICByZWZlcmVuY2UsXHJcbiAgICAgIGZvcndhcmRBeGlzXHJcbiAgICB9KTtcclxuXHJcbiAgICAvLyBSZWdpc3RlciB0aGUgbGF5ZXIgYW5kIGFuaW1hdGlvblxyXG4gICAgdGhpcy5yZWdpc3RlckxheWVyKGxheWVyTmFtZSwge1xyXG4gICAgICB0cmFja2luZ0NvbmZpZyxcclxuICAgICAgbWF4U3BlZWQsXHJcbiAgICAgIG1heEhTcGVlZDogdW5kZWZpbmVkLFxyXG4gICAgICBtYXhWU3BlZWQ6IHVuZGVmaW5lZCxcclxuICAgICAgaER1cmF0aW9uOiB1bmRlZmluZWQsXHJcbiAgICAgIHZEdXJhdGlvbjogdW5kZWZpbmVkLFxyXG4gICAgICBoVmVsb2NpdHk6IFswLCAwXSxcclxuICAgICAgdlZlbG9jaXR5OiBbMCwgMF0sXHJcbiAgICAgIGhhc1NhY2NhZGUsXHJcbiAgICAgIGJsZW5kVGltZSxcclxuICAgICAgZWFzaW5nRm4sXHJcbiAgICAgIG1pY3JvU2FjY2FkZTogeyBoOiAwLCB2OiAwIH0sXHJcbiAgICAgIG1hY3JvU2FjY2FkZTogeyBoOiAwLCB2OiAwIH0sXHJcbiAgICAgIHNhY2NhZGVUYXJnZXQ6IEZhY2VUYXJnZXRUeXBlcy5FeWVDZW50ZXIsXHJcbiAgICAgIGFuaW1hdGlvbnM6IHsgW2FuaW1hdGlvbl06IHt9IH0sXHJcbiAgICB9KTtcclxuICAgIHRoaXMuX2xvb2tMYXllcnNbbGF5ZXJOYW1lXSA9IGFuaW1hdGlvbjtcclxuXHJcbiAgICAvLyBWYWxpZGF0ZSB0aGUgbG9vayBhbmltYXRpb25cclxuICAgIHRoaXMuX3JlZ2lzdGVyTG9va0FuaW1hdGlvbihsYXllck5hbWUsIGFuaW1hdGlvbik7XHJcblxyXG4gICAgLy8gSW5pdGlhbGl6ZSBzYWNjYWRlIHRpbWVyc1xyXG4gICAgaWYgKGhhc1NhY2NhZGUpIHtcclxuICAgICAgY29uc3QgbWFjcm9TYWNjYWRlV2FpdFJhbmdlID0gdGhpcy5fdGFyZ2V0XHJcbiAgICAgICAgPyBNYWNyb1NhY2NhZGVXYWl0UmFuZ2VzLmV5ZVRhcmdldFxyXG4gICAgICAgIDogTWFjcm9TYWNjYWRlV2FpdFJhbmdlcy5kZWZhdWx0O1xyXG4gICAgICB0aGlzLl9pbml0aWFsaXplTWljcm9UaW1lcihsYXllck5hbWUsIC4uLk1pY3JvU2FjY2FkZVdhaXRSYW5nZXMuZGVmYXVsdCk7XHJcbiAgICAgIHRoaXMuX2luaXRpYWxpemVNYWNyb1RpbWVyKGxheWVyTmFtZSwgLi4ubWFjcm9TYWNjYWRlV2FpdFJhbmdlKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0YXJ0IGtlZXBpbmcgdHJhY2sgb2YgYW4gYW5pbWF0aW9uIGxheWVyIHRoYXQgb3ducyBhIGJsaW5rIGFuaW1hdGlvbi4gQmxpbmtcclxuICAgKiBhbmltYXRpb25zIGNhbiBiZSBvZiBhbnkgdHlwZSwgYnV0IGlmIGl0IGlzIG9mIHR5cGUgcmFuZG9tQW5pbWF0aW9uIHRoZW4gYVxyXG4gICAqIGl0IHdpbGwgYmUgcmFuZG9taXplZCBlYWNoIHRpbWUgYSBibGluayBpcyBjYWxsZWQuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gbGF5ZXJOYW1lIC0gTmFtZSBvZiB0aGUgbGF5ZXIgdG8ga2VlcCB0cmFjayBvZi5cclxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgLSBPcHRpb25zIGZvciB0aGUgbGF5ZXIuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IFtvcHRpb25zLmFuaW1hdGlvbiA9ICdibGluayddIC0gTmFtZSBvZiB0aGUgYmxpbmsgYW5pbWF0aW9uXHJcbiAgICogb24gdGhlIGxheWVyLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbb3B0aW9ucy5ibGVuZFRpbWU9W1BvaW50T2ZJbnRlcmVzdEZlYXR1cmUuREVGQVVMVF9MQVlFUl9PUFRJT05TLmJsZW5kVGltZV17QGxpbmsgUG9pbnRPZkludGVyZXN0RmVhdHVyZSNERUZBVUxUX0xBWUVSX09QVElPTlMjYmxlbmRUaW1lfV0gLVxyXG4gICAqIERlZmF1bHQgYW1vdW50IG9mIHRpbWUgdG8gdXNlIHdoZW4gbWFuaXB1bGF0aW5nIHRoZSBsYXllcidzIHdlaWdodC5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb3B0aW9ucy5lYXNpbmdGbiAtIERlZmF1bHQgZWFzaW5nIGZ1bmN0aW9uIHRvIHVzZSB3aGVuXHJcbiAgICogbWFuaXB1bGF0aW5nIHRoZSBsYXllcidzIHdlaWdodC5cclxuICAgKi9cclxuICByZWdpc3RlckJsaW5rTGF5ZXIoXHJcbiAgICBsYXllck5hbWUsXHJcbiAgICB7XHJcbiAgICAgIGFuaW1hdGlvbiA9ICdibGluaycsXHJcbiAgICAgIGJsZW5kVGltZSA9IFBvaW50T2ZJbnRlcmVzdEZlYXR1cmUuREVGQVVMVF9MQVlFUl9PUFRJT05TLmJsZW5kVGltZSxcclxuICAgICAgZWFzaW5nRm5cclxuICAgIH0gPSB7fVxyXG4gICkge1xyXG4gICAgLy8gUmVnaXN0ZXIgdGhlIGxheWVyIGFuZCBhbmltYXRpb25cclxuICAgIHRoaXMucmVnaXN0ZXJMYXllcihsYXllck5hbWUsIHtcclxuICAgICAgYmxlbmRUaW1lLFxyXG4gICAgICBlYXNpbmdGbixcclxuICAgICAgYW5pbWF0aW9uczogeyBbYW5pbWF0aW9uXToge30gfSxcclxuICAgIH0pO1xyXG4gICAgdGhpcy5fYmxpbmtMYXllcnNbbGF5ZXJOYW1lXSA9IGFuaW1hdGlvbjtcclxuICB9XHJcblxyXG4gIHVwZGF0ZShkZWx0YVRpbWUpIHtcclxuICAgIHN1cGVyLnVwZGF0ZShkZWx0YVRpbWUpO1xyXG5cclxuICAgIC8vIFVwZGF0ZSB0aGUgbG9vayBhbmdsZXNcclxuICAgIGlmICh0aGlzLl90YXJnZXQpIHtcclxuICAgICAgdGhpcy5fc2V0TG9va0FuZ2xlcygpO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgdGhpcy5fcmVzZXRMb29rQW5nbGVzKCk7XHJcbiAgICB9XHJcblxyXG4gICAgY29uc3QgZGVsdGFTZWNvbmRzID0gTWF0aC5taW4oZGVsdGFUaW1lLCBNYXhEZWx0YSkgLyAxMDAwO1xyXG4gICAgbGV0IHRyaWdnZXJCbGluayA9IGZhbHNlO1xyXG5cclxuICAgIC8vIFNldCBsb29rIGJsZW5kIHZhbHVlc1xyXG4gICAgT2JqZWN0LmVudHJpZXModGhpcy5fbG9va0xheWVycykuZm9yRWFjaCgoW2xheWVyTmFtZSwgYW5pbU5hbWVdKSA9PiB7XHJcbiAgICAgIGNvbnN0IG9wdGlvbnMgPSB0aGlzLl9tYW5hZ2VkTGF5ZXJzW2xheWVyTmFtZV07XHJcblxyXG4gICAgICAvLyBJbmNyZW1lbnQgdGhlIHNhY2NhZGUgdGltZXJzXHJcbiAgICAgIGlmIChvcHRpb25zLmlzQWN0aXZlICYmIG9wdGlvbnMuaGFzU2FjY2FkZSkge1xyXG4gICAgICAgIG9wdGlvbnMubWljcm9TYWNjYWRlVGltZXIuZXhlY3V0ZShkZWx0YVRpbWUpO1xyXG4gICAgICAgIG9wdGlvbnMubWFjcm9TYWNjYWRlVGltZXIuZXhlY3V0ZShkZWx0YVRpbWUpO1xyXG4gICAgICB9XHJcblxyXG4gICAgICAvLyBTZXQgdGhlIGJsZW5kIHZhbHVlc1xyXG4gICAgICBpZiAob3B0aW9ucy5hbmltYXRpb25zW2FuaW1OYW1lXS5pc0FjdGl2ZSkge1xyXG4gICAgICAgIGNvbnN0IGN1cnJlbnRIID0gdGhpcy5faG9zdC5BbmltYXRpb25GZWF0dXJlLmdldEFuaW1hdGlvbkJsZW5kV2VpZ2h0KFxyXG4gICAgICAgICAgbGF5ZXJOYW1lLCBhbmltTmFtZSwgJ1gnXHJcbiAgICAgICAgKTtcclxuICAgICAgICBjb25zdCBjdXJyZW50ViA9IHRoaXMuX2hvc3QuQW5pbWF0aW9uRmVhdHVyZS5nZXRBbmltYXRpb25CbGVuZFdlaWdodChcclxuICAgICAgICAgIGxheWVyTmFtZSwgYW5pbU5hbWUsICdZJ1xyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGxldCB0YXJnZXRIID0gb3B0aW9ucy50cmFja2luZ0NvbmZpZy5hbmdsZXMuaDtcclxuICAgICAgICBsZXQgdGFyZ2V0ViA9IG9wdGlvbnMudHJhY2tpbmdDb25maWcuYW5nbGVzLnY7XHJcblxyXG4gICAgICAgIC8vIENoZWNrIGlmIHRoZSBsb29rIGFuZ2xlIGhhcyBjaGFuZ2VkIGVub3VnaCB0byB0cmlnZ2VyIGEgYmxpbmtcclxuICAgICAgICBpZiAodGhpcy5faXNUYXJnZXRNb3ZpbmcgJiYgIXRyaWdnZXJCbGluaykge1xyXG4gICAgICAgICAgY29uc3QgcHJldlRhcmdldEggPSBvcHRpb25zLnRyYWNraW5nQ29uZmlnLnByZXZBbmdsZXMuaDtcclxuICAgICAgICAgIGNvbnN0IHByZXZUYXJnZXRWID0gb3B0aW9ucy50cmFja2luZ0NvbmZpZy5wcmV2QW5nbGVzLnY7XHJcbiAgICAgICAgICBjb25zdCBjaGFuZ2VBbW91bnQgPSBNYXRoVXRpbHMudG9EZWdyZWVzKFxyXG4gICAgICAgICAgICBNYXRoVXRpbHMuZ2V0QW5nbGVCZXR3ZWVuKFxyXG4gICAgICAgICAgICAgIFtwcmV2VGFyZ2V0SCwgcHJldlRhcmdldFZdLFxyXG4gICAgICAgICAgICAgIFt0YXJnZXRILCB0YXJnZXRWXVxyXG4gICAgICAgICAgICApXHJcbiAgICAgICAgICApO1xyXG5cclxuICAgICAgICAgIGlmIChjaGFuZ2VBbW91bnQgPj0gQmxpbmtUaHJlc2hvbGQpIHtcclxuICAgICAgICAgICAgdHJpZ2dlckJsaW5rID0gdHJ1ZTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIG9wdGlvbnMudHJhY2tpbmdDb25maWcucHJldkFuZ2xlcy5oID0gdGFyZ2V0SDtcclxuICAgICAgICBvcHRpb25zLnRyYWNraW5nQ29uZmlnLnByZXZBbmdsZXMudiA9IHRhcmdldFY7XHJcblxyXG4gICAgICAgIC8vIEFkZCBpbiB0aGUgc2FjY2FkZSBtb3ZlbWVudFxyXG4gICAgICAgIGlmIChvcHRpb25zLmhhc1NhY2NhZGUpIHtcclxuICAgICAgICAgIE1hdGhVdGlscy5kYW1wVmFsdWUoXHJcbiAgICAgICAgICAgIDAsXHJcbiAgICAgICAgICAgIG9wdGlvbnMubWFjcm9TYWNjYWRlLmggKyBvcHRpb25zLm1hY3JvU2FjY2FkZS5oLFxyXG4gICAgICAgICAgICBvcHRpb25zLmhWZWxvY2l0eSxcclxuICAgICAgICAgICAgb3B0aW9ucy5oRHVyYXRpb24sXHJcbiAgICAgICAgICAgIG9wdGlvbnMubWF4SFNwZWVkXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgdGFyZ2V0SCArPSBvcHRpb25zLmhWZWxvY2l0eVswXTtcclxuICAgICAgICAgIE1hdGhVdGlscy5kYW1wVmFsdWUoXHJcbiAgICAgICAgICAgIDAsXHJcbiAgICAgICAgICAgIG9wdGlvbnMubWFjcm9TYWNjYWRlLnYgKyBvcHRpb25zLm1hY3JvU2FjY2FkZS52LFxyXG4gICAgICAgICAgICBvcHRpb25zLnZWZWxvY2l0eSxcclxuICAgICAgICAgICAgb3B0aW9ucy52RHVyYXRpb24sXHJcbiAgICAgICAgICAgIG9wdGlvbnMubWF4VlNwZWVkXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgICAgdGFyZ2V0ViArPSBvcHRpb25zLnZWZWxvY2l0eVswXTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIENsYW1wIHRvIG1heCBzcGVlZFxyXG4gICAgICAgIGNvbnN0IGZhY3RvciA9IE1hdGhVdGlscy5jbGFtcChkZWx0YVNlY29uZHMgKiBvcHRpb25zLm1heFNwZWVkLCAwLCAxKTtcclxuICAgICAgICB0YXJnZXRIID0gTWF0aFV0aWxzLmxlcnAoY3VycmVudEgsIHRhcmdldEgsIGZhY3Rvcik7XHJcbiAgICAgICAgdGFyZ2V0ViA9IE1hdGhVdGlscy5sZXJwKGN1cnJlbnRWLCB0YXJnZXRWLCBmYWN0b3IpO1xyXG5cclxuICAgICAgICAvLyBVcGRhdGUgdGhlIGJsZW5kIHZhbHVlc1xyXG4gICAgICAgIHRoaXMuX2hvc3QuQW5pbWF0aW9uRmVhdHVyZS5zZXRBbmltYXRpb25CbGVuZFdlaWdodChcclxuICAgICAgICAgIGxheWVyTmFtZSxcclxuICAgICAgICAgIGFuaW1OYW1lLFxyXG4gICAgICAgICAgJ1gnLFxyXG4gICAgICAgICAgdGFyZ2V0SFxyXG4gICAgICAgICk7XHJcbiAgICAgICAgdGhpcy5faG9zdC5BbmltYXRpb25GZWF0dXJlLnNldEFuaW1hdGlvbkJsZW5kV2VpZ2h0KFxyXG4gICAgICAgICAgbGF5ZXJOYW1lLFxyXG4gICAgICAgICAgYW5pbU5hbWUsXHJcbiAgICAgICAgICAnWScsXHJcbiAgICAgICAgICB0YXJnZXRWXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgaWYgKCF0cmlnZ2VyQmxpbmsgfHwgIXRoaXMuX2lzVGFyZ2V0TW92aW5nKSB7XHJcbiAgICAgIHJldHVybjtcclxuICAgIH1cclxuXHJcbiAgICAvLyBFeGVjdXRlIGJsaW5rXHJcbiAgICBPYmplY3QuZW50cmllcyh0aGlzLl9ibGlua0xheWVycykuZm9yRWFjaCgoW2xheWVyTmFtZSwgYW5pbU5hbWVdKSA9PiB7XHJcbiAgICAgIGNvbnN0IGFuaW1hdGlvbiA9IHRoaXMuX21hbmFnZWRMYXllcnNbbGF5ZXJOYW1lXS5hbmltYXRpb25zW2FuaW1OYW1lXTtcclxuXHJcbiAgICAgIGlmIChhbmltYXRpb24uaXNBY3RpdmUpIHtcclxuICAgICAgICB0aGlzLl9ob3N0LkFuaW1hdGlvbkZlYXR1cmUucGxheUFuaW1hdGlvbihsYXllck5hbWUsIGFuaW1OYW1lKTtcclxuICAgICAgfVxyXG4gICAgfSlcclxuICB9XHJcblxyXG4gIGluc3RhbGxBcGkoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEBpbm5lclxyXG4gICAgICogQG5hbWVzcGFjZSBQb2ludE9mSW50ZXJlc3RGZWF0dXJlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IGFwaSA9IHN1cGVyLmluc3RhbGxBcGkoKTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhhcGksIHtcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBtZW1iZXJvZiBQb2ludE9mSW50ZXJlc3RGZWF0dXJlXHJcbiAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgKiBAc2VlIGNvcmUvUG9pbnRPZkludGVyZXN0RmVhdHVyZSN0YXJnZXRcclxuICAgICAgICovXHJcbiAgICAgIHRhcmdldDoge1xyXG4gICAgICAgIGdldDogKCkgPT4gdGhpcy50YXJnZXQsXHJcbiAgICAgICAgc2V0OiB0YXJnZXQgPT4geyB0aGlzLnRhcmdldCA9IHRhcmdldCB9LFxyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcblxyXG4gICAgT2JqZWN0LmFzc2lnbihhcGksIHtcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBtZW1iZXJvZiBQb2ludE9mSW50ZXJlc3RGZWF0dXJlXHJcbiAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAqIEBzZWUgY29yZS9Qb2ludE9mSW50ZXJlc3RGZWF0dXJlI3JlZ2lzdGVyTG9va0xheWVyXHJcbiAgICAgICAqL1xyXG4gICAgICByZWdpc3Rlckxvb2tMYXllcjogdGhpcy5yZWdpc3Rlckxvb2tMYXllci5iaW5kKHRoaXMpLFxyXG4gICAgICAvKipcclxuICAgICAgICogQG1lbWJlcm9mIFBvaW50T2ZJbnRlcmVzdEZlYXR1cmVcclxuICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAqIEBtZXRob2RcclxuICAgICAgICogQHNlZSBjb3JlL1BvaW50T2ZJbnRlcmVzdEZlYXR1cmUjcmVnaXN0ZXJCbGlua0xheWVyXHJcbiAgICAgICAqL1xyXG4gICAgICByZWdpc3RlckJsaW5rTGF5ZXI6IHRoaXMucmVnaXN0ZXJCbGlua0xheWVyLmJpbmQodGhpcyksXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbWVtYmVyb2YgUG9pbnRPZkludGVyZXN0RmVhdHVyZVxyXG4gICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgKiBAc2VlIGNvcmUvUG9pbnRPZkludGVyZXN0RmVhdHVyZSNzZXRUYXJnZXRcclxuICAgICAgICovXHJcbiAgICAgIHNldFRhcmdldDogdGhpcy5zZXRUYXJnZXQuYmluZCh0aGlzKSxcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBtZW1iZXJvZiBQb2ludE9mSW50ZXJlc3RGZWF0dXJlXHJcbiAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAqIEBzZWUgY29yZS9Qb2ludE9mSW50ZXJlc3RGZWF0dXJlI3NldFRhcmdldEJ5TmFtZVxyXG4gICAgICAgKi9cclxuICAgICAgc2V0VGFyZ2V0QnlOYW1lOiB0aGlzLnNldFRhcmdldEJ5TmFtZS5iaW5kKHRoaXMpLFxyXG4gICAgICAvKipcclxuICAgICAgICogQG1lbWJlcm9mIFBvaW50T2ZJbnRlcmVzdEZlYXR1cmVcclxuICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAqIEBtZXRob2RcclxuICAgICAgICogQHNlZSBjb3JlL1BvaW50T2ZJbnRlcmVzdEZlYXR1cmUjc2V0VGFyZ2V0QnlJZFxyXG4gICAgICAgKi9cclxuICAgICAgc2V0VGFyZ2V0QnlJZDogdGhpcy5zZXRUYXJnZXRCeUlkLmJpbmQodGhpcyksXHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gYXBpO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgUG9pbnRPZkludGVyZXN0RmVhdHVyZTtcclxuZXhwb3J0IHsgQXhpc01hcCB9OyIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcclxuXHJcbi8qKlxyXG4gKiBAbW9kdWxlIGNvcmUvYW5pbXBhY2tcclxuICovXHJcblxyXG5pbXBvcnQge1xyXG4gIExpbmVhcixcclxuICBRdWFkcmF0aWMsXHJcbiAgQ3ViaWMsXHJcbiAgUXVhcnRpYyxcclxuICBRdWludGljLFxyXG4gIFNpbnVzb2lkYWwsXHJcbiAgRXhwb25lbnRpYWwsXHJcbiAgQ2lyY3VsYXIsXHJcbiAgRWxhc3RpYyxcclxuICBCYWNrLFxyXG4gIEJvdW5jZSxcclxufSBmcm9tICcuL0Vhc2luZyc7XHJcbmltcG9ydCBBbmltYXRpb25GZWF0dXJlLCB7QW5pbWF0aW9uVHlwZXN9IGZyb20gJy4vQW5pbWF0aW9uRmVhdHVyZSc7XHJcbmltcG9ydCBBbmltYXRpb25MYXllciwge1xyXG4gIExheWVyQmxlbmRNb2RlcyxcclxuICBEZWZhdWx0TGF5ZXJCbGVuZE1vZGUsXHJcbn0gZnJvbSAnLi9BbmltYXRpb25MYXllcic7XHJcbmltcG9ydCBTaW5nbGVTdGF0ZSBmcm9tICcuL3N0YXRlL1NpbmdsZVN0YXRlJztcclxuaW1wb3J0IFRyYW5zaXRpb25TdGF0ZSBmcm9tICcuL3N0YXRlL1RyYW5zaXRpb25TdGF0ZSc7XHJcbmltcG9ydCBGcmVlQmxlbmRTdGF0ZSBmcm9tICcuL3N0YXRlL0ZyZWVCbGVuZFN0YXRlJztcclxuaW1wb3J0IFF1ZXVlU3RhdGUgZnJvbSAnLi9zdGF0ZS9RdWV1ZVN0YXRlJztcclxuaW1wb3J0IFJhbmRvbUFuaW1hdGlvblN0YXRlIGZyb20gJy4vc3RhdGUvUmFuZG9tQW5pbWF0aW9uU3RhdGUnO1xyXG5pbXBvcnQgQmxlbmQxZFN0YXRlIGZyb20gJy4vc3RhdGUvQmxlbmQxZFN0YXRlJztcclxuaW1wb3J0IEJsZW5kMmRTdGF0ZSBmcm9tICcuL3N0YXRlL0JsZW5kMmRTdGF0ZSc7XHJcbmltcG9ydCBBbmltYXRpb25VdGlscyBmcm9tICcuL0FuaW1hdGlvblV0aWxzJztcclxuXHJcbi8qKlxyXG4gKiBAbmFtZXNwYWNlXHJcbiAqL1xyXG5jb25zdCBFYXNpbmcgPSB7XHJcbiAgLyoqXHJcbiAgICogQHNlZSBMaW5lYXJcclxuICAgKi9cclxuICBMaW5lYXIsXHJcbiAgLyoqXHJcbiAgICogQHNlZSBRdWFkcmF0aWNcclxuICAgKi9cclxuICBRdWFkcmF0aWMsXHJcbiAgLyoqXHJcbiAgICogQHNlZSBDdWJpY1xyXG4gICAqL1xyXG4gIEN1YmljLFxyXG4gIC8qKlxyXG4gICAqIEBzZWUgUXVhcnRpY1xyXG4gICAqL1xyXG4gIFF1YXJ0aWMsXHJcbiAgLyoqXHJcbiAgICogQHNlZSBRdWludGljXHJcbiAgICovXHJcbiAgUXVpbnRpYyxcclxuICAvKipcclxuICAgKiBAc2VlIFNpbnVzb2lkYWxcclxuICAgKi9cclxuICBTaW51c29pZGFsLFxyXG4gIC8qKlxyXG4gICAqIEBzZWUgRXhwb25lbnRpYWxcclxuICAgKi9cclxuICBFeHBvbmVudGlhbCxcclxuICAvKipcclxuICAgKiBAc2VlIENpcmN1bGFyXHJcbiAgICovXHJcbiAgQ2lyY3VsYXIsXHJcbiAgLyoqXHJcbiAgICogQHNlZSBFbGFzdGljXHJcbiAgICovXHJcbiAgRWxhc3RpYyxcclxuICAvKipcclxuICAgKiBAc2VlIEJhY2tcclxuICAgKi9cclxuICBCYWNrLFxyXG4gIC8qKlxyXG4gICAqIEBzZWUgQm91bmNlXHJcbiAgICovXHJcbiAgQm91bmNlLFxyXG59O1xyXG5leHBvcnQge1xyXG4gIC8qKlxyXG4gICAqIEBzZWUgY29yZS9BbmltYXRpb25GZWF0dXJlXHJcbiAgICovXHJcbiAgQW5pbWF0aW9uRmVhdHVyZSxcclxuICAvKipcclxuICAgKiBAc2VlIEFuaW1hdGlvbkxheWVyXHJcbiAgICovXHJcbiAgQW5pbWF0aW9uTGF5ZXIsXHJcbiAgLyoqXHJcbiAgICogQHNlZSBjb3JlL1NpbmdsZVN0YXRlXHJcbiAgICovXHJcbiAgU2luZ2xlU3RhdGUsXHJcbiAgLyoqXHJcbiAgICogQHNlZSBUcmFuc2l0aW9uU3RhdGVcclxuICAgKi9cclxuICBUcmFuc2l0aW9uU3RhdGUsXHJcbiAgLyoqXHJcbiAgICogQHNlZSBGcmVlQmxlbmRTdGF0ZVxyXG4gICAqL1xyXG4gIEZyZWVCbGVuZFN0YXRlLFxyXG4gIC8qKlxyXG4gICAqIEBzZWUgUXVldWVTdGF0ZVxyXG4gICAqL1xyXG4gIFF1ZXVlU3RhdGUsXHJcbiAgLyoqXHJcbiAgICogQHNlZSBSYW5kb21BbmltYXRpb25TdGF0ZVxyXG4gICAqL1xyXG4gIFJhbmRvbUFuaW1hdGlvblN0YXRlLFxyXG4gIC8qKlxyXG4gICAqIEBzZWUgQmxlbmQxZFN0YXRlXHJcbiAgICovXHJcbiAgQmxlbmQxZFN0YXRlLFxyXG4gIC8qKlxyXG4gICAqIEBzZWUgQmxlbmQyZFN0YXRlXHJcbiAgICovXHJcbiAgQmxlbmQyZFN0YXRlLFxyXG4gIC8qKlxyXG4gICAqIEBzZWUgQW5pbWF0aW9uVXRpbHNcclxuICAgKi9cclxuICBBbmltYXRpb25VdGlscyxcclxuXHJcbiAgRWFzaW5nLFxyXG4gIC8qKlxyXG4gICAqIEBzZWUgTGF5ZXJCbGVuZE1vZGVzXHJcbiAgICovXHJcbiAgTGF5ZXJCbGVuZE1vZGVzLFxyXG4gIC8qKlxyXG4gICAqIEBzZWUgRGVmYXVsdExheWVyQmxlbmRNb2RlXHJcbiAgICovXHJcbiAgRGVmYXVsdExheWVyQmxlbmRNb2RlLFxyXG4gIC8qKlxyXG4gICAqIEBzZWUgQW5pbWF0aW9uVHlwZXNcclxuICAgKi9cclxuICBBbmltYXRpb25UeXBlcyxcclxufTtcclxuIiwiLy8gQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxyXG5pbXBvcnQgRGVmZXJyZWQgZnJvbSAnY29yZS9EZWZlcnJlZCc7XHJcblxyXG4vKipcclxuICogQ2xhc3MgdGhhdCBjYW4gcGxheSBiYWNrIGF1ZGlvIGdlbmVyYXRlZCBieSBBV1MgUG9sbHkgYW5kIHN5bmNocm9uaXplZCBlbWl0XHJcbiAqIHNwZWVjaG1hcmsgbWVzc2FnZXMuXHJcbiAqXHJcbiAqIEBhYnN0cmFjdFxyXG4gKi9cclxuY2xhc3MgQWJzdHJhY3RTcGVlY2gge1xyXG4gIC8qKlxyXG4gICAqIEBjb25zdHJ1Y3RvclxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtjb3JlL1RleHRUb1NwZWVjaEZlYXR1cmV9IHNwZWFrZXIgLSBUaGUgZmVhdHVyZSB0aGF0IG93bnMgdGhlIFNwZWVjaCBhbmRcclxuICAgKiB3aWxsIGVtaXQgc3BlZWNobWFyayBtZXNzYWdlcy5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIFRoZSB0ZXh0IG9mIHRoZSBzcGVlY2guXHJcbiAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gW3NwZWVjaG1hcmtzPVtdXSAtIEFuIGFycmF5IG9mIHNwZWVjaG1hcmsgb2JqZWN0cyByZXByZXNlbnRpbmdcclxuICAgKiB0aGUgdGV4dCBhbmQgdGltaW5nIG9mIHRoZSBzcGVlY2guXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3Ioc3BlYWtlciwgdGV4dCwgc3BlZWNobWFya3MgPSBbXSkge1xyXG4gICAgdGhpcy5fc3BlYWtlciA9IHNwZWFrZXI7XHJcbiAgICB0aGlzLl90ZXh0ID0gdGV4dDtcclxuICAgIHRoaXMuX3NwZWVjaG1hcmtzID0gc3BlZWNobWFya3M7XHJcbiAgICB0aGlzLl9zcGVlY2htYXJrT2Zmc2V0ID0gMDtcclxuICAgIHRoaXMuX3Jlc2V0KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXNldCB0cmFja2luZyBwcm9wZXJ0aWVzLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbY3VycmVudFRpbWU9MF0gLSBUaW1lIHRvIHVzZSBmb3IgX3N0YXJ0VGltZS5cclxuICAgKi9cclxuICBfcmVzZXQoY3VycmVudFRpbWUgPSAwKSB7XHJcbiAgICB0aGlzLl9zdGFydFRpbWUgPSBjdXJyZW50VGltZTtcclxuICAgIHRoaXMuX2xvY2FsVGltZSA9IDA7XHJcbiAgICB0aGlzLl9wYXVzZVRpbWUgPSAwO1xyXG4gICAgdGhpcy5fcGxheWluZyA9IGZhbHNlO1xyXG4gICAgdGhpcy5fbWFya0l0ZXIgPSB0aGlzLl9zcGVlY2htYXJrcy52YWx1ZXMoKTtcclxuICAgIGNvbnN0IHt2YWx1ZSwgZG9uZX0gPSB0aGlzLl9tYXJrSXRlci5uZXh0KCk7XHJcbiAgICB0aGlzLl9jdXJyZW50TWFyayA9IHZhbHVlO1xyXG4gICAgdGhpcy5fZW5kVGltZSA9IHRoaXMuX3NwZWVjaG1hcmtzLmxlbmd0aFxyXG4gICAgICA/IHRoaXMuX3NwZWVjaG1hcmtzW3RoaXMuX3NwZWVjaG1hcmtzLmxlbmd0aCAtIDFdLnRpbWVcclxuICAgICAgOiAwO1xyXG4gICAgdGhpcy5fZG9uZSA9IGRvbmU7XHJcbiAgICB0aGlzLl9wcm9taXNlID0gbnVsbDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhIG5ldyBwcm9taXNlIHRoYXQgd2lsbCBzdG9wIHBsYXliYWNrIGFuZCBlbWl0IG1lc3NhZ2VzIGZvciB0aGlzIHNwZWVjaC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbkZpbmlzaCAtIEZ1bmNpdG9uIHRvIGV4ZWN1dGUgb25jZSB0aGUgc3BlZWNoIHN0b3BzLlxyXG4gICAqIEBwYXJhbSB7b25FcnJvcj19IG9uRXJyb3IgLSBGdW5jdGlvbiB0byBleGVjdXRlIGlmIHRoZSBzcGVlY2ggZW5jb3VudGVycyBhblxyXG4gICAqIGVycm9yLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbkludGVycnVwdCAtIEZ1bmN0aW9uIHRvIGV4ZWN1dGUgaWYgdGhlIHNwZWVjaCBpcyBjYW5jZWxlZC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH1cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX2NyZWF0ZVByb21pc2Uob25GaW5pc2gsIG9uRXJyb3IsIG9uSW50ZXJydXB0KSB7XHJcbiAgICBjb25zdCBvblJlc29sdmUgPSB2YWx1ZSA9PiB7XHJcbiAgICAgIHRoaXMuX3BsYXlpbmcgPSBmYWxzZTtcclxuXHJcbiAgICAgIHRoaXMuX3NwZWFrZXIuZW1pdCh0aGlzLl9zcGVha2VyLmNvbnN0cnVjdG9yLkVWRU5UUy5zdG9wLCB0aGlzKTtcclxuICAgICAgdGhpcy5fc3BlYWtlci5jb25zdHJ1Y3Rvci5lbWl0KFxyXG4gICAgICAgIHRoaXMuX3NwZWFrZXIuY29uc3RydWN0b3IuRVZFTlRTLnN0b3AsXHJcbiAgICAgICAgdGhpc1xyXG4gICAgICApO1xyXG5cclxuICAgICAgaWYgKHR5cGVvZiBvbkZpbmlzaCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIG9uRmluaXNoKHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBvblJlamVjdCA9IGUgPT4ge1xyXG4gICAgICB0aGlzLl9wbGF5aW5nID0gZmFsc2U7XHJcblxyXG4gICAgICB0aGlzLl9zcGVha2VyLmVtaXQodGhpcy5fc3BlYWtlci5jb25zdHJ1Y3Rvci5FVkVOVFMuc3RvcCwgdGhpcyk7XHJcbiAgICAgIHRoaXMuX3NwZWFrZXIuY29uc3RydWN0b3IuZW1pdChcclxuICAgICAgICB0aGlzLl9zcGVha2VyLmNvbnN0cnVjdG9yLkVWRU5UUy5zdG9wLFxyXG4gICAgICAgIHRoaXNcclxuICAgICAgKTtcclxuXHJcbiAgICAgIGNvbnNvbGUuZXJyb3IoXHJcbiAgICAgICAgYCR7dGhpcy5jb25zdHJ1Y3Rvci5uYW1lfSBlbmNvdW50ZXJlZCBhbiB1bmV4cGVjdGVkIGVycm9yOiAke2V9YFxyXG4gICAgICApO1xyXG5cclxuICAgICAgaWYgKHR5cGVvZiBvbkVycm9yID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgb25FcnJvcihlKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICBjb25zdCBvbkNhbmNlbCA9IHZhbHVlID0+IHtcclxuICAgICAgdGhpcy5fcGxheWluZyA9IGZhbHNlO1xyXG5cclxuICAgICAgdGhpcy5fc3BlYWtlci5lbWl0KHRoaXMuX3NwZWFrZXIuY29uc3RydWN0b3IuRVZFTlRTLmludGVycnVwdCwgdGhpcyk7XHJcbiAgICAgIHRoaXMuX3NwZWFrZXIuY29uc3RydWN0b3IuZW1pdChcclxuICAgICAgICB0aGlzLl9zcGVha2VyLmNvbnN0cnVjdG9yLkVWRU5UUy5pbnRlcnJ1cHQsXHJcbiAgICAgICAgdGhpc1xyXG4gICAgICApO1xyXG5cclxuICAgICAgaWYgKHR5cGVvZiBvbkludGVycnVwdCA9PT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIG9uSW50ZXJydXB0KHZhbHVlKTtcclxuICAgICAgfVxyXG4gICAgfTtcclxuXHJcbiAgICB0aGlzLl9wcm9taXNlID0gbmV3IERlZmVycmVkKHVuZGVmaW5lZCwgb25SZXNvbHZlLCBvblJlamVjdCwgb25DYW5jZWwpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLl9wcm9taXNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmV0dXJuIHdoZXRoZXIgb3Igbm90IHRoZSBzcGVlY2ggaGFzIHJlYWNoZWQgaXQncyBlbmQuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgX2NoZWNrRmluaXNoZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fZG9uZSAmJiB0aGlzLl9sb2NhbFRpbWUgPj0gdGhpcy5fZW5kVGltZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgdGhlIHBsYXliYWNrIHN0YXRlIG9mIHRoZSBhdWRpby5cclxuICAgKlxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEB0eXBlIHtib29sZWFufVxyXG4gICAqL1xyXG4gIGdldCBwbGF5aW5nKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3BsYXlpbmc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSB0ZXh0IG9mIHRoZSBzcGVlY2guXHJcbiAgICpcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAqL1xyXG4gIGdldCB0ZXh0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3RleHQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIGEgc2hhbGxvdyBjb3B5IG9mIHRoZSBzcGVlY2htYXJrcyBhcnJheSBmb3IgdGhlIHNwZWVjaC5cclxuICAgKlxyXG4gICAqIEByZWFkb25seVxyXG4gICAqIEB0eXBlIHtBcnJheS48T2JqZWN0Pn1cclxuICAgKi9cclxuICBnZXQgc3BlZWNobWFya3MoKSB7XHJcbiAgICByZXR1cm4gWy4uLnRoaXMuX3NwZWVjaG1hcmtzXTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgYW5kIHNldHMgdGhlIG51bWJlciBvZiBzZWNvbmRzIHRvIG9mZnNldCBzcGVlY2htYXJrIGVtaXNzaW9uLlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgZ2V0IHNwZWVjaG1hcmtPZmZzZXQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fc3BlZWNobWFya09mZnNldCAvIDEwMDA7XHJcbiAgfVxyXG5cclxuICBzZXQgc3BlZWNobWFya09mZnNldChvZmZzZXQpIHtcclxuICAgIHRoaXMuX3NwZWVjaG1hcmtPZmZzZXQgPSBvZmZzZXQgKiAxMDAwOyAvLyBTdG9yZSBhcyBtaWxsaXNlY29uZHNcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEVtaXQgc3BlZWNobWFyayBtZXNzYWdlcyBhcyB0aGV5IGFyZSBlbmNvdW50ZXJlZCBpbiBzeW5jIHdpdGggYXVkaW8uXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gY3VycmVudFRpbWUgLSBDdXJyZW50IGdsb2JhbCB0aW1lIHdoZW4gdXBkYXRlIHdhcyBjYWxsZWQuXHJcbiAgICovXHJcbiAgdXBkYXRlKGN1cnJlbnRUaW1lKSB7XHJcbiAgICBpZiAoIXRoaXMuX3BsYXlpbmcpIHtcclxuICAgICAgcmV0dXJuO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFVwZGF0ZSBsb2NhbCBhdWRpbyB0aW1lXHJcbiAgICB0aGlzLl9sb2NhbFRpbWUgPSBjdXJyZW50VGltZSAtIHRoaXMuX3N0YXJ0VGltZTtcclxuXHJcbiAgICBpZiAoIXRoaXMuX2RvbmUpIHtcclxuICAgICAgLy8gRW1pdCBzcGVlY2htYXJrIG1lc3NhZ2VzIGZvciBtYXJrcyB1cCB0byB0aGUgY3VycmVudCB0aW1lXHJcbiAgICAgIHdoaWxlIChcclxuICAgICAgICAhdGhpcy5fZG9uZSAmJlxyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRNYXJrLnRpbWUgKyB0aGlzLl9zcGVlY2htYXJrT2Zmc2V0IDw9IHRoaXMuX2xvY2FsVGltZVxyXG4gICAgICApIHtcclxuICAgICAgICB0aGlzLl9zcGVha2VyLmVtaXQoXHJcbiAgICAgICAgICB0aGlzLl9zcGVha2VyLmNvbnN0cnVjdG9yLkVWRU5UU1t0aGlzLl9jdXJyZW50TWFyay50eXBlXSxcclxuICAgICAgICAgIHtcclxuICAgICAgICAgICAgc3BlZWNoOiB0aGlzLFxyXG4gICAgICAgICAgICBtYXJrOiB0aGlzLl9jdXJyZW50TWFyayxcclxuICAgICAgICAgIH1cclxuICAgICAgICApO1xyXG4gICAgICAgIGNvbnN0IHt2YWx1ZSwgZG9uZX0gPSB0aGlzLl9tYXJrSXRlci5uZXh0KCk7XHJcblxyXG4gICAgICAgIHRoaXMuX2N1cnJlbnRNYXJrID0gdmFsdWU7XHJcbiAgICAgICAgdGhpcy5fZG9uZSA9IGRvbmU7XHJcbiAgICAgIH1cclxuICAgIH1cclxuXHJcbiAgICAvLyBFbmQgcGxheWJhY2tcclxuICAgIGlmICh0aGlzLl9jaGVja0ZpbmlzaGVkKCkpIHtcclxuICAgICAgdGhpcy5zdG9wKCk7XHJcbiAgICAgIHRoaXMuX3Jlc2V0KCk7XHJcbiAgICB9XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQbGF5IHRoZSBzcGVlY2ggZnJvbSB0aGUgYmVnaW5uaW5nLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IGN1cnJlbnRUaW1lIC0gQ3VycmVudCBnbG9iYWwgdGltZSB3aGVuIHBsYXkgd2FzIGNhbGxlZC5cclxuICAgKiBAcGFyYW0ge0Z1bmN0aW9uPX0gb25GaW5pc2ggLSBPcHRpb25hbCBmdW5jdGlvbiB0byBleGVjdXRlIG9uY2UgdGhlIHNwZWVjaFxyXG4gICAqIHByb21pc2UgcmVzb2x2ZXMuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uRXJyb3IgLSBPcHRpb25hbCBmdW5jdGlvbiB0byBleGVjdXRlIGlmIHRoZSBzcGVlY2hcclxuICAgKiBlbmNvdW50ZXJzIGFuZCBlcnJvciBkdXJpbmcgcGxheWJhY2suXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uSW50ZXJydXB0IC0gT3B0aW9uYWwgZnVuY3Rpb24gdG8gZXhlY3V0ZSBpZiB0aGUgc3BlZWNoXHJcbiAgICogaXMgY2FuY2VsZWQuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9IFJlc29sdmVzIG9uY2UgdGhlIHNwZWVjaCByZWFjaGVzIHRoZSBlbmQgb2YgcGxheWJhY2suXHJcbiAgICovXHJcbiAgcGxheShjdXJyZW50VGltZSwgb25GaW5pc2gsIG9uRXJyb3IsIG9uSW50ZXJydXB0KSB7XHJcbiAgICB0aGlzLl9yZXNldChjdXJyZW50VGltZSk7XHJcbiAgICB0aGlzLl9wbGF5aW5nID0gdHJ1ZTtcclxuXHJcbiAgICB0aGlzLl9zcGVha2VyLmVtaXQodGhpcy5fc3BlYWtlci5jb25zdHJ1Y3Rvci5FVkVOVFMucGxheSwgdGhpcyk7XHJcbiAgICB0aGlzLl9zcGVha2VyLmNvbnN0cnVjdG9yLmVtaXQodGhpcy5fc3BlYWtlci5jb25zdHJ1Y3Rvci5FVkVOVFMucGxheSwgdGhpcyk7XHJcblxyXG4gICAgcmV0dXJuIHRoaXMuX2NyZWF0ZVByb21pc2Uob25GaW5pc2gsIG9uRXJyb3IsIG9uSW50ZXJydXB0KTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhdXNlIHRoZSBzcGVlY2ggYXQgdGhlIGN1cnJlbnQgdGltZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBjdXJyZW50VGltZSAtIEN1cnJlbnQgZ2xvYmFsIHRpbWUgd2hlbiBwYXVzZSB3YXMgY2FsbGVkLlxyXG4gICAqL1xyXG4gIHBhdXNlKGN1cnJlbnRUaW1lKSB7XHJcbiAgICB0aGlzLl9wbGF5aW5nID0gZmFsc2U7XHJcbiAgICB0aGlzLl9wYXVzZVRpbWUgPSBjdXJyZW50VGltZTtcclxuXHJcbiAgICB0aGlzLl9zcGVha2VyLmVtaXQodGhpcy5fc3BlYWtlci5jb25zdHJ1Y3Rvci5FVkVOVFMucGF1c2UsIHRoaXMpO1xyXG4gICAgdGhpcy5fc3BlYWtlci5jb25zdHJ1Y3Rvci5lbWl0KFxyXG4gICAgICB0aGlzLl9zcGVha2VyLmNvbnN0cnVjdG9yLkVWRU5UUy5wYXVzZSxcclxuICAgICAgdGhpc1xyXG4gICAgKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFJlc3VtZSB0aGUgc3BlZWNoIGF0IHRoZSBjdXJyZW50IHRpbWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge251bWJlcn0gY3VycmVudFRpbWUgLSBDdXJyZW50IGdsb2JhbCB0aW1lIHdoZW4gcmVzdW1lIHdhcyBjYWxsZWQuXHJcbiAgICogQHBhcmFtIHtGdW5jdGlvbj19IG9uRmluaXNoIC0gT3B0aW9uYWwgZnVuY3Rpb24gdG8gZXhlY3V0ZSBvbmNlIHRoZSBzcGVlY2hcclxuICAgKiBwcm9taXNlIHJlc29sdmVzLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbkVycm9yIC0gT3B0aW9uYWwgZnVuY3Rpb24gdG8gZXhlY3V0ZSBpZiB0aGUgc3BlZWNoXHJcbiAgICogZW5jb3VudGVycyBhbmQgZXJyb3IgZHVyaW5nIHBsYXliYWNrLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBvbkludGVycnVwdCAtIE9wdGlvbmFsIGZ1bmN0aW9uIHRvIGV4ZWN1dGUgaWYgdGhlIHNwZWVjaFxyXG4gICAqIGlzIGNhbmNlbGVkLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0RlZmVycmVkfSBSZXNvbHZlcyBvbmNlIHRoZSBzcGVlY2ggcmVhY2hlcyB0aGUgZW5kIG9mIHBsYXliYWNrLlxyXG4gICAqL1xyXG4gIHJlc3VtZShjdXJyZW50VGltZSwgb25GaW5pc2gsIG9uRXJyb3IsIG9uSW50ZXJydXB0KSB7XHJcbiAgICAvLyBQbGF5IGZyb20gdGhlIGJlZ2lubmluZyBpZiB0aGUgc3BlZWNoIGhhc24ndCBwbGF5ZWQgeWV0XHJcbiAgICBpZiAoIXRoaXMuX3Byb21pc2UpIHtcclxuICAgICAgdGhpcy5fcmVzZXQoY3VycmVudFRpbWUpO1xyXG4gICAgICB0aGlzLl9jcmVhdGVQcm9taXNlKG9uRmluaXNoLCBvbkVycm9yLCBvbkludGVycnVwdCk7XHJcbiAgICB9XHJcblxyXG4gICAgdGhpcy5fcGxheWluZyA9IHRydWU7XHJcbiAgICB0aGlzLl9zdGFydFRpbWUgKz0gY3VycmVudFRpbWUgLSB0aGlzLl9wYXVzZVRpbWU7XHJcblxyXG4gICAgdGhpcy5fc3BlYWtlci5lbWl0KHRoaXMuX3NwZWFrZXIuY29uc3RydWN0b3IuRVZFTlRTLnJlc3VtZSwgdGhpcyk7XHJcbiAgICB0aGlzLl9zcGVha2VyLmNvbnN0cnVjdG9yLmVtaXQoXHJcbiAgICAgIHRoaXMuX3NwZWFrZXIuY29uc3RydWN0b3IuRVZFTlRTLnJlc3VtZSxcclxuICAgICAgdGhpc1xyXG4gICAgKTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENhbmNlbHMgcGxheWJhY2sgb2YgdGhlIHNwZWVjaCBhdCB0aGUgY3VycmVudCB0aW1lLiBDYW5jZWwgdGhlIHNwZWVjaCBwcm9taXNlLlxyXG4gICAqL1xyXG4gIGNhbmNlbCgpIHtcclxuICAgIGlmICh0aGlzLl9wcm9taXNlKSB7XHJcbiAgICAgIHRoaXMuX3Byb21pc2UuY2FuY2VsKCk7XHJcbiAgICAgIHRoaXMuX3Byb21pc2UgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX3BsYXlpbmcgPSBmYWxzZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFN0b3AgdGhlIHNwZWVjaCBhbmQgcmVzZXQgdGltZSB0byB0aGUgYmVnaW5uaW5nLiBSZXNvbHZlIHRoZSBzcGVlY2ggcHJvbWlzZS5cclxuICAgKi9cclxuICBzdG9wKCkge1xyXG4gICAgaWYgKHRoaXMuX3Byb21pc2UpIHtcclxuICAgICAgdGhpcy5fcHJvbWlzZS5yZXNvbHZlKCk7XHJcbiAgICAgIHRoaXMuX3Byb21pc2UgPSBudWxsO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX3BsYXlpbmcgPSBmYWxzZTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IEFic3RyYWN0U3BlZWNoO1xyXG4iLCIvLyBDb3B5cmlnaHQgQW1hem9uLmNvbSwgSW5jLiBvciBpdHMgYWZmaWxpYXRlcy4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cclxuLy8gU1BEWC1MaWNlbnNlLUlkZW50aWZpZXI6IE1JVC0wXHJcbmltcG9ydCBBYnN0cmFjdFNwZWVjaCBmcm9tICcuL0Fic3RyYWN0U3BlZWNoJztcclxuXHJcbi8qKlxyXG4gKiBUaGUgYnVpbHQtaW4gY2xhc3MgZm9yIGFzeW5jaHJvbm91cyBQcm9taXNlcy5cclxuICogQGV4dGVybmFsIEF1ZGlvXHJcbiAqIEBzZWUgaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvQVBJL0hUTUxBdWRpb0VsZW1lbnQvQXVkaW9cclxuICovXHJcblxyXG4vKipcclxuICogQGV4dGVuZHMgQWJzdHJhY3RTcGVlY2hcclxuICogQGFsaWFzIGNvcmUvU3BlZWNoXHJcbiAqL1xyXG5jbGFzcyBTcGVlY2ggZXh0ZW5kcyBBYnN0cmFjdFNwZWVjaCB7XHJcbiAgLyoqXHJcbiAgICogQGNvbnN0cnVjdG9yXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge1RleHRUb1NwZWVjaH0gc3BlYWtlciAtIFRoZSBvd25lciBvZiB0aGUgU3BlZWNoIHRoYXQgd2lsbCBlbWl0IHNwZWVjaG1hcmtcclxuICAgKiBtZXNzYWdlcy5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIFRoZSB0ZXh0IG9mIHRoZSBzcGVlY2guXHJcbiAgICogQHBhcmFtIHtBcnJheS48T2JqZWN0Pn0gW3NwZWVjaG1hcmtzPVtdXSAtIEFuIGFycmF5IG9mIHNwZWVjaG1hcmsgb2JqZWN0cyByZXByZXNlbnRpbmdcclxuICAgKiB0aGUgdGV4dCBhbmQgdGltaW5nIG9mIHRoZSBzcGVlY2guXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IGF1ZGlvQ29uZmlnIC0gT2JqZWN0IGNvbnRhaW5pbmcgYXVkaW8gYW5kIHVybC5cclxuICAgKiBAcGFyYW0ge2V4dGVybmFsOkF1ZGlvfSBhdWRpb0NvbmZpZy5hdWRpbyAtIFBsYXlhYmxlIGF1ZGlvIG9iamVjdC5cclxuICAgKi9cclxuICBjb25zdHJ1Y3RvcihzcGVha2VyLCB0ZXh0LCBzcGVlY2htYXJrcyA9IFtdLCBhdWRpb0NvbmZpZykge1xyXG4gICAgc3VwZXIoc3BlYWtlciwgdGV4dCwgc3BlZWNobWFya3MpO1xyXG4gICAgdGhpcy5fYXVkaW8gPSBhdWRpb0NvbmZpZy5hdWRpbztcclxuXHJcbiAgICAvLyBLZWVwIHRyYWNrIG9mIHdoZXRoZXIgdGhlIGF1ZGlvIGhhcyBmaW5pc2hlZCBwbGF5aW5nIHRocm91Z2hcclxuICAgIHRoaXMuX2F1ZGlvLm9uZW5kZWQgPSAoKSA9PiB7XHJcbiAgICAgIHRoaXMuX2F1ZGlvRmluaXNoZWQgPSB0cnVlO1xyXG4gICAgfTtcclxuICAgIHRoaXMuX2F1ZGlvRmluaXNoZWQgPSB0cnVlO1xyXG4gIH1cclxuXHJcbiAgX2NoZWNrRmluaXNoZWQoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fYXVkaW9GaW5pc2hlZCAmJiBzdXBlci5fY2hlY2tGaW5pc2hlZCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgcGxheWFibGUgYXVkaW8gZm9yIHRoZSBzcGVlY2guXHJcbiAgICpcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAdHlwZSB7ZXh0ZXJuYWw6QXVkaW99XHJcbiAgICovXHJcbiAgZ2V0IGF1ZGlvKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2F1ZGlvO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgYXVkaW8gdm9sdW1lIGZvciB0aGUgc3BlZWNoLlxyXG4gICAqXHJcbiAgICogQHR5cGUge251bWJlcn1cclxuICAgKi9cclxuICBnZXQgdm9sdW1lKCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2F1ZGlvLnZvbHVtZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldHMgdGhlIGF1ZGlvIHZvbHVtZSBmb3IgdGhlIHNwZWVjaC5cclxuICAgKi9cclxuICBzZXQgdm9sdW1lKHZvbHVtZSkge1xyXG4gICAgdGhpcy5fYXVkaW8udm9sdW1lID0gdm9sdW1lO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU2V0IHRoZSBhdWRpbydzIGN1cnJlbnQgbG9jYWwgdGltZSBhbmQgcGxheSBpdC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICovXHJcbiAgX3BsYXlBdWRpbygpIHtcclxuICAgIGlmICh0aGlzLl9zcGVlY2htYXJrT2Zmc2V0IDwgMCkge1xyXG4gICAgICB0aGlzLl9hdWRpby5jdXJyZW50VGltZSA9IHRoaXMuX3NwZWVjaG1hcmtPZmZzZXQ7XHJcbiAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xyXG4gICAgICAgIGlmICh0aGlzLl9wbGF5aW5nKSB7XHJcbiAgICAgICAgICB0aGlzLl9hdWRpby5jdXJyZW50VGltZSA9XHJcbiAgICAgICAgICAgICh0aGlzLl9sb2NhbFRpbWUgKyB0aGlzLl9zcGVlY2htYXJrT2Zmc2V0KSAvIDEwMDA7XHJcbiAgICAgICAgICB0aGlzLl9hdWRpby5wbGF5KCk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9LCAtdGhpcy5fc3BlZWNobWFya09mZnNldCk7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICB0aGlzLl9hdWRpby5jdXJyZW50VGltZSA9IDA7XHJcbiAgICAgIHRoaXMuX2F1ZGlvLnBsYXkoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhdXNlIHRoZSBhdWRpbyBvbmNlIGl0IGlzIHBsYXlhYmxlLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfcGF1c2VBdWRpbygpIHtcclxuICAgIHRoaXMuX2F1ZGlvLnBsYXkoKS50aGVuKCgpID0+IHtcclxuICAgICAgaWYgKCF0aGlzLl9wbGF5aW5nKSB7XHJcbiAgICAgICAgdGhpcy5fYXVkaW8ucGF1c2UoKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICBwbGF5KGN1cnJlbnRUaW1lLCBvbkZpbmlzaCwgb25FcnJvciwgb25JbnRlcnJ1cHQpIHtcclxuICAgIHRoaXMuX2F1ZGlvRmluaXNoZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuX3BsYXlBdWRpbygpO1xyXG5cclxuICAgIHJldHVybiBzdXBlci5wbGF5KGN1cnJlbnRUaW1lLCBvbkZpbmlzaCwgb25FcnJvciwgb25JbnRlcnJ1cHQpO1xyXG4gIH1cclxuXHJcbiAgcGF1c2UoY3VycmVudFRpbWUpIHtcclxuICAgIHRoaXMuX3BhdXNlQXVkaW8oKTtcclxuICAgIHN1cGVyLnBhdXNlKGN1cnJlbnRUaW1lKTtcclxuICB9XHJcblxyXG4gIHJlc3VtZShjdXJyZW50VGltZSwgb25GaW5pc2gsIG9uRXJyb3IsIG9uSW50ZXJydXB0KSB7XHJcbiAgICB0aGlzLl9hdWRpb0ZpbmlzaGVkID0gZmFsc2U7XHJcbiAgICB0aGlzLl9hdWRpby5wbGF5KCk7XHJcblxyXG4gICAgcmV0dXJuIHN1cGVyLnJlc3VtZShjdXJyZW50VGltZSwgb25GaW5pc2gsIG9uRXJyb3IsIG9uSW50ZXJydXB0KTtcclxuICB9XHJcblxyXG4gIGNhbmNlbCgpIHtcclxuICAgIHRoaXMuX3BhdXNlQXVkaW8oKTtcclxuICAgIHN1cGVyLmNhbmNlbCgpO1xyXG4gIH1cclxuXHJcbiAgc3RvcCgpIHtcclxuICAgIHRoaXMuX3BhdXNlQXVkaW8oKTtcclxuICAgIHRoaXMuX2F1ZGlvLmN1cnJlbnRUaW1lID0gMDtcclxuICAgIHN1cGVyLnN0b3AoKTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFNwZWVjaDtcclxuIiwiLy8gQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxyXG5cclxuaW1wb3J0IFV0aWxzIGZyb20gJ2NvcmUvVXRpbHMnO1xyXG5cclxuLyoqXHJcbiAqIEEgY29sbGVjdGlvbiBvZiB1c2VmdWwgdGV4dC10by1zcGVlY2ggZnVuY3Rpb25zLlxyXG4gKlxyXG4gKiBAaGlkZWNvbnN0cnVjdG9yXHJcbiAqL1xyXG5jbGFzcyBUZXh0VG9TcGVlY2hVdGlscyB7XHJcbiAgLyoqXHJcbiAgICogUmV0dXJucyBhIG5ldyBzdHJpbmcgd2l0aCBTU01MIG1hcmtzIGluc2VydGVkIGJhc2VkIG9uXHJcbiAgICogbWF0Y2hlcyBiZXR3ZWVuIHRoZSBpbnB1dCBzdHJpbmcgYW5kIHRoZSBpbnB1dCBtYXAuIFRoZVxyXG4gICAqIHdvcmQgbWF0Y2hlcyBhcmUgY2FzZS1pbnNlbnNpdGl2ZS4gV29yZHMgd2l0aGluIGV4aXN0aW5nXHJcbiAgICogU1NNTCB0YWdzIHdpbGwgbm90IGJlIGFmZmVjdGVkLiBJbnB1dCB0ZXh0IHdpbGwgYmUgc3Vycm91bmRlZFxyXG4gICAqIGJ5IDxzcGVhaz48L3NwZWFrPiB0YWdzIGlmIG5lZWRlZC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gSW5wdXQgc3RyaW5nLlxyXG4gICAqIEBwYXJhbSB7b2JqZWN0fSBtYXAgLSBJbnB1dCBvYmplY3QgdGhhdCBtYXBzIG1hcmsga2V5c1xyXG4gICAqIHRvIGFycmF5cyBvZiB3b3Jkcy4gRXhhbXBsZTpcclxuICAgKlxyXG4gICAqICB7XHJcbiAgICogICAgJ21hcms6c2FkJyA6IFsnc2FkJywgJ2JsdWUnLCAnZG93biddLFxyXG4gICAqICAgICdtYXJrOmhhcHB5JyA6IFsnam95JywgJ2dsYWQnLCAnZ3JlYXQnXSxcclxuICAgKiAgICAnbWFyazpubycgOiBbJ25vJywgJ25haCcsICduYXknLCAnc3VyZSddXHJcbiAgICogIH1cclxuICAgKiBAcGFyYW0ge0FycmF5LjxzdHJpbmc+fSBbcmFuZG9tTWFya3MgPSBbXV0gLSBJZiB0aGVyZSBhcmUgc2VudGVuY2VzIHRoYXQgZG9uJ3RcclxuICAgKiBtYXRjaCBhbnkgd29yZHMgZnJvbSB0aGUgbWFwIG9iamVjdCwgbWFya3MgZnJvbSB0aGlzIGFycmF5IHdpbGwgYmUgcmFuZG9tbHlcclxuICAgKiBjaG9zZW4gYW5kIGluc2VydGVkLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge3N0cmluZ30gLSBVcGRhdGVkIGlucHV0IHN0cmluZy5cclxuICAgKi9cclxuICBzdGF0aWMgYXV0b0dlbmVyYXRlU1NNTE1hcmtzKHRleHQsIG1hcCwgcmFuZG9tTWFya3MgPSBbXSkge1xyXG4gICAgaWYgKHR5cGVvZiBtYXAgIT09ICdvYmplY3QnIHx8IG1hcCA9PT0gbnVsbCkge1xyXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXHJcbiAgICAgICAgYENhbm5vdCBnZW5lcmF0ZSBTU01MIG1hcmtzIGZvciB0ZXh0IFwiJHt0ZXh0fVwiIGJlY2F1c2UgbWFwIGlzIG5vdCBhbiBvYmplY3QuYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIHByb2Nlc3MgdGhlIGlucHV0IG1hcCBpbnRvIGFuIGludGVybmFsIGZvcm1hdFxyXG4gICAgY29uc3QgaW50ZXJuYWxNYXAgPSB0aGlzLl9wcm9jZXNzSW5wdXRNYXAobWFwKTtcclxuXHJcbiAgICBjb25zdCBzcGVha1RhZ3MgPSBbJzxzcGVhaz4nLCAnPC9zcGVhaz4nXTtcclxuICAgIGNvbnN0IHNzbWxNYXJrUmVnZXggPSAvPG1hcmsgbmFtZT0oPzpcInwnKSguKj8pKD86XCJ8JylcXC8+LztcclxuICAgIGNvbnN0IHNzbWxUYWdSZWdleCA9IC88W14+XSo+L2c7XHJcblxyXG4gICAgLy8gSWRlbnRpZnkgYW55IGV4aXN0aW5nIFNTTUwgdGFnc1xyXG4gICAgY29uc3QgZXhpc3RpbmdUYWdzID0gW107XHJcbiAgICBsZXQgcmVzdWx0ID0gc3NtbFRhZ1JlZ2V4LmV4ZWModGV4dCk7XHJcblxyXG4gICAgd2hpbGUgKHJlc3VsdCAhPT0gbnVsbCkge1xyXG4gICAgICBleGlzdGluZ1RhZ3MucHVzaCh7XHJcbiAgICAgICAgc3RhcnQ6IHJlc3VsdC5pbmRleCxcclxuICAgICAgICBlbmQ6IHJlc3VsdC5pbmRleCArIHJlc3VsdFswXS5sZW5ndGgsXHJcbiAgICAgICAgdGV4dDogcmVzdWx0WzBdLFxyXG4gICAgICB9KTtcclxuXHJcbiAgICAgIHJlc3VsdCA9IHNzbWxUYWdSZWdleC5leGVjKHRleHQpO1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGNodW5rcyA9IFtdO1xyXG4gICAgbGV0IGluZGV4ID0gMDtcclxuICAgIGxldCBzc21sTWFya1Jlc3VsdDtcclxuICAgIGxldCBkdXBsaWNhdGVNYXJrVG9DaGVjayA9IFtdO1xyXG4gICAgZXhpc3RpbmdUYWdzLmZvckVhY2goZXhpc3RpbmdUYWcgPT4ge1xyXG4gICAgICBjb25zdCBzdWJzdHIgPSB0ZXh0LnNsaWNlKGluZGV4LCBleGlzdGluZ1RhZy5zdGFydCk7XHJcblxyXG4gICAgICBpZiAoc3Vic3RyICE9PSAnJykge1xyXG4gICAgICAgIC8vIGF1dG8tbWFyayBub24tdGFnIHRleHRcclxuICAgICAgICBjaHVua3MucHVzaChcclxuICAgICAgICAgIHRoaXMuX2luc2VydE1hcmtzKHN1YnN0ciwgaW50ZXJuYWxNYXAsIGR1cGxpY2F0ZU1hcmtUb0NoZWNrKVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIGR1cGxpY2F0ZU1hcmtUb0NoZWNrID0gW107XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIHNzbWxNYXJrUmVzdWx0ID0gc3NtbE1hcmtSZWdleC5leGVjKGV4aXN0aW5nVGFnLnRleHQpO1xyXG5cclxuICAgICAgaWYgKHNzbWxNYXJrUmVzdWx0ICE9PSBudWxsKSB7XHJcbiAgICAgICAgY29uc3QgbWFya1RleHQgPSBzc21sTWFya1Jlc3VsdFsxXTtcclxuICAgICAgICBkdXBsaWNhdGVNYXJrVG9DaGVjay5wdXNoKG1hcmtUZXh0KTtcclxuICAgICAgfSBlbHNlIGlmICghc3BlYWtUYWdzLmluY2x1ZGVzKGV4aXN0aW5nVGFnLnRleHQpKSB7XHJcbiAgICAgICAgY2h1bmtzLnB1c2goZXhpc3RpbmdUYWcudGV4dCk7XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIGFkdmFuY2UgdGhlIGluZGV4XHJcbiAgICAgIGluZGV4ID0gZXhpc3RpbmdUYWcuZW5kO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY2h1bmtzLnB1c2goXHJcbiAgICAgIHRoaXMuX2luc2VydE1hcmtzKHRleHQuc2xpY2UoaW5kZXgpLCBpbnRlcm5hbE1hcCwgZHVwbGljYXRlTWFya1RvQ2hlY2spXHJcbiAgICApO1xyXG5cclxuICAgIGxldCBtYXJrZWRUZXh0ID0gY2h1bmtzLmpvaW4oJycpO1xyXG5cclxuICAgIGlmIChyYW5kb21NYXJrcyAmJiByYW5kb21NYXJrcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgIC8vIGFkZCByYW5kb20gbWFya3MgdG8gYW55IHVubWFya2VkIHNlbnRlbmNlc1xyXG4gICAgICBtYXJrZWRUZXh0ID0gdGhpcy5hZGRNYXJrc1RvVW5tYXJrZWRTZW50ZW5jZXMoXHJcbiAgICAgICAgbWFya2VkVGV4dCxcclxuICAgICAgICByYW5kb21NYXJrc1xyXG4gICAgICApO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBUZXh0VG9TcGVlY2hVdGlscy52YWxpZGF0ZVRleHQobWFya2VkVGV4dCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGEgbmV3IHN0cmluZyB3aXRoIGEgcmFuZG9tIFNTTUwgbWFyayBpbnNlcnRlZCBhdCBlYWNoIHNlbnRlbmNlIHRoYXRcclxuICAgKiBkb2VzIG5vdCBhbHJlYWR5IGNvbnRhaW4gYW4gU1NNTCBtYXJrLlxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBJbnB1dCBzdHJpbmcuXHJcbiAgICogQHBhcmFtIHtBcnJheS48c3RyaW5nPn0gbWFya3MgLSBBbnkgYXJyYXkgb2YgcmFuZG9tIFNTTUwgbWFya3MgdG8gY2hvb3NlIGZyb21cclxuICAgKiB3aGVuIG1vZGlmeWluZyB0aGUgdGV4dC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICovXHJcbiAgc3RhdGljIGFkZE1hcmtzVG9Vbm1hcmtlZFNlbnRlbmNlcyh0ZXh0LCBtYXJrcykge1xyXG4gICAgaWYgKCFtYXJrcyB8fCBtYXJrcy5sZW5ndGggPT09IDApIHJldHVybiB0ZXh0O1xyXG5cclxuICAgIGNvbnN0IHNzbWxNYXJrUmVnZXggPSAvPG1hcmsgbmFtZT0oPzpcInwnKSguKj8pKD86XCJ8JylcXC8+L2c7XHJcbiAgICBjb25zdCBzc21sVGFnUmVnZXggPSAvPFtePl0qPi9nO1xyXG5cclxuICAgIC8vIEZpbmQgdGhlIGluZGljZXMgb2YgYW55IG1hcmtzIGluIHRoZSB0ZXh0XHJcbiAgICBjb25zdCBtYXJrSW5kaWNlcyA9IFtdO1xyXG4gICAgbGV0IG1hcmtSZXN1bHQgPSBzc21sTWFya1JlZ2V4LmV4ZWModGV4dCk7XHJcblxyXG4gICAgd2hpbGUgKG1hcmtSZXN1bHQgIT09IG51bGwpIHtcclxuICAgICAgbWFya0luZGljZXMucHVzaChtYXJrUmVzdWx0LmluZGV4KTtcclxuICAgICAgbWFya1Jlc3VsdCA9IHNzbWxNYXJrUmVnZXguZXhlYyh0ZXh0KTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBGaW5kIGFsbCBTU01MIHRhZ3MgaW4gdGhlIHRleHRcclxuICAgIGNvbnN0IGV4aXN0aW5nVGFncyA9IFtdO1xyXG4gICAgbGV0IHNzbWxSZXN1bHQgPSBzc21sVGFnUmVnZXguZXhlYyh0ZXh0KTtcclxuICAgIHdoaWxlIChzc21sUmVzdWx0ICE9PSBudWxsKSB7XHJcbiAgICAgIGV4aXN0aW5nVGFncy5wdXNoKHtcclxuICAgICAgICBzdGFydDogc3NtbFJlc3VsdC5pbmRleCxcclxuICAgICAgICBlbmQ6IHNzbWxSZXN1bHQuaW5kZXggKyBzc21sUmVzdWx0WzBdLmxlbmd0aCxcclxuICAgICAgICB0ZXh0OiBzc21sUmVzdWx0WzBdLFxyXG4gICAgICB9KTtcclxuICAgICAgc3NtbFJlc3VsdCA9IHNzbWxUYWdSZWdleC5leGVjKHRleHQpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENyZWF0ZSBhIGNvcHkgb2YgdGhlIHRleHQgd2l0aCBhbGwgU1NNTCBtYXJrcyByZXBsYWNlcyB3aXRoIHdoaXRlc3BhY2VcclxuICAgIGxldCBjbGVhbmVkVGV4dCA9IHRleHQuc2xpY2UoKTtcclxuICAgIGV4aXN0aW5nVGFncy5mb3JFYWNoKGV4aXN0aW5nU3NtbCA9PiB7XHJcbiAgICAgIGNvbnN0IHdoaXRlc3BhY2UgPSBuZXcgQXJyYXkoZXhpc3RpbmdTc21sLnRleHQubGVuZ3RoICsgMSkuam9pbignICcpO1xyXG4gICAgICBjbGVhbmVkVGV4dCA9IFtcclxuICAgICAgICBjbGVhbmVkVGV4dC5zbGljZSgwLCBleGlzdGluZ1NzbWwuc3RhcnQpLFxyXG4gICAgICAgIHdoaXRlc3BhY2UsXHJcbiAgICAgICAgY2xlYW5lZFRleHQuc2xpY2UoZXhpc3RpbmdTc21sLmVuZCksXHJcbiAgICAgIF0uam9pbignJyk7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCBzZW50ZW5jZUVuZEluZGljZXMgPSB0aGlzLl9nZXRTZW50ZW5jZUVuZHMoY2xlYW5lZFRleHQpO1xyXG5cclxuICAgIC8vIE9ubHkgaW5zZXJ0IHJhbmRvbSBtYXJrcyBpbnRvIHNlbnRlbmNlcyB0aGF0IGRvbid0IGFscmVhZHkgaGF2ZSBhbnlcclxuICAgIGxldCBwcmV2SW5kZXggPSAwO1xyXG4gICAgY29uc3QgdGFyZ2V0SW5kaWNlcyA9IHNlbnRlbmNlRW5kSW5kaWNlcy5maWx0ZXIoaW5kZXggPT4ge1xyXG4gICAgICBjb25zdCBjb250YWluc01hcmsgPVxyXG4gICAgICAgIG1hcmtJbmRpY2VzLmZpbmRJbmRleChtYXJrSW5kZXggPT4ge1xyXG4gICAgICAgICAgcmV0dXJuIHByZXZJbmRleCA8PSBtYXJrSW5kZXggJiYgaW5kZXggPiBtYXJrSW5kZXg7XHJcbiAgICAgICAgfSkgIT09IC0xO1xyXG4gICAgICBwcmV2SW5kZXggPSBpbmRleDtcclxuICAgICAgcmV0dXJuICFjb250YWluc01hcms7XHJcbiAgICB9KTtcclxuXHJcbiAgICBjb25zdCByYW5kb21NYXJrZWRUZXh0ID0gdGhpcy5faW5zZXJ0UmFuZG9tTWFya3NBdChcclxuICAgICAgdGV4dCxcclxuICAgICAgdGFyZ2V0SW5kaWNlcyxcclxuICAgICAgbWFya3NcclxuICAgICk7XHJcblxyXG4gICAgcmV0dXJuIHJhbmRvbU1hcmtlZFRleHQ7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZW5lcmF0ZSBhIHZlcnNpb24gb2YgZ2l2ZW4gdGV4dCB0aGF0IGlzIGVuY2xvc2VkIGJ5IFBvbGx5IHNzbWwgc3BlYWsgdGFncy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gVGhlIHRleHQgdG8gdmFsaWRhdGUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfSAtIFVwZGF0ZWQgaW5wdXQgc3RyaW5nLlxyXG4gICAqL1xyXG4gIHN0YXRpYyB2YWxpZGF0ZVRleHQodGV4dCkge1xyXG4gICAgaWYgKCF0ZXh0KSB7XHJcbiAgICAgIHRleHQgPSAnPHNwZWFrPjwvc3BlYWs+JztcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHRleHQgPSB0ZXh0XHJcbiAgICAgICAgLnJlcGxhY2UoLyheXFxzKjxcXHMqc3BlYWtcXHMqKT5cXHMqfCheXFxzKikvLCAnPHNwZWFrPicpXHJcbiAgICAgICAgLnJlcGxhY2UoLyhcXHMqPFxccypcXC9cXHMqc3BlYWtcXHMqPlxccyokfFxccyokKS8sICc8L3NwZWFrPicpO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB0ZXh0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGFyc2UgYW4gaW5wdXQgc3RyaW5nIGFuZCBpbnNlcnQgU1NNTCBtYXJrcyBiYXNlZCBvblxyXG4gICAqIHdvcmQgbWF0Y2hlcyBpbiBhIG1hcC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIElucHV0IHN0cmluZy5cclxuICAgKiBAcGFyYW0ge0FycmF5LjxudW1iZXI+fSBbaW5kaWNlcyA9IFtdXSAtIEFuIGFycmF5IG9mIGluZGljZXMgaW4gdGhlIHRleHQgaW5wdXRcclxuICAgKiB3aGVyZSByYW5kb20gbWFya3Mgc2hvdWxkIGJlIGluc2VydGVkLlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IFttYXJrcyA9IFtdXSAtIEFuIGFycmF5IG9mIG1hcmsgc3RyaW5ncyB0byBjaG9vc2VcclxuICAgKiBmcm9tIHdoZW4gaW5zZXJ0aW5nIHJhbmRvbSBtYXJrcy5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVXBkYXRlZCBpbnB1dCBzdHJpbmcuXHJcbiAgICovXHJcbiAgc3RhdGljIF9pbnNlcnRSYW5kb21NYXJrc0F0KHRleHQsIGluZGljZXMgPSBbXSwgbWFya3MgPSBbXSkge1xyXG4gICAgaWYgKCFtYXJrcyB8fCBtYXJrcy5sZW5ndGggPT09IDAgfHwgIWluZGljZXMgfHwgaW5kaWNlcy5sZW5ndGggPT09IDApIHtcclxuICAgICAgcmV0dXJuIHRleHQ7XHJcbiAgICB9XHJcblxyXG4gICAgbGV0IG9mZnNldCA9IDA7XHJcbiAgICBpbmRpY2VzLmZvckVhY2goaW5kZXggPT4ge1xyXG4gICAgICBjb25zdCByYW5kb21NYXJrID0gYDxtYXJrIG5hbWU9JyR7XHJcbiAgICAgICAgbWFya3NbVXRpbHMuZ2V0UmFuZG9tSW50KDAsIG1hcmtzLmxlbmd0aCldXHJcbiAgICAgIH0nLz5gO1xyXG4gICAgICB0ZXh0ID0gW1xyXG4gICAgICAgIHRleHQuc2xpY2UoMCwgaW5kZXggKyBvZmZzZXQpLFxyXG4gICAgICAgIHJhbmRvbU1hcmssXHJcbiAgICAgICAgdGV4dC5zbGljZShpbmRleCArIG9mZnNldCksXHJcbiAgICAgIF0uam9pbignJyk7XHJcbiAgICAgIG9mZnNldCArPSByYW5kb21NYXJrLmxlbmd0aDtcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiB0ZXh0O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUGFyc2VzIGEgc3RyaW5nIG9mIHRleHQgYW5kIHJldHVybnMgYW4gYXJyYXkgY29udGFpbmluZyB0aGUgaW5kaWNlc1xyXG4gICAqIG9mIHRoZSBsYXN0IGNoYXJhY3RlciBpbiBhIHNlbnRlbmNlIHRoYXQgaXMgbm90IGluIHRoZSBmb2xsb3dpbmcgbGlzdDpcclxuICAgKiAgKCcuJywgJz8nLCAnIScpXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBUZXh0IHRvIHByb2Nlc3MgZm9yIGVuZCBvZiBzZW50ZW5jZVxyXG4gICAqIGluZGljZXMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7QXJyYXkuPG51bWJlcj59IC0gQXJyYXkgb2YgZW5kIG9mIHNlbnRlbmNlIGluZGljZXMuXHJcbiAgICovXHJcbiAgc3RhdGljIF9nZXRTZW50ZW5jZUVuZHModGV4dCkge1xyXG4gICAgY29uc3Qgc2VudGVuY2VSZWdleCA9IC9bXi4hP10rWy4hP10rL2c7XHJcbiAgICBjb25zdCBlbmRTZW50ZW5jZVJlZ2V4ID0gL1suIT9dKy87XHJcblxyXG4gICAgbGV0IHJlc3VsdCA9IHNlbnRlbmNlUmVnZXguZXhlYyh0ZXh0KTtcclxuICAgIGNvbnN0IHNlbnRlbmNlRW5kcyA9IFtdO1xyXG4gICAgd2hpbGUgKHJlc3VsdCAhPT0gbnVsbCkge1xyXG4gICAgICAvLyBmaW5kIHRoZSBsYXN0IG5vbi1wdW5jdHVhdGlvbiBjaGFyYWN0ZXJcclxuICAgICAgY29uc3QgcHVuY3RSZXN1bHQgPSBlbmRTZW50ZW5jZVJlZ2V4LmV4ZWMocmVzdWx0WzBdKTtcclxuICAgICAgc2VudGVuY2VFbmRzLnB1c2goXHJcbiAgICAgICAgcmVzdWx0LmluZGV4ICsgcmVzdWx0WzBdLmxlbmd0aCAtIHB1bmN0UmVzdWx0WzBdLmxlbmd0aFxyXG4gICAgICApO1xyXG4gICAgICByZXN1bHQgPSBzZW50ZW5jZVJlZ2V4LmV4ZWModGV4dCk7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIHNlbnRlbmNlRW5kcztcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFBhcnNlIGFuIGlucHV0IHN0cmluZyBhbmQgaW5zZXJ0IFNTTUwgbWFya3MgYmFzZWQgb25cclxuICAgKiB3b3JkIG1hdGNoZXMgaW4gYSBtYXAuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBJbnB1dCBzdHJpbmcuXHJcbiAgICogQHBhcmFtIHtNYXB9IG1hcCAtIE1hcHBpbmcgb2Ygd29yZHMgdG8gbWFyayB2YWx1ZXMgdGhhdFxyXG4gICAqIHdpbGwgYmUgaW5zZXJ0ZWQgYXMgdGhlIHZhbHVlIGZvciBhIG1hcmsncyAnbmFtZScgYXR0cmlidXRlLlxyXG4gICAqIEBwYXJhbSB7QXJyYXl9IGR1cGxpY2F0ZXNUb0NoZWNrIC0gQSBsaXN0IG9mIG1hcmsgdmFsdWVzIHRvIGNoZWNrIGZvciBkdXBsaWNhdGUgYWdhaW5zdCB0aGUgZmlyc3Qgd29yZFxyXG4gICAqXHJcbiAgICogQHJldHVybnMge3N0cmluZ30gLSBVcGRhdGVkIGlucHV0IHN0cmluZy5cclxuICAgKi9cclxuICBzdGF0aWMgX2luc2VydE1hcmtzKHRleHQsIG1hcCwgZHVwbGljYXRlc1RvQ2hlY2spIHtcclxuICAgIGlmICh0ZXh0ID09PSAnJykgcmV0dXJuIHRleHQ7XHJcblxyXG4gICAgY29uc3Qgd29yZFJlZ2V4ID0gL1xcdyt8XFxzK3xbXlxcc1xcd10rL2c7XHJcblxyXG4gICAgbGV0IGxvd2VyQ2FzZVdvcmQ7XHJcbiAgICBsZXQgY2hlY2tEdXBsaWNhdGUgPSB0cnVlO1xyXG4gICAgY29uc3QgbWFya2VkV29yZHMgPSB0ZXh0Lm1hdGNoKHdvcmRSZWdleCkubWFwKHdvcmQgPT4ge1xyXG4gICAgICBsb3dlckNhc2VXb3JkID0gd29yZC50b0xvd2VyQ2FzZSgpO1xyXG5cclxuICAgICAgaWYgKG1hcC5oYXMobG93ZXJDYXNlV29yZCkpIHtcclxuICAgICAgICBjb25zdCBtYXJrcyA9IG1hcC5nZXQobG93ZXJDYXNlV29yZCkubWFwKG1hcmsgPT4ge1xyXG4gICAgICAgICAgaWYgKGNoZWNrRHVwbGljYXRlKSB7XHJcbiAgICAgICAgICAgIGNoZWNrRHVwbGljYXRlID0gZmFsc2U7XHJcbiAgICAgICAgICAgIHJldHVybiBkdXBsaWNhdGVzVG9DaGVjay5pbmNsdWRlcyhtYXJrKVxyXG4gICAgICAgICAgICAgID8gJydcclxuICAgICAgICAgICAgICA6IGA8bWFyayBuYW1lPScke21hcmt9Jy8+YDtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJldHVybiBgPG1hcmsgbmFtZT0nJHttYXJrfScvPmA7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfSk7XHJcbiAgICAgICAgcmV0dXJuIGAke21hcmtzLmpvaW4oJycpfSR7d29yZH1gO1xyXG4gICAgICB9IGVsc2Uge1xyXG4gICAgICAgIGNoZWNrRHVwbGljYXRlID0gZmFsc2U7XHJcbiAgICAgICAgcmV0dXJuIHdvcmQ7XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG5cclxuICAgIGNvbnN0IGV4aXN0aW5nTWFya3MgPSBkdXBsaWNhdGVzVG9DaGVjay5tYXAobWFyayA9PiB7XHJcbiAgICAgIHJldHVybiBgPG1hcmsgbmFtZT0nJHttYXJrfScvPmA7XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gYCR7ZXhpc3RpbmdNYXJrcy5qb2luKCcnKX0ke21hcmtlZFdvcmRzLmpvaW4oJycpfWA7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQcm9jZXNzZXMgYW4gaW5wdXQgb2JqZWN0IGZvciBtYXBwaW5nIGFuIGFycmF5XHJcbiAgICogb2Ygd29yZHMgdG8gc3BlY2lmaWMgbWFyayBrZXlzLiBDb252ZXJ0cyB0aGUgaW5wdXRcclxuICAgKiBtYXAgaW50byBhIE1hcCB3aXRoIGEgbW9yZSBlZmZpY2llbnQgZm9ybWF0IGZvclxyXG4gICAqIHBlcmZvcm1pbmcgbWFyayBpbmplY3Rpb24uXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtvYmplY3R9IG1hcCAtIElucHV0IG9iamVjdCB0aGF0IG1hcHMgbWFyayBrZXlzXHJcbiAgICogdG8gYXJyYXlzIG9mIHdvcmRzLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge01hcH0gLSBNYXAgZm9yIGludGVybmFsIHVzZS5cclxuICAgKi9cclxuICBzdGF0aWMgX3Byb2Nlc3NJbnB1dE1hcChtYXApIHtcclxuICAgIGNvbnN0IGludGVybmFsTWFwID0gbmV3IE1hcCgpO1xyXG5cclxuICAgIGxldCBsaXN0ID0gW107XHJcbiAgICBPYmplY3QuZW50cmllcyhtYXApLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xyXG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxyXG4gICAgICAgICAgYENhbm5vdCBnZW5lcmF0ZSBTU01MIG1hcmtzIGZyb20gbWFwIFwiJHttYXB9XCIgYmVjYXVzZSB2YWx1ZSBmb3Iga2V5ICcke2tleX0nIGlzIG5vdCBhbiBhcnJheS5gXHJcbiAgICAgICAgKTtcclxuICAgICAgfVxyXG5cclxuICAgICAgdmFsdWUuZm9yRWFjaCh3b3JkID0+IHtcclxuICAgICAgICBjb25zdCBsb3dlckNhc2VXb3JkID0gd29yZC50b0xvd2VyQ2FzZSgpO1xyXG4gICAgICAgIGxpc3QgPSBpbnRlcm5hbE1hcC5nZXQobG93ZXJDYXNlV29yZCk7XHJcblxyXG4gICAgICAgIGlmIChsaXN0ICE9PSB1bmRlZmluZWQgJiYgIWxpc3QuaW5jbHVkZXMoa2V5KSkge1xyXG4gICAgICAgICAgaW50ZXJuYWxNYXAuc2V0KGxvd2VyQ2FzZVdvcmQsIFsuLi5saXN0LCBrZXldKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgaW50ZXJuYWxNYXAuc2V0KGxvd2VyQ2FzZVdvcmQsIFtrZXldKTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGludGVybmFsTWFwO1xyXG4gIH1cclxufVxyXG5cclxuZXhwb3J0IGRlZmF1bHQgVGV4dFRvU3BlZWNoVXRpbHM7XHJcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcclxuaW1wb3J0IEFic3RyYWN0SG9zdEZlYXR1cmUgZnJvbSAnY29yZS9BYnN0cmFjdEhvc3RGZWF0dXJlJztcclxuaW1wb3J0IEFuaW1hdGlvblV0aWxzIGZyb20gJ2NvcmUvYW5pbXBhY2svQW5pbWF0aW9uVXRpbHMnO1xyXG5pbXBvcnQgTWF0aFV0aWxzIGZyb20gJ2NvcmUvTWF0aFV0aWxzJztcclxuaW1wb3J0IERlZmVycmVkIGZyb20gJ2NvcmUvRGVmZXJyZWQnO1xyXG5pbXBvcnQgU3BlZWNoIGZyb20gJy4vQWJzdHJhY3RTcGVlY2gnO1xyXG5pbXBvcnQgVGV4dFRvU3BlZWNoVXRpbHMgZnJvbSAnLi9UZXh0VG9TcGVlY2hVdGlscyc7XHJcblxyXG4vKipcclxuICogVGhlIEFtYXpvbiBQb2xseSBzZXJ2aWNlIG9iamVjdC5cclxuICogQGV4dGVybmFsIFBvbGx5XHJcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FXU0phdmFTY3JpcHRTREsvbGF0ZXN0L0FXUy9Qb2xseS5odG1sXHJcbiAqL1xyXG5cclxuLyoqXHJcbiAqIFRoZSBwcmVzaWduZXIgb2JqZWN0IHRoYXQgY2FuIGJlIHVzZWQgdG8gZ2VuZXJhdGUgcHJlc2lnbmVkIHVybHMgZm9yIHRoZSBQb2xseSBzZXJ2aWNlLlxyXG4gKiBAZXh0ZXJuYWwgUHJlc2lnbmVyXHJcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL0FXU0phdmFTY3JpcHRTREsvbGF0ZXN0L0FXUy9Qb2xseS9QcmVzaWduZXIuaHRtbFxyXG4gKi9cclxuXHJcbi8vIEF2YWlsYWJsZSBvcHRpb25zIGZvciBQb2xseVxyXG5jb25zdCBlbmdpbmVzID0gWydzdGFuZGFyZCcsICduZXVyYWwnXTtcclxuY29uc3QgYXVkaW9Gb3JtYXRzID0gWydtcDMnLCAnb2dnX3ZvcmJpcycsICdwY20nXTtcclxuY29uc3Qgc3BlZWNobWFya1R5cGVzID0gWydzZW50ZW5jZScsICdzc21sJywgJ3Zpc2VtZScsICd3b3JkJ107XHJcbmNvbnN0IHNhbXBsZVJhdGVzID0ge1xyXG4gIG1wMzoge1xyXG4gICAgcmF0ZXM6IFsnODAwMCcsICcxNjAwMCcsICcyMjA1MCcsICcyNDAwMCddLFxyXG4gICAgZGVmYXVsdHM6IHtcclxuICAgICAgc3RhbmRhcmQ6ICcyMDUwJyxcclxuICAgICAgbmV1cmFsOiAnMjQwMCcsXHJcbiAgICB9LFxyXG4gIH0sXHJcbiAgcGNtOiB7XHJcbiAgICByYXRlczogWyc4MDAwJywgJzE2MDAwJ10sXHJcbiAgICBkZWZhdWx0czoge1xyXG4gICAgICBzdGFuZGFyZDogJzE2MDAnLFxyXG4gICAgICBuZXVyYWw6ICcxNjAwJyxcclxuICAgIH0sXHJcbiAgfSxcclxufTtcclxuc2FtcGxlUmF0ZXMub2dnX3ZvcmJpcyA9IHNhbXBsZVJhdGVzLm1wMztcclxubGV0IGF3c1ZlcnNpb247XHJcblxyXG4vKipcclxuICogQmFzZSBjbGFzcyBmb3IgdHVybmluZyB0ZXh0IGlucHV0IGludG8gcGxheWFibGUgYXVkaW8uIFRoZXJlIHNob3VsZCBiZSBvbmUgaW5zdGFuY2VcclxuICogcGVyIHNwZWFrZXIsIGVhY2ggaW5zdGFuY2UgY2FuIHBsYXkgb25seSBvbmUgcGllY2Ugb2YgdGV4dCBhdCBhIHRpbWUuXHJcbiAqXHJcbiAqIEBleHRlbmRzIEFic3RyYWN0SG9zdEZlYXR1cmVcclxuICogQGFic3RyYWN0XHJcbiAqXHJcbiAqIEBwcm9wZXJ0eSB7KG51bWJlcnx1bmRlZmluZWQpfSBBV1NfVkVSU0lPTiAtIEdldHMgdGhlIHZlcnNpb24gb2YgQVdTIFNESyBiZWluZ1xyXG4gKiB1c2VkLiBXaWxsIGJlIHVuZGVmaW5lZCB1bnRpbCBbaW5pdGlhbGl6ZVNlcnZpY2Vde0BsaW5rIEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZS5pbml0aWFsaXplU2VydmljZX1cclxuICogaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGV4ZWN1dGVkLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW1BPTExZX01JTl9ORVVSQUxfVkVSU0lPTj0nMi41MDMnXSAtIEdldHMgdGhlIG1pbmltdW0gdmVyc2lvblxyXG4gKiBvZiB0aGUgQVdTIFNESyB0aGF0IGlzIG5lY2Vzc2FyeSB0byB1c2UgbmV1cmFsIHZvaWNlcyB3aXRoIEFXUyBQb2xseS5cclxuICogQHByb3BlcnR5IHtPYmplY3R9IFBPTExZX0RFRkFVTFRTIC0gRGVmYXVsdCB2YWx1ZXMgdG8gdXNlIHdpdGggY2FsbHMgdG8ge0BsaW5rIGV4dGVybmFsOlBvbGx5fS5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtQT0xMWV9ERUZBVUxUUy5FbmdpbmU9J3N0YW5kYXJkJ11cclxuICogQHByb3BlcnR5IHtBcnJheS48c3RyaW5nPn0gW1BPTExZX0RFRkFVTFRTLkxleGljb25OYW1lcz1bXV1cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtQT0xMWV9ERUZBVUxUUy5PdXRwdXRGb3JtYXQ9J21wMyddXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbUE9MTFlfREVGQVVMVFMuU2FtcGxlUmF0ZT0nMjIwNTAnXVxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW1BPTExZX0RFRkFVTFRTLlRleHQ9JyddXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbUE9MTFlfREVGQVVMVFMuVGV4dFR5cGU9J3NzbWwnXVxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW1BPTExZX0RFRkFVTFRTLlZvaWNlSWQ9J0FteSddXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbUE9MTFlfREVGQVVMVFMuTGFuZ3VhZ2VDb2RlPSdlbi1HQiddXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbUE9MTFlfREVGQVVMVFMuTGFuZ3VhZ2VOYW1lPSdCcml0aXNoIEVuZ2xpc2gnXVxyXG4gKiBAcHJvcGVydHkge0FycmF5LjxzdHJpbmc+fSBbUE9MTFlfVk9JQ0VTPVtdXSAtIEFuIGFycmF5IG9mIHZvaWNlcyBhdmFpbGFibGUgaW5cclxuICogUG9sbHkuIFdpbGwgYmUgZW1wdHkgdW50aWwgW2luaXRpYWxpemVTZXJ2aWNlXXtAbGluayBBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUuaW5pdGlhbGl6ZVNlcnZpY2V9XHJcbiAqIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBleGVjdXRlZC4gU2VlIFtQb2xseSBEb2N1bWVudGF0aW9uXXtAbGluayBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vcG9sbHkvbGF0ZXN0L2RnL3ZvaWNlbGlzdC5odG1sfVxyXG4gKiBmb3IgYSBmdWxsIGxpc3Qgb2YgYXZhaWxhYmxlIHZvaWNlcy5cclxuICogQHByb3BlcnR5IHtPYmplY3R9IFtQT0xMWV9MQU5HVUFHRVM9e31dIC0gQW4gb2JqZWN0IHRoYXQgbWFwcyBsYW5ndWFnZSBuYW1lc1xyXG4gKiB0byBsYW5ndWFnZSBjb2RlcyB0aGF0IGFyZSBhdmFpbGFibGUgaW4gUG9sbHkuIFdpbGwgYmUgZW1wdHkgdW50aWxcclxuICogW2luaXRpYWxpemVTZXJ2aWNlXXtAbGluayBBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUuaW5pdGlhbGl6ZVNlcnZpY2V9XHJcbiAqIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBleGVjdXRlZC4gU2VlIFtQb2xseSBEb2N1bWVudGF0aW9uXXtAbGluayBodHRwczovL2RvY3MuYXdzLmFtYXpvbi5jb20vcG9sbHkvbGF0ZXN0L2RnL1N1cHBvcnRlZExhbmd1YWdlLmh0bWx9XHJcbiAqIGZvciBhIGZ1bGwgbGlzdCBvZiBhdmFpbGFibGUgbGFuZ3VhZ2VzIGFuZCBjb3JyZXNwb25kaW5nIGNvZGVzLlxyXG4gKiBAcHJvcGVydHkge09iamVjdH0gW1BPTExZX0xBTkdVQUdFX0NPREVTPXt9XSAtIEFuIG9iamVjdCB0aGF0IG1hcHMgbGFuZ3VhZ2UgY29kZXNcclxuICogdG8gbGFuZ3VhZ2UgbmFtZXMgdGhhdCBhcmUgYXZhaWxhYmxlIGluIFBvbGx5LiBXaWxsIGJlIGVtcHR5IHVudGlsXHJcbiAqIFtpbml0aWFsaXplU2VydmljZV17QGxpbmsgQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlLmluaXRpYWxpemVTZXJ2aWNlfVxyXG4gKiBoYXMgYmVlbiBzdWNjZXNzZnVsbHkgZXhlY3V0ZWQuIFNlZSBbUG9sbHkgRG9jdW1lbnRhdGlvbl17QGxpbmsgaHR0cHM6Ly9kb2NzLmF3cy5hbWF6b24uY29tL3BvbGx5L2xhdGVzdC9kZy9TdXBwb3J0ZWRMYW5ndWFnZS5odG1sfVxyXG4gKiBmb3IgYSBmdWxsIGxpc3Qgb2YgYXZhaWxhYmxlIGxhbmd1YWdlcyBhbmQgY29ycmVzcG9uZGluZyBjb2Rlcy5cclxuICogQHByb3BlcnR5IHtPYmplY3R9IEVWRU5UUyAtIEJ1aWx0LWluIG1lc3NhZ2VzIHRoYXQgdGhlIGZlYXR1cmUgZW1pdHMuIFdoZW4gdGhlXHJcbiAqIGZlYXR1cmUgaXMgYWRkZWQgdG8gYSB7QGxpbmsgY29yZS9Ib3N0T2JqZWN0fSwgZXZlbnQgbmFtZXMgd2lsbCBiZSBwcmVmaXhlZCBieSB0aGVcclxuICogbmFtZSBvZiB0aGUgZmVhdHVyZSBjbGFzcyArICcuJy5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVFMucmVhZHk9b25SZWFkeUV2ZW50XSAtIE1lc3NhZ2UgdGhhdCBpcyBlbWl0dGVkIGFmdGVyXHJcbiAqIFtpbml0aWFsaXplU2VydmljZV17QGxpbmsgQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlLmluaXRpYWxpemVTZXJ2aWNlfSBoYXMgYmVlblxyXG4gKiBzdWNjZXNzZnVsbHkgZXhlY3V0ZWQuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRTLnBsYXk9b25QbGF5RXZlbnRdIC0gTWVzc2FnZSB0aGF0IGlzIGVtaXR0ZWQgYWZ0ZXJcclxuICogZWFjaCBjYWxsIHRvIFtwbGF5XXtAbGluayBBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUjcGxheX0uIFRoZSBzcGVlY2ggdGhhdCB3YXMgcGxheWVkXHJcbiAqIGlzIHN1cHBsaWVkIGFzIGFuIGFyZ3VtZW50IHRvIGxpc3RlbmVyIGZ1bmN0aW9ucy5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVFMucGF1c2U9b25QYXVzZUV2ZW50XSAtIE1lc3NhZ2UgdGhhdCBpcyBlbWl0dGVkIGFmdGVyXHJcbiAqIGVhY2ggY2FsbCB0byBbcGF1c2Vde0BsaW5rIEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZSNwYXVzZX0uIFRoZSBzcGVlY2ggdGhhdCB3YXMgcGF1c2VkXHJcbiAqIGlzIHN1cHBsaWVkIGFzIGFuIGFyZ3VtZW50IHRvIGxpc3RlbmVyIGZ1bmN0aW9ucy5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVFMucmVzdW1lPW9uUmVzdW1lRXZlbnRdIC0gTWVzc2FnZSB0aGF0IGlzIGVtaXR0ZWQgYWZ0ZXJcclxuICogZWFjaCBjYWxsIHRvIFtyZXN1bWVde0BsaW5rIEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZSNyZXN1bWV9LiBUaGUgc3BlZWNoIHRoYXQgd2FzXHJcbiAqIHJlc3VtZWQgaXMgc3VwcGxpZWQgYXMgYW4gYXJndW1lbnQgdG8gbGlzdGVuZXIgZnVuY3Rpb25zLlxyXG4gKiBAcHJvcGVydHkge3N0cmluZ30gW0VWRU5UUy5pbnRlcnJ1cHQ9b25JbnRlcnJ1cHRFdmVudF0gLSBNZXNzYWdlIHRoYXQgaXMgZW1pdHRlZFxyXG4gKiBpZiB0aGVyZSBpcyBhIGN1cnJlbnQgc3BlZWNoIGluIHByb2dyZXNzIGFuZCBbcGxheV17QGxpbmsgQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlI3BsYXl9XHJcbiAqIG9yIFtyZXN1bWVde0BsaW5rIEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZSNyZXN1bWV9IGFyZSBleGVjdXRlZCBmb3IgYSBuZXcgc3BlZWNoLlxyXG4gKiBUaGUgc3BlZWNoIHRoYXQgd2FzIGludGVycnVwdGVkIGlzIHN1cHBsaWVkIGFzIGFuIGFyZ3VtZW50IHRvIGxpc3RlbmVyIGZ1bmN0aW9ucy5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVFMuc3RvcD1vblN0b3BFdmVudF0gLSBNZXNzYWdlIHRoYXQgaXMgZW1pdHRlZCBhZnRlclxyXG4gKiBlYWNoIGNhbGwgdG8gW3N0b3Bde0BsaW5rIEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZSNzdG9wfSBhbmQgd2hlbiBhIHNwZWVjaCByZWFjaGVzXHJcbiAqIHRoZSBlbmQgb2YgcGxheWJhY2suIFRoZSBzcGVlY2ggdGhhdCB3YXMgc3RvcHBlZCBpcyBzdXBwbGllZCBhcyBhbiBhcmd1bWVudFxyXG4gKiB0byBsaXN0ZW5lciBmdW5jdGlvbnMuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRTLnNlbnRlbmNlPW9uU2VudGVuY2VFdmVudF0gLSBNZXNzYWdlIHRoYXQgaXMgZW1pdHRlZFxyXG4gKiBlYWNoIHRpbWUgYSBzZW50ZW5jZSBzcGVlY2htYXJrIGlzIGVuY291bnRlcmVkIHdob3NlIHRpbWVzdGFtcCBtYXRjaGVzIHVwIHdpdGhcclxuICogdGhlIHNwZWVjaCBhdWRpbydzIGN1cnJlbnQgdGltZS4gVGhlIHNlbnRlbmNlIHNwZWVjaG1hcmsgb2JqZWN0IGlzIHN1cHBsaWVkIGFzXHJcbiAqIGFuIGFyZ3VtZW50IHRvIGxpc3RlbmVyIGZ1bmN0aW9ucy5cclxuICogQHByb3BlcnR5IHtzdHJpbmd9IFtFVkVOVFMud29yZD1vbldvcmRFdmVudF0gLSBNZXNzYWdlIHRoYXQgaXMgZW1pdHRlZFxyXG4gKiBlYWNoIHRpbWUgYSB3b3JkIHNwZWVjaG1hcmsgaXMgZW5jb3VudGVyZWQgd2hvc2UgdGltZXN0YW1wIG1hdGNoZXMgdXAgd2l0aFxyXG4gKiB0aGUgc3BlZWNoIGF1ZGlvJ3MgY3VycmVudCB0aW1lLiBUaGUgd29yZCBzcGVlY2htYXJrIG9iamVjdCBpcyBzdXBwbGllZCBhc1xyXG4gKiBhbiBhcmd1bWVudCB0byBsaXN0ZW5lciBmdW5jdGlvbnMuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRTLnZpc2VtZT1vblZpc2VtZUV2ZW50XSAtIE1lc3NhZ2UgdGhhdCBpcyBlbWl0dGVkXHJcbiAqIGVhY2ggdGltZSBhIHZpc2VtZSBzcGVlY2htYXJrIGlzIGVuY291bnRlcmVkIHdob3NlIHRpbWVzdGFtcCBtYXRjaGVzIHVwIHdpdGhcclxuICogdGhlIHNwZWVjaCBhdWRpbydzIGN1cnJlbnQgdGltZS4gVGhlIHZpc2VtZSBzcGVlY2htYXJrIG9iamVjdCBpcyBzdXBwbGllZCBhc1xyXG4gKiBhbiBhcmd1bWVudCB0byBsaXN0ZW5lciBmdW5jdGlvbnMuXHJcbiAqIEBwcm9wZXJ0eSB7c3RyaW5nfSBbRVZFTlRTLnNzbWw9b25Tc21sRXZlbnRdIC0gTWVzc2FnZSB0aGF0IGlzIGVtaXR0ZWRcclxuICogZWFjaCB0aW1lIGEgc3NtbCBzcGVlY2htYXJrIGlzIGVuY291bnRlcmVkIHdob3NlIHRpbWVzdGFtcCBtYXRjaGVzIHVwIHdpdGhcclxuICogdGhlIHNwZWVjaCBhdWRpbydzIGN1cnJlbnQgdGltZS4gVGhlIHNzbWwgc3BlZWNobWFyayBvYmplY3QgaXMgc3VwcGxpZWQgYXNcclxuICogYW4gYXJndW1lbnQgdG8gbGlzdGVuZXIgZnVuY3Rpb25zLlxyXG4gKiBAcHJvcGVydHkge09iamVjdH0gU0VSVklDRVMgLSBBV1Mgc2VydmljZXMgdGhhdCBhcmUgbmVjZXNzYXJ5IGZvciB0aGUgZmVhdHVyZVxyXG4gKiB0byBmdW5jdGlvbi5cclxuICogQHByb3BlcnR5IHtleHRlcm5hbDpQb2xseX0gU0VSVklDRVMucG9sbHkgLSBUaGUgUG9sbHkgc2VydmljZSB0aGF0IGlzIHVzZWRcclxuICogdG8gc3ludGhlc2l6ZSBzcGVlY2htYXJrcy4gV2lsbCBiZSB1bmRlZmluZWQgdW50aWwgW2luaXRpYWxpemVTZXJ2aWNlXXtAbGluayBBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUuaW5pdGlhbGl6ZVNlcnZpY2V9XHJcbiAqIGhhcyBiZWVuIHN1Y2Nlc3NmdWxseSBleGVjdXRlZFxyXG4gKiBAcHJvcGVydHkge2V4dGVybmFsOlByZXNpZ25lcn0gU0VSVklDRVMucHJlc2lnbmVyIC0gVGhlIFBvbGx5IFByZXNpZ25lclxyXG4gKiBvYmplY3QgdGhhdCBpcyB1c2VkIHRvIHN5bnRoZXNpemUgc3BlZWNoIGF1ZGlvLiBXaWxsIGJlIHVuZGVmaW5lZCB1bnRpbFxyXG4gKiBbaW5pdGlhbGl6ZVNlcnZpY2Vde0BsaW5rIEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZS5pbml0aWFsaXplU2VydmljZX1cclxuICogaGFzIGJlZW4gc3VjY2Vzc2Z1bGx5IGV4ZWN1dGVkLlxyXG4gKi9cclxuY2xhc3MgQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlIGV4dGVuZHMgQWJzdHJhY3RIb3N0RmVhdHVyZSB7XHJcbiAgLyoqXHJcbiAgICogQGNvbnN0cnVjdG9yXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2NvcmUvSG9zdE9iamVjdH0gaG9zdCAtIEhvc3Qgb2JqZWN0IG1hbmFnaW5nIHRoZSBmZWF0dXJlLlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gb3B0aW9ucyAtIE9wdGlvbnMgdGhhdCB3aWxsIGJlIHNlbnQgdG8gUG9sbHkgZm9yIGVhY2ggc3BlZWNoLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0aW9ucy52b2ljZSAtIFRoZSBuYW1lIG9mIHRoZSBQb2xseSB2b2ljZSB0byB1c2UgZm9yIGFsbCBzcGVlY2guXHJcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRpb25zLmVuZ2luZSAtIFRoZSBuYW1lIG9mIHRoZSBQb2xseSBlbmdpbmUgdG8gdXNlIGZvciBhbGwgc3BlZWNoLlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nPX0gb3B0aW9ucy5sYW5ndWFnZSAtIFRoZSBuYW1lIG9mIHRoZSBsYW5ndWFnZSB0byB1c2UgZm9yIGFsbCBzcGVlY2guXHJcbiAgICogQHBhcmFtIHthdWRpb0Zvcm1hdH0gW29wdGlvbnMuYXVkaW9Gb3JtYXQ9J21wMyddIC0gVGhlIGZvcm1hdCB0byB1c2UgZm9yIGdlbmVyYXRlZFxyXG4gICAqIGF1ZGlvIGZvciBhbGwgc3BlZWNoZXMuXHJcbiAgICogQHBhcmFtIHtzdHJpbmc9fSBvcHRpb25zLnNhbXBsZVJhdGUgLSBUaGUgc2FtcGxlIHJhdGUgZm9yIGF1ZGlvIGZpbGVzIGZvciBhbGxcclxuICAgKiBzcGVlY2hlcy5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMuc3BlZWNobWFya09mZnNldD0wXSAtIEFtb3VudCBvZiB0aW1lIGluIHNlY29uZHMgdG9cclxuICAgKiBvZmZzZXQgc3BlZWNobWFyayBldmVudCBlbWlzc2lvbiBmcm9tIHRoZSBhdWRpby5cclxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdGlvbnMubWluRW5kTWFya0R1cmF0aW9uPS4wNV0gLSBUaGUgbWluaW11bSBhbW91bnQgb2YgdGltZVxyXG4gICAqIGluIHNlY29uZHMgdGhhdCB0aGUgbGFzdCBzcGVlY2htYXJrIG9mIGVhY2ggdHlwZSBpbiBhIHNwZWVjaCBjYW4gaGF2ZSBpdHNcclxuICAgKiBkdXJhdGlvbiBwcm9wZXJ0eSBzZXQgdG8uXHJcbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRpb25zLnZvbHVtZT0xXSAtIFRoZSBkZWZhdWx0IHZvbHVtZSB0byBwbGF5IHNwZWVjaCBhdWRpb1xyXG4gICAqIHdpdGguXHJcbiAgICogQHBhcmFtIHtib29sZWFufSBbb3B0aW9ucy5pc0dsb2JhbD1mYWxzZV0gLSBXaGV0aGVyIHRoZSBhdWRpbyBzb3VyY2Ugc2hvdWxkIGRlZmF1bHRcclxuICAgKiB0byBnbG9iYWwgcmVnYXJkbGVzcyBvZiB3aGV0aGVyIG9yIG5vdCBpdCBpcyBhdHRhY2hlZCB0byBhbiBvYmplY3QuXHJcbiAgICovXHJcbiAgY29uc3RydWN0b3IoXHJcbiAgICBob3N0LFxyXG4gICAgb3B0aW9ucyA9IHtcclxuICAgICAgdm9pY2U6IHVuZGVmaW5lZCxcclxuICAgICAgZW5naW5lOiB1bmRlZmluZWQsXHJcbiAgICAgIGxhbmd1YWdlOiB1bmRlZmluZWQsXHJcbiAgICAgIGF1ZGlvRm9ybWF0OiAnbXAzJyxcclxuICAgICAgc2FtcGxlUmF0ZTogdW5kZWZpbmVkLFxyXG4gICAgICBzcGVlY2htYXJrT2Zmc2V0OiAwLFxyXG4gICAgICBtaW5FbmRNYXJrRHVyYXRpb246IDAuMDUsXHJcbiAgICAgIHZvbHVtZTogMSxcclxuICAgICAgaXNHbG9iYWw6IGZhbHNlLFxyXG4gICAgfVxyXG4gICkge1xyXG4gICAgc3VwZXIoaG9zdCk7XHJcblxyXG4gICAgdGhpcy5fc3BlZWNoQ2FjaGUgPSB7fTtcclxuICAgIHRoaXMuX2N1cnJlbnRTcGVlY2ggPSBudWxsO1xyXG4gICAgdGhpcy5fY3VycmVudFByb21pc2UgPSBudWxsO1xyXG4gICAgdGhpcy5faXNWYWxpZGF0ZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuc3BlZWNobWFya09mZnNldCA9IE51bWJlci5pc05hTihOdW1iZXIob3B0aW9ucy5zcGVlY2htYXJrT2Zmc2V0KSlcclxuICAgICAgPyAwXHJcbiAgICAgIDogTnVtYmVyKG9wdGlvbnMuc3BlZWNobWFya09mZnNldCk7XHJcbiAgICB0aGlzLm1pbkVuZE1hcmtEdXJhdGlvbiA9IE51bWJlci5pc05hTihOdW1iZXIob3B0aW9ucy5taW5FbmRNYXJrRHVyYXRpb24pKVxyXG4gICAgICA/IDBcclxuICAgICAgOiBOdW1iZXIob3B0aW9ucy5taW5FbmRNYXJrRHVyYXRpb24pO1xyXG4gICAgdGhpcy52b2x1bWUgPSBOdW1iZXIuaXNOYU4oTnVtYmVyKG9wdGlvbnMudm9sdW1lKSlcclxuICAgICAgPyAxXHJcbiAgICAgIDogTnVtYmVyKG9wdGlvbnMudm9sdW1lKTtcclxuICAgIHRoaXMuX2lzR2xvYmFsID0gb3B0aW9ucy5pc0dsb2JhbCB8fCBmYWxzZTtcclxuICAgIHRoaXMuX3Byb21pc2VzID0ge1xyXG4gICAgICB2b2x1bWU6IERlZmVycmVkLnJlc29sdmUoKSxcclxuICAgIH07XHJcbiAgICB0aGlzLl92b2x1bWVQYXVzZWQgPSBmYWxzZTtcclxuXHJcbiAgICAvLyBTZXQgZGVmYXVsdCBvcHRpb25zIGZvciBlYWNoIHNwZWVjaFxyXG4gICAgdGhpcy5fdm9pY2UgPSBvcHRpb25zLnZvaWNlIHx8IHRoaXMuY29uc3RydWN0b3IuUE9MTFlfREVGQVVMVFMuVm9pY2VJZDtcclxuICAgIHRoaXMuX2xhbmd1YWdlID1cclxuICAgICAgb3B0aW9ucy5sYW5ndWFnZSB8fCB0aGlzLmNvbnN0cnVjdG9yLlBPTExZX0RFRkFVTFRTLkxhbmd1YWdlTmFtZTtcclxuICAgIHRoaXMuX2VuZ2luZSA9IGVuZ2luZXMuaW5jbHVkZXMob3B0aW9ucy5lbmdpbmUpXHJcbiAgICAgID8gb3B0aW9ucy5lbmdpbmVcclxuICAgICAgOiB0aGlzLmNvbnN0cnVjdG9yLlBPTExZX0RFRkFVTFRTLkVuZ2luZTtcclxuICAgIHRoaXMuX2F1ZGlvRm9ybWF0ID0gYXVkaW9Gb3JtYXRzLmluY2x1ZGVzKG9wdGlvbnMuYXVkaW9Gb3JtYXQpXHJcbiAgICAgID8gb3B0aW9ucy5hdWRpb0Zvcm1hdFxyXG4gICAgICA6IHRoaXMuY29uc3RydWN0b3IuUE9MTFlfREVGQVVMVFMuT3V0cHV0Rm9ybWF0O1xyXG4gICAgdGhpcy5fc2FtcGxlUmF0ZSA9IHNhbXBsZVJhdGVzW3RoaXMuX2F1ZGlvRm9ybWF0XS5yYXRlcy5pbmNsdWRlcyhcclxuICAgICAgb3B0aW9ucy5zYW1wbGVSYXRlXHJcbiAgICApXHJcbiAgICAgID8gb3B0aW9ucy5zYW1wbGVSYXRlXHJcbiAgICAgIDogdGhpcy5jb25zdHJ1Y3Rvci5QT0xMWV9ERUZBVUxUUy5TYW1wbGVSYXRlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RvcmUgUG9sbHksIFByZXNpZ25lciBhbmQgQVdTIFNESyBWZXJzaW9uIGZvciB1c2UgYWNyb3NzIGFsbCBpbnN0YW5jZXMuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge2V4dGVybmFsOlBvbGx5fSBwb2xseSAtIFBvbGx5IGluc3RhbmNlIHRvIHVzZSB0byBnZW5lcmF0ZSBzcGVlY2htYXJrcy5cclxuICAgKiBAcGFyYW0ge2V4dGVybmFsOlByZXNpZ25lcn0gcHJlc2lnbmVyIC0gUHJlc2lnbmVyIGluc3RhbmNlIHRvIHVzZSB0byBnZW5lcmF0ZVxyXG4gICAqIGF1ZGlvIFVSTHMuXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHZlcnNpb24gLSBWZXJzaW9uIG9mIHRoZSBBV1MgU0RLIHRvIHVzZSB0byB2YWxpZGF0ZSB2b2ljZSBvcHRpb25zLlxyXG4gICAqL1xyXG4gIHN0YXRpYyBpbml0aWFsaXplU2VydmljZShwb2xseSwgcHJlc2lnbmVyLCB2ZXJzaW9uKSB7XHJcbiAgICAvLyBNYWtlIHN1cmUgYWxsIHdlcmUgZGVmaW5lZFxyXG4gICAgaWYgKFxyXG4gICAgICBwb2xseSA9PT0gdW5kZWZpbmVkIHx8XHJcbiAgICAgIHByZXNpZ25lciA9PT0gdW5kZWZpbmVkIHx8XHJcbiAgICAgIHZlcnNpb24gPT09IHVuZGVmaW5lZFxyXG4gICAgKSB7XHJcbiAgICAgIHRocm93IG5ldyBFcnJvcihcclxuICAgICAgICAnQ2Fubm90IGluaXRpYWxpemUgVGV4dFRvU3BlZWNoIGZlYXR1cmUuIEFsbCBhcmd1bWVudHMgbXVzdCBiZSBkZWZpbmVkLidcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICAvLyBBZGQgc3VtZXJpYW4gaG9zdHMgdXNlci1hZ2VudFxyXG4gICAgaWYgKHBvbGx5LmNvbmZpZykge1xyXG4gICAgICBwb2xseS5jb25maWcuY3VzdG9tVXNlckFnZW50ID0gdGhpcy5fd2l0aEN1c3RvbVVzZXJBZ2VudChcclxuICAgICAgICBwb2xseS5jb25maWcuY3VzdG9tVXNlckFnZW50XHJcbiAgICAgICk7XHJcbiAgICB9XHJcbiAgICBpZiAocHJlc2lnbmVyLnNlcnZpY2UgJiYgcHJlc2lnbmVyLnNlcnZpY2UuY29uZmlnKSB7XHJcbiAgICAgIHByZXNpZ25lci5zZXJ2aWNlLmNvbmZpZy5jdXN0b21Vc2VyQWdlbnQgPSB0aGlzLl93aXRoQ3VzdG9tVXNlckFnZW50KFxyXG4gICAgICAgIHByZXNpZ25lci5zZXJ2aWNlLmNvbmZpZy5jdXN0b21Vc2VyQWdlbnRcclxuICAgICAgKTtcclxuICAgIH1cclxuXHJcbiAgICB0aGlzLl9pc1JlYWR5ID0gZmFsc2U7XHJcblxyXG4gICAgLy8gU3RvcmUgcGFyYW1ldGVyc1xyXG4gICAgdGhpcy5TRVJWSUNFUy5wb2xseSA9IHBvbGx5O1xyXG4gICAgdGhpcy5TRVJWSUNFUy5wcmVzaWduZXIgPSBwcmVzaWduZXI7XHJcbiAgICBhd3NWZXJzaW9uID0gdmVyc2lvbjtcclxuXHJcbiAgICAvLyBDbGVhciB0aGUgY3VycmVudCBwb2xseSBvYmplY3RzXHJcbiAgICBjb25zdCBhdmFpbGFibGVWb2ljZXMgPSB0aGlzLlBPTExZX1ZPSUNFUztcclxuICAgIGF2YWlsYWJsZVZvaWNlcy5sZW5ndGggPSAwO1xyXG5cclxuICAgIGNvbnN0IGF2YWlsYWJsZUxhbmd1YWdlcyA9IHRoaXMuUE9MTFlfTEFOR1VBR0VTO1xyXG4gICAgT2JqZWN0LmtleXMoYXZhaWxhYmxlTGFuZ3VhZ2VzKS5mb3JFYWNoKG5hbWUgPT4ge1xyXG4gICAgICBkZWxldGUgYXZhaWxhYmxlTGFuZ3VhZ2VzW25hbWVdO1xyXG4gICAgfSk7XHJcblxyXG4gICAgY29uc3QgYXZhaWxhYmxlTGFuZ3VhZ2VDb2RlcyA9IHRoaXMuUE9MTFlfTEFOR1VBR0VfQ09ERVM7XHJcbiAgICBPYmplY3Qua2V5cyhhdmFpbGFibGVMYW5ndWFnZUNvZGVzKS5mb3JFYWNoKG5hbWUgPT4ge1xyXG4gICAgICBkZWxldGUgYXZhaWxhYmxlTGFuZ3VhZ2VDb2Rlc1tuYW1lXTtcclxuICAgIH0pO1xyXG5cclxuICAgIC8vIFJlLXBvcHVsYXRlIGFjY29yZGluZyB0byB2ZXJzaW9uXHJcbiAgICBjb25zdCBtaW5OZXVyYWxTZGsgPSB0aGlzLlBPTExZX01JTl9ORVVSQUxfVkVSU0lPTjtcclxuXHJcbiAgICByZXR1cm4gdGhpcy5TRVJWSUNFUy5wb2xseVxyXG4gICAgICAuZGVzY3JpYmVWb2ljZXMoKVxyXG4gICAgICAucHJvbWlzZSgpXHJcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcclxuICAgICAgICBjb25zdCBhbGxDb2RlcyA9IHt9O1xyXG5cclxuICAgICAgICByZXNwb25zZS5Wb2ljZXMuZm9yRWFjaCh2b2ljZSA9PiB7XHJcbiAgICAgICAgICBpZiAoXHJcbiAgICAgICAgICAgIHZvaWNlLlN1cHBvcnRlZEVuZ2luZXMuaW5jbHVkZXMoJ3N0YW5kYXJkJykgfHxcclxuICAgICAgICAgICAgdmVyc2lvbiA+PSBtaW5OZXVyYWxTZGtcclxuICAgICAgICAgICkge1xyXG4gICAgICAgICAgICBhdmFpbGFibGVWb2ljZXMucHVzaCh2b2ljZSk7XHJcbiAgICAgICAgICB9XHJcblxyXG4gICAgICAgICAgYXZhaWxhYmxlVm9pY2VzLmZvckVhY2godm9pY2UgPT4ge1xyXG4gICAgICAgICAgICBhdmFpbGFibGVMYW5ndWFnZXNbdm9pY2UuTGFuZ3VhZ2VOYW1lXSA9IHZvaWNlLkxhbmd1YWdlQ29kZTtcclxuICAgICAgICAgICAgYWxsQ29kZXNbdm9pY2UuTGFuZ3VhZ2VDb2RlXSA9IHZvaWNlLkxhbmd1YWdlTmFtZTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG5cclxuICAgICAgICBPYmplY3QuZW50cmllcyhhdmFpbGFibGVMYW5ndWFnZXMpLmZvckVhY2goKFtuYW1lLCBjb2RlXSkgPT4ge1xyXG4gICAgICAgICAgYXZhaWxhYmxlTGFuZ3VhZ2VDb2Rlc1tjb2RlXSA9IG5hbWU7XHJcbiAgICAgICAgfSk7XHJcblxyXG4gICAgICAgIC8vIE5vdGlmeSB0aGF0IHdlJ3JlIHJlYWR5IHRvIGdlbmVyYXRlIHNwZWVjaGVzXHJcbiAgICAgICAgdGhpcy5faXNSZWFkeSA9IHRydWU7XHJcbiAgICAgICAgdGhpcy5lbWl0KHRoaXMuRVZFTlRTLnJlYWR5KTtcclxuICAgICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJbmRpY2F0ZXMgd2hldGhlciBvciBub3QgdGhlIGNsYXNzIGlzIGNhcGFibGUgb2YgZ2VuZXJhdGluZyBzcGVlY2ggYXVkaW8uIFBvbGx5LFxyXG4gICAqIFByZXNpZ25lciBhbmQgQVdTIFNESyB2ZXJzaW9uIG51bWJlciBtdXN0IGhhdmUgYmVlbiBkZWZpbmVkIHVzaW5nXHJcbiAgICogW2luaXRpYWxpemVTZXJ2aWNlXXtAbGluayBBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUuaW5pdGlhbGl6ZVNlcnZpY2V9LlxyXG4gICAqXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgc3RhdGljIGdldCBpc1JlYWR5KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX2lzUmVhZHk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHRoZSB0ZXh0IG9mIHRoZSBjdXJyZW50bHkgcGxheWluZyBzcGVlY2guXHJcbiAgICpcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAdHlwZSB7c3RyaW5nfVxyXG4gICAqL1xyXG4gIGdldCBjdXJyZW50U3BlZWNoKCkge1xyXG4gICAgaWYgKHRoaXMuX2N1cnJlbnRTcGVlY2gpIHtcclxuICAgICAgcmV0dXJuIHRoaXMuX2N1cnJlbnRTcGVlY2gudGV4dDtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIHJldHVybiBudWxsO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyBhbmQgc2V0cyB0aGUgbnVtYmVyIG9mIHNlY29uZHMgdG8gb2Zmc2V0IHNwZWVjaG1hcmsgZW1pc3Npb24uXHJcbiAgICpcclxuICAgKiBAdHlwZSB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldCBzcGVlY2htYXJrT2Zmc2V0KCkge1xyXG4gICAgcmV0dXJuIHRoaXMuX3NwZWVjaG1hcmtPZmZzZXQ7XHJcbiAgfVxyXG5cclxuICBzZXQgc3BlZWNobWFya09mZnNldChvZmZzZXQpIHtcclxuICAgIHRoaXMuX3NwZWVjaG1hcmtPZmZzZXQgPSBvZmZzZXQ7XHJcblxyXG4gICAgaWYgKHRoaXMuX2N1cnJlbnRTcGVlY2gpIHtcclxuICAgICAgdGhpcy5fY3VycmVudFNwZWVjaC5zcGVlY2htYXJrT2Zmc2V0ID0gb2Zmc2V0O1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyBhbmQgc2V0cyB0aGUgVGhlIG1pbmltdW0gYW1vdW50IG9mIHRpbWUgaW4gc2Vjb25kcyB0aGF0IHRoZSBsYXN0XHJcbiAgICogc3BlZWNobWFyayBvZiBlYWNoIHR5cGUgaW4gYSBzcGVlY2ggY2FuIGhhdmUgaXRzIGR1cmF0aW9uIHByb3BlcnR5IHNldCB0by5cclxuICAgKlxyXG4gICAqIEB0eXBlIG51bWJlclxyXG4gICAqL1xyXG4gIGdldCBtaW5FbmRNYXJrRHVyYXRpb24oKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fbWluRW5kTWFya0R1cmF0aW9uIC8gMTAwMDtcclxuICB9XHJcblxyXG4gIHNldCBtaW5FbmRNYXJrRHVyYXRpb24oZHVyYXRpb24pIHtcclxuICAgIHRoaXMuX21pbkVuZE1hcmtEdXJhdGlvbiA9IGR1cmF0aW9uICogMTAwMDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEFwcGVuZHMgdGhlIFN1bWVyaWFuIEhvc3RzIGN1c3RvbSB1c2VyLWFnZW50IHRvIGEgc3RyaW5nIGlmIGl0IGlzIG5vdFxyXG4gICAqIGFscmVhZHkgcHJlc2VudC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gY3VycmVudFVzZXJBZ2VudCAtIFN0cmluZyB0byBhcHBlbmQgdG8gaWYgbmVlZGVkLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgKi9cclxuICBzdGF0aWMgX3dpdGhDdXN0b21Vc2VyQWdlbnQoY3VycmVudFVzZXJBZ2VudCkge1xyXG4gICAgY29uc3Qgc3VtZXJpYW5Ib3N0c1VzZXJBZ2VudCA9ICdyZXF1ZXN0LXNvdXJjZS9TdW1lcmlhbkhvc3RzJztcclxuXHJcbiAgICBpZiAoY3VycmVudFVzZXJBZ2VudCA9PSBudWxsKSB7XHJcbiAgICAgIHJldHVybiBzdW1lcmlhbkhvc3RzVXNlckFnZW50O1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjdXJyZW50VXNlckFnZW50LmluZGV4T2Yoc3VtZXJpYW5Ib3N0c1VzZXJBZ2VudCkgIT09IC0xKSB7XHJcbiAgICAgIHJldHVybiBjdXJyZW50VXNlckFnZW50O1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBjdXJyZW50VXNlckFnZW50LmNvbmNhdCgnICcsIHN1bWVyaWFuSG9zdHNVc2VyQWdlbnQpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIGlmIGEgZ2l2ZW4gZW5naW5lIHR5cGUgaXMgY29tcGF0aWJsZSB3aXRoIHRoZSBBV1MgU0RLIHZlcnNpb24uIElmIGl0XHJcbiAgICogaXMsIHJldHVybiB0aGUgb3JpZ2luYWwgdmFsdWUuIE90aGVyd2lzZSByZXR1cm4gYSBkZWZhdWx0LlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbmdpbmUgLSBUaGUgdHlwZSBvZiBQb2xseSB2b2ljZSBlbmdpbmUgdG8gdmFsaWRhdGUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAqL1xyXG4gIF92YWxpZGF0ZUVuZ2luZShlbmdpbmUpIHtcclxuICAgIC8vIERlZmF1bHQgdG8gdGhlIHN0YW5kYXJkIGVuZ2luZSBpZiBuZXVyYWwgaXMgbm90IGF2YWlsYWJsZSBmb3IgdGhpcyB2ZXJzaW9uXHJcbiAgICBpZiAoXHJcbiAgICAgIGVuZ2luZSA9PT0gdW5kZWZpbmVkIHx8XHJcbiAgICAgIHRoaXMuY29uc3RydWN0b3IuQVdTX1ZFUlNJT04gPCB0aGlzLmNvbnN0cnVjdG9yLlBPTExZX01JTl9ORVVSQUxfVkVSU0lPTlxyXG4gICAgKSB7XHJcbiAgICAgIGVuZ2luZSA9IHRoaXMuY29uc3RydWN0b3IuUE9MTFlfREVGQVVMVFMuRW5naW5lO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBlbmdpbmU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDaGVja3MgaWYgYSBnaXZlbiBhdWRpbyBmb3JtYXQgdHlwZSBpcyBjb21wYXRpYmxlIHdpdGggUG9sbHkuIElmIGl0IGlzLCByZXR1cm5cclxuICAgKiB0aGUgb3JpZ2luYWwgdmFsdWUuIE90aGVyd2lzZSByZXR1cm4gYSBkZWZhdWx0LlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSBlbmdpbmUgLSBUaGUgdHlwZSBvZiBQb2xseSB2b2ljZSBlbmdpbmUgdG8gdmFsaWRhdGUuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gICAqL1xyXG4gIF92YWxpZGF0ZUZvcm1hdChmb3JtYXQpIHtcclxuICAgIGlmIChmb3JtYXQgPT09IHVuZGVmaW5lZCB8fCAhYXVkaW9Gb3JtYXRzLmluY2x1ZGVzKGZvcm1hdCkpIHtcclxuICAgICAgZm9ybWF0ID0gdGhpcy5jb25zdHJ1Y3Rvci5QT0xMWV9ERUZBVUxUUy5PdXRwdXRGb3JtYXQ7XHJcbiAgICB9XHJcblxyXG4gICAgcmV0dXJuIGZvcm1hdDtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENoZWNrcyBpZiBhIGdpdmVuIGF1ZGlvIHNhbXBsaW5nIHJhdGUgaXMgY29tcGF0aWJsZSB3aXRoIHRoZSBjdXJyZW50IGF1ZGlvXHJcbiAgICogZm9ybWF0LiBJZiBpdCBpcywgcmV0dXJuIHRoZSBvcmlnaW5hbCB2YWx1ZS4gT3RoZXJ3aXNlIHJldHVybiBhIGRlZmF1bHQuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGVuZ2luZSAtIFRoZSB0eXBlIG9mIFBvbGx5IHZvaWNlIGVuZ2luZSB0byB2YWxpZGF0ZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICovXHJcbiAgX3ZhbGlkYXRlUmF0ZShyYXRlKSB7XHJcbiAgICAvLyBVc2UgZGVmYXVsdCBpZiBzcGVjaWZpZWQgc2FtcGxlIHJhdGUgaXMgbm90IHZhbGlkIGZvciB0aGUgYXVkaW8gZm9ybWF0XHJcbiAgICBpZiAoXHJcbiAgICAgIHJhdGUgPT09IHVuZGVmaW5lZCB8fFxyXG4gICAgICAhc2FtcGxlUmF0ZXNbdGhpcy5fYXVkaW9Gb3JtYXRdLnJhdGVzLmluY2x1ZGVzKHJhdGUpXHJcbiAgICApIHtcclxuICAgICAgcmF0ZSA9IHNhbXBsZVJhdGVzW3RoaXMuX2F1ZGlvRm9ybWF0XS5kZWZhdWx0c1t0aGlzLl9lbmdpbmVdO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiByYXRlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIGlmIGEgZ2l2ZW4gUG9sbHkgdm9pY2UgaWQgaXMgY29tcGF0aWJsZSB3aXRoIHRoZSBjdXJyZW50IFBvbGx5IGVuZ2luZS5cclxuICAgKiBJZiBpdCBpcywgcmV0dXJuIHRoZSBvcmlnaW5hbCB2YWx1ZS4gT3RoZXJ3aXNlIHJldHVybiBhIGRlZmF1bHQuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IGVuZ2luZSAtIFRoZSB0eXBlIG9mIFBvbGx5IHZvaWNlIGVuZ2luZSB0byB2YWxpZGF0ZS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtzdHJpbmd9XHJcbiAgICovXHJcbiAgX3ZhbGlkYXRlVm9pY2Uodm9pY2VJZCkge1xyXG4gICAgY29uc3Qgdm9pY2UgPSB0aGlzLmNvbnN0cnVjdG9yLlBPTExZX1ZPSUNFUy5maW5kKHYgPT4gdi5JZCA9PT0gdm9pY2VJZCk7XHJcblxyXG4gICAgLy8gVXNlIHRoZSBkZWZhdWx0IHZvaWNlIGlmIHRoZSB2b2ljZSBpc24ndCBzdXBwb3J0ZWQgYnkgdGhlIGVuZ2luZVxyXG4gICAgaWYgKHZvaWNlID09PSB1bmRlZmluZWQgfHwgIXZvaWNlLlN1cHBvcnRlZEVuZ2luZXMuaW5jbHVkZXModGhpcy5fZW5naW5lKSkge1xyXG4gICAgICB2b2ljZUlkID0gdGhpcy5jb25zdHJ1Y3Rvci5QT0xMWV9ERUZBVUxUUy5Wb2ljZUlkO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiB2b2ljZUlkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQ2hlY2tzIGlmIGEgZ2l2ZW4gUG9sbHkgbGFuZ3VhZ2UgaXMgY29tcGF0aWJsZSB3aXRoIHRoZSBjdXJyZW50IFBvbGx5IHZvaWNlLlxyXG4gICAqIElmIGl0IGlzLCByZXR1cm4gdGhlIG9yaWdpbmFsIHZhbHVlLiBPdGhlcndpc2UgcmV0dXJuIGEgZGVmYXVsdC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gZW5naW5lIC0gVGhlIHR5cGUgb2YgUG9sbHkgdm9pY2UgZW5naW5lIHRvIHZhbGlkYXRlLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge3N0cmluZ31cclxuICAgKi9cclxuICBfdmFsaWRhdGVMYW5ndWFnZShsYW5ndWFnZSkge1xyXG4gICAgY29uc3Qgdm9pY2UgPSB0aGlzLmNvbnN0cnVjdG9yLlBPTExZX1ZPSUNFUy5maW5kKHYgPT4gdi5JZCA9PT0gdGhpcy5fdm9pY2UpO1xyXG4gICAgY29uc3QgbGFuZ3VhZ2VDb2RlID0gdGhpcy5jb25zdHJ1Y3Rvci5QT0xMWV9MQU5HVUFHRVNbbGFuZ3VhZ2VdO1xyXG5cclxuICAgIC8vIEZpbmQgdGhlIGxhbmd1YWdlcyBhdmFpbGFibGUgZm9yIHRoZSBjdXJyZW50IHZvaWNlXHJcbiAgICBjb25zdCBhdmFpbGFibGVDb2RlcyA9IFt2b2ljZS5MYW5ndWFnZUNvZGVdO1xyXG4gICAgaWYgKHZvaWNlLkFkZGl0aW9uYWxMYW5ndWFnZUNvZGVzKSB7XHJcbiAgICAgIGF2YWlsYWJsZUNvZGVzLnB1c2goLi4udm9pY2UuQWRkaXRpb25hbExhbmd1YWdlQ29kZXMpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIElmIHRoZSBjdXJyZW50IHZvaWNlIGRvZXNuJ3Qgc3VwcG9ydCB0aGUgbGFuZ3VhZ2UsIHVzZSBpdHMgZGVmYXVsdFxyXG4gICAgaWYgKCFhdmFpbGFibGVDb2Rlcy5pbmNsdWRlcyhsYW5ndWFnZUNvZGUpKSB7XHJcbiAgICAgIGxhbmd1YWdlID0gdGhpcy5jb25zdHJ1Y3Rvci5QT0xMWV9MQU5HVUFHRV9DT0RFU1t2b2ljZS5MYW5ndWFnZUNvZGVdO1xyXG4gICAgfVxyXG5cclxuICAgIHJldHVybiBsYW5ndWFnZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFZhbGlkYXRlIHRoZSBjdXJyZW50IFBvbGx5IG9wdGlvbnMgdG8gbWFrZSBzdXJlIHRoZXkgYXJlIGNvbXBhdGlibGUgd2l0aCBlYWNoXHJcbiAgICogb3RoZXIuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF92YWxpZGF0ZSgpIHtcclxuICAgIC8vIFZhbGlkYXRlIHNwZWVjaCBwYXJhbWV0ZXJzXHJcbiAgICB0aGlzLl9lbmdpbmUgPSB0aGlzLl92YWxpZGF0ZUVuZ2luZSh0aGlzLl9lbmdpbmUpO1xyXG4gICAgdGhpcy5fYXVkaW9Gb3JtYXQgPSB0aGlzLl92YWxpZGF0ZUZvcm1hdCh0aGlzLl9hdWRpb0Zvcm1hdCk7XHJcbiAgICB0aGlzLl9zYW1wbGVSYXRlID0gdGhpcy5fdmFsaWRhdGVSYXRlKHRoaXMuX3NhbXBsZVJhdGUpO1xyXG4gICAgdGhpcy5fdm9pY2UgPSB0aGlzLl92YWxpZGF0ZVZvaWNlKHRoaXMuX3ZvaWNlKTtcclxuICAgIHRoaXMuX2xhbmd1YWdlID0gdGhpcy5fdmFsaWRhdGVMYW5ndWFnZSh0aGlzLl9sYW5ndWFnZSk7XHJcbiAgICB0aGlzLl9pc1ZhbGlkYXRlZCA9IHRydWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm4gYW4gb2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVycyBjb21wYXRpYmxlIHdpdGggUG9sbHkuc3ludGhlc2l6ZVNwZWVjaC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7T2JqZWN0fVxyXG4gICAqL1xyXG4gIF9nZXRDb25maWcoKSB7XHJcbiAgICAvLyBNYWtlIHN1cmUgcGFyYW1ldGVycyBoYXZlIGJlZW4gdmFsaWRhdGVkXHJcbiAgICBpZiAodGhpcy5jb25zdHJ1Y3Rvci5pc1JlYWR5ICYmICF0aGlzLl9pc1ZhbGlkYXRlZCkge1xyXG4gICAgICB0aGlzLl92YWxpZGF0ZSgpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIENyZWF0ZSBhIGNvbmZpZyBvYmplY3QgY29tcGF0aWJsZSB3aXRoIFBvbGx5XHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBFbmdpbmU6IHRoaXMuX2VuZ2luZSxcclxuICAgICAgT3V0cHV0Rm9ybWF0OiB0aGlzLl9hdWRpb0Zvcm1hdCxcclxuICAgICAgU2FtcGxlUmF0ZTogdGhpcy5fc2FtcGxlUmF0ZSxcclxuICAgICAgVm9pY2VJZDogdGhpcy5fdm9pY2UsXHJcbiAgICAgIExhbmd1YWdlQ29kZTogdGhpcy5jb25zdHJ1Y3Rvci5QT0xMWV9MQU5HVUFHRVNbdGhpcy5fbGFuZ3VhZ2VdLFxyXG4gICAgfTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZSBQb2xseSBwYXJhbWV0ZXJzIHdpdGggb3B0aW9ucyBmcm9tIGEgZ2l2ZW4gY29uZmlnLiBBbGwgc3RvcmVkIHNwZWVjaGVzXHJcbiAgICogd2lsbCBiZSB1cGRhdGVkIHRvIHVzZSB0aGUgbmV3IHBhcmFtZXRlcnMsIHVubGVzcyB0aGUgc3BlZWNoIHRleHQgaXMgY29udGFpbmVkXHJcbiAgICogaW4gdGhlICdza2lwU3BlZWNoZXMnIHBhcmFtZXRlci5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIC0gUG9sbHkgcGFyYW1ldGVyIG9wdGlvbnMgdG8gb3ZlcndyaXRlLlxyXG4gICAqIEBwYXJhbSB7QXJyYXkuPHN0cmluZz59IHNraXBTcGVlY2hlcyAtIFRleHQgb2YgYW55IHNwZWVjaGVzIHRoYXQgc2hvdWxkIG5vdFxyXG4gICAqIGhhdmUgcGFyYW1ldGVycyB1cGRhdGVkLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge09iamVjdH1cclxuICAgKi9cclxuICBfdXBkYXRlQ29uZmlnKGNvbmZpZywgc2tpcFNwZWVjaGVzID0gW10pIHtcclxuICAgIGNvbnN0IGN1cnJlbnRDb25maWcgPSB0aGlzLl9nZXRDb25maWcoKTtcclxuICAgIGlmICghY29uZmlnKSB7XHJcbiAgICAgIHJldHVybiBjdXJyZW50Q29uZmlnO1xyXG4gICAgfVxyXG5cclxuICAgIHRoaXMuX2lzVmFsaWRhdGVkID0gZmFsc2U7XHJcbiAgICBjb25zdCBjdXJyZW50Q29uZmlnU3RyID0gSlNPTi5zdHJpbmdpZnkoY3VycmVudENvbmZpZyk7XHJcblxyXG4gICAgLy8gVXBkYXRlIG9wdGlvbnNcclxuICAgIGlmIChjb25maWcuRW5naW5lKSB7XHJcbiAgICAgIHRoaXMuX2VuZ2luZSA9IGNvbmZpZy5FbmdpbmU7XHJcbiAgICB9XHJcblxyXG4gICAgaWYgKGNvbmZpZy5hdWRpb0Zvcm1hdCkge1xyXG4gICAgICB0aGlzLl9hdWRpb0Zvcm1hdCA9IGNvbmZpZy5hdWRpb0Zvcm1hdDtcclxuICAgIH1cclxuXHJcbiAgICBpZiAoY29uZmlnLlNhbXBsZVJhdGUpIHtcclxuICAgICAgdGhpcy5fc2FtcGxlUmF0ZSA9IGNvbmZpZy5TYW1wbGVSYXRlO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjb25maWcuVm9pY2VJZCkge1xyXG4gICAgICB0aGlzLl92b2ljZSA9IGNvbmZpZy5Wb2ljZUlkO1xyXG4gICAgfVxyXG5cclxuICAgIGlmIChjb25maWcuTGFuZ3VhZ2UpIHtcclxuICAgICAgdGhpcy5fbGFuZ3VhZ2UgPSBjb25maWcuTGFuZ3VhZ2U7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVmFsaWRhdGUgdGhlIGNvbmZpZ1xyXG4gICAgY29uc3QgdmFsaWRDb25maWcgPSB0aGlzLl9nZXRDb25maWcoKTtcclxuXHJcbiAgICAvLyBFeGl0IGlmIG5vdGhpbmcgaGFzIGNoYW5nZWRcclxuICAgIGNvbnN0IGNvbmZpZ1N0ciA9IEpTT04uc3RyaW5naWZ5KHZhbGlkQ29uZmlnKTtcclxuICAgIGlmIChjdXJyZW50Q29uZmlnU3RyID09PSBjb25maWdTdHIpIHtcclxuICAgICAgdGhpcy5faXNWYWxpZGF0ZWQgPSB0cnVlO1xyXG4gICAgICByZXR1cm4gdmFsaWRDb25maWc7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gVXBkYXRlIGFsbCBjYWNoZWQgY29uZmlnc1xyXG4gICAgT2JqZWN0LmVudHJpZXModGhpcy5fc3BlZWNoQ2FjaGUpLmZvckVhY2goKFt0ZXh0LCBzcGVlY2hdKSA9PiB7XHJcbiAgICAgIC8vIENoZWNrIGlmIHRoaXMgaXMgYSBza2lwcGVkIHNwZWVjaFxyXG4gICAgICBpZiAoc2tpcFNwZWVjaGVzLmluY2x1ZGVzKHRleHQpKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcblxyXG4gICAgICBjb25zdCBzcGVlY2hDb25maWdTdHIgPSBKU09OLnN0cmluZ2lmeShzcGVlY2guY29uZmlnKTtcclxuXHJcbiAgICAgIC8vIFVwZGF0ZSB0aGUgc3BlZWNoIHdpdGggbmV3IHBhcmFtZXRlcnNcclxuICAgICAgaWYgKHNwZWVjaENvbmZpZ1N0ciAhPT0gY29uZmlnU3RyKSB7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlU3BlZWNoKHRleHQsIHZhbGlkQ29uZmlnKTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIHZhbGlkQ29uZmlnO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVXBkYXRlIGFuIGV4aXN0aW5nIHNwZWVjaCwgb3IgYWRkIGEgbmV3IHNwZWVjaCB3aXRoIG5ldyBQb2xseSBwYXJhbWV0ZXJzIHdpdGhcclxuICAgKiBvcHRpb25zIGZyb20gYSBnaXZlbiBjb25maWcuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCBvZiB0aGUgc3BlZWNoIHRvIHVwZGF0ZS5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gY29uZmlnIC0gUG9sbHkgcGFyYW1ldGVyIG9wdGlvbnMgdG8gdXBkYXRlLlxyXG4gICAqIEBwYXJhbSB7Ym9vbGVhbn0gW2ZvcmNlPWZhbHNlXSAtIFdoZXRoZXIgdG8gZm9yY2UgdGhlIHNwZWVjaCB0byBiZSB1cGRhdGVkXHJcbiAgICogaWYgbm8gcGFyYW1ldGVycyBoYXZlIGNoYW5nZXMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7QWJzdHJhY3RTcGVlY2h9XHJcbiAgICovXHJcbiAgX3VwZGF0ZVNwZWVjaCh0ZXh0LCBjb25maWcsIGZvcmNlID0gZmFsc2UpIHtcclxuICAgIGNvbnN0IHNwZWVjaCA9IHRoaXMuX3NwZWVjaENhY2hlW3RleHRdIHx8IHt9O1xyXG4gICAgLy8gRXhpdCBpZiBub3RoaW5nIGhhcyBjaGFuZ2VkIGFuZCBmb3JjZSBpcyBmYWxzZVxyXG4gICAgaWYgKFxyXG4gICAgICAhZm9yY2UgJiZcclxuICAgICAgY29uZmlnICE9PSB1bmRlZmluZWQgJiZcclxuICAgICAgc3BlZWNoLmNvbmZpZyAmJlxyXG4gICAgICBKU09OLnN0cmluZ2lmeShjb25maWcpID09PSBKU09OLnN0cmluZ2lmeShzcGVlY2guY29uZmlnKVxyXG4gICAgKSB7XHJcbiAgICAgIHJldHVybiBzcGVlY2g7XHJcbiAgICB9XHJcblxyXG4gICAgLy8gQ3JlYXRlIHNlcGFyYXRlIHBhcmFtZXRlcnMgZm9yIGF1ZGlvIGFuZCBzcGVlY2htYXJrIGdlbmVyYXRpb25cclxuICAgIGNvbnN0IGF1ZGlvUGFyYW1zID0ge1xyXG4gICAgICAuLi5jb25maWcsXHJcbiAgICAgIFRleHQ6IHRleHQsXHJcbiAgICAgIFRleHRUeXBlOiAnc3NtbCcsXHJcbiAgICB9O1xyXG4gICAgY29uc3Qgc3BlZWNobWFya1BhcmFtcyA9IHtcclxuICAgICAgLi4uYXVkaW9QYXJhbXMsXHJcbiAgICAgIE91dHB1dEZvcm1hdDogJ2pzb24nLFxyXG4gICAgICBTcGVlY2hNYXJrVHlwZXM6IHNwZWVjaG1hcmtUeXBlcyxcclxuICAgIH07XHJcblxyXG4gICAgLy8gR2VuZXJhdGUgYXVkaW8gYW5kIHNwZWVjaG1hcmtzXHJcbiAgICBzcGVlY2guY29uZmlnID0gY29uZmlnO1xyXG4gICAgc3BlZWNoLnByb21pc2UgPSBQcm9taXNlLmFsbChbXHJcbiAgICAgIHRoaXMuX3N5bnRoZXNpemVTcGVlY2htYXJrcyhzcGVlY2htYXJrUGFyYW1zKSxcclxuICAgICAgdGhpcy5fc3ludGhlc2l6ZUF1ZGlvKGF1ZGlvUGFyYW1zKSxcclxuICAgIF0pLnRoZW4ocmVzdWx0cyA9PiB7XHJcbiAgICAgIHJldHVybiB0aGlzLl9jcmVhdGVTcGVlY2godGV4dCwgLi4ucmVzdWx0cyk7XHJcbiAgICB9KTtcclxuICAgIHRoaXMuX3NwZWVjaENhY2hlW3RleHRdID0gc3BlZWNoO1xyXG5cclxuICAgIHJldHVybiBzcGVlY2g7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgYSBuZXcgU3BlZWNoIG9iamVjdCBmb3IgdGhlIHNwZWFrZXIuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtUZXh0VG9TcGVlY2h9IHNwZWFrZXIgLSBUaGUgVGV4dFRvU3BlZWNoIGluc3RhbmNlIHRoYXQgd2lsbCBvd24gdGhlIHNwZWVjaC5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIFRleHQgb2YgdGhlIHNwZWVjaC5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gc3BlZWNobWFya3MgLSBTcGVlY2htYXJrcyBmb3IgdGhlIHNwZWVjaC5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gYXVkaW9Db25maWcgLSBBdWRpbyBmb3IgdGhlIHNwZWVjaC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtBYnN0cmFjdFNwZWVjaH1cclxuICAgKi9cclxuICBfY3JlYXRlU3BlZWNoKHRleHQsIHNwZWVjaG1hcmtzLCBhdWRpb0NvbmZpZykge1xyXG4gICAgcmV0dXJuIG5ldyBTcGVlY2godGhpcywgdGV4dCwgc3BlZWNobWFya3MsIGF1ZGlvQ29uZmlnKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBwcmVzaWduZWQgVVJMIG9mIHNwZWVjaCBhdWRpbyBmb3IgdGhlIGdpdmVuIHNwZWVjaCB0ZXh0LlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBQYXJhbWV0ZXJzIG9iamVjdCBjb21wYXRpYmxlIHdpdGggUG9sbHkuc3ludGhlc2l6ZVNwZWVjaC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH0gUmVzb2x2ZXMgd2l0aCBhbiBvYmplY3QgY29udGFpbmluZyB0aGUgYXVkaW8gVVJMLlxyXG4gICAqL1xyXG4gIF9zeW50aGVzaXplQXVkaW8ocGFyYW1zKSB7XHJcbiAgICByZXR1cm4gbmV3IERlZmVycmVkKChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgdGhpcy5jb25zdHJ1Y3Rvci5TRVJWSUNFUy5wcmVzaWduZXIuZ2V0U3ludGhlc2l6ZVNwZWVjaFVybChcclxuICAgICAgICBwYXJhbXMsXHJcbiAgICAgICAgZnVuY3Rpb24oZXJyb3IsIHVybCkge1xyXG4gICAgICAgICAgaWYgKCFlcnJvcikge1xyXG4gICAgICAgICAgICByZXNvbHZlKHt1cmx9KTtcclxuICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgIHJlamVjdChlcnJvcik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICApO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXRyaWV2ZXMgYW5kIHBhcnNlcyBzcGVlY2htYXJrcyBmb3IgdGhlIGdpdmVuIHNwZWVjaCB0ZXh0LlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBwYXJhbXMgLSBQYXJhbWV0ZXJzIG9iamVjdCBjb21wYXRpYmxlIHdpdGggUG9sbHkuc3ludGhlc2l6ZVNwZWVjaC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH0gUmVzb2x2ZXMgd2l0aCBhbiBhcnJheSBvZiBzcGVlY2htYXJrIG9iamVjdHNcclxuICAgKi9cclxuICBfc3ludGhlc2l6ZVNwZWVjaG1hcmtzKHBhcmFtcykge1xyXG4gICAgcmV0dXJuIHRoaXMuY29uc3RydWN0b3IuU0VSVklDRVMucG9sbHlcclxuICAgICAgLnN5bnRoZXNpemVTcGVlY2gocGFyYW1zKVxyXG4gICAgICAucHJvbWlzZSgpXHJcbiAgICAgIC50aGVuKHJlc3VsdCA9PiB7XHJcbiAgICAgICAgLy8gQ29udmVydCBjaGFyY29kZXMgdG8gc3RyaW5nXHJcbiAgICAgICAgY29uc3QganNvblN0cmluZyA9IEpTT04uc3RyaW5naWZ5KHJlc3VsdC5BdWRpb1N0cmVhbSk7XHJcbiAgICAgICAgY29uc3QganNvbiA9IEpTT04ucGFyc2UoanNvblN0cmluZyk7XHJcbiAgICAgICAgY29uc3QgZGF0YVN0ciA9IGpzb24uZGF0YS5tYXAoYyA9PiBTdHJpbmcuZnJvbUNoYXJDb2RlKGMpKS5qb2luKCcnKTtcclxuXHJcbiAgICAgICAgY29uc3QgbWFya1R5cGVzID0ge1xyXG4gICAgICAgICAgc2VudGVuY2U6IFtdLFxyXG4gICAgICAgICAgd29yZDogW10sXHJcbiAgICAgICAgICB2aXNlbWU6IFtdLFxyXG4gICAgICAgICAgc3NtbDogW10sXHJcbiAgICAgICAgfTtcclxuICAgICAgICBjb25zdCBlbmRNYXJrVHlwZXMgPSB7XHJcbiAgICAgICAgICBzZW50ZW5jZTogbnVsbCxcclxuICAgICAgICAgIHdvcmQ6IG51bGwsXHJcbiAgICAgICAgICB2aXNlbWU6IG51bGwsXHJcbiAgICAgICAgICBzc21sOiBudWxsLFxyXG4gICAgICAgIH07XHJcblxyXG4gICAgICAgIC8vIFNwbGl0IGJ5IGVuY2xvc2luZyB7fSB0byBjcmVhdGUgc3BlZWNobWFyayBvYmplY3RzXHJcbiAgICAgICAgY29uc3Qgc3BlZWNoTWFya3MgPSBbLi4uZGF0YVN0ci5tYXRjaEFsbCgvXFx7Lio/XFx9KD89XFxufCQpL2dtKV0ubWFwKFxyXG4gICAgICAgICAgbWF0Y2ggPT4ge1xyXG4gICAgICAgICAgICBjb25zdCBtYXJrID0gSlNPTi5wYXJzZShtYXRjaFswXSk7XHJcblxyXG4gICAgICAgICAgICAvLyBTZXQgdGhlIGR1cmF0aW9uIG9mIHRoZSBsYXN0IHNwZWVjaG1hcmsgc3RvcmVkIG1hdGNoaW5nIHRoaXMgb25lJ3MgdHlwZVxyXG4gICAgICAgICAgICBjb25zdCBudW1NYXJrcyA9IG1hcmtUeXBlc1ttYXJrLnR5cGVdLmxlbmd0aDtcclxuICAgICAgICAgICAgaWYgKG51bU1hcmtzID4gMCkge1xyXG4gICAgICAgICAgICAgIGNvbnN0IGxhc3RNYXJrID0gbWFya1R5cGVzW21hcmsudHlwZV1bbnVtTWFya3MgLSAxXTtcclxuICAgICAgICAgICAgICBsYXN0TWFyay5kdXJhdGlvbiA9IG1hcmsudGltZSAtIGxhc3RNYXJrLnRpbWU7XHJcbiAgICAgICAgICAgIH1cclxuXHJcbiAgICAgICAgICAgIG1hcmtUeXBlc1ttYXJrLnR5cGVdLnB1c2gobWFyayk7XHJcbiAgICAgICAgICAgIGVuZE1hcmtUeXBlc1ttYXJrLnR5cGVdID0gbWFyaztcclxuICAgICAgICAgICAgcmV0dXJuIG1hcms7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgKTtcclxuXHJcbiAgICAgICAgLy8gRmluZCB0aGUgdGltZSBvZiB0aGUgbGF0ZXN0IHNwZWVjaG1hcmtcclxuICAgICAgICBjb25zdCBlbmRUaW1lcyA9IFtdO1xyXG4gICAgICAgIGlmIChlbmRNYXJrVHlwZXMuc2VudGVuY2UpIHtcclxuICAgICAgICAgIGVuZFRpbWVzLnB1c2goZW5kTWFya1R5cGVzLnNlbnRlbmNlLnRpbWUpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZW5kTWFya1R5cGVzLndvcmQpIHtcclxuICAgICAgICAgIGVuZFRpbWVzLnB1c2goZW5kTWFya1R5cGVzLndvcmQudGltZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbmRNYXJrVHlwZXMudmlzZW1lKSB7XHJcbiAgICAgICAgICBlbmRUaW1lcy5wdXNoKGVuZE1hcmtUeXBlcy52aXNlbWUudGltZSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbmRNYXJrVHlwZXMuc3NtbCkge1xyXG4gICAgICAgICAgZW5kVGltZXMucHVzaChlbmRNYXJrVHlwZXMuc3NtbC50aW1lKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgY29uc3QgZW5kVGltZSA9IE1hdGgubWF4KC4uLmVuZFRpbWVzKTtcclxuXHJcbiAgICAgICAgLy8gQ2FsY3VsYXRlIGR1cmF0aW9uIGZvciB0aGUgZW5kaW5nIHNwZWVjaE1hcmtzIG9mIGVhY2ggdHlwZVxyXG4gICAgICAgIGlmIChlbmRNYXJrVHlwZXMuc2VudGVuY2UpIHtcclxuICAgICAgICAgIGVuZE1hcmtUeXBlcy5zZW50ZW5jZS5kdXJhdGlvbiA9IE1hdGgubWF4KFxyXG4gICAgICAgICAgICB0aGlzLl9taW5FbmRNYXJrRHVyYXRpb24sXHJcbiAgICAgICAgICAgIGVuZFRpbWUgLSBlbmRNYXJrVHlwZXMuc2VudGVuY2UudGltZVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgaWYgKGVuZE1hcmtUeXBlcy53b3JkKSB7XHJcbiAgICAgICAgICBlbmRNYXJrVHlwZXMud29yZC5kdXJhdGlvbiA9IE1hdGgubWF4KFxyXG4gICAgICAgICAgICB0aGlzLl9taW5FbmRNYXJrRHVyYXRpb24sXHJcbiAgICAgICAgICAgIGVuZFRpbWUgLSBlbmRNYXJrVHlwZXMud29yZC50aW1lXHJcbiAgICAgICAgICApO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoZW5kTWFya1R5cGVzLnZpc2VtZSkge1xyXG4gICAgICAgICAgZW5kTWFya1R5cGVzLnZpc2VtZS5kdXJhdGlvbiA9IE1hdGgubWF4KFxyXG4gICAgICAgICAgICB0aGlzLl9taW5FbmRNYXJrRHVyYXRpb24sXHJcbiAgICAgICAgICAgIGVuZFRpbWUgLSBlbmRNYXJrVHlwZXMudmlzZW1lLnRpbWVcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChlbmRNYXJrVHlwZXMuc3NtbCkge1xyXG4gICAgICAgICAgZW5kTWFya1R5cGVzLnNzbWwuZHVyYXRpb24gPSBNYXRoLm1heChcclxuICAgICAgICAgICAgdGhpcy5fbWluRW5kTWFya0R1cmF0aW9uLFxyXG4gICAgICAgICAgICBlbmRUaW1lIC0gZW5kTWFya1R5cGVzLnNzbWwudGltZVxyXG4gICAgICAgICAgKTtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHJldHVybiBzcGVlY2hNYXJrcztcclxuICAgICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBSZXR1cm5zIGEgU3BlZWNoIG9iamVjdCB0aGF0IGhhcyB0aGUgZ2l2ZW4gdGV4dC5cclxuICAgKlxyXG4gICAqIEBwcml2YXRlXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIFRoZSB0ZXh0IGNvbnRlbnQgb2YgdGhlIFNwZWVjaC5cclxuICAgKiBAcGFyYW0ge09iamVjdD19IGNvbmZpZyAtIE9wdGlvbnMgdG8gdXBkYXRlIHRoZSBTcGVlY2ggd2l0aC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtEZWZlcnJlZH0gUmVzb2x2ZXMgd2l0aCBTcGVlY2ggb3IgbnVsbDtcclxuICAgKi9cclxuICBfZ2V0U3BlZWNoKHRleHQsIGNvbmZpZykge1xyXG4gICAgLy8gTWFrZSBzdXJlIEFXUyBzZXJ2aWNlcyBleGlzdFxyXG4gICAgaWYgKCF0aGlzLmNvbnN0cnVjdG9yLmlzUmVhZHkpIHtcclxuICAgICAgY29uc3QgZSA9ICdBV1Mgc2VydmljZXMgaGF2ZSBub3QgYmVlbiBpbml0aWFsaXplZC4nO1xyXG4gICAgICByZXR1cm4gRGVmZXJyZWQucmVqZWN0KGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIE1ha2Ugc3VyZSBpdHMgcG9zc2libGUgdG8gZ2VuZXJhdGUgc3BlZWNoZXNcclxuICAgIGlmICghdGV4dCkge1xyXG4gICAgICBjb25zdCBlID0gJ0Nhbm5vdCBwbGF5IGEgc3BlZWNoIHdpdGggbm8gdGV4dC4nO1xyXG4gICAgICByZXR1cm4gRGVmZXJyZWQucmVqZWN0KGUpO1xyXG4gICAgfVxyXG5cclxuICAgIC8vIFVwZGF0ZSB0aGUgc3BlZWNoIHdpdGggb3B0aW9uc1xyXG4gICAgdGV4dCA9IFRleHRUb1NwZWVjaFV0aWxzLnZhbGlkYXRlVGV4dCh0ZXh0KTtcclxuICAgIGNvbmZpZyA9IHRoaXMuX3VwZGF0ZUNvbmZpZyhjb25maWcsIHRleHQpO1xyXG5cclxuICAgIHJldHVybiB0aGlzLl91cGRhdGVTcGVlY2godGV4dCwgY29uZmlnKS5wcm9taXNlO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogQWRkcyBhIG5hbWVzcGFjZSB0byB0aGUgaG9zdCB3aXRoIHRoZSBuYW1lIG9mIHRoZSBmZWF0dXJlIHRvIGNvbnRhaW4gcHJvcGVydGllc1xyXG4gICAqIGFuZCBtZXRob2RzIGZyb20gdGhlIGZlYXR1cmUgdGhhdCB1c2VycyBvZiB0aGUgaG9zdCBuZWVkIGFjY2VzcyB0by5cclxuICAgKlxyXG4gICAqIEBzZWUgVGV4dFRvU3BlZWNoRmVhdHVyZVxyXG4gICAqL1xyXG4gIGluc3RhbGxBcGkoKSB7XHJcbiAgICAvKipcclxuICAgICAqIEBpbm5lclxyXG4gICAgICogQG5hbWVzcGFjZSBUZXh0VG9TcGVlY2hGZWF0dXJlXHJcbiAgICAgKi9cclxuICAgIGNvbnN0IGFwaSA9IHN1cGVyLmluc3RhbGxBcGkoKTtcclxuXHJcbiAgICBPYmplY3QuYXNzaWduKGFwaSwge1xyXG4gICAgICAvKipcclxuICAgICAgICogQG1lbWJlcm9mIFRleHRUb1NwZWVjaEZlYXR1cmVcclxuICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAqIEBtZXRob2RcclxuICAgICAgICogQHNlZSBBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUjcGxheVxyXG4gICAgICAgKi9cclxuICAgICAgcGxheTogdGhpcy5wbGF5LmJpbmQodGhpcyksXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbWVtYmVyb2YgVGV4dFRvU3BlZWNoRmVhdHVyZVxyXG4gICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgKiBAc2VlIEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZSNwYXVzZVxyXG4gICAgICAgKi9cclxuICAgICAgcGF1c2U6IHRoaXMucGF1c2UuYmluZCh0aGlzKSxcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBtZW1iZXJvZiBUZXh0VG9TcGVlY2hGZWF0dXJlXHJcbiAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAqIEBzZWUgQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlI3Jlc3VtZVxyXG4gICAgICAgKi9cclxuICAgICAgcmVzdW1lOiB0aGlzLnJlc3VtZS5iaW5kKHRoaXMpLFxyXG4gICAgICAvKipcclxuICAgICAgICogQG1lbWJlcm9mIFRleHRUb1NwZWVjaEZlYXR1cmVcclxuICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAqIEBtZXRob2RcclxuICAgICAgICogQHNlZSBBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUjc3RvcFxyXG4gICAgICAgKi9cclxuICAgICAgc3RvcDogdGhpcy5zdG9wLmJpbmQodGhpcyksXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbWVtYmVyb2YgVGV4dFRvU3BlZWNoRmVhdHVyZVxyXG4gICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgKiBAc2VlIEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZSNnZXRWb2x1bWVcclxuICAgICAgICovXHJcbiAgICAgIGdldFZvbHVtZTogdGhpcy5nZXRWb2x1bWUuYmluZCh0aGlzKSxcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBtZW1iZXJvZiBUZXh0VG9TcGVlY2hGZWF0dXJlXHJcbiAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgKiBAbWV0aG9kXHJcbiAgICAgICAqIEBzZWUgQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlI3NldFZvbHVtZVxyXG4gICAgICAgKi9cclxuICAgICAgc2V0Vm9sdW1lOiB0aGlzLnNldFZvbHVtZS5iaW5kKHRoaXMpLFxyXG4gICAgICAvKipcclxuICAgICAgICogQG1lbWJlcm9mIFRleHRUb1NwZWVjaEZlYXR1cmVcclxuICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAqIEBtZXRob2RcclxuICAgICAgICogQHNlZSBBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUjcGF1c2VWb2x1bWVcclxuICAgICAgICovXHJcbiAgICAgIHBhdXNlVm9sdW1lOiB0aGlzLnBhdXNlVm9sdW1lLmJpbmQodGhpcyksXHJcbiAgICAgIC8qKlxyXG4gICAgICAgKiBAbWVtYmVyb2YgVGV4dFRvU3BlZWNoRmVhdHVyZVxyXG4gICAgICAgKiBAaW5zdGFuY2VcclxuICAgICAgICogQG1ldGhvZFxyXG4gICAgICAgKiBAc2VlIEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZSNyZXN1bWVWb2x1bWVcclxuICAgICAgICovXHJcbiAgICAgIHJlc3VtZVZvbHVtZTogdGhpcy5yZXN1bWVWb2x1bWUuYmluZCh0aGlzKSxcclxuICAgIH0pO1xyXG5cclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGFwaSwge1xyXG4gICAgICAvKipcclxuICAgICAgICogQG1lbWJlcm9mIFRleHRUb1NwZWVjaEZlYXR1cmVcclxuICAgICAgICogQGluc3RhbmNlXHJcbiAgICAgICAqIEBzZWUgQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlI3NwZWVjaG1hcmtPZmZzZXRcclxuICAgICAgICovXHJcbiAgICAgIHNwZWVjaG1hcmtPZmZzZXQ6IHtcclxuICAgICAgICBnZXQ6ICgpID0+IHRoaXMuc3BlZWNobWFya09mZnNldCxcclxuICAgICAgICBzZXQ6IG9mZnNldCA9PiB7XHJcbiAgICAgICAgICB0aGlzLnNwZWVjaG1hcmtPZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgfSxcclxuICAgICAgfSxcclxuICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBhcGk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIGFuZCBzZXRzIHRoZSB2b2x1bWUgdXNlZCBmb3IgYWxsIGF1ZGlvIGNsaXBzIHBsYXllZCBieSB0aGUgc3BlYWtlci5cclxuICAgKlxyXG4gICAqIEB0eXBlIHtudW1iZXJ9XHJcbiAgICovXHJcbiAgc2V0IHZvbHVtZSh2b2x1bWUpIHtcclxuICAgIHRoaXMuX3ZvbHVtZSA9IE1hdGhVdGlscy5jbGFtcCh2b2x1bWUpO1xyXG4gIH1cclxuXHJcbiAgZ2V0IHZvbHVtZSgpIHtcclxuICAgIHJldHVybiB0aGlzLl92b2x1bWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBHZXRzIHdoZXRoZXIgb3Igbm90IHRoZSBzcGVha2VyJ3Mgdm9sdW1lIHZhbHVlIGlzIGN1cnJlbnRseSBiZWluZyB0d2VlbmVkLlxyXG4gICAqXHJcbiAgICogQHJlYWRvbmx5XHJcbiAgICogQHR5cGUge2Jvb2xlYW59XHJcbiAgICovXHJcbiAgZ2V0IHZvbHVtZVBlbmRpbmcoKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fcHJvbWlzZXMudm9sdW1lICYmIHRoaXMuX3Byb21pc2VzLnZvbHVtZS5wZW5kaW5nO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogR2V0cyB0aGUgdm9sdW1lIHVzZWQgZm9yIGFsbCBhdWRpbyBjbGlwcyBwbGF5ZWQgYnkgdGhlIHNwZWFrZXIuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gICAqL1xyXG4gIGdldFZvbHVtZSgpIHtcclxuICAgIHJldHVybiB0aGlzLnZvbHVtZTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFVwZGF0ZXMgdGhlIHZvbHVtZSB1c2VkIGZvciBhbGwgYXVkaW8gY2xpcHMgcGxheWVkIGJ5IHRoZSBzcGVha2VyIG92ZXIgdGltZS5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSB2b2x1bWUgLSBUYXJnZXQgdm9sdW1lIHZhbHVlLlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBbc2Vjb25kcz0wXSAtIEFtb3VudCBvZiB0aW1lIGl0IHdpbGwgdGFrZSB0byByZWFjaCB0aGUgdGFyZ2V0XHJcbiAgICogdm9sdW1lLlxyXG4gICAqIEBwYXJhbSB7RnVuY3Rpb249fSBlYXNpbmdGbiAtIEVhc2luZyBmdW5jdGlvbiB1c2VkIGZvciBpbnRlcnBvbGF0aW9uLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge0RlZmVycmVkfVxyXG4gICAqL1xyXG4gIHNldFZvbHVtZSh2b2x1bWUsIHNlY29uZHMgPSAwLCBlYXNpbmdGbikge1xyXG4gICAgaWYgKHRoaXMudm9sdW1lUGVuZGluZykge1xyXG4gICAgICB0aGlzLl9wcm9taXNlcy52b2x1bWUuY2FuY2VsKCk7XHJcbiAgICB9XHJcblxyXG4gICAgdm9sdW1lID0gTWF0aFV0aWxzLmNsYW1wKHZvbHVtZSk7XHJcbiAgICB0aGlzLl9wcm9taXNlcy52b2x1bWUgPSBBbmltYXRpb25VdGlscy5pbnRlcnBvbGF0ZVByb3BlcnR5KFxyXG4gICAgICB0aGlzLFxyXG4gICAgICAndm9sdW1lJyxcclxuICAgICAgdm9sdW1lLFxyXG4gICAgICB7c2Vjb25kcywgZWFzaW5nRm59XHJcbiAgICApO1xyXG5cclxuICAgIHJldHVybiB0aGlzLl9wcm9taXNlcy52b2x1bWU7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBQYXVzZSBpbnRlcnBvbGF0aW9uIGhhcHBlbmluZyBvbiB0aGUgc3BlYWtlcidzIHZvbHVtZSBwcm9wZXJ0eS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqL1xyXG4gIHBhdXNlVm9sdW1lKCkge1xyXG4gICAgdGhpcy5fdm9sdW1lUGF1c2VkID0gdHJ1ZTtcclxuXHJcbiAgICByZXR1cm4gdGhpcy52b2x1bWVQZW5kaW5nO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogUmVzdW1lIGFueSBpbnRlcnBvbGF0aW9uIGhhcHBlbmluZyBvbiB0aGUgc3BlYWtlcidzIHZvbHVtZSBwcm9wZXJ0eS5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxyXG4gICAqL1xyXG4gIHJlc3VtZVZvbHVtZSgpIHtcclxuICAgIHRoaXMuX3ZvbHVtZVBhdXNlZCA9IGZhbHNlO1xyXG5cclxuICAgIHJldHVybiB0aGlzLnZvbHVtZVBlbmRpbmc7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBVcGRhdGUgdGhlIGN1cnJlbnRseSBwbGF5aW5nIHNwZWVjaC5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBkZWx0YVRpbWUgLSBUaW1lIHNpbmNlIHRoZSBsYXN0IHVwZGF0ZS5cclxuICAgKi9cclxuICB1cGRhdGUoZGVsdGFUaW1lKSB7XHJcbiAgICBpZiAoIXRoaXMuX3ZvbHVtZVBhdXNlZCkge1xyXG4gICAgICB0aGlzLl9wcm9taXNlcy52b2x1bWUuZXhlY3V0ZShkZWx0YVRpbWUpO1xyXG4gICAgfVxyXG5cclxuICAgIGlmICh0aGlzLl9jdXJyZW50U3BlZWNoICYmIHRoaXMuX2N1cnJlbnRTcGVlY2gucGxheWluZykge1xyXG4gICAgICB0aGlzLl9jdXJyZW50U3BlZWNoLnZvbHVtZSA9IHRoaXMuX3ZvbHVtZTtcclxuICAgICAgdGhpcy5fY3VycmVudFNwZWVjaC51cGRhdGUodGhpcy5faG9zdC5ub3cpO1xyXG4gICAgICBzdXBlci51cGRhdGUoZGVsdGFUaW1lKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIFNldCB0aGUgY3VycmVudCBzcGVlY2ggdG8gYSBuZXcgYXNzZXQgYW5kIHVwZGF0ZSB0aGUgc3BlZWNoJ3Mgc3BlZWNobWFya1xyXG4gICAqIG9mZnNldCB2YWx1ZSB0byBtYXRjaCB0aGF0IG9mIHRoZSBmZWF0dXJlLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKlxyXG4gICAqIEBwYXJhbSB7QWJzdHJhY3RTcGVlY2h9IHNwZWVjaCAtIFNwZWVjaCB0byBzZXQgYXMgY3VycmVudC5cclxuICAgKi9cclxuICBfc2V0Q3VycmVudFNwZWVjaChzcGVlY2gpIHtcclxuICAgIHNwZWVjaC5zcGVlY2htYXJrT2Zmc2V0ID0gdGhpcy5fc3BlZWNobWFya09mZnNldDtcclxuICAgIHRoaXMuX2N1cnJlbnRTcGVlY2ggPSBzcGVlY2g7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgYSBwcm9taXNlIHRoYXQgd2lsbCBwbGF5L3Jlc3VtZSBhIHNwZWVjaCB3aXRoIHRoZSBnaXZlbiB0ZXh0IGFmdGVyXHJcbiAgICogdGhlIGF1ZGlvIGNvbnRleHQgYXR0ZW1wdHMgdG8gcmVzdW1lIGFuZCBzcGVlY2ggYXVkaW8gaXMgcmV0cmlldmVkIGZyb20gUG9sbHkuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtzdHJpbmd9IHRleHQgLSBUaGUgdGV4dCBvZiB0aGUgbmV3IHNwZWVjaCB0byBwbGF5LlxyXG4gICAqIEBwYXJhbSB7T2JqZWN0PX0gY29uZmlnIC0gT3B0aW9uYWwgcGFyYW1ldGVycyBmb3IgdGhlIHNwZWVjaC5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gW3BsYXlNZXRob2QgPSAncGxheSddIC0gTWV0aG9kIHRvIGV4ZWN1dGUgb24gdGhlIHJlc3VsdGluZ1xyXG4gICAqIFNwZWVjaCBvYmplY3QuIFZhbGlkIG9wdGlvbnMgYXJlICdwbGF5JyBhbmQgJ3Jlc3VtZScuXHJcbiAgICovXHJcbiAgX3N0YXJ0U3BlZWNoKHRleHQsIGNvbmZpZywgcGxheU1ldGhvZCA9ICdwbGF5Jykge1xyXG4gICAgLy8gSWYgbm8gdGV4dCBpcyBwcm92aWRlZCwgdHJ5IHRvIHVzZSB0aGUgY3VycmVudCBzcGVlY2hcclxuICAgIGlmICh0ZXh0ID09PSB1bmRlZmluZWQgJiYgcGxheU1ldGhvZCA9PT0gJ3Jlc3VtZScgJiYgdGhpcy5fY3VycmVudFNwZWVjaCkge1xyXG4gICAgICB0ZXh0ID0gdGhpcy5fY3VycmVudFNwZWVjaC50ZXh0O1xyXG4gICAgfVxyXG5cclxuICAgIGNvbnN0IGN1cnJlbnRQcm9taXNlID0gdGhpcy5fY3VycmVudFByb21pc2UgfHwge1xyXG4gICAgICBwbGF5OiBuZXcgRGVmZXJyZWQoXHJcbiAgICAgICAgdW5kZWZpbmVkLFxyXG4gICAgICAgICgpID0+IHtcclxuICAgICAgICAgIGN1cnJlbnRQcm9taXNlLnNwZWVjaC5jYW5jZWwoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgICgpID0+IHtcclxuICAgICAgICAgIGN1cnJlbnRQcm9taXNlLnNwZWVjaC5jYW5jZWwoKTtcclxuICAgICAgICB9LFxyXG4gICAgICAgICgpID0+IHtcclxuICAgICAgICAgIGN1cnJlbnRQcm9taXNlLnNwZWVjaC5jYW5jZWwoKTtcclxuICAgICAgICB9XHJcbiAgICAgICksXHJcbiAgICAgIHNwZWVjaDogbmV3IERlZmVycmVkKCksXHJcbiAgICB9O1xyXG4gICAgdGhpcy5fY3VycmVudFByb21pc2UgPSBjdXJyZW50UHJvbWlzZTtcclxuXHJcbiAgICB0aGlzLl9nZXRTcGVlY2godGV4dCwgY29uZmlnKVxyXG4gICAgICAudGhlbihzcGVlY2ggPT4ge1xyXG4gICAgICAgIC8vIEV4aXQgaWYgdGhlIHByb21pc2UgaXMgbm8gbG9uZ2VyIHBlbmRpbmcgYmVjYXVzZSBvZiB1c2VyIGludGVyYWN0aW9uXHJcbiAgICAgICAgaWYgKCFjdXJyZW50UHJvbWlzZS5wbGF5LnBlbmRpbmcpIHtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9IGVsc2UgaWYgKHRoaXMuX2N1cnJlbnRQcm9taXNlICE9PSBjdXJyZW50UHJvbWlzZSkge1xyXG4gICAgICAgICAgLy8gQ2FuY2VsIGlmIGFub3RoZXIgY2FsbCB0byBwbGF5IGhhcyBhbHJlYWR5IGJlZW4gbWFkZVxyXG4gICAgICAgICAgY3VycmVudFByb21pc2UucGxheS5jYW5jZWwoKTtcclxuICAgICAgICAgIHJldHVybjtcclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIC8vIFJlc2V0IGN1cnJlbnQgc3BlZWNoIHdoZW4gdGhlIHNwZWVjaCBlbmRzXHJcbiAgICAgICAgY29uc3Qgb25GaW5pc2ggPSAoKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLl9jdXJyZW50U3BlZWNoID0gbnVsbDtcclxuICAgICAgICAgIHRoaXMuX2N1cnJlbnRQcm9taXNlID0gbnVsbDtcclxuICAgICAgICB9O1xyXG5cclxuICAgICAgICAvLyBDYW5jZWwgdGhlIGN1cnJlbnRseSBwbGF5aW5nIHNwZWVjaFxyXG4gICAgICAgIGlmICh0aGlzLl9jdXJyZW50U3BlZWNoICYmIHRoaXMuX2N1cnJlbnRTcGVlY2gucGxheWluZykge1xyXG4gICAgICAgICAgaWYgKHBsYXlNZXRob2QgPT09ICdwbGF5Jykge1xyXG4gICAgICAgICAgICB0aGlzLl9jdXJyZW50U3BlZWNoLmNhbmNlbCgpO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChcclxuICAgICAgICAgICAgcGxheU1ldGhvZCA9PT0gJ3Jlc3VtZScgJiZcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudFNwZWVjaC5hdWRpbyAhPT0gc3BlZWNoLmF1ZGlvXHJcbiAgICAgICAgICApIHtcclxuICAgICAgICAgICAgdGhpcy5fY3VycmVudFNwZWVjaC5jYW5jZWwoKTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcblxyXG4gICAgICAgIHRoaXMuX3NldEN1cnJlbnRTcGVlY2goc3BlZWNoKTtcclxuXHJcbiAgICAgICAgLy8gUGxheSB0aGUgc3BlZWNoXHJcbiAgICAgICAgY3VycmVudFByb21pc2Uuc3BlZWNoID0gc3BlZWNoW3BsYXlNZXRob2RdKFxyXG4gICAgICAgICAgdGhpcy5faG9zdC5ub3csXHJcbiAgICAgICAgICBvbkZpbmlzaCxcclxuICAgICAgICAgIG9uRmluaXNoLFxyXG4gICAgICAgICAgb25GaW5pc2hcclxuICAgICAgICApO1xyXG4gICAgICAgIGN1cnJlbnRQcm9taXNlLnNwZWVjaFxyXG4gICAgICAgICAgLnRoZW4oKCkgPT4ge1xyXG4gICAgICAgICAgICBpZiAoY3VycmVudFByb21pc2Uuc3BlZWNoLnJlc29sdmVkKSB7XHJcbiAgICAgICAgICAgICAgY3VycmVudFByb21pc2UucGxheS5yZXNvbHZlKCk7XHJcbiAgICAgICAgICAgIH0gZWxzZSB7XHJcbiAgICAgICAgICAgICAgY3VycmVudFByb21pc2UucGxheS5jYW5jZWwoKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfSlcclxuICAgICAgICAgIC5jYXRjaChlcnJvciA9PiB7XHJcbiAgICAgICAgICAgIGN1cnJlbnRQcm9taXNlLnBsYXkucmVqZWN0KGVycm9yKTtcclxuICAgICAgICAgIH0pO1xyXG4gICAgICB9KVxyXG4gICAgICAuY2F0Y2goZSA9PiB7XHJcbiAgICAgICAgZSA9IGBDYW5ub3QgJHtwbGF5TWV0aG9kfSBzcGVlY2ggJHt0ZXh0fSBvbiBob3N0ICR7dGhpcy5ob3N0LmlkfS4gJHtlfWA7XHJcbiAgICAgICAgY3VycmVudFByb21pc2UucGxheS5yZWplY3QoZSk7XHJcbiAgICAgIH0pO1xyXG5cclxuICAgIHJldHVybiBjdXJyZW50UHJvbWlzZS5wbGF5O1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RvcCBhbnkgc3BlZWNoZXMgY3VycmVudGx5IHBsYXlpbmcgYW5kIHBsYXkgYSBuZXcgc3BlZWNoIGZyb20gdGhlIGJlZ2lubmluZy5cclxuICAgKlxyXG4gICAqIEBwYXJhbSB7c3RyaW5nfSB0ZXh0IC0gVGhlIHRleHQgb2YgdGhlIG5ldyBzcGVlY2ggdG8gcGxheS5cclxuICAgKiBAcGFyYW0ge09iamVjdD19IGNvbmZpZyAtIE9wdGlvbmFsIHBhcmFtZXRlcnMgZm9yIHRoZSBzcGVlY2guXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9XHJcbiAgICovXHJcbiAgcGxheSh0ZXh0LCBjb25maWcpIHtcclxuICAgIHJldHVybiB0aGlzLl9zdGFydFNwZWVjaCh0ZXh0LCBjb25maWcsICdwbGF5Jyk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBJZiBhIHNwZWVjaCBpcyBjdXJyZW50bHkgcGxheWluZywgcGF1c2UgaXQgYXQgdGhlIGN1cnJlbnQgdGltZS5cclxuICAgKi9cclxuICBwYXVzZSgpIHtcclxuICAgIGlmICh0aGlzLl9jdXJyZW50U3BlZWNoICYmIHRoaXMuX2N1cnJlbnRTcGVlY2gucGxheWluZykge1xyXG4gICAgICB0aGlzLl9jdXJyZW50U3BlZWNoLnBhdXNlKHRoaXMuX2hvc3Qubm93KTtcclxuICAgIH0gZWxzZSB7XHJcbiAgICAgIGNvbnNvbGUud2FybihcclxuICAgICAgICBgQ2Fubm90IHBhdXNlIHNwZWVjaCBvbiBob3N0ICR7dGhpcy5ob3N0LmlkfS4gTm8gc3BlZWNoIGlzIGN1cnJlbnRseSBwbGF5aW5nYFxyXG4gICAgICApO1xyXG4gICAgfVxyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RvcCBhbnkgc3BlZWNoZXMgY3VycmVudGx5IHBsYXlpbmcgYW5kIHJlc3VtZSBhIG5ldyBzcGVlY2ggZnJvbSB0aGUgY3VycmVudFxyXG4gICAqIHRpbWUuXHJcbiAgICpcclxuICAgKiBAcGFyYW0ge3N0cmluZz19IHRleHQgLSBUaGUgdGV4dCBvZiB0aGUgbmV3IHNwZWVjaCB0byBwbGF5LiBJZiB1bmRlZmluZWQgYW5kXHJcbiAgICogdGhlcmUgaXMgYSBjdXJyZW50IHNwZWVjaCB0aGF0IGlzIHBhdXNlZCwgdGhlIGN1cnJlbnQgc3BlZWNoIHdpbGwgYmUgcmVzdW1lZC5cclxuICAgKiBAcGFyYW0ge09iamVjdD19IGNvbmZpZyAtIE9wdGlvbmFsIHBhcmFtZXRlcnMgZm9yIHRoZSBzcGVlY2guXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9XHJcbiAgICovXHJcbiAgcmVzdW1lKHRleHQsIGNvbmZpZykge1xyXG4gICAgcmV0dXJuIHRoaXMuX3N0YXJ0U3BlZWNoKHRleHQsIGNvbmZpZywgJ3Jlc3VtZScpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogSWYgYSBzcGVlY2ggaXMgY3VycmVudGx5IHBsYXlpbmcsIHN0b3AgcGxheWJhY2sgYW5kIHJlc2V0IHRpbWUuXHJcbiAgICovXHJcbiAgc3RvcCgpIHtcclxuICAgIGlmICh0aGlzLl9jdXJyZW50U3BlZWNoICYmIHRoaXMuX2N1cnJlbnRTcGVlY2gucGxheWluZykge1xyXG4gICAgICB0aGlzLl9jdXJyZW50U3BlZWNoLnN0b3AoKTtcclxuICAgICAgdGhpcy5fY3VycmVudFNwZWVjaCA9IG51bGw7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBjb25zb2xlLndhcm4oXHJcbiAgICAgICAgYENhbm5vdCBzdG9wIHNwZWVjaCBvbiBob3N0ICR7dGhpcy5ob3N0LmlkfS4gTm8gc3BlZWNoIGlzIGN1cnJlbnRseSBwbGF5aW5nLmBcclxuICAgICAgKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIGRpc2NhcmQoKSB7XHJcbiAgICBpZiAodGhpcy5fY3VycmVudFNwZWVjaCAmJiB0aGlzLl9jdXJyZW50U3BlZWNoLnBsYXlpbmcpIHtcclxuICAgICAgdGhpcy5fY3VycmVudFNwZWVjaC5zdG9wKCk7XHJcbiAgICB9XHJcblxyXG4gICAgZGVsZXRlIHRoaXMuX3NwZWVjaENhY2hlO1xyXG5cclxuICAgIHN1cGVyLmRpc2NhcmQoKTtcclxuICB9XHJcbn1cclxuXHJcbk9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZSwge1xyXG4gIEFXU19WRVJTSU9OOiB7XHJcbiAgICBnZXQ6ICgpID0+IGF3c1ZlcnNpb24sXHJcbiAgfSxcclxuICBQT0xMWV9NSU5fTkVVUkFMX1ZFUlNJT046IHtcclxuICAgIHZhbHVlOiAnMi41MDMnLFxyXG4gICAgd3JpdGFibGU6IGZhbHNlLFxyXG4gIH0sXHJcbiAgUE9MTFlfREVGQVVMVFM6IHtcclxuICAgIHZhbHVlOiB7XHJcbiAgICAgIEVuZ2luZTogJ3N0YW5kYXJkJyxcclxuICAgICAgTGV4aWNvbk5hbWVzOiBbXSxcclxuICAgICAgT3V0cHV0Rm9ybWF0OiAnbXAzJyxcclxuICAgICAgU2FtcGxlUmF0ZTogJzIyMDUwJyxcclxuICAgICAgVGV4dDogJycsXHJcbiAgICAgIFRleHRUeXBlOiAnc3NtbCcsXHJcbiAgICAgIFZvaWNlSWQ6ICdBbXknLFxyXG4gICAgICBMYW5ndWFnZUNvZGU6ICdlbi1HQicsXHJcbiAgICAgIExhbmd1YWdlTmFtZTogJ0JyaXRpc2ggRW5nbGlzaCcsXHJcbiAgICB9LFxyXG4gICAgd3JpdGFibGU6IGZhbHNlLFxyXG4gIH0sXHJcbiAgUE9MTFlfVk9JQ0VTOiB7XHJcbiAgICB2YWx1ZTogW10sXHJcbiAgICB3cml0YWJsZTogZmFsc2UsXHJcbiAgfSxcclxuICBQT0xMWV9MQU5HVUFHRVM6IHtcclxuICAgIHZhbHVlOiB7fSxcclxuICAgIHdyaXRhYmxlOiBmYWxzZSxcclxuICB9LFxyXG4gIFBPTExZX0xBTkdVQUdFX0NPREVTOiB7XHJcbiAgICB2YWx1ZToge30sXHJcbiAgICB3cml0YWJsZTogZmFsc2UsXHJcbiAgfSxcclxuICBfaXNSZWFkeToge1xyXG4gICAgdmFsdWU6IGZhbHNlLFxyXG4gICAgd3JpdGFibGU6IHRydWUsXHJcbiAgfSxcclxuICBFVkVOVFM6IHtcclxuICAgIHZhbHVlOiB7XHJcbiAgICAgIC4uLk9iamVjdC5nZXRQcm90b3R5cGVPZihBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUpLkVWRU5UUyxcclxuICAgICAgcmVhZHk6ICdvblJlYWR5RXZlbnQnLFxyXG4gICAgICBwbGF5OiAnb25QbGF5RXZlbnQnLFxyXG4gICAgICBwYXVzZTogJ29uUGF1c2VFdmVudCcsXHJcbiAgICAgIHJlc3VtZTogJ29uUmVzdW1lRXZlbnQnLFxyXG4gICAgICBpbnRlcnJ1cHQ6ICdvbkludGVycnVwdEV2ZW50JyxcclxuICAgICAgc3RvcDogJ29uU3RvcEV2ZW50JyxcclxuICAgICAgc2VudGVuY2U6ICdvblNlbnRlbmNlRXZlbnQnLFxyXG4gICAgICB3b3JkOiAnb25Xb3JkRXZlbnQnLFxyXG4gICAgICB2aXNlbWU6ICdvblZpc2VtZUV2ZW50JyxcclxuICAgICAgc3NtbDogJ29uU3NtbEV2ZW50JyxcclxuICAgIH0sXHJcbiAgfSxcclxuICBTRVJWSUNFUzoge1xyXG4gICAgdmFsdWU6IHtcclxuICAgICAgLi4uT2JqZWN0LmdldFByb3RvdHlwZU9mKEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZSkuU0VSVklDRVMsXHJcbiAgICAgIHBvbGx5OiB1bmRlZmluZWQsXHJcbiAgICAgIHByZXNpZ25lcjogdW5kZWZpbmVkLFxyXG4gICAgfSxcclxuICB9LFxyXG59KTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZTtcclxuIiwiLy8gQ29weXJpZ2h0IEFtYXpvbi5jb20sIEluYy4gb3IgaXRzIGFmZmlsaWF0ZXMuIEFsbCBSaWdodHMgUmVzZXJ2ZWQuXHJcbi8vIFNQRFgtTGljZW5zZS1JZGVudGlmaWVyOiBNSVQtMFxyXG5pbXBvcnQgU3BlZWNoIGZyb20gJ2FwcC9hd3NwYWNrL1NwZWVjaCc7XHJcbmltcG9ydCBEZWZlcnJlZCBmcm9tICdjb3JlL0RlZmVycmVkJztcclxuaW1wb3J0IEFic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZSBmcm9tICcuL0Fic3RyYWN0VGV4dFRvU3BlZWNoRmVhdHVyZSc7XHJcblxyXG4vKipcclxuICogQGV4dGVuZHMgQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlXHJcbiAqIEBhbGlhcyBjb3JlL1RleHRUb1NwZWVjaEZlYXR1cmVcclxuICovXHJcbmNsYXNzIFRleHRUb1NwZWVjaEZlYXR1cmUgZXh0ZW5kcyBBYnN0cmFjdFRleHRUb1NwZWVjaEZlYXR1cmUge1xyXG4gIGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcclxuICAgIHN1cGVyKC4uLmFyZ3MpO1xyXG5cclxuICAgIHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcclxuICAgIHRoaXMuX3NldEF1ZGlvQ29udGV4dCgpO1xyXG4gICAgdGhpcy5fb2JzZXJ2ZUF1ZGlvQ29udGV4dCgpO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogU3RvcmUgdGhlIGF1ZGlvIGNvbnRleHQgdGhhdCB3aWxsIGJlIHVzZWQgdG8gZW5zdXJlIGF1ZGlvIGNhbiBiZSBwbGF5ZWQuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqL1xyXG4gIF9zZXRBdWRpb0NvbnRleHQoKSB7XHJcbiAgICB0aGlzLl9hdWRpb0NvbnRleHQgPSBuZXcgQXVkaW9Db250ZXh0KCk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBMaXN0ZW4gZm9yIHN0YXRlIGNoYW5nZXMgb24gdGhlIGF1ZGlvIGNvbnRleHQgdG8gZGV0ZXJtaW5lIHdoZXRoZXIgdGhlIGZlYXR1cmVcclxuICAgKiBpcyBlbmFibGVkLlxyXG4gICAqXHJcbiAgICogQHByaXZhdGVcclxuICAgKi9cclxuICBfb2JzZXJ2ZUF1ZGlvQ29udGV4dCgpIHtcclxuICAgIGlmICh0aGlzLl9hdWRpb0NvbnRleHQpIHtcclxuICAgICAgdGhpcy5fYXVkaW9Db250ZXh0Lm9uc3RhdGVjaGFuZ2UgPSAoKSA9PiB7XHJcbiAgICAgICAgaWYgKHRoaXMuX2F1ZGlvQ29udGV4dC5zdGF0ZSA9PT0gJ3J1bm5pbmcnKSB7XHJcbiAgICAgICAgICB0aGlzLl9lbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgdGhpcy5fZW5hYmxlZCA9IGZhbHNlO1xyXG4gICAgICAgICAgY29uc29sZS53YXJuKFxyXG4gICAgICAgICAgICAnVGhlIGF1ZGlvIGNvbnRleHQgaXMgbm90IHJ1bm5pbmcuIFNwZWVjaCB3aWxsIG5vdCBiZSBhYmxlIHRvIGJlIHBsYXllZCB1bnRpbCBpdCBpcyByZXN1bWVkLiBVc2UgdGhlIFwiVGV4dFRvU3BlZWNoRmVhdHVyZS5yZXN1bWVBdWRpb1wiIG1ldGhvZCB0byB0cnkgdG8gcmVzdW1lIGl0IGFmdGVyIGEgdXNlciBnZXN0dXJlLidcclxuICAgICAgICAgICk7XHJcbiAgICAgICAgfVxyXG4gICAgICB9O1xyXG5cclxuICAgICAgdGhpcy5fYXVkaW9Db250ZXh0Lm9uc3RhdGVjaGFuZ2UoKTtcclxuICAgIH1cclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIENyZWF0ZSBhbiBBdWRpbyBvYmplY3Qgb2Ygc3BlZWNoIGF1ZGlvIGZvciB0aGUgZ2l2ZW4gc3BlZWNoIHRleHQuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIFBhcmFtZXRlcnMgb2JqZWN0IGNvbXBhdGlibGUgd2l0aCBQb2xseS5zeW50aGVzaXplU3BlZWNoLlxyXG4gICAqXHJcbiAgICogQHJldHVybnMge1Byb21pc2V9IFJlc29sdmVzIHdpdGggYW4gb2JqZWN0IGNvbnRhaW5pbmcgdGhlIGF1ZGlvIFVSTCBhbmQgQXVkaW9cclxuICAgKiBvYmplY3QuXHJcbiAgICovXHJcbiAgX3N5bnRoZXNpemVBdWRpbyhwYXJhbXMpIHtcclxuICAgIHJldHVybiBzdXBlci5fc3ludGhlc2l6ZUF1ZGlvKHBhcmFtcykudGhlbihyZXN1bHQgPT4ge1xyXG4gICAgICBjb25zdCB7dXJsfSA9IHJlc3VsdDtcclxuXHJcbiAgICAgIC8vIENyZWF0ZSBhbiBBdWRpbyBvYmplY3QgdGhhdCBwb2ludHMgdG8gdGhlIHByZXNpZ25lZCB1cmxcclxuICAgICAgY29uc3QgYXVkaW8gPSBuZXcgQXVkaW8odXJsKTtcclxuICAgICAgYXVkaW8ubG9vcCA9IHRoaXMubG9vcDtcclxuICAgICAgYXVkaW8uY3Jvc3NPcmlnaW4gPSAnYW5vbnltb3VzJztcclxuICAgICAgYXVkaW8ucHJlbG9hZCA9ICdhdXRvJztcclxuICAgICAgcmVzdWx0LmF1ZGlvID0gYXVkaW87XHJcblxyXG4gICAgICByZXR1cm4gbmV3IFByb21pc2UocmVzb2x2ZSA9PiB7XHJcbiAgICAgICAgLy8gUmVzb2x2ZSBvbmNlIHRoZSBtaW5pbXVtIGFtb3VudCBpcyBsb2FkZWRcclxuICAgICAgICBhdWRpby5hZGRFdmVudExpc3RlbmVyKCdjYW5wbGF5dGhyb3VnaCcsICgpID0+IHtcclxuICAgICAgICAgIHJlc29sdmUocmVzdWx0KTtcclxuICAgICAgICB9KTtcclxuXHJcbiAgICAgICAgLy8gU3RhcnQgbG9hZGluZyB0aGUgYXVkaW9cclxuICAgICAgICBkb2N1bWVudC5ib2R5LmFwcGVuZENoaWxkKGF1ZGlvKTtcclxuICAgICAgICBhdWRpby5sb2FkKCk7XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgfVxyXG5cclxuICAvKipcclxuICAgKiBDcmVhdGUgYSBuZXcgU3BlZWNoIG9iamVjdCBmb3IgdGhlIHNwZWFrZXIuXHJcbiAgICpcclxuICAgKiBAcHJpdmF0ZVxyXG4gICAqXHJcbiAgICogQHBhcmFtIHtUZXh0VG9TcGVlY2h9IHNwZWFrZXIgLSBUaGUgVGV4dFRvU3BlZWNoIGluc3RhbmNlIHRoYXQgd2lsbCBvd24gdGhlIHNwZWVjaC5cclxuICAgKiBAcGFyYW0ge3N0cmluZ30gdGV4dCAtIFRleHQgb2YgdGhlIHNwZWVjaC5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gc3BlZWNobWFya3MgLSBTcGVlY2htYXJrcyBmb3IgdGhlIHNwZWVjaC5cclxuICAgKiBAcGFyYW0ge09iamVjdH0gYXVkaW9Db25maWcgLSBBdWRpbyBmb3IgdGhlIHNwZWVjaC5cclxuICAgKlxyXG4gICAqIEByZXR1cm5zIHtBYnN0cmFjdFNwZWVjaH1cclxuICAgKi9cclxuICBfY3JlYXRlU3BlZWNoKHRleHQsIHNwZWVjaG1hcmtzLCBhdWRpb0NvbmZpZykge1xyXG4gICAgcmV0dXJuIG5ldyBTcGVlY2godGhpcywgdGV4dCwgc3BlZWNobWFya3MsIGF1ZGlvQ29uZmlnKTtcclxuICB9XHJcblxyXG4gIC8qKlxyXG4gICAqIEdldHMgd2hldGhlciBvciBub3QgdGhlIGF1ZGlvIGNvbnRleHQgaXMgcnVubmluZyBhbmQgc3BlZWNoIGNhbiBiZSBwbGF5ZWQuXHJcbiAgICpcclxuICAgKiBAcmVhZG9ubHlcclxuICAgKiBAdHlwZSB7Ym9vbGVhbn1cclxuICAgKi9cclxuICBnZXQgZW5hYmxlZCgpIHtcclxuICAgIHJldHVybiB0aGlzLl9lbmFibGVkO1xyXG4gIH1cclxuXHJcbiAgLyoqXHJcbiAgICogVHJ5IHRvIHJlc3VtZSB0aGUgYXVkaW8gY29udGV4dC4gVGhpcyB3aWxsIGJlIGF1dG9tYXRpY2FsbHkgZXhlY3V0ZWQgZWFjaCB0aW1lXHJcbiAgICogc3BlZWNoIGlzIHBsYXllZCBvciByZXN1bWVkLiBJZiB1c2luZyBtYW51YWxseSwgaXQgc2hvdWxkIGJlIGNhbGxlZCBhZnRlciBhXHJcbiAgICogdXNlciBpbnRlcmFjdGlvbiBvY2N1cnMuXHJcbiAgICpcclxuICAgKiBAcmV0dXJucyB7RGVmZXJyZWR9IC0gUmVzb2x2ZXMgb25jZSB0aGUgYXVkaW8gY29udGV4dCBoYXMgcmVzdW1lZC5cclxuICAgKi9cclxuICByZXN1bWVBdWRpbygpIHtcclxuICAgIGNvbnN0IHByb21pc2UgPSBuZXcgRGVmZXJyZWQoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xyXG4gICAgICB0aGlzLl9hdWRpb0NvbnRleHRcclxuICAgICAgICAucmVzdW1lKClcclxuICAgICAgICAudGhlbigoKSA9PiB7XHJcbiAgICAgICAgICB0aGlzLl9lbmFibGVkID0gdHJ1ZTtcclxuICAgICAgICAgIHJlc29sdmUoKTtcclxuICAgICAgICB9KVxyXG4gICAgICAgIC5jYXRjaChlID0+IHtcclxuICAgICAgICAgIHRoaXMuX2VuYWJsZWQgPSBmYWxzZTtcclxuICAgICAgICAgIHJlamVjdChlKTtcclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIHByb21pc2U7XHJcbiAgfVxyXG5cclxuICBfc3RhcnRTcGVlY2godGV4dCwgY29uZmlnLCBwbGF5TWV0aG9kID0gJ3BsYXknKSB7XHJcbiAgICBjb25zdCBjdXJyZW50UHJvbWlzZSA9IHtcclxuICAgICAgcGxheTogbmV3IERlZmVycmVkKFxyXG4gICAgICAgIHVuZGVmaW5lZCxcclxuICAgICAgICAoKSA9PiB7IGN1cnJlbnRQcm9taXNlLnNwZWVjaC5jYW5jZWwoKTsgfSxcclxuICAgICAgICAoKSA9PiB7IGN1cnJlbnRQcm9taXNlLnNwZWVjaC5jYW5jZWwoKTsgfSxcclxuICAgICAgICAoKSA9PiB7IGN1cnJlbnRQcm9taXNlLnNwZWVjaC5jYW5jZWwoKTsgfVxyXG4gICAgICApLFxyXG4gICAgICBzcGVlY2g6IG5ldyBEZWZlcnJlZCgpLFxyXG4gICAgfTtcclxuICAgIHRoaXMuX2N1cnJlbnRQcm9taXNlID0gY3VycmVudFByb21pc2U7XHJcblxyXG4gICAgLy8gVHJ5IHRvIHN0YXJ0IHRoZSBhdWRpbyBjb250ZXh0XHJcbiAgICB0aGlzLnJlc3VtZUF1ZGlvKCkudGhlbigoKSA9PiB7XHJcbiAgICAgIC8vIEV4aXQgaWYgdGhlIHByb21pc2UgaXMgbm8gbG9uZ2VyIHBlbmRpbmcgYmVjYXVzZSBvZiB1c2VyIGludGVyYWN0aW9uXHJcbiAgICAgIGlmICghY3VycmVudFByb21pc2UucGxheS5wZW5kaW5nKSB7XHJcbiAgICAgICAgcmV0dXJuO1xyXG4gICAgICB9XHJcbiAgICAgIC8vIENhbmNlbCBpZiBhbm90aGVyIGNhbGwgdG8gcGxheSBoYXMgYWxyZWFkeSBiZWVuIG1hZGVcclxuICAgICAgZWxzZSBpZiAodGhpcy5fY3VycmVudFByb21pc2UgIT09IGN1cnJlbnRQcm9taXNlKSB7XHJcbiAgICAgICAgY3VycmVudFByb21pc2UucGxheS5jYW5jZWwoKTtcclxuICAgICAgICByZXR1cm47XHJcbiAgICAgIH1cclxuXHJcbiAgICAgIC8vIFRoZSBhdWRpbyBjb250ZXh0IGlzIHJ1bm5pbmcgc28gdGhlIHNwZWVjaCBjYW4gYmUgcGxheWVkXHJcbiAgICAgIGlmICh0aGlzLl9lbmFibGVkKSB7XHJcbiAgICAgICAgc3VwZXIuX3N0YXJ0U3BlZWNoKHRleHQsIGNvbmZpZywgcGxheU1ldGhvZCk7XHJcbiAgICAgIH1cclxuICAgICAgLy8gUmVqZWN0IGlmIHRoZSBhdWRpbyBjb250ZXh0IGlzIG5vdCBydW5uaW5nXHJcbiAgICAgIGVsc2Uge1xyXG4gICAgICAgIGN1cnJlbnRQcm9taXNlLnJlamVjdChcclxuICAgICAgICAgIG5ldyBFcnJvcihcclxuICAgICAgICAgICAgYENhbm5vdCAke3BsYXlNZXRob2R9IHNwZWVjaCBvbiBob3N0ICR7dGhpcy5faG9zdC5pZH0uIFRoZSBhdWRpbyBjb250ZXh0IGlzIG5vdCBydW5uaW5nLiBVc2UgdGhlIFwiVGV4dFRvU3BlZWNoRmVhdHVyZS5yZXN1bWVBdWRpb1wiIG1ldGhvZCB0byB0cnkgdG8gcmVzdW1lIGl0IGFmdGVyIGEgdXNlciBnZXN0dXJlLmBcclxuICAgICAgICAgIClcclxuICAgICAgICApO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuXHJcbiAgICByZXR1cm4gY3VycmVudFByb21pc2UucGxheTtcclxuICB9XHJcblxyXG4gIHBsYXkodGV4dCwgY29uZmlnKSB7XHJcbiAgICByZXR1cm4gdGhpcy5fc3RhcnRTcGVlY2godGV4dCwgY29uZmlnLCAncGxheScpO1xyXG4gIH1cclxuXHJcbiAgcmVzdW1lKHRleHQsIGNvbmZpZykge1xyXG4gICAgcmV0dXJuIHRoaXMuX3N0YXJ0U3BlZWNoKHRleHQsIGNvbmZpZywgJ3Jlc3VtZScpO1xyXG4gIH1cclxuXHJcbiAgaW5zdGFsbEFwaSgpIHtcclxuICAgIGNvbnN0IGFwaSA9IHN1cGVyLmluc3RhbGxBcGkoKTtcclxuXHJcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhhcGksIHtcclxuICAgICAgLyoqXHJcbiAgICAgICAqIEBtZW1iZXJvZiBUZXh0VG9TcGVlY2hGZWF0dXJlXHJcbiAgICAgICAqIEBpbnN0YW5jZVxyXG4gICAgICAgKiBAc2VlIGNvcmUvVGV4dFRvU3BlZWNoRmVhdHVyZSNlbmFibGVkXHJcbiAgICAgICAqL1xyXG4gICAgICBlbmFibGVkOiB7XHJcbiAgICAgICAgZ2V0OiAoKSA9PiB0aGlzLl9lbmFibGVkLFxyXG4gICAgICB9LFxyXG4gICAgfSk7XHJcblxyXG4gICAgcmV0dXJuIGFwaTtcclxuICB9XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IFRleHRUb1NwZWVjaEZlYXR1cmU7XHJcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcclxuaW1wb3J0IFRleHRUb1NwZWVjaEZlYXR1cmUgZnJvbSAnLi9UZXh0VG9TcGVlY2hGZWF0dXJlJztcclxuaW1wb3J0IFRleHRUb1NwZWVjaFV0aWxzIGZyb20gJy4vVGV4dFRvU3BlZWNoVXRpbHMnO1xyXG5pbXBvcnQgU3BlZWNoIGZyb20gJy4vU3BlZWNoJztcclxuXHJcbi8qKlxyXG4gKiBAbW9kdWxlIGNvcmUvYXdzcGFja1xyXG4gKi9cclxuXHJcbmV4cG9ydCB7XHJcbiAgLyoqXHJcbiAgICogQHNlZSBjb3JlL1RleHRUb1NwZWVjaEZlYXR1cmVcclxuICAgKi9cclxuICBUZXh0VG9TcGVlY2hGZWF0dXJlLFxyXG4gIC8qKlxyXG4gICAqIEBzZWUgY29yZS9UZXh0VG9TcGVlY2hVdGlsc1xyXG4gICAqL1xyXG4gIFRleHRUb1NwZWVjaFV0aWxzLFxyXG4gIC8qKlxyXG4gICAqIEBzZWUgY29yZS9TcGVlY2hcclxuICAgKi9cclxuICBTcGVlY2gsXHJcbn07XHJcbiIsIi8vIENvcHlyaWdodCBBbWF6b24uY29tLCBJbmMuIG9yIGl0cyBhZmZpbGlhdGVzLiBBbGwgUmlnaHRzIFJlc2VydmVkLlxyXG4vLyBTUERYLUxpY2Vuc2UtSWRlbnRpZmllcjogTUlULTBcclxuXHJcbi8qKlxyXG4gKiBAbW9kdWxlIGNvcmUvSE9TVFxyXG4gKi9cclxuXHJcbmltcG9ydCBVdGlscyBmcm9tICcuL1V0aWxzJztcclxuaW1wb3J0IE1hdGhVdGlscyBmcm9tICcuL01hdGhVdGlscyc7XHJcbmltcG9ydCBEZWZlcnJlZCBmcm9tICcuL0RlZmVycmVkJztcclxuaW1wb3J0IHtlbnZ9IGZyb20gJy4vSG9zdEVudmlyb25tZW50JztcclxuaW1wb3J0IE1lc3NlbmdlciBmcm9tICcuL01lc3Nlbmdlcic7XHJcbmltcG9ydCBIb3N0T2JqZWN0IGZyb20gJy4vSG9zdE9iamVjdCc7XHJcbmltcG9ydCBMaXBzeW5jRmVhdHVyZSwgeyBEZWZhdWx0VmlzZW1lTWFwIH0gZnJvbSAnLi9MaXBzeW5jRmVhdHVyZSc7XHJcbmltcG9ydCBHZXN0dXJlRmVhdHVyZSwgeyBEZWZhdWx0R2VzdHVyZVdvcmRzIH0gZnJvbSAnLi9HZXN0dXJlRmVhdHVyZSc7XHJcbmltcG9ydCBQb2ludE9mSW50ZXJlc3RGZWF0dXJlLCB7IEF4aXNNYXAgfSBmcm9tICcuL1BvaW50T2ZJbnRlcmVzdEZlYXR1cmUnO1xyXG5cclxuaW1wb3J0IHsgRWFzaW5nLFxyXG4gIEFuaW1hdGlvbkZlYXR1cmUsXHJcbiAgQW5pbWF0aW9uVHlwZXMsXHJcbiAgQW5pbWF0aW9uTGF5ZXIsXHJcbiAgTGF5ZXJCbGVuZE1vZGVzLFxyXG4gIERlZmF1bHRMYXllckJsZW5kTW9kZSxcclxuICBTaW5nbGVTdGF0ZSxcclxuICBUcmFuc2l0aW9uU3RhdGUsXHJcbiAgRnJlZUJsZW5kU3RhdGUsXHJcbiAgUXVldWVTdGF0ZSxcclxuICBSYW5kb21BbmltYXRpb25TdGF0ZSxcclxuICBCbGVuZDFkU3RhdGUsXHJcbiAgQmxlbmQyZFN0YXRlLFxyXG4gIEFuaW1hdGlvblV0aWxzIH0gZnJvbSAnLi9hbmltcGFjayc7XHJcblxyXG5pbXBvcnQgeyBUZXh0VG9TcGVlY2hGZWF0dXJlLFxyXG4gIFRleHRUb1NwZWVjaFV0aWxzLFxyXG4gIFNwZWVjaCB9IGZyb20gJy4vYXdzcGFjayc7XHJcblxyXG5leHBvcnQge1xyXG4gIC8qKlxyXG4gICAqIEBzZWUgZW52XHJcbiAgICovXHJcbiAgZW52LFxyXG4gIC8qKlxyXG4gICAqIEBzZWUgVXRpbHNcclxuICAgKi9cclxuICBVdGlscyxcclxuICAvKipcclxuICAgKiBAc2VlIE1hdGhVdGlsc1xyXG4gICAqL1xyXG4gIE1hdGhVdGlscyxcclxuICAvKipcclxuICAgKiBAc2VlIERlZmVycmVkXHJcbiAgICovXHJcbiAgRGVmZXJyZWQsXHJcbiAgLyoqXHJcbiAgICogQHNlZSBjb3JlL01lc3NlbmdlclxyXG4gICAqL1xyXG4gIE1lc3NlbmdlcixcclxuICAvKipcclxuICAgKiBAc2VlIGNvcmUvSG9zdE9iamVjdFxyXG4gICAqL1xyXG4gIEhvc3RPYmplY3QsXHJcbiAgLyoqXHJcbiAgICogQHNlZSBjb3JlL0xpcHN5bmNGZWF0dXJlXHJcbiAgICovXHJcbiAgTGlwc3luY0ZlYXR1cmUsXHJcbiAgLyoqXHJcbiAgICogQHNlZSBHZXN0dXJlRmVhdHVyZVxyXG4gICAqL1xyXG4gIEdlc3R1cmVGZWF0dXJlLFxyXG4gIC8qKlxyXG4gICAqIEBzZWUgY29yZS9Qb2ludE9mSW50ZXJlc3RGZWF0dXJlXHJcbiAgICovXHJcbiAgUG9pbnRPZkludGVyZXN0RmVhdHVyZSxcclxuICAvKipcclxuICAgKiBAc2VlIERlZmF1bHRWaXNlbWVNYXBcclxuICAgKi9cclxuICBEZWZhdWx0VmlzZW1lTWFwLFxyXG4gIC8qKlxyXG4gICAqIEBzZWUgRGVmYXVsdEdlc3R1cmVXb3Jkc1xyXG4gICAqL1xyXG4gIERlZmF1bHRHZXN0dXJlV29yZHMsXHJcbiAgLyoqXHJcbiAgICogQHNlZSBBeGlzTWFwXHJcbiAgICovXHJcbiAgQXhpc01hcCxcclxuXHJcbiAgLy8gQW5pbXBhY2tcclxuICAvKipcclxuICAgKiBAc2VlIGNvcmUvQW5pbWF0aW9uRmVhdHVyZVxyXG4gICAqL1xyXG4gICBBbmltYXRpb25GZWF0dXJlLFxyXG4gICAvKipcclxuICAgICogQHNlZSBBbmltYXRpb25MYXllclxyXG4gICAgKi9cclxuICAgQW5pbWF0aW9uTGF5ZXIsXHJcbiAgIC8qKlxyXG4gICAgKiBAc2VlIGNvcmUvU2luZ2xlU3RhdGVcclxuICAgICovXHJcbiAgIFNpbmdsZVN0YXRlLFxyXG4gICAvKipcclxuICAgICogQHNlZSBUcmFuc2l0aW9uU3RhdGVcclxuICAgICovXHJcbiAgIFRyYW5zaXRpb25TdGF0ZSxcclxuICAgLyoqXHJcbiAgICAqIEBzZWUgRnJlZUJsZW5kU3RhdGVcclxuICAgICovXHJcbiAgIEZyZWVCbGVuZFN0YXRlLFxyXG4gICAvKipcclxuICAgICogQHNlZSBRdWV1ZVN0YXRlXHJcbiAgICAqL1xyXG4gICBRdWV1ZVN0YXRlLFxyXG4gICAvKipcclxuICAgICogQHNlZSBSYW5kb21BbmltYXRpb25TdGF0ZVxyXG4gICAgKi9cclxuICAgUmFuZG9tQW5pbWF0aW9uU3RhdGUsXHJcbiAgIC8qKlxyXG4gICAgKiBAc2VlIEJsZW5kMWRTdGF0ZVxyXG4gICAgKi9cclxuICAgQmxlbmQxZFN0YXRlLFxyXG4gICAvKipcclxuICAgICogQHNlZSBCbGVuZDJkU3RhdGVcclxuICAgICovXHJcbiAgIEJsZW5kMmRTdGF0ZSxcclxuICAgLyoqXHJcbiAgICAqIEBzZWUgQW5pbWF0aW9uVXRpbHNcclxuICAgICovXHJcbiAgIEFuaW1hdGlvblV0aWxzLFxyXG4gXHJcbiAgIEVhc2luZyxcclxuICAgLyoqXHJcbiAgICAqIEBzZWUgTGF5ZXJCbGVuZE1vZGVzXHJcbiAgICAqL1xyXG4gICBMYXllckJsZW5kTW9kZXMsXHJcbiAgIC8qKlxyXG4gICAgKiBAc2VlIERlZmF1bHRMYXllckJsZW5kTW9kZVxyXG4gICAgKi9cclxuICAgRGVmYXVsdExheWVyQmxlbmRNb2RlLFxyXG4gICAvKipcclxuICAgICogQHNlZSBBbmltYXRpb25UeXBlc1xyXG4gICAgKi9cclxuICAgQW5pbWF0aW9uVHlwZXMsXHJcblxyXG5cclxuICAgLy8gQVdTIFBhY2tcclxuICAvKipcclxuICAgKiBAc2VlIGNvcmUvVGV4dFRvU3BlZWNoRmVhdHVyZVxyXG4gICAqL1xyXG4gIFRleHRUb1NwZWVjaEZlYXR1cmUsXHJcbiAgLyoqXHJcbiAgICogQHNlZSBjb3JlL1RleHRUb1NwZWVjaFV0aWxzXHJcbiAgICovXHJcbiAgVGV4dFRvU3BlZWNoVXRpbHMsXHJcbiAgLyoqXHJcbiAgICogQHNlZSBjb3JlL1NwZWVjaFxyXG4gICAqL1xyXG4gIFNwZWVjaCxcclxufTtcclxuIl0sIm5hbWVzIjpbIkRlZmVycmVkIiwiZXhlY3V0YWJsZSIsIm9uUmVzb2x2ZSIsIm9uUmVqZWN0Iiwib25DYW5jZWwiLCJFcnJvciIsInJlcyIsInJlaiIsImNhbmNlbCIsInN0YXR1cyIsInJlc29sdmVkIiwicmVqZWN0ZWQiLCJjYW5jZWxlZCIsInBlbmRpbmciLCJyZXNvbHZlIiwicmVqZWN0IiwidmFsdWUiLCJfc3RhdHVzIiwiX3Jlc29sdmUiLCJfcmVqZWN0IiwiX2NhbmNlbCIsIl9leGVjdXRhYmxlIiwiYXJncyIsIml0ZXJhYmxlIiwiU3ltYm9sIiwiaXRlcmF0b3IiLCJlIiwiYXJyYXkiLCJkZWZlcnJlZCIsImZpbHRlciIsIml0ZW0iLCJyZXN1bHQiLCJ1bmRlZmluZWQiLCJyZXNvbHZlVmFsdWUiLCJmb3JFYWNoIiwibGVuZ3RoIiwiZXJyb3IiLCJjYW5jZWxWYWx1ZSIsIm51bUl0ZW1zIiwiaXRlbVRyYWNrZXIiLCJmYWlsZWQiLCJudW1SZXNvbHZlZCIsInJlc29sdXRpb25zIiwiaW5kZXgiLCJQcm9taXNlIiwidGhlbiIsIlV0aWxzIiwicmVwbGFjZSIsImMiLCJyYW5kb21OdW1iZXIiLCJNYXRoIiwiZmxvb3IiLCJEYXRlIiwibm93IiwicmFuZG9tIiwidG9TdHJpbmciLCJuYW1lIiwibmFtZUFycmF5IiwiaW5jbHVkZXMiLCJuYW1lU2V0IiwiU2V0IiwibWF0Y2hHcm91cCIsIm1hdGNoIiwiYmFzZU5hbWUiLCJzbGljZSIsImluY3JlbWVudCIsIk51bWJlciIsInNldE5hbWUiLCJzZXRNYXRjaEdyb3VwIiwic2V0SW5jcmVtZW50Iiwic2Vjb25kcyIsIm9uRmluaXNoIiwib25Qcm9ncmVzcyIsIm9uRXJyb3IiLCJjb25zb2xlIiwid2FybiIsImN1cnJlbnRUaW1lIiwidG90YWxUaW1lIiwib25VcGRhdGUiLCJkZWx0YVRpbWUiLCJtaW4iLCJtYXgiLCJjZWlsIiwiUmFkaWFuVG9EZWdyZWUiLCJQSSIsIkRlZ3JlZVRvUmFkaWFuIiwiTWF0aFV0aWxzIiwicmFkaWFucyIsImRlZ3JlZXMiLCJmcm9tIiwidG8iLCJmYWN0b3IiLCJhIiwiYiIsInAiLCJkaXN0U3FyIiwiZGlzdGFuY2VTcXVhcmVkIiwidCIsInBvaW50IiwidmVydGljZXMiLCJtaW5YIiwiUE9TSVRJVkVfSU5GSU5JVFkiLCJtaW5ZIiwibWF4WCIsIk5FR0FUSVZFX0lORklOSVRZIiwibWF4WSIsInYiLCJkWCIsImRZIiwibWlkWCIsIm1pZFkiLCJkTWF4Iiwic3VwZXJJbmRpY2VzIiwidmVydHNXaXRoU3VwZXIiLCJzdXBlclNvcnRlZEluZGljZXMiLCJzb3J0UG9pbnRzQ0NXIiwic3VwZXJUcmlhbmdsZSIsImluZGljZXMiLCJlZGdlcyIsInRyaWFuZ2xlcyIsIm5ld1ZlcnQiLCJuZXdJbmRleCIsImludmFsaWRUcmlhbmdsZXMiLCJ0cmlhbmdsZSIsImlzUG9pbnRJbkNpcmN1bUNpcmNsZSIsInB1c2giLCJib3VuZGluZ1BvbHkiLCJlZGdlIiwiY291bnQiLCJvdGhlclRyaWFuZ2xlIiwib3RoZXJFZGdlIiwic3BsaWNlIiwiaW5kZXhPZiIsInNvcnRlZEluZGljZXMiLCJ0cmlhbmdsZXNUb1JlbW92ZSIsIm1hcCIsImF4IiwiYXkiLCJieCIsImJ5IiwiY3giLCJjeSIsImRlbm9tIiwiYVZhbCIsImJWYWwiLCJjVmFsIiwiY2VudHJvaWQiLCJzb3J0IiwiYXRhbjIiLCJhYnMiLCJ2ZWN0b3IiLCJBcnJheSIsInJlZHVjZXIiLCJhY2N1bXVsYXRvciIsImN1cnJlbnRWYWx1ZSIsInNxcnQiLCJyZWR1Y2UiLCJ2ZWN0b3JBIiwidmVjdG9yQiIsInZhbHVlQSIsInZhbHVlQiIsIm5vcm1hbEEiLCJub3JtYWxpemVWZWN0b3IiLCJub3JtYWxCIiwiZG90IiwiZ2V0RG90UHJvZHVjdCIsImFjb3MiLCJjbGFtcCIsInZlY3RvcjMiLCJtYXRyaXgzIiwiZXZlcnkiLCJ4IiwieSIsInoiLCJtYWduaXR1ZGUiLCJnZXRWZWN0b3JNYWduaXR1ZGUiLCJmaWxsIiwibWF0cml4NCIsInNjYWxlWCIsInNjYWxlWSIsInNjYWxlWiIsInIiLCJ0YXJnZXRWYWx1ZSIsInZhbHVlU3RvcmUiLCJzbW9vdGhUaW1lIiwibWF4U3BlZWQiLCJjbGFtcFRpbWUiLCJkZWx0YVZhbHVlIiwiY2xhbXBEZWx0YVZhbHVlIiwibGFzdFZhbHVlIiwiZDEiLCJkMiIsImQzIiwiZDQiLCJNZXNzZW5nZXIiLCJpZCIsIl9pZCIsImNyZWF0ZUlkIiwiX2Rpc3BhdGNoZXIiLCJ3aW5kb3ciLCJfY2FsbGJhY2tzIiwiX2V2ZW50TGlzdGVuZXJzIiwibWVzc2FnZSIsImNhbGxiYWNrIiwiZGV0YWlsIiwiQ3VzdG9tRXZlbnQiLCJsaXN0ZW5lciIsImFkZEV2ZW50TGlzdGVuZXIiLCJfY3JlYXRlTG9jYWxNZXNzYWdlIiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIl9jcmVhdGVMaXN0ZW5lciIsIl9hZGRMaXN0ZW5lciIsImkiLCJzdG9wTGlzdGVuaW5nIiwiX3JlbW92ZUxpc3RlbmVyIiwicmVnZXhwIiwibWVzc2FnZXMiLCJPYmplY3QiLCJrZXlzIiwidGVzdCIsImV2ZW50IiwiX2NyZWF0ZUV2ZW50IiwiZGlzcGF0Y2hFdmVudCIsIm1lc3NlbmdlciIsIkdsb2JhbE1lc3NlbmdlciIsImxpc3RlblRvIiwic3RvcExpc3RlbmluZ1RvQWxsIiwiZW1pdCIsImRlZmluZVByb3BlcnRpZXMiLCJ3cml0YWJsZSIsIkVWRU5UUyIsIkFic3RyYWN0SG9zdEZlYXR1cmUiLCJob3N0IiwiX2hvc3QiLCJldmVudHMiLCJhcGkiLCJlbnRyaWVzIiwiY29uc3RydWN0b3IiLCJvd25lciIsInN0b3BMaXN0ZW5pbmdCeVJlZ2V4cCIsInVwZGF0ZSIsIlJlZ0V4cCIsInNvdXJjZSIsIlJlc3VsdENsYXNzIiwibWl4aW5DbGFzc0ZhY3RvcmllcyIsIm1peGluQ2xhc3NGYWN0b3J5IiwiU0VSVklDRVMiLCJIb3N0T2JqZWN0IiwiX293bmVyIiwiX2ZlYXR1cmVzIiwiX3dhaXRzIiwiX2xhc3RVcGRhdGUiLCJkdCIsIndhaXQiLCJleGVjdXRlIiwidmFsdWVzIiwiZmVhdHVyZSIsIm9uQ29tcGxldGUiLCJGZWF0dXJlQ2xhc3MiLCJmb3JjZSIsImlucHV0VHlwZSIsInByb3RvdHlwZSIsImluc3RhbGxBcGkiLCJhZGRGZWF0dXJlIiwidHlwZU5hbWUiLCJyZW1vdmVGZWF0dXJlIiwiZGlzY2FyZCIsImRlZmluZVByb3BlcnR5IiwiZ2V0UHJvdG90eXBlT2YiLCJMaW5lYXIiLCJOb25lIiwiayIsIkluIiwiT3V0IiwiSW5PdXQiLCJRdWFkcmF0aWMiLCJDdWJpYyIsIlF1YXJ0aWMiLCJRdWludGljIiwiU2ludXNvaWRhbCIsImNvcyIsInNpbiIsIkV4cG9uZW50aWFsIiwiQ2lyY3VsYXIiLCJFbGFzdGljIiwicyIsImFzaW4iLCJCYWNrIiwiQm91bmNlIiwiRmVhdHVyZURlcGVuZGVudEludGVyZmFjZSIsIkJhc2VDbGFzcyIsIkZlYXR1cmVEZXBlbmRlbnRNaXhpbiIsIl9pbml0aWFsaXplZCIsIl9vbkZlYXR1cmVBZGRlZCIsImJpbmQiLCJfb25GZWF0dXJlUmVtb3ZlZCIsIkVWRU5UX0RFUEVOREVOQ0lFUyIsImV2ZW50TmFtZSIsIkFuaW1hdGlvbkZlYXR1cmVEZXBlbmRlbnRJbnRlcmZhY2UiLCJvbGROYW1lIiwibmV3TmFtZSIsImxheWVyTmFtZSIsImFuaW1hdGlvbk5hbWUiLCJQYXJlbnRDbGFzcyIsIk1peGluIiwiQW5pbWF0aW9uRmVhdHVyZURlcGVuZGVudE1peGluIiwiQW5pbWF0aW9uRmVhdHVyZSIsImFkZExheWVyIiwicmVtb3ZlTGF5ZXIiLCJyZW5hbWVMYXllciIsImFkZEFuaW1hdGlvbiIsInJlbW92ZUFuaW1hdGlvbiIsInJlbmFtZUFuaW1hdGlvbiIsIk1hbmFnZWRBbmltYXRpb25MYXllckludGVyZmFjZSIsIm9wdGlvbnMiLCJuYW1lRmlsdGVyIiwid2VpZ2h0IiwiZWFzaW5nRm4iLCJNYW5hZ2VkQW5pbWF0aW9uTGF5ZXJNaXhpbiIsIl9tYW5hZ2VkTGF5ZXJzIiwibGF5ZXJzIiwiX29uTGF5ZXJBZGRlZCIsIl9vbkxheWVyUmVtb3ZlZCIsImlzQWN0aXZlIiwiZ2V0QW5pbWF0aW9ucyIsImFuaW1OYW1lIiwiX29uQW5pbWF0aW9uQWRkZWQiLCJhbmltYXRpb25zIiwiX29uQW5pbWF0aW9uUmVtb3ZlZCIsImxheWVyT3B0aW9ucyIsImFuaW1PcHRpb25zIiwiREVGQVVMVF9MQVlFUl9PUFRJT05TIiwiYW5pbWF0aW9uT3B0aW9ucyIsImFzc2lnbiIsInJlZ2lzdGVyQW5pbWF0aW9uIiwicmVnaXN0ZXJMYXllciIsImxheWVyTmFtZXMiLCJzZXRMYXllcldlaWdodCIsImJsZW5kVGltZSIsInNldExheWVyV2VpZ2h0cyIsImVuYWJsZSIsImRpc2FibGUiLCJUZXh0VG9TcGVlY2hGZWF0dXJlRGVwZW5kZW50SW50ZXJmYWNlIiwiVGV4dFRvU3BlZWNoRmVhdHVyZURlcGVuZGVudE1peGluIiwiVGV4dFRvU3BlZWNoRmVhdHVyZSIsInBsYXkiLCJwYXVzZSIsInJlc3VtZSIsInN0b3AiLCJzZW50ZW5jZSIsIndvcmQiLCJ2aXNlbWUiLCJzc21sIiwiRGVmYXVsdFZpc2VtZU1hcCIsInNpbCIsIm92ZXJyaWRlV2VpZ2h0IiwiUyIsIlQiLCJmIiwidSIsIkUiLCJvIiwiTyIsIkxpcHN5bmNGZWF0dXJlIiwidmlzZW1lQmxlbmRUaW1lIiwiZGVjYXlSYXRlIiwiYW1vdW50IiwidmlzZW1lRWFzaW5nRm4iLCJ2aXNlbWVMYXllcnMiLCJ0YWxraW5nQmxlbmRUaW1lIiwidGFsa2luZ0Vhc2luZ0ZuIiwidGFsa2luZ0xheWVycyIsInZpc2VtZUxlYWRUaW1lIiwiX3Zpc2VtZUxheWVycyIsIl90YWxraW5nTGF5ZXJzIiwiYW5pbWF0aW9uIiwidmlzZW1lTWFwIiwicmVnaXN0ZXJWaXNlbWVMYXllciIsInJlZ2lzdGVyVGFsa2luZ0xheWVyIiwiZ2V0QW5pbWF0aW9uVHlwZSIsIndlaWdodE5hbWVzIiwiZ2V0QW5pbWF0aW9uQmxlbmROYW1lcyIsInZpc2VtZU9wdGlvbnMiLCJzcGVlY2htYXJrT2Zmc2V0IiwiX3Zpc2VtZUxlYWRUaW1lIiwiX3JlZ2lzdGVyVmlzZW1lQW5pbWF0aW9uIiwicmVzdW1lQW5pbWF0aW9uIiwiX29uU3RvcCIsIl9vblBsYXkiLCJwYXVzZUFuaW1hdGlvbiIsIm1hcmsiLCJpc1Zpc2VtZUFjdGl2ZSIsInZpc2VtZU5hbWVzIiwiZHVyYXRpb24iLCJsZXJwRmFjdG9yIiwibGVycCIsImJsZW5kSW5UaW1lIiwiaG9sZFRpbWUiLCJfYW5pbWF0ZVNpbXBsZVZpc2VtZSIsImRlY2F5V2VpZ2h0IiwiX2FuaW1hdGVIZWxkVmlzZW1lIiwidmlzZW1lTmFtZSIsInBlYWtXZWlnaHQiLCJibGVuZE91dFRpbWUiLCJ3ZWlnaHRQcm9taXNlIiwic2V0QW5pbWF0aW9uQmxlbmRXZWlnaHQiLCJzdGFydFByb21pc2UiLCJob2xkUHJvbWlzZSIsImdldCIsInNldCIsIm1peCIsIlNTTUxTcGVlY2htYXJrSW50ZXJmYWNlIiwiU1NNTFNwZWVjaE1hcmtNaXhpbiIsIkpTT04iLCJwYXJzZSIsIm1ldGhvZCIsImFwcGx5IiwiRGVmYXVsdEdlc3R1cmVXb3JkcyIsImJpZyIsImhlYXJ0IiwibWFueSIsIm1vdmVtZW50Iiwib25lIiwiYWdncmVzc2l2ZSIsInlvdSIsImRlZmVuc2UiLCJ3YXZlIiwic2VsZiIsIkdlc3R1cmVGZWF0dXJlIiwibWluaW11bUludGVydmFsIiwibGF5ZXIiLCJsYXllckhvbGRUaW1lIiwibGF5ZXJNaW5pbXVtSW50ZXJ2YWwiLCJjYW5BZHZhbmNlIiwiaXNRdWV1ZUVuZCIsImN1cnJlbnRHZXN0dXJlIiwiX2dldEhvbGRUaW1lIiwiaG9sZFRpbWVyIiwicGxheU5leHRBbmltYXRpb24iLCJwbGF5VGltZXIiLCJhdXRvRGlzYWJsZSIsImFuaW0iLCJ3b3JkcyIsImdlc3R1cmVNYXAiLCJ0cmFuc2l0aW9uVGltZSIsImtleSIsInN0cmluZ2lmeSIsImdlbmVyaWNHZXN0dXJlcyIsInJlYXNvbiIsIl9nZXRNaW5pbXVtSW50ZXJ2YWwiLCJwbGF5QW5pbWF0aW9uIiwiZ2V0UGF1c2VkIiwiY3JlYXRlR2VzdHVyZU1hcCIsImNyZWF0ZUdlbmVyaWNHZXN0dXJlQXJyYXkiLCJwbGF5R2VzdHVyZSIsInN0b3BBbmltYXRpb24iLCJpbnRlcnJ1cHRBbmltYXRpb24iLCJBbmltYXRpb25VdGlscyIsInByb3BlcnR5T3duZXIiLCJwcm9wZXJ0eU5hbWUiLCJpc05hTiIsInN0YXJ0VmFsdWUiLCJpbnRlcnBvbGF0b3IiLCJwcm9ncmVzcyIsImVhc2VGYWN0b3IiLCJBYnN0cmFjdFN0YXRlIiwiX3dlaWdodCIsIl9pbnRlcm5hbFdlaWdodCIsIl9wYXVzZWQiLCJfcHJvbWlzZXMiLCJmaW5pc2giLCJfcGxheUNhbGxiYWNrcyIsImludGVycG9sYXRlUHJvcGVydHkiLCJwcm9taXNlIiwiYWxsIiwidXBkYXRlSW50ZXJuYWxXZWlnaHQiLCJUcmFuc2l0aW9uU3RhdGUiLCJfdG8iLCJfZnJvbSIsIl93ZWlnaHRQcm9taXNlIiwidG90YWxXZWlnaHQiLCJzdGF0ZSIsImN1cnJlbnRTdGF0ZXMiLCJ0YXJnZXRTdGF0ZSIsImRlYWN0aXZhdGUiLCJyZXNldCIsIndlaWdodFByb21pc2VzIiwic2V0V2VpZ2h0Iiwib25OZXh0IiwicHJvbWlzZXMiLCJBbmltYXRpb25QbGF5ZXJJbnRlcmZhY2UiLCJmbiIsInBsYXlNZXRob2QiLCJBbmltYXRpb25QbGF5ZXJNaXhpbiIsIl90cmFuc2l0aW9uU3RhdGUiLCJfc3RhdGVzIiwiTWFwIiwiX2N1cnJlbnRTdGF0ZSIsIl90cmFuc2l0aW9uVGltZSIsIl9lYXNpbmdGbiIsImhhcyIsImN1cnJlbnRBbmltYXRpb24iLCJ3ZWlnaHRQZW5kaW5nIiwiY29uZmlndXJlIiwiX3ByZXBhcmVDdXJyZW50U3RhdGUiLCJTdGF0ZUNvbnRhaW5lckludGVyZmFjZSIsImN1cnJlbnROYW1lIiwiU3RhdGVDb250YWluZXJNaXhpbiIsInVuaXF1ZU5hbWUiLCJnZXRVbmlxdWVOYW1lIiwiUXVldWVTdGF0ZSIsInF1ZXVlU3RhdGVzIiwiYWRkU3RhdGUiLCJfcXVldWUiLCJfZG9uZSIsImludGVybmFsV2VpZ2h0IiwibmV4dCIsImRvbmUiLCJ3cmFwIiwibGFzdE5hbWUiLCJzaXplIiwiZ2V0U3RhdGUiLCJsb29wQ291bnQiLCJJbmZpbml0eSIsImlzVHJhbnNpdGlvbmluZyIsIl9yZXNldCIsInBhdXNlZCIsInN0b3BwZWQiLCJkaXNjYXJkU3RhdGVzIiwiQWJzdHJhY3RCbGVuZFN0YXRlIiwiYmxlbmRTdGF0ZXMiLCJibGVuZFdlaWdodHMiLCJGcmVlQmxlbmRTdGF0ZSIsInN1bVdlaWdodHMiLCJCbGVuZDFkU3RhdGUiLCJibGVuZFRocmVzaG9sZHMiLCJwaGFzZU1hdGNoZXMiLCJfYmxlbmRWYWx1ZSIsImJsZW5kVmFsdWUiLCJub25aZXJvRGlmZmVyZW50U2l6ZSIsImNvbnRhaW5zRHVwbGljYXRlcyIsIl90aHJlc2hvbGRzIiwicGhhc2VNYXRjaCIsIl9zb3J0VGhyZXNob2xkcyIsIl9mb3JjZU5vVGhyZXNob2xkRHVwZXMiLCJfcGhhc2VMZWFkU3RhdGUiLCJfdXBkYXRlQmxlbmRXZWlnaHRzIiwidGhyZXNob2xkVmFsdWUiLCJzYW1lVmFsdWUiLCJmaW5kIiwidGhyZXNob2xkIiwicmVtb3ZlZCIsImZpbmRJbmRleCIsIm5vcm1hbGl6ZWRUaW1lIiwidGFyZ2V0SW5kZXgiLCJ0aHJlc2hvbGRBIiwidGhyZXNob2xkQiIsImZhY3RvckIiLCJmYWN0b3JBIiwic3RhdGVBIiwic3RhdGVCIiwiQmxlbmQyZFN0YXRlIiwib3RoZXJUaHJlc2hvbGQiLCJfYmxlbmRWYWx1ZVgiLCJfYmxlbmRWYWx1ZVkiLCJibGVuZFZhbHVlWCIsImJsZW5kVmFsdWVZIiwiX3ZlcnRpY2VzIiwiX3RyaWFuZ2xlcyIsImdldERlbGF1bmF5VHJpYW5ndWxhdGlvbiIsInByb3BlcnR5IiwidG9VcHBlckNhc2UiLCJfc2V0SW5mbHVlbmNlQ2xvc2VzdFBvaW50T25MaW5lIiwiaXNQb2ludEluVHJpYW5nbGUiLCJfc2V0SW5mbHVlbmNlVHJpYW5nbGUiLCJfc2V0SW5mbHVlbmNlQ2xvc2VzdFBvaW50SW5UcmlhbmdsZXMiLCJhcmVhQSIsInRyaWFuZ2xlQXJlYSIsImFyZWFCIiwiYXJlYUMiLCJ0b3RhbEFyZWEiLCJ3ZWlnaHRBIiwid2VpZ2h0QiIsIndlaWdodEMiLCJ0aHJlc2hvbGRDIiwic3RhdGVDIiwiX3NldFBoYXNlTGVhZFN0YXRlIiwiZ2xvYmFsQ2xvc2VzdFBvaW50IiwiZ2xvYmFsTWluRGlzdCIsImNsb3Nlc3RUcmlhbmdsZSIsInBvaW50QSIsImNsb3Nlc3RQb2ludE9uTGluZSIsInBvaW50QiIsInBvaW50QyIsImRpc3RBIiwiZGlzdEIiLCJkaXN0QyIsImxvY2FsQ2xvc2VzdFBvaW50IiwibG9jYWxNaW5EaXN0IiwiY2xvc2VzdFBvaW50Iiwic3RhdGVzIiwicGhhc2VNYXRjaGVkIiwiTGF5ZXJCbGVuZE1vZGVzIiwiT3ZlcnJpZGUiLCJBZGRpdGl2ZSIsIkRlZmF1bHRMYXllckJsZW5kTW9kZSIsInZhbGlkYXRlQmxlbmRNb2RlIiwiYmxlbmRNb2RlIiwiQW5pbWF0aW9uTGF5ZXIiLCJfYmxlbmRNb2RlIiwiX3dlaWdodFBhdXNlZCIsImlzV2VpZ2h0QWN0aXZlIiwiZ2V0U3RhdGVOYW1lcyIsImJsZW5kTmFtZSIsInNldEJsZW5kV2VpZ2h0IiwiZ2V0QmxlbmRXZWlnaHQiLCJTaW5nbGVTdGF0ZSIsIl90aW1lU2NhbGUiLCJ0aW1lU2NhbGUiLCJfbG9vcENvdW50IiwidGltZSIsIlJhbmRvbUFuaW1hdGlvblN0YXRlIiwic3ViU3RhdGVzIiwiX3BsYXlJbnRlcnZhbCIsInBsYXlJbnRlcnZhbCIsImdldFJhbmRvbUZsb2F0IiwicGxheVJhbmRvbUFuaW1hdGlvbiIsInRpbWVyIiwiX3Jlc2V0VGltZXIiLCJyYW5kb21TdGF0ZSIsImdldFJhbmRvbUludCIsImNhbmNlbEFuaW1hdGlvbiIsIkFuaW1hdGlvblR5cGVzIiwic2luZ2xlIiwiZnJlZUJsZW5kIiwicXVldWUiLCJyYW5kb21BbmltYXRpb24iLCJibGVuZDFkIiwiYmxlbmQyZCIsIl9sYXllcnMiLCJfbGF5ZXJNYXAiLCJleGlzdGluZyIsImxhc3RJbmRleCIsIm51bUxheWVycyIsIndlaWdodE11bHRpcGxpZXIiLCJjdXJyZW50U3RhdGUiLCJibGVuZFN0YXRlT3B0aW9ucyIsImJsZW5kT3B0aW9ucyIsIl9jcmVhdGVTaW5nbGVTdGF0ZSIsInF1ZXVlT3B0aW9ucyIsInF1ZXVlT3B0aW9uIiwiYmxlbmRNYXRjaFBoYXNlcyIsInN1YlN0YXRlT3B0aW9ucyIsImxheWVySW5kZXgiLCJfdmFsaWRhdGVJbmRleCIsImV2ZW50RGF0YSIsImN1cnJlbnRJbmRleCIsImdldEFuaW1hdGlvbkJsZW5kV2VpZ2h0IiwicGF1c2VXZWlnaHQiLCJyZXN1bWVXZWlnaHQiLCJhbmltYXRpb25UeXBlIiwiX3ZhbGlkYXRlTmV3QW5pbWF0aW9uIiwicmVtb3ZlU3RhdGUiLCJjdXJyZW50QW5pbWF0aW9uTmFtZSIsIm5ld0FuaW1hdGlvbk5hbWUiLCJyZW5hbWVTdGF0ZSIsIm5leHRRdWV1ZWRBbmltYXRpb24iLCJsIiwicmVzdW1lZCIsIm1vdmVMYXllciIsImdldExheWVyV2VpZ2h0IiwicGF1c2VMYXllcldlaWdodCIsInJlc3VtZUxheWVyV2VpZ2h0IiwicGF1c2VMYXllciIsInJlc3VtZUxheWVyIiwiZ2V0VHJhbnNpdGlvbmluZyIsImdldEN1cnJlbnRBbmltYXRpb24iLCJfdXBkYXRlSW50ZXJuYWxXZWlnaHRzIiwiQXhpc01hcCIsIlBvc2l0aXZlWCIsIk5lZ2F0aXZlWCIsIlBvc2l0aXZlWSIsIk5lZ2F0aXZlWSIsIlBvc2l0aXZlWiIsIk5lZ2F0aXZlWiIsIkZhY2VUYXJnZXRUeXBlcyIsIkV5ZUNlbnRlciIsIkV5ZUxlZnQiLCJFeWVSaWdodCIsIk1vdXRoIiwiRmFjZVZlY3RvcnMiLCJNaWNyb1NhY2NhZGVXYWl0UmFuZ2VzIiwicG9zdE1hY3JvIiwiTWFjcm9TYWNjYWRlV2FpdFJhbmdlcyIsIm1vdXRoVGFyZ2V0IiwiZXllVGFyZ2V0IiwiQmxpbmtUaHJlc2hvbGQiLCJNYXhEZWx0YSIsIlBvaW50T2ZJbnRlcmVzdEZlYXR1cmUiLCJ0YXJnZXQiLCJsb29rVHJhY2tlciIsInNjZW5lIiwibG9va0JsZW5kVGltZSIsImxvb2tFYXNpbmdGbiIsImxvb2tMYXllcnMiLCJibGlua0JsZW5kVGltZSIsImJsaW5rRWFzaW5nRm4iLCJibGlua0xheWVycyIsIl92YWxpZGF0ZVRyYW5zZm9ybU9iamVjdCIsIl9sb29rVHJhY2tlciIsIl9zY2VuZSIsIl90YXJnZXQiLCJfcHJldlRhcmdldFBvcyIsIl9pc1RhcmdldE1vdmluZyIsIl9sb29rTGF5ZXJzIiwiX3RyYWNraW5nQ29uZmlncyIsIl9ibGlua0xheWVycyIsInJlZmVyZW5jZSIsImZvcndhcmRBeGlzIiwiaGFzU2FjY2FkZSIsInJlZ2lzdGVyTG9va0xheWVyIiwicmVnaXN0ZXJCbGlua0xheWVyIiwiX3JlZ2lzdGVyTG9va0FuaW1hdGlvbiIsImNvbmZpZyIsInRyYWNraW5nQ29uZmlnIiwiYW5nbGVzIiwiaCIsInByZXZBbmdsZXMiLCJzb3VyY2VQb3NpdGlvbiIsIl9nZXRXb3JsZFBvc2l0aW9uIiwidGFyZ2V0UG9zaXRpb24iLCJsb29rVmVjdG9yIiwidGFyZ2V0UG9zIiwidHJhY2tlclBvcyIsInRhcmdldFNwaGVyaWNhbCIsImNhcnRlc2lhblRvU3BoZXJpY2FsIiwidGFyZ2V0QW5nbGVzIiwiX3NwaGVyaWNhbFRvQmxlbmRWYWx1ZSIsInJlZkRpcmVjdGlvbiIsIl9nZXRPYmplY3REaXJlY3Rpb24iLCJyZWZTcGhlcmljYWwiLCJyZWZBbmdsZXMiLCJ0YXJnZXRUeXBlIiwiZGlzdGFuY2UiLCJfZ2V0VGFyZ2V0RGlzdGFuY2UiLCJmYWNlVmVjdG9yIiwic3BoZXJpY2FsIiwiYmxlbmRWYWx1ZXMiLCJtYXhIU3BlZWQiLCJleHAiLCJtYXhWU3BlZWQiLCJEMCIsImQiLCJoRHVyYXRpb24iLCJ2RHVyYXRpb24iLCJtaWNyb1NhY2NhZGUiLCJfdXBkYXRlTGF5ZXJTcGVlZCIsIl9pbml0aWFsaXplTWljcm9UaW1lciIsIm1hY3JvU2FjY2FkZSIsIm1hY3JvU2FjY2FkZVdhaXRSYW5nZSIsImhMaW1pdCIsImhGYWN0b3IiLCJ2TGltaXQiLCJ2RmFjdG9yIiwic2FjY2FkZVRhcmdldCIsIl9nZXRGYWNlVGFyZ2V0QW5nbGVzIiwiX2luaXRpYWxpemVNYWNyb1RpbWVyIiwibWluV2FpdFRpbWUiLCJtYXhXYWl0VGltZSIsIndhaXRUaW1lIiwibWljcm9TYWNjYWRlVGltZXIiLCJfc2V0TWljcm9TYWNjYWRlIiwibWFjcm9TYWNjYWRlVGltZXIiLCJfc2V0TWFjcm9TYWNjYWRlIiwiX2FkZFRyYWNraW5nQ29uZmlnIiwiaFZlbG9jaXR5IiwidlZlbG9jaXR5IiwiX3NldExvb2tBbmdsZXMiLCJfcmVzZXRMb29rQW5nbGVzIiwiZGVsdGFTZWNvbmRzIiwidHJpZ2dlckJsaW5rIiwiY3VycmVudEgiLCJjdXJyZW50ViIsInRhcmdldEgiLCJ0YXJnZXRWIiwicHJldlRhcmdldEgiLCJwcmV2VGFyZ2V0ViIsImNoYW5nZUFtb3VudCIsInRvRGVncmVlcyIsImdldEFuZ2xlQmV0d2VlbiIsImRhbXBWYWx1ZSIsInNldFRhcmdldCIsInNldFRhcmdldEJ5TmFtZSIsInNldFRhcmdldEJ5SWQiLCJvYmoiLCJmb3J3YXJkVmVjdG9yIiwicm90YXRpb24iLCJnZXRSb3RhdGlvbk1hdHJpeCIsIl9nZXRXb3JsZE1hdHJpeCIsInJvdGF0ZVZlY3RvciIsInRoZXRhIiwicGhpIiwiRWFzaW5nIiwiQWJzdHJhY3RTcGVlY2giLCJzcGVha2VyIiwidGV4dCIsInNwZWVjaG1hcmtzIiwiX3NwZWFrZXIiLCJfdGV4dCIsIl9zcGVlY2htYXJrcyIsIl9zcGVlY2htYXJrT2Zmc2V0IiwiX3N0YXJ0VGltZSIsIl9sb2NhbFRpbWUiLCJfcGF1c2VUaW1lIiwiX3BsYXlpbmciLCJfbWFya0l0ZXIiLCJfY3VycmVudE1hcmsiLCJfZW5kVGltZSIsIl9wcm9taXNlIiwib25JbnRlcnJ1cHQiLCJpbnRlcnJ1cHQiLCJvZmZzZXQiLCJ0eXBlIiwic3BlZWNoIiwiX2NoZWNrRmluaXNoZWQiLCJfY3JlYXRlUHJvbWlzZSIsIlNwZWVjaCIsImF1ZGlvQ29uZmlnIiwiX2F1ZGlvIiwiYXVkaW8iLCJvbmVuZGVkIiwiX2F1ZGlvRmluaXNoZWQiLCJ2b2x1bWUiLCJzZXRUaW1lb3V0IiwiX3BsYXlBdWRpbyIsIl9wYXVzZUF1ZGlvIiwiVGV4dFRvU3BlZWNoVXRpbHMiLCJyYW5kb21NYXJrcyIsImludGVybmFsTWFwIiwiX3Byb2Nlc3NJbnB1dE1hcCIsInNwZWFrVGFncyIsInNzbWxNYXJrUmVnZXgiLCJzc21sVGFnUmVnZXgiLCJleGlzdGluZ1RhZ3MiLCJleGVjIiwic3RhcnQiLCJlbmQiLCJjaHVua3MiLCJzc21sTWFya1Jlc3VsdCIsImR1cGxpY2F0ZU1hcmtUb0NoZWNrIiwiZXhpc3RpbmdUYWciLCJzdWJzdHIiLCJfaW5zZXJ0TWFya3MiLCJtYXJrVGV4dCIsIm1hcmtlZFRleHQiLCJqb2luIiwiYWRkTWFya3NUb1VubWFya2VkU2VudGVuY2VzIiwidmFsaWRhdGVUZXh0IiwibWFya3MiLCJtYXJrSW5kaWNlcyIsIm1hcmtSZXN1bHQiLCJzc21sUmVzdWx0IiwiY2xlYW5lZFRleHQiLCJleGlzdGluZ1NzbWwiLCJ3aGl0ZXNwYWNlIiwic2VudGVuY2VFbmRJbmRpY2VzIiwiX2dldFNlbnRlbmNlRW5kcyIsInByZXZJbmRleCIsInRhcmdldEluZGljZXMiLCJjb250YWluc01hcmsiLCJtYXJrSW5kZXgiLCJyYW5kb21NYXJrZWRUZXh0IiwiX2luc2VydFJhbmRvbU1hcmtzQXQiLCJyYW5kb21NYXJrIiwic2VudGVuY2VSZWdleCIsImVuZFNlbnRlbmNlUmVnZXgiLCJzZW50ZW5jZUVuZHMiLCJwdW5jdFJlc3VsdCIsImR1cGxpY2F0ZXNUb0NoZWNrIiwid29yZFJlZ2V4IiwibG93ZXJDYXNlV29yZCIsImNoZWNrRHVwbGljYXRlIiwibWFya2VkV29yZHMiLCJ0b0xvd2VyQ2FzZSIsImV4aXN0aW5nTWFya3MiLCJsaXN0IiwiaXNBcnJheSIsImVuZ2luZXMiLCJhdWRpb0Zvcm1hdHMiLCJzcGVlY2htYXJrVHlwZXMiLCJzYW1wbGVSYXRlcyIsIm1wMyIsInJhdGVzIiwiZGVmYXVsdHMiLCJzdGFuZGFyZCIsIm5ldXJhbCIsInBjbSIsIm9nZ192b3JiaXMiLCJhd3NWZXJzaW9uIiwiQWJzdHJhY3RUZXh0VG9TcGVlY2hGZWF0dXJlIiwidm9pY2UiLCJlbmdpbmUiLCJsYW5ndWFnZSIsImF1ZGlvRm9ybWF0Iiwic2FtcGxlUmF0ZSIsIm1pbkVuZE1hcmtEdXJhdGlvbiIsImlzR2xvYmFsIiwiX3NwZWVjaENhY2hlIiwiX2N1cnJlbnRTcGVlY2giLCJfY3VycmVudFByb21pc2UiLCJfaXNWYWxpZGF0ZWQiLCJfaXNHbG9iYWwiLCJfdm9sdW1lUGF1c2VkIiwiX3ZvaWNlIiwiUE9MTFlfREVGQVVMVFMiLCJWb2ljZUlkIiwiX2xhbmd1YWdlIiwiTGFuZ3VhZ2VOYW1lIiwiX2VuZ2luZSIsIkVuZ2luZSIsIl9hdWRpb0Zvcm1hdCIsIk91dHB1dEZvcm1hdCIsIl9zYW1wbGVSYXRlIiwiU2FtcGxlUmF0ZSIsIl9taW5FbmRNYXJrRHVyYXRpb24iLCJBV1NfVkVSU0lPTiIsIlBPTExZX01JTl9ORVVSQUxfVkVSU0lPTiIsImZvcm1hdCIsInJhdGUiLCJ2b2ljZUlkIiwiUE9MTFlfVk9JQ0VTIiwiSWQiLCJTdXBwb3J0ZWRFbmdpbmVzIiwibGFuZ3VhZ2VDb2RlIiwiUE9MTFlfTEFOR1VBR0VTIiwiYXZhaWxhYmxlQ29kZXMiLCJMYW5ndWFnZUNvZGUiLCJBZGRpdGlvbmFsTGFuZ3VhZ2VDb2RlcyIsIlBPTExZX0xBTkdVQUdFX0NPREVTIiwiX3ZhbGlkYXRlRW5naW5lIiwiX3ZhbGlkYXRlRm9ybWF0IiwiX3ZhbGlkYXRlUmF0ZSIsIl92YWxpZGF0ZVZvaWNlIiwiX3ZhbGlkYXRlTGFuZ3VhZ2UiLCJpc1JlYWR5IiwiX3ZhbGlkYXRlIiwic2tpcFNwZWVjaGVzIiwiY3VycmVudENvbmZpZyIsIl9nZXRDb25maWciLCJjdXJyZW50Q29uZmlnU3RyIiwiTGFuZ3VhZ2UiLCJ2YWxpZENvbmZpZyIsImNvbmZpZ1N0ciIsInNwZWVjaENvbmZpZ1N0ciIsIl91cGRhdGVTcGVlY2giLCJhdWRpb1BhcmFtcyIsIlRleHQiLCJUZXh0VHlwZSIsInNwZWVjaG1hcmtQYXJhbXMiLCJTcGVlY2hNYXJrVHlwZXMiLCJfc3ludGhlc2l6ZVNwZWVjaG1hcmtzIiwiX3N5bnRoZXNpemVBdWRpbyIsInJlc3VsdHMiLCJfY3JlYXRlU3BlZWNoIiwicGFyYW1zIiwicHJlc2lnbmVyIiwiZ2V0U3ludGhlc2l6ZVNwZWVjaFVybCIsInVybCIsInBvbGx5Iiwic3ludGhlc2l6ZVNwZWVjaCIsImpzb25TdHJpbmciLCJBdWRpb1N0cmVhbSIsImpzb24iLCJkYXRhU3RyIiwiZGF0YSIsIlN0cmluZyIsImZyb21DaGFyQ29kZSIsIm1hcmtUeXBlcyIsImVuZE1hcmtUeXBlcyIsInNwZWVjaE1hcmtzIiwibWF0Y2hBbGwiLCJudW1NYXJrcyIsImxhc3RNYXJrIiwiZW5kVGltZXMiLCJlbmRUaW1lIiwiX3VwZGF0ZUNvbmZpZyIsImdldFZvbHVtZSIsInNldFZvbHVtZSIsInBhdXNlVm9sdW1lIiwicmVzdW1lVm9sdW1lIiwiX3ZvbHVtZSIsInZvbHVtZVBlbmRpbmciLCJwbGF5aW5nIiwiY3VycmVudFByb21pc2UiLCJfZ2V0U3BlZWNoIiwiX3NldEN1cnJlbnRTcGVlY2giLCJfc3RhcnRTcGVlY2giLCJ2ZXJzaW9uIiwiY3VzdG9tVXNlckFnZW50IiwiX3dpdGhDdXN0b21Vc2VyQWdlbnQiLCJzZXJ2aWNlIiwiX2lzUmVhZHkiLCJhdmFpbGFibGVWb2ljZXMiLCJhdmFpbGFibGVMYW5ndWFnZXMiLCJhdmFpbGFibGVMYW5ndWFnZUNvZGVzIiwibWluTmV1cmFsU2RrIiwiZGVzY3JpYmVWb2ljZXMiLCJyZXNwb25zZSIsImFsbENvZGVzIiwiVm9pY2VzIiwiY29kZSIsInJlYWR5IiwiY3VycmVudFVzZXJBZ2VudCIsInN1bWVyaWFuSG9zdHNVc2VyQWdlbnQiLCJjb25jYXQiLCJMZXhpY29uTmFtZXMiLCJfZW5hYmxlZCIsIl9zZXRBdWRpb0NvbnRleHQiLCJfb2JzZXJ2ZUF1ZGlvQ29udGV4dCIsIl9hdWRpb0NvbnRleHQiLCJBdWRpb0NvbnRleHQiLCJvbnN0YXRlY2hhbmdlIiwiQXVkaW8iLCJsb29wIiwiY3Jvc3NPcmlnaW4iLCJwcmVsb2FkIiwiZG9jdW1lbnQiLCJib2R5IiwiYXBwZW5kQ2hpbGQiLCJsb2FkIiwicmVzdW1lQXVkaW8iLCJlbmFibGVkIiwiZW52Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///506\n')}},__webpack_exports__={};return __webpack_modules__[506](),__webpack_exports__=__webpack_exports__.default,__webpack_exports__})()}));